(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("fs"), require("typescript"), (function webpackLoadOptionalExternalModule() { try { return require("RAML.XmlValidation"); } catch(e) {} }()));
	else if(typeof define === 'function' && define.amd)
		define(["fs", "typescript", "RAML.XmlValidation"], factory);
	else if(typeof exports === 'object')
		exports["Parser"] = factory(require("fs"), require("typescript"), (function webpackLoadOptionalExternalModule() { try { return require("RAML.XmlValidation"); } catch(e) {} }()));
	else
		root["RAML"] = root["RAML"] || {}, root["RAML"]["Parser"] = factory(root["fs"], root["typescript"], root["RAML.XmlValidation"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_38__, __WEBPACK_EXTERNAL_MODULE_146__, __WEBPACK_EXTERNAL_MODULE_172__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var apiLoader = __webpack_require__(9);
	var path = __webpack_require__(15);
	var PromiseConstructor = __webpack_require__(30);
	/**
	 * RAML 1.0 top-level AST interfaces.
	 */
	exports.api10 = __webpack_require__(12);
	/**
	 * RAML 0.8 top-level AST interfaces.
	 */
	exports.api08 = __webpack_require__(13);
	function loadApiSync(apiPath, arg1, arg2) {
	    return apiLoader.loadApi(apiPath, arg1, arg2).getOrElse(null);
	}
	exports.loadApiSync = loadApiSync;
	function loadRAMLSync(ramlPath, arg1, arg2) {
	    return apiLoader.loadApi(ramlPath, arg1, arg2).getOrElse(null);
	}
	exports.loadRAMLSync = loadRAMLSync;
	function optionsForContent(content, arg2, filePath) {
	    return {
	        fsResolver: {
	            content: function (pathStr) {
	                if (pathStr === (filePath || path.resolve("/", "#local.raml")).replace(/\\/, "/")) {
	                    return content;
	                }
	                if (arg2) {
	                    if (arg2.fsResolver) {
	                        return arg2.fsResolver.content(pathStr);
	                    }
	                }
	            },
	            contentAsync: function (pathStr) {
	                if (pathStr === (filePath || path.resolve("/", "#local.raml")).replace(/\\/, "/")) {
	                    return Promise.resolve(content);
	                }
	                if (arg2) {
	                    if (arg2.fsResolver) {
	                        return arg2.fsResolver.contentAsync(pathStr);
	                    }
	                }
	            }
	        },
	        httpResolver: arg2 ? arg2.httpResolver : null,
	        rejectOnErrors: arg2 ? arg2.rejectOnErrors : false,
	        attributeDefaults: arg2 ? arg2.attributeDefaults : true
	    };
	}
	/**
	 * Load RAML synchronously. May load both Api and Typed fragments. If the 'rejectOnErrors' option is set to true, [[ApiLoadingError]] is thrown for RAML which contains errors.
	 * @param content content of the raml
	 * @param options Load options  (note you should path a resolvers if you want includes to be resolved)
	 * @return RAMLLanguageElement instance.
	 **/
	function parseRAMLSync(content, arg2) {
	    var filePath = null;
	    if (arg2 && arg2.filePath)
	        filePath = arg2.filePath;
	    return apiLoader.loadApi(filePath || "/#local.raml", [], optionsForContent(content, arg2, filePath)).getOrElse(null);
	}
	exports.parseRAMLSync = parseRAMLSync;
	/**
	 * Load RAML asynchronously. May load both Api and Typed fragments. If the 'rejectOnErrors' option is set to true, [[ApiLoadingError]] is thrown for RAML which contains errors.
	 * @param content content of the raml
	 * @param options Load options  (note you should path a resolvers if you want includes to be resolved)
	 * @return RAMLLanguageElement instance.
	 **/
	function parseRAML(content, arg2) {
	    var filePath = null;
	    if (arg2 && arg2.filePath)
	        filePath = arg2.filePath;
	    return apiLoader.loadApiAsync(filePath || "/#local.raml", [], optionsForContent(content, arg2, filePath));
	}
	exports.parseRAML = parseRAML;
	function loadApi(apiPath, arg1, arg2) {
	    return apiLoader.loadApiAsync(apiPath, arg1, arg2);
	}
	exports.loadApi = loadApi;
	function loadRAML(ramlPath, arg1, arg2) {
	    return apiLoader.loadRAMLAsync(ramlPath, arg1, arg2);
	}
	exports.loadRAML = loadRAML;
	/**
	 * Gets AST node by runtime type, if runtime type matches any.
	 * @param runtimeType - runtime type to find the match for
	 */
	function getLanguageElementByRuntimeType(runtimeType) {
	    return apiLoader.getLanguageElementByRuntimeType(runtimeType);
	}
	exports.getLanguageElementByRuntimeType = getLanguageElementByRuntimeType;
	/**
	 * Check if the AST node represents fragment
	 */
	function isFragment(node) {
	    return exports.api10.isFragment(node);
	}
	exports.isFragment = isFragment;
	/**
	 * Convert fragment representing node to FragmentDeclaration instance.
	 */
	function asFragment(node) {
	    return exports.api10.asFragment(node);
	}
	exports.asFragment = asFragment;
	/**
	 * High-level AST interfaces.
	 */
	exports.hl = __webpack_require__(10);
	/**
	 * Low-level AST interfaces.
	 */
	exports.ll = __webpack_require__(11);
	/**
	 * Search functionality, operates on high AST level.
	 */
	exports.search = __webpack_require__(1);
	/**
	 * High-level stub node factory methods.
	 */
	exports.stubs = __webpack_require__(2);
	exports.utils = __webpack_require__(3);
	/**
	 * Low-level project factory.
	 */
	exports.project = __webpack_require__(4);
	/**
	 * Helpers for classification of high-level AST entity types.
	 */
	exports.universeHelpers = __webpack_require__(14);
	/**
	 * Definition system.
	 */
	exports.ds = __webpack_require__(36);
	/**
	 * Schema utilities.
	 */
	exports.schema = __webpack_require__(5);
	/**
	 * A set of constants describing definition system entities.
	 * @hidden
	 **/
	exports.universes = exports.ds.universesInfo;
	/**
	 * Exposed parser model modification methods. Operate on high-level.
	 */
	exports.parser = __webpack_require__(6);
	/**
	 * Applies traits and resources types to API on high-level.
	 * Top-level expansion should be performed via calling expand() method of API node.
	 */
	exports.expander = __webpack_require__(7);
	/**
	 * Exposed part of custom methods applied to top-level AST during generation.
	 * Not to be used by parser clients.
	 */
	exports.wrapperHelper = __webpack_require__(8);
	if (typeof Promise === 'undefined' && typeof window !== 'undefined') {
	    window.Promise = PromiseConstructor;
	}
	//# sourceMappingURL=index.js.map

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var search = __webpack_require__(23);
	var hlimpl = __webpack_require__(16);
	(function (LocationKind) {
	    LocationKind[LocationKind["VALUE_COMPLETION"] = 0] = "VALUE_COMPLETION";
	    LocationKind[LocationKind["KEY_COMPLETION"] = 1] = "KEY_COMPLETION";
	    LocationKind[LocationKind["PATH_COMPLETION"] = 2] = "PATH_COMPLETION";
	    LocationKind[LocationKind["DIRECTIVE_COMPLETION"] = 3] = "DIRECTIVE_COMPLETION";
	    LocationKind[LocationKind["VERSION_COMPLETION"] = 4] = "VERSION_COMPLETION";
	    LocationKind[LocationKind["ANNOTATION_COMPLETION"] = 5] = "ANNOTATION_COMPLETION";
	    LocationKind[LocationKind["SEQUENCE_KEY_COPLETION"] = 6] = "SEQUENCE_KEY_COPLETION";
	    LocationKind[LocationKind["INCOMMENT"] = 7] = "INCOMMENT";
	})(exports.LocationKind || (exports.LocationKind = {}));
	var LocationKind = exports.LocationKind;
	function determineCompletionKind(text, offset) {
	    return search.determineCompletionKind(text, offset);
	}
	exports.determineCompletionKind = determineCompletionKind;
	function enumValues(c, n) {
	    return search.enumValues(c, n);
	}
	exports.enumValues = enumValues;
	function globalDeclarations(n) {
	    return search.globalDeclarations(n);
	}
	exports.globalDeclarations = globalDeclarations;
	function qName(n, p) {
	    return hlimpl.qName(n, p);
	}
	exports.qName = qName;
	function subTypesWithLocals(t, n) {
	    return search.subTypesWithLocals(t, n);
	}
	exports.subTypesWithLocals = subTypesWithLocals;
	function nodesDeclaringType(t, n) {
	    return search.nodesDeclaringType(t, n);
	}
	exports.nodesDeclaringType = nodesDeclaringType;
	function isExampleNodeContent(n) {
	    return search.isExampleNodeContent(n);
	}
	exports.isExampleNodeContent = isExampleNodeContent;
	function findExampleContentType(n) {
	    return search.findExampleContentType(n);
	}
	exports.findExampleContentType = findExampleContentType;
	function parseDocumentationContent(n, t) {
	    return search.parseDocumentationContent(n, t);
	}
	exports.parseDocumentationContent = parseDocumentationContent;
	function parseStructuredExample(exampleNode, type) {
	    return search.parseStructuredExample(exampleNode, type);
	}
	exports.parseStructuredExample = parseStructuredExample;
	function isExampleNode(node) {
	    return search.isExampleNode(node);
	}
	exports.isExampleNode = isExampleNode;
	function referenceTargets(p0, c) {
	    return search.referenceTargets(p0, c);
	}
	exports.referenceTargets = referenceTargets;
	function findUsages(unit, offset) {
	    return search.findUsages(unit, offset);
	}
	exports.findUsages = findUsages;
	function findDeclaration(unit, offset, nodePart) {
	    return search.findDeclaration(unit, offset, nodePart);
	}
	exports.findDeclaration = findDeclaration;
	//# sourceMappingURL=searchProxy.js.map

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var hlimpl = __webpack_require__(16);
	var jsyaml = __webpack_require__(27);
	var stubs = __webpack_require__(17);
	function createStubNode(t, p, key, unit) {
	    if (key === void 0) { key = null; }
	    return stubs.createStubNode(t, p, key, unit);
	}
	exports.createStubNode = createStubNode;
	function createStub(parent, property, key) {
	    return stubs.createStub(parent, property, key);
	}
	exports.createStub = createStub;
	function createStubNoParentPatch(parent, property, key) {
	    return stubs.createStub0(parent, property, key);
	}
	exports.createStubNoParentPatch = createStubNoParentPatch;
	function createResourceStub(parent, key) {
	    return stubs.createResourceStub(parent, key);
	}
	exports.createResourceStub = createResourceStub;
	function createMethodStub(parent, key) {
	    return stubs.createMethodStub(parent, key);
	}
	exports.createMethodStub = createMethodStub;
	function createResponseStub(parent, key) {
	    return stubs.createResponseStub(parent, key);
	}
	exports.createResponseStub = createResponseStub;
	function createBodyStub(parent, key) {
	    return stubs.createBodyStub(parent, key);
	}
	exports.createBodyStub = createBodyStub;
	function createUriParameterStub(parent, key) {
	    return stubs.createUriParameterStub(parent, key);
	}
	exports.createUriParameterStub = createUriParameterStub;
	function createQueryParameterStub(parent, key) {
	    return stubs.createQueryParameterStub(parent, key);
	}
	exports.createQueryParameterStub = createQueryParameterStub;
	function createASTPropImpl(node, parent, _def, _prop, fk) {
	    if (fk === void 0) { fk = false; }
	    return new hlimpl.ASTPropImpl(node, parent, _def, _prop, fk);
	}
	exports.createASTPropImpl = createASTPropImpl;
	function createASTNodeImpl(node, parent, _def, _prop) {
	    return new hlimpl.ASTNodeImpl(node, parent, _def, _prop);
	}
	exports.createASTNodeImpl = createASTNodeImpl;
	function createVirtualASTPropImpl(node, parent, _def, _prop) {
	    return new VirtualAttr(node, parent, _def, _prop);
	}
	exports.createVirtualASTPropImpl = createVirtualASTPropImpl;
	function createVirtualNodeImpl(node, parent, _def, _prop) {
	    return new VirtualNode(node, parent, _def, _prop);
	}
	exports.createVirtualNodeImpl = createVirtualNodeImpl;
	var VirtualAttr = (function (_super) {
	    __extends(VirtualAttr, _super);
	    function VirtualAttr() {
	        _super.apply(this, arguments);
	    }
	    VirtualAttr.prototype.value = function () {
	        return "";
	    };
	    return VirtualAttr;
	}(hlimpl.ASTPropImpl));
	var VirtualNode = (function (_super) {
	    __extends(VirtualNode, _super);
	    function VirtualNode() {
	        _super.apply(this, arguments);
	    }
	    VirtualNode.prototype.value = function () {
	        return "";
	    };
	    return VirtualNode;
	}(hlimpl.ASTNodeImpl));
	function createMapping(name, value) {
	    return jsyaml.createMapping(name, value);
	}
	exports.createMapping = createMapping;
	function createMap() {
	    return jsyaml.createMap([]);
	}
	exports.createMap = createMap;
	function createAttr(_property, val) {
	    return stubs.createAttr(_property, val);
	}
	exports.createAttr = createAttr;
	//# sourceMappingURL=stubProxy.js.map

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var rs = __webpack_require__(28);
	var hlimpl = __webpack_require__(16);
	var defs = __webpack_require__(36);
	var jsyaml = __webpack_require__(27);
	var expander = __webpack_require__(24);
	var linter = __webpack_require__(25);
	var builder = __webpack_require__(26);
	function hasAsyncRequests() {
	    return rs.hasAsyncRequests();
	}
	exports.hasAsyncRequests = hasAsyncRequests;
	function addLoadCallback(x) {
	    rs.addLoadCallback(x);
	}
	exports.addLoadCallback = addLoadCallback;
	function getTransformerNames() {
	    return expander.getTransformNames();
	}
	exports.getTransformerNames = getTransformerNames;
	exports.updateType = function (node) {
	    var type = builder.doDescrimination(node);
	    if (type == null && node.property()) {
	        type = node.property().range();
	    }
	    if (type) {
	        node.patchType(type);
	    }
	};
	function getFragmentDefenitionName(node) {
	    return hlimpl.getFragmentDefenitionName(node);
	}
	exports.getFragmentDefenitionName = getFragmentDefenitionName;
	function genStructuredValue(name, parent, pr) {
	    if (pr.range() instanceof defs.ReferenceType) {
	        var t = pr.range();
	        var mockNode = jsyaml.createNode(name);
	        return new hlimpl.StructuredValue(mockNode, parent, pr);
	    }
	    else
	        return name;
	}
	exports.genStructuredValue = genStructuredValue;
	function parseUrl(u) {
	    return new linter.UrlParameterNameValidator().parseUrl(u);
	}
	exports.parseUrl = parseUrl;
	//# sourceMappingURL=utils.js.map

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var limpl = __webpack_require__(27);
	function createProject(path, r, h) {
	    return new limpl.Project(path, r, h);
	}
	exports.createProject = createProject;
	//# sourceMappingURL=project.js.map

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var def = __webpack_require__(36);
	var refResolvers = __webpack_require__(29);
	var schemaGenImpl = __webpack_require__(18);
	var contentprovider = __webpack_require__(31);
	var su = def.getSchemaUtils();
	function createSchema(c, u) {
	    return su.createSchema(c, new contentprovider.ContentProvider(u));
	}
	exports.createSchema = createSchema;
	function getXMLSchema(c) {
	    return su.getXMLSchema(c);
	}
	exports.getXMLSchema = getXMLSchema;
	function getJSONSchema(c, u) {
	    return su.getJSONSchema(c, new contentprovider.ContentProvider(u));
	}
	exports.getJSONSchema = getJSONSchema;
	function completeReference(includePath, includeReference, content) {
	    return refResolvers.completeReference(includePath, includeReference, content);
	}
	exports.completeReference = completeReference;
	function getIncludePath(p) {
	    return refResolvers.getIncludePath(p);
	}
	exports.getIncludePath = getIncludePath;
	function getIncludeReference(p) {
	    return refResolvers.getIncludeReference(p);
	}
	exports.getIncludeReference = getIncludeReference;
	function createSchemaModelGenerator() {
	    return new schemaGenImpl.SchemaToModelGenerator();
	}
	exports.createSchemaModelGenerator = createSchemaModelGenerator;
	function createModelToSchemaGenerator() {
	    return new schemaGenImpl.ModelToSchemaGenerator();
	}
	exports.createModelToSchemaGenerator = createModelToSchemaGenerator;
	//# sourceMappingURL=schema.js.map

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.modify = __webpack_require__(19);
	//# sourceMappingURL=parser.js.map

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ex = __webpack_require__(24);
	function expandTraitsAndResourceTypes(api) {
	    return ex.expandTraitsAndResourceTypes(api);
	}
	exports.expandTraitsAndResourceTypes = expandTraitsAndResourceTypes;
	//# sourceMappingURL=expanderStub.js.map

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var wh = __webpack_require__(33);
	function completeRelativeUri(res) {
	    return wh.completeRelativeUri(res);
	}
	exports.completeRelativeUri = completeRelativeUri;
	//  function schema(body:api.TypeDeclaration, api:api.Api):Opt<SchemaDef> {
	//     return wh.schema(body,api);
	// } 
	//# sourceMappingURL=wrapperHelperStub.js.map

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/main.d.ts" />
	"use strict";
	var RamlWrapper1Impl = __webpack_require__(20);
	var path = __webpack_require__(15);
	var Opt = __webpack_require__(21);
	var jsyaml = __webpack_require__(27);
	var hlimpl = __webpack_require__(16);
	var llimpl = __webpack_require__(27);
	var expander = __webpack_require__(24);
	var universeDef = __webpack_require__(22);
	var ramlServices = __webpack_require__(34);
	var universeProvider = __webpack_require__(35);
	/***
	 * Load API synchronously. Detects RAML version and uses corresponding parser.
	 * @param apiPath Path to API: local file system path or Web URL
	 * @param options Load options
	 * @return Opt&lt;Api&gt;, where Api belongs to RAML 1.0 or RAML 0.8 model.
	 ***/
	function loadApi(apiPath, arg1, arg2) {
	    var api = loadRAMLInternal(apiPath, arg1, arg2);
	    // if (false) {
	    //     //TODO loaded RAML is API
	    //     throw new Error("Loaded RAML is not API");
	    // } else {
	    return new Opt(api);
	    // }
	}
	exports.loadApi = loadApi;
	/***
	 * Load RAML synchronously. Detects RAML version and uses corresponding parser.
	 * @param ramlPath Path to RAML: local file system path or Web URL
	 * @param options Load options
	 * @return Opt&lt;RAMLLanguageElement&gt;, where RAMLLanguageElement belongs to RAML 1.0 or RAML 0.8 model.
	 ***/
	function loadRAML(ramlPath, arg1, arg2) {
	    var result = loadRAMLInternal(ramlPath, arg1, arg2);
	    return new Opt(result);
	}
	exports.loadRAML = loadRAML;
	function loadRAMLInternal(apiPath, arg1, arg2) {
	    var gotArray = Array.isArray(arg1);
	    var extensionsAndOverlays = (gotArray ? arg1 : null);
	    var options = (gotArray ? arg2 : arg1);
	    options = options || {};
	    var project = getProject(apiPath, options);
	    var pr = apiPath.indexOf("://");
	    var unitName = (pr != -1 && pr < 6) ? apiPath : path.basename(apiPath);
	    var unit = project.unit(unitName);
	    if (arg2 && !extensionsAndOverlays) {
	        extensionsAndOverlays = null;
	    }
	    var api;
	    if (unit) {
	        if (extensionsAndOverlays && extensionsAndOverlays.length > 0) {
	            var extensionUnits = [];
	            extensionsAndOverlays.forEach(function (currentPath) {
	                if (!currentPath || currentPath.trim().length == 0) {
	                    throw new Error("Extensions and overlays list should contain legal file paths");
	                }
	            });
	            extensionsAndOverlays.forEach(function (unitPath) {
	                extensionUnits.push(project.unit(path.basename(unitPath)));
	            });
	            //calling to perform the checks, we do not actually need the api itself
	            extensionUnits.forEach(function (extensionUnit) { return toApi(extensionUnit, options); });
	            api = toApi(expander.mergeAPIs(unit, extensionUnits, hlimpl.OverlayMergeMode.MERGE), options);
	        }
	        else {
	            api = toApi(unit, options);
	            api.highLevel().setMergeMode(hlimpl.OverlayMergeMode.MERGE);
	        }
	    }
	    if (!unit) {
	        throw new Error("Can not resolve :" + apiPath);
	    }
	    if (options.rejectOnErrors && api && api.errors().filter(function (x) { return !x.isWarning; }).length) {
	        throw toError(api);
	    }
	    if (options.attributeDefaults != null && api) {
	        api.setAttributeDefaults(options.attributeDefaults);
	    }
	    else if (api) {
	        api.setAttributeDefaults(true);
	    }
	    return api;
	}
	/***
	 * Load API asynchronously. Detects RAML version and uses corresponding parser.
	 * @param apiPath Path to API: local file system path or Web URL
	 * @param options Load options
	 * @return Promise&lt;Api&gt;, where Api belongs to RAML 1.0 or RAML 0.8 model.
	 ***/
	function loadApiAsync(apiPath, arg1, arg2) {
	    var ramlPromise = loadRAMLAsync(apiPath, arg1, arg2);
	    return ramlPromise.then(function (loadedRaml) {
	        // if (false) {
	        //     //TODO check that loaded RAML is API
	        //     return Promise.reject("Specified RAML is not API");
	        // } else {
	        return loadedRaml;
	        // }
	    });
	}
	exports.loadApiAsync = loadApiAsync;
	/***
	 * Load API asynchronously. Detects RAML version and uses corresponding parser.
	 * @param ramlPath Path to RAML: local file system path or Web URL
	 * @param options Load options
	 * @return Promise&lt;RAMLLanguageElement&gt;, where RAMLLanguageElement belongs to RAML 1.0 or RAML 0.8 model.
	 ***/
	function loadRAMLAsync(ramlPath, arg1, arg2) {
	    var gotArray = Array.isArray(arg1);
	    var extensionsAndOverlays = (gotArray ? arg1 : null);
	    var options = (gotArray ? arg2 : arg1);
	    options = options || {};
	    var project = getProject(ramlPath, options);
	    var pr = ramlPath.indexOf("://");
	    var unitName = (pr != -1 && pr < 6) ? ramlPath : path.basename(ramlPath);
	    if (arg2 && !extensionsAndOverlays) {
	        extensionsAndOverlays = null;
	    }
	    if (!extensionsAndOverlays || extensionsAndOverlays.length == 0) {
	        return fetchAndLoadApiAsync(project, unitName, options).then(function (masterApi) {
	            masterApi.highLevel().setMergeMode(hlimpl.OverlayMergeMode.MERGE);
	            if (options.attributeDefaults != null && masterApi) {
	                masterApi.setAttributeDefaults(options.attributeDefaults);
	            }
	            else if (masterApi) {
	                masterApi.setAttributeDefaults(true);
	            }
	            return masterApi;
	        });
	    }
	    else {
	        extensionsAndOverlays.forEach(function (currentPath) {
	            if (!currentPath || currentPath.trim().length == 0) {
	                throw new Error("Extensions and overlays list should contain legal file paths");
	            }
	        });
	        return fetchAndLoadApiAsync(project, unitName, options).then(function (masterApi) {
	            var apiPromises = [];
	            extensionsAndOverlays.forEach(function (extensionUnitPath) {
	                apiPromises.push(fetchAndLoadApiAsync(project, path.basename(extensionUnitPath), options));
	            });
	            return Promise.all(apiPromises).then(function (apis) {
	                var overlayUnits = [];
	                apis.forEach(function (currentApi) { return overlayUnits.push(currentApi.highLevel().lowLevel().unit()); });
	                var result = expander.mergeAPIs(masterApi.highLevel().lowLevel().unit(), overlayUnits, hlimpl.OverlayMergeMode.MERGE);
	                if (options.attributeDefaults != null && result) {
	                    result.setAttributeDefaults(options.attributeDefaults);
	                }
	                else if (result) {
	                    result.setAttributeDefaults(true);
	                }
	                return result;
	            }).then(function (mergedHighLevel) {
	                return toApi(mergedHighLevel, options);
	            });
	        });
	    }
	}
	exports.loadRAMLAsync = loadRAMLAsync;
	/**
	 * Gets AST node by runtime type, if runtime type matches any.
	 * @param runtimeType
	 */
	function getLanguageElementByRuntimeType(runtimeType) {
	    if (runtimeType == null) {
	        return null;
	    }
	    var highLevelNode = runtimeType.getAdapter(ramlServices.RAMLService).getDeclaringNode();
	    if (highLevelNode == null) {
	        return null;
	    }
	    return highLevelNode.wrapperNode();
	}
	exports.getLanguageElementByRuntimeType = getLanguageElementByRuntimeType;
	function fetchAndLoadApiAsync(project, unitName, options) {
	    return llimpl.fetchIncludesAndMasterAsync(project, unitName).then(function (x) {
	        try {
	            var api = toApi(x, options);
	            if (options.rejectOnErrors && api && api.errors().filter(function (x) { return !x.isWarning; }).length) {
	                return Promise.reject(toError(api));
	            }
	            return api;
	        }
	        catch (err) {
	            return Promise.reject(err);
	        }
	    });
	}
	function getProject(apiPath, options) {
	    options = options || {};
	    var includeResolver = options.fsResolver;
	    var httpResolver = options.httpResolver;
	    var projectRoot = path.dirname(apiPath);
	    var project = new jsyaml.Project(projectRoot, includeResolver, httpResolver);
	    return project;
	}
	;
	function toApi(unitOrHighlevel, options, checkApisOverlays) {
	    if (checkApisOverlays === void 0) { checkApisOverlays = false; }
	    if (!unitOrHighlevel) {
	        return null;
	    }
	    var unit = null;
	    var highLevel = null;
	    if (unitOrHighlevel.isRAMLUnit) {
	        unit = unitOrHighlevel;
	    }
	    else {
	        highLevel = unitOrHighlevel;
	        unit = highLevel.lowLevel().unit();
	    }
	    var api;
	    var contents = unit.contents();
	    var ramlFirstLine = hlimpl.ramlFirstLine(contents);
	    if (!ramlFirstLine) {
	        throw new Error("Invalid first line. A RAML document is expected to start with '#%RAML <version> <?fragment type>'.");
	    }
	    var verStr = ramlFirstLine[1];
	    var ramlFileType = ramlFirstLine[2];
	    var typeName;
	    var apiImpl;
	    var ramlVersion;
	    if (verStr == '0.8') {
	        ramlVersion = 'RAML08';
	    }
	    else if (verStr == '1.0') {
	        ramlVersion = 'RAML10';
	    }
	    if (!ramlVersion) {
	        throw new Error("Unknown version of RAML expected to see one of '#%RAML 0.8' or '#%RAML 1.0'");
	    }
	    if (ramlVersion == 'RAML08' && checkApisOverlays) {
	        throw new Error('Extensions and overlays are not supported in RAML 0.8.');
	    }
	    //if (!ramlFileType || ramlFileType.trim() === "") {
	    //    if (verStr=='0.8') {
	    //        typeName = universeDef.Universe08.Api.name;
	    //        apiImpl = RamlWrapper08.ApiImpl;
	    //    } else if(verStr=='1.0'){
	    //        typeName = universeDef.Universe10.Api.name;
	    //        apiImpl = RamlWrapper1.ApiImpl;
	    //    }
	    //} else if (ramlFileType === "Overlay") {
	    //    apiImpl = RamlWrapper1.OverlayImpl;
	    //    typeName = universeDef.Universe10.Overlay.name;
	    //} else if (ramlFileType === "Extension") {
	    //    apiImpl = RamlWrapper1.ExtensionImpl;
	    //    typeName = universeDef.Universe10.Extension.name;
	    //}
	    var universe = universeProvider(ramlVersion);
	    var apiType = universe.type(typeName);
	    if (!highLevel) {
	        highLevel = hlimpl.fromUnit(unit);
	    }
	    //api = new apiImpl(highLevel);
	    api = highLevel.wrapperNode();
	    return api;
	}
	;
	function toError(api) {
	    var error = new Error('Api contains errors.');
	    error.parserErrors = api.errors();
	    return error;
	}
	exports.toError = toError;
	function loadApis1(projectRoot, cacheChildren, expandTraitsAndResourceTypes) {
	    if (cacheChildren === void 0) { cacheChildren = false; }
	    if (expandTraitsAndResourceTypes === void 0) { expandTraitsAndResourceTypes = true; }
	    var universe = universeProvider("RAML10");
	    var apiType = universe.type(universeDef.Universe10.Api.name);
	    var p = new jsyaml.Project(projectRoot);
	    var result = [];
	    p.units().forEach(function (x) {
	        var lowLevel = x.ast();
	        if (cacheChildren) {
	            lowLevel = llimpl.toChildCachingNode(lowLevel);
	        }
	        var api = new RamlWrapper1Impl.ApiImpl(new hlimpl.ASTNodeImpl(lowLevel, null, apiType, null));
	        if (expandTraitsAndResourceTypes) {
	            api = expander.expandTraitsAndResourceTypes(api);
	        }
	        result.push(api);
	    });
	    return result;
	}
	exports.loadApis1 = loadApis1;
	//# sourceMappingURL=apiLoader.js.map

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	(function (NodeKind) {
	    NodeKind[NodeKind["BASIC"] = 0] = "BASIC";
	    NodeKind[NodeKind["NODE"] = 1] = "NODE";
	    NodeKind[NodeKind["ATTRIBUTE"] = 2] = "ATTRIBUTE";
	})(exports.NodeKind || (exports.NodeKind = {}));
	var NodeKind = exports.NodeKind;
	(function (RAMLVersion) {
	    RAMLVersion[RAMLVersion["RAML10"] = 0] = "RAML10";
	    RAMLVersion[RAMLVersion["RAML08"] = 1] = "RAML08";
	})(exports.RAMLVersion || (exports.RAMLVersion = {}));
	var RAMLVersion = exports.RAMLVersion;
	function isParseResult(object) {
	    return object.asElement && object.getKind && object.asAttr && object.lowLevel;
	}
	exports.isParseResult = isParseResult;
	(function (IssueCode) {
	    IssueCode[IssueCode["UNRESOLVED_REFERENCE"] = 0] = "UNRESOLVED_REFERENCE";
	    IssueCode[IssueCode["YAML_ERROR"] = 1] = "YAML_ERROR";
	    IssueCode[IssueCode["UNKNOWN_NODE"] = 2] = "UNKNOWN_NODE";
	    IssueCode[IssueCode["MISSING_REQUIRED_PROPERTY"] = 3] = "MISSING_REQUIRED_PROPERTY";
	    IssueCode[IssueCode["PROPERTY_EXPECT_TO_HAVE_SINGLE_VALUE"] = 4] = "PROPERTY_EXPECT_TO_HAVE_SINGLE_VALUE";
	    //TODO IMPLEMENT
	    IssueCode[IssueCode["KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT"] = 5] = "KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT";
	    IssueCode[IssueCode["UNABLE_TO_RESOLVE_INCLUDE_FILE"] = 6] = "UNABLE_TO_RESOLVE_INCLUDE_FILE";
	    IssueCode[IssueCode["INVALID_VALUE_SCHEMA"] = 7] = "INVALID_VALUE_SCHEMA";
	    IssueCode[IssueCode["MISSED_CONTEXT_REQUIREMENT"] = 8] = "MISSED_CONTEXT_REQUIREMENT";
	    IssueCode[IssueCode["NODE_HAS_VALUE"] = 9] = "NODE_HAS_VALUE";
	    IssueCode[IssueCode["ONLY_OVERRIDE_ALLOWED"] = 10] = "ONLY_OVERRIDE_ALLOWED";
	    IssueCode[IssueCode["ILLEGAL_PROPERTY_VALUE"] = 11] = "ILLEGAL_PROPERTY_VALUE";
	    IssueCode[IssueCode["ILLEGAL_PROPERTY"] = 12] = "ILLEGAL_PROPERTY";
	    IssueCode[IssueCode["INVALID_PROPERTY"] = 13] = "INVALID_PROPERTY";
	})(exports.IssueCode || (exports.IssueCode = {}));
	var IssueCode = exports.IssueCode;
	//# sourceMappingURL=highLevelAST.js.map

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var path = __webpack_require__(15);
	var URL = __webpack_require__(37);
	var util = __webpack_require__(32);
	var ASTDelta = (function () {
	    function ASTDelta() {
	    }
	    return ASTDelta;
	}());
	exports.ASTDelta = ASTDelta;
	(function (CommandKind) {
	    CommandKind[CommandKind["ADD_CHILD"] = 0] = "ADD_CHILD";
	    CommandKind[CommandKind["REMOVE_CHILD"] = 1] = "REMOVE_CHILD";
	    CommandKind[CommandKind["MOVE_CHILD"] = 2] = "MOVE_CHILD";
	    CommandKind[CommandKind["CHANGE_KEY"] = 3] = "CHANGE_KEY";
	    CommandKind[CommandKind["CHANGE_VALUE"] = 4] = "CHANGE_VALUE";
	    CommandKind[CommandKind["INIT_RAML_FILE"] = 5] = "INIT_RAML_FILE";
	})(exports.CommandKind || (exports.CommandKind = {}));
	var CommandKind = exports.CommandKind;
	var TextChangeCommand = (function () {
	    function TextChangeCommand(offset, replacementLength, text, unit, target) {
	        if (target === void 0) { target = null; }
	        this.offset = offset;
	        this.replacementLength = replacementLength;
	        this.text = text;
	        this.unit = unit;
	        this.target = target;
	    }
	    return TextChangeCommand;
	}());
	exports.TextChangeCommand = TextChangeCommand;
	var CompositeCommand = (function () {
	    function CompositeCommand() {
	        this.commands = [];
	    }
	    return CompositeCommand;
	}());
	exports.CompositeCommand = CompositeCommand;
	(function (InsertionPointType) {
	    InsertionPointType[InsertionPointType["NONE"] = 0] = "NONE";
	    InsertionPointType[InsertionPointType["START"] = 1] = "START";
	    InsertionPointType[InsertionPointType["END"] = 2] = "END";
	    InsertionPointType[InsertionPointType["POINT"] = 3] = "POINT";
	})(exports.InsertionPointType || (exports.InsertionPointType = {}));
	var InsertionPointType = exports.InsertionPointType;
	var ASTChangeCommand = (function () {
	    function ASTChangeCommand(kind, target, value, position) {
	        this.toSeq = false;
	        this.kind = kind;
	        this.target = target;
	        this.value = value;
	        this.position = position;
	    }
	    return ASTChangeCommand;
	}());
	exports.ASTChangeCommand = ASTChangeCommand;
	function setAttr(t, value) {
	    return new ASTChangeCommand(CommandKind.CHANGE_VALUE, t, value, -1);
	}
	exports.setAttr = setAttr;
	function setAttrStructured(t, value) {
	    return new ASTChangeCommand(CommandKind.CHANGE_VALUE, t, value.lowLevel(), -1);
	}
	exports.setAttrStructured = setAttrStructured;
	function setKey(t, value) {
	    return new ASTChangeCommand(CommandKind.CHANGE_KEY, t, value, -1);
	}
	exports.setKey = setKey;
	function removeNode(t, child) {
	    return new ASTChangeCommand(CommandKind.REMOVE_CHILD, t, child, -1);
	}
	exports.removeNode = removeNode;
	function insertNode(t, child, insertAfter, toSeq) {
	    if (insertAfter === void 0) { insertAfter = null; }
	    if (toSeq === void 0) { toSeq = false; }
	    var s = new ASTChangeCommand(CommandKind.ADD_CHILD, t, child, -1);
	    s.insertionPoint = insertAfter;
	    s.toSeq = toSeq;
	    return s;
	}
	exports.insertNode = insertNode;
	function initRamlFile(root, newroot) {
	    return new ASTChangeCommand(CommandKind.INIT_RAML_FILE, root, newroot, -1);
	}
	exports.initRamlFile = initRamlFile;
	var LineMapperImpl = (function () {
	    function LineMapperImpl(content, absPath) {
	        this.content = content;
	        this.absPath = absPath;
	    }
	    LineMapperImpl.prototype.position = function (_pos) {
	        var pos = _pos;
	        this.initMapping();
	        for (var i = 0; i < this.mapping.length; i++) {
	            var lineLength = this.mapping[i];
	            if (pos < lineLength) {
	                return {
	                    line: i,
	                    column: pos,
	                    position: _pos
	                };
	            }
	            pos -= lineLength;
	        }
	        if (pos == 0) {
	            return {
	                line: this.mapping.length - 1,
	                column: this.mapping[this.mapping.length - 1],
	                position: this.content.length
	            };
	        }
	        if (pos == 1) {
	            //sometimes YAML library reports an error at a position of document length + 1, no idea what they want
	            //to tell us that way
	            return {
	                line: this.mapping.length - 1,
	                column: this.mapping[this.mapping.length - 1] - 1,
	                position: _pos - 1
	            };
	        }
	        throw new Error("Character position exceeds text length: " + _pos + " > + " + this.content.length + ".\nUnit path: " + this.absPath);
	    };
	    LineMapperImpl.prototype.initMapping = function () {
	        if (this.mapping != null) {
	            return;
	        }
	        if (this.content == null) {
	            throw new Error("Line Mapper has been given null content" + (this.absPath != null
	                ? ('. Path: ' + this.absPath) : ' and null path.'));
	        }
	        this.mapping = [];
	        var ind = 0;
	        var l = this.content.length;
	        for (var i = 0; i < l; i++) {
	            if (this.content.charAt(i) == '\r') {
	                if (i < l - 1 && this.content.charAt(i + 1) == '\n') {
	                    this.mapping.push(i - ind + 2);
	                    ind = i + 2;
	                    i++;
	                }
	                else {
	                    this.mapping.push(i - ind + 1);
	                    ind = i + 1;
	                }
	            }
	            else if (this.content.charAt(i) == '\n') {
	                this.mapping.push(i - ind + 1);
	                ind = i + 1;
	            }
	        }
	        this.mapping.push(l - ind);
	    };
	    return LineMapperImpl;
	}());
	exports.LineMapperImpl = LineMapperImpl;
	/**
	 * Canonic way of resolving references in RAML specs:
	 * * relative reference is regarded as relative to containing unit
	 * * absolute local path (starting with slash) is regarderd as relative to root RAML
	 * * absolute web paths are regarded as such
	 *
	 * @param reference reference to be resolved
	 * @param unitPath path of unit containing the reference, absolute or relative to root
	 * @param rootPath path to root RAML
	 * @returns resolved path
	 */
	function buildPath(reference, unitPath, rootPath) {
	    if (path.isAbsolute(reference)) {
	        var e = path.extname(unitPath);
	        if (e != ".xsd") {
	            //SUPPORTING 0.8 style resolving due to compatiblity reasons
	            reference = reference.substr(1);
	            unitPath = toAbsolutePath(rootPath, path.basename(unitPath));
	        }
	    }
	    if (isWebPath(reference) || path.isAbsolute(reference)) {
	        return reference;
	    }
	    if (isWebPath(unitPath) || path.isAbsolute(unitPath)) {
	        return toAbsolutePath(path.dirname(unitPath), reference);
	    }
	    return toAbsolutePath(path.dirname(toAbsolutePath(rootPath, unitPath)), reference);
	}
	exports.buildPath = buildPath;
	/**
	 * Resolving reference against context
	 * * absolute local and web references are regarded as such
	 * * relative references are regarded as relative to the context
	 * @param context absolute local or web path
	 * @param reference
	 * @returns resolved reference
	 */
	function toAbsolutePath(context, reference) {
	    if (isWebPath(reference)) {
	        return reference;
	    }
	    var apath;
	    if (isWebPath(context)) {
	        var rp = util.stringEndsWith(context, "/") ? context : context + "/";
	        apath = URL.resolve(rp, reference).replace(/\\/g, "/");
	    }
	    else {
	        apath = path.resolve(context, reference).replace(/\\/g, "/");
	    }
	    return apath;
	}
	exports.toAbsolutePath = toAbsolutePath;
	/**
	 * Check if reference points to web resource
	 * @param reference
	 * @returns {boolean}
	 */
	function isWebPath(reference) {
	    if (reference == null)
	        return false;
	    return util.stringStartsWith(reference, "http://") || util.stringStartsWith(reference, "https://");
	}
	exports.isWebPath = isWebPath;
	function isLowLevelNode(object) {
	    return object.start && object.end && object.unit && object.key
	        && object.value && object.children && object.includePath;
	}
	exports.isLowLevelNode = isLowLevelNode;
	//# sourceMappingURL=lowLevelAST.js.map

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * <p>See <a href="http://raml.org">http://raml.org</a> for more information about RAML.</p>
	 *
	 * <p>This parser is at a beta state of development, as part of the API Workbench development cycle (<a href="http://apiworkbench.com">http://apiworkbench.com</a>).</p>
	 *
	 * <p><a href="https://github.com/raml-org/raml-js-parser-2/blob/master/documentation/GettingStarted.md">Getting Started Guide</a> describes the first steps with the parser.</p>
	 *
	 * <h2>Installation</h2>
	 *
	 * <pre><code>git clone https://github.com/raml-org/raml-js-parser-2
	 *
	 * cd raml-js-parser-2
	 *
	 * npm install
	 *
	 * node test/test.js  //here you should observe JSON representation of XKCD API in your console
	 *
	 * node test/testAsync.js  //same as above but in asynchronous mode
	 * </code></pre>
	 *
	 * <h2>Usage</h2>
	 *
	 * <ul>
	 * <li>For parser usage example refer to <code>test/test.js</code></li>
	 * <li>For asynchrounous usage example refer to <code>test/testAsync.js</code></li>
	 * </ul>
	 **/
	"use strict";
	/**
	 * Custom type guard for Api. Returns true if node is instance of Api. Returns false otherwise.
	 * Also returns false for super interfaces of Api.
	 */
	function isApi(node) {
	    return node.kind() == "Api" && node.RAMLVersion() == "RAML10";
	}
	exports.isApi = isApi;
	/**
	 * Custom type guard for LibraryBase. Returns true if node is instance of LibraryBase. Returns false otherwise.
	 * Also returns false for super interfaces of LibraryBase.
	 */
	function isLibraryBase(node) {
	    return node.kind() == "LibraryBase" && node.RAMLVersion() == "RAML10";
	}
	exports.isLibraryBase = isLibraryBase;
	/**
	 * Custom type guard for Annotable. Returns true if node is instance of Annotable. Returns false otherwise.
	 * Also returns false for super interfaces of Annotable.
	 */
	function isAnnotable(node) {
	    return node.kind() == "Annotable" && node.RAMLVersion() == "RAML10";
	}
	exports.isAnnotable = isAnnotable;
	/**
	 * Custom type guard for AnnotationRef. Returns true if node is instance of AnnotationRef. Returns false otherwise.
	 * Also returns false for super interfaces of AnnotationRef.
	 */
	function isAnnotationRef(node) {
	    return node.kind() == "AnnotationRef" && node.RAMLVersion() == "RAML10";
	}
	exports.isAnnotationRef = isAnnotationRef;
	/**
	 * Custom type guard for Reference. Returns true if node is instance of Reference. Returns false otherwise.
	 * Also returns false for super interfaces of Reference.
	 */
	function isReference(node) {
	    return node.kind() == "Reference" && node.RAMLVersion() == "RAML10";
	}
	exports.isReference = isReference;
	/**
	 * Custom type guard for ValueType. Returns true if node is instance of ValueType. Returns false otherwise.
	 * Also returns false for super interfaces of ValueType.
	 */
	function isValueType(node) {
	    return node.kind() == "ValueType" && node.RAMLVersion() == "RAML10";
	}
	exports.isValueType = isValueType;
	/**
	 * Custom type guard for StringType. Returns true if node is instance of StringType. Returns false otherwise.
	 * Also returns false for super interfaces of StringType.
	 */
	function isStringType(node) {
	    return node.kind() == "StringType" && node.RAMLVersion() == "RAML10";
	}
	exports.isStringType = isStringType;
	/**
	 * Custom type guard for UriTemplate. Returns true if node is instance of UriTemplate. Returns false otherwise.
	 * Also returns false for super interfaces of UriTemplate.
	 */
	function isUriTemplate(node) {
	    return node.kind() == "UriTemplate" && node.RAMLVersion() == "RAML10";
	}
	exports.isUriTemplate = isUriTemplate;
	/**
	 * Custom type guard for RelativeUriString. Returns true if node is instance of RelativeUriString. Returns false otherwise.
	 * Also returns false for super interfaces of RelativeUriString.
	 */
	function isRelativeUriString(node) {
	    return node.kind() == "RelativeUriString" && node.RAMLVersion() == "RAML10";
	}
	exports.isRelativeUriString = isRelativeUriString;
	/**
	 * Custom type guard for FullUriTemplateString. Returns true if node is instance of FullUriTemplateString. Returns false otherwise.
	 * Also returns false for super interfaces of FullUriTemplateString.
	 */
	function isFullUriTemplateString(node) {
	    return node.kind() == "FullUriTemplateString" && node.RAMLVersion() == "RAML10";
	}
	exports.isFullUriTemplateString = isFullUriTemplateString;
	/**
	 * Custom type guard for StatusCodeString. Returns true if node is instance of StatusCodeString. Returns false otherwise.
	 * Also returns false for super interfaces of StatusCodeString.
	 */
	function isStatusCodeString(node) {
	    return node.kind() == "StatusCodeString" && node.RAMLVersion() == "RAML10";
	}
	exports.isStatusCodeString = isStatusCodeString;
	/**
	 * Custom type guard for FixedUriString. Returns true if node is instance of FixedUriString. Returns false otherwise.
	 * Also returns false for super interfaces of FixedUriString.
	 */
	function isFixedUriString(node) {
	    return node.kind() == "FixedUriString" && node.RAMLVersion() == "RAML10";
	}
	exports.isFixedUriString = isFixedUriString;
	/**
	 * Custom type guard for ContentType. Returns true if node is instance of ContentType. Returns false otherwise.
	 * Also returns false for super interfaces of ContentType.
	 */
	function isContentType(node) {
	    return node.kind() == "ContentType" && node.RAMLVersion() == "RAML10";
	}
	exports.isContentType = isContentType;
	/**
	 * Custom type guard for MarkdownString. Returns true if node is instance of MarkdownString. Returns false otherwise.
	 * Also returns false for super interfaces of MarkdownString.
	 */
	function isMarkdownString(node) {
	    return node.kind() == "MarkdownString" && node.RAMLVersion() == "RAML10";
	}
	exports.isMarkdownString = isMarkdownString;
	/**
	 * Custom type guard for SchemaString. Returns true if node is instance of SchemaString. Returns false otherwise.
	 * Also returns false for super interfaces of SchemaString.
	 */
	function isSchemaString(node) {
	    return node.kind() == "SchemaString" && node.RAMLVersion() == "RAML10";
	}
	exports.isSchemaString = isSchemaString;
	/**
	 * Custom type guard for MimeType. Returns true if node is instance of MimeType. Returns false otherwise.
	 * Also returns false for super interfaces of MimeType.
	 */
	function isMimeType(node) {
	    return node.kind() == "MimeType" && node.RAMLVersion() == "RAML10";
	}
	exports.isMimeType = isMimeType;
	/**
	 * Custom type guard for AnyType. Returns true if node is instance of AnyType. Returns false otherwise.
	 * Also returns false for super interfaces of AnyType.
	 */
	function isAnyType(node) {
	    return node.kind() == "AnyType" && node.RAMLVersion() == "RAML10";
	}
	exports.isAnyType = isAnyType;
	/**
	 * Custom type guard for NumberType. Returns true if node is instance of NumberType. Returns false otherwise.
	 * Also returns false for super interfaces of NumberType.
	 */
	function isNumberType(node) {
	    return node.kind() == "NumberType" && node.RAMLVersion() == "RAML10";
	}
	exports.isNumberType = isNumberType;
	/**
	 * Custom type guard for IntegerType. Returns true if node is instance of IntegerType. Returns false otherwise.
	 * Also returns false for super interfaces of IntegerType.
	 */
	function isIntegerType(node) {
	    return node.kind() == "IntegerType" && node.RAMLVersion() == "RAML10";
	}
	exports.isIntegerType = isIntegerType;
	/**
	 * Custom type guard for NullType. Returns true if node is instance of NullType. Returns false otherwise.
	 * Also returns false for super interfaces of NullType.
	 */
	function isNullType(node) {
	    return node.kind() == "NullType" && node.RAMLVersion() == "RAML10";
	}
	exports.isNullType = isNullType;
	/**
	 * Custom type guard for TimeOnlyType. Returns true if node is instance of TimeOnlyType. Returns false otherwise.
	 * Also returns false for super interfaces of TimeOnlyType.
	 */
	function isTimeOnlyType(node) {
	    return node.kind() == "TimeOnlyType" && node.RAMLVersion() == "RAML10";
	}
	exports.isTimeOnlyType = isTimeOnlyType;
	/**
	 * Custom type guard for DateOnlyType. Returns true if node is instance of DateOnlyType. Returns false otherwise.
	 * Also returns false for super interfaces of DateOnlyType.
	 */
	function isDateOnlyType(node) {
	    return node.kind() == "DateOnlyType" && node.RAMLVersion() == "RAML10";
	}
	exports.isDateOnlyType = isDateOnlyType;
	/**
	 * Custom type guard for DateTimeOnlyType. Returns true if node is instance of DateTimeOnlyType. Returns false otherwise.
	 * Also returns false for super interfaces of DateTimeOnlyType.
	 */
	function isDateTimeOnlyType(node) {
	    return node.kind() == "DateTimeOnlyType" && node.RAMLVersion() == "RAML10";
	}
	exports.isDateTimeOnlyType = isDateTimeOnlyType;
	/**
	 * Custom type guard for DateTimeType. Returns true if node is instance of DateTimeType. Returns false otherwise.
	 * Also returns false for super interfaces of DateTimeType.
	 */
	function isDateTimeType(node) {
	    return node.kind() == "DateTimeType" && node.RAMLVersion() == "RAML10";
	}
	exports.isDateTimeType = isDateTimeType;
	/**
	 * Custom type guard for FileType. Returns true if node is instance of FileType. Returns false otherwise.
	 * Also returns false for super interfaces of FileType.
	 */
	function isFileType(node) {
	    return node.kind() == "FileType" && node.RAMLVersion() == "RAML10";
	}
	exports.isFileType = isFileType;
	/**
	 * Custom type guard for BooleanType. Returns true if node is instance of BooleanType. Returns false otherwise.
	 * Also returns false for super interfaces of BooleanType.
	 */
	function isBooleanType(node) {
	    return node.kind() == "BooleanType" && node.RAMLVersion() == "RAML10";
	}
	exports.isBooleanType = isBooleanType;
	/**
	 * Custom type guard for AnnotationTarget. Returns true if node is instance of AnnotationTarget. Returns false otherwise.
	 * Also returns false for super interfaces of AnnotationTarget.
	 */
	function isAnnotationTarget(node) {
	    return node.kind() == "AnnotationTarget" && node.RAMLVersion() == "RAML10";
	}
	exports.isAnnotationTarget = isAnnotationTarget;
	/**
	 * Custom type guard for TraitRef. Returns true if node is instance of TraitRef. Returns false otherwise.
	 * Also returns false for super interfaces of TraitRef.
	 */
	function isTraitRef(node) {
	    return node.kind() == "TraitRef" && node.RAMLVersion() == "RAML10";
	}
	exports.isTraitRef = isTraitRef;
	/**
	 * Custom type guard for Trait. Returns true if node is instance of Trait. Returns false otherwise.
	 * Also returns false for super interfaces of Trait.
	 */
	function isTrait(node) {
	    return node.kind() == "Trait" && node.RAMLVersion() == "RAML10";
	}
	exports.isTrait = isTrait;
	/**
	 * Custom type guard for MethodBase. Returns true if node is instance of MethodBase. Returns false otherwise.
	 * Also returns false for super interfaces of MethodBase.
	 */
	function isMethodBase(node) {
	    return node.kind() == "MethodBase" && node.RAMLVersion() == "RAML10";
	}
	exports.isMethodBase = isMethodBase;
	/**
	 * Custom type guard for Operation. Returns true if node is instance of Operation. Returns false otherwise.
	 * Also returns false for super interfaces of Operation.
	 */
	function isOperation(node) {
	    return node.kind() == "Operation" && node.RAMLVersion() == "RAML10";
	}
	exports.isOperation = isOperation;
	/**
	 * Custom type guard for TypeDeclaration. Returns true if node is instance of TypeDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of TypeDeclaration.
	 */
	function isTypeDeclaration(node) {
	    return node.kind() == "TypeDeclaration" && node.RAMLVersion() == "RAML10";
	}
	exports.isTypeDeclaration = isTypeDeclaration;
	/**
	 * Custom type guard for ModelLocation. Returns true if node is instance of ModelLocation. Returns false otherwise.
	 * Also returns false for super interfaces of ModelLocation.
	 */
	function isModelLocation(node) {
	    return node.kind() == "ModelLocation" && node.RAMLVersion() == "RAML10";
	}
	exports.isModelLocation = isModelLocation;
	/**
	 * Custom type guard for LocationKind. Returns true if node is instance of LocationKind. Returns false otherwise.
	 * Also returns false for super interfaces of LocationKind.
	 */
	function isLocationKind(node) {
	    return node.kind() == "LocationKind" && node.RAMLVersion() == "RAML10";
	}
	exports.isLocationKind = isLocationKind;
	/**
	 * Custom type guard for ExampleSpec. Returns true if node is instance of ExampleSpec. Returns false otherwise.
	 * Also returns false for super interfaces of ExampleSpec.
	 */
	function isExampleSpec(node) {
	    return node.kind() == "ExampleSpec" && node.RAMLVersion() == "RAML10";
	}
	exports.isExampleSpec = isExampleSpec;
	/**
	 * Custom type guard for UsesDeclaration. Returns true if node is instance of UsesDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of UsesDeclaration.
	 */
	function isUsesDeclaration(node) {
	    return node.kind() == "UsesDeclaration" && node.RAMLVersion() == "RAML10";
	}
	exports.isUsesDeclaration = isUsesDeclaration;
	/**
	 * Custom type guard for XMLFacetInfo. Returns true if node is instance of XMLFacetInfo. Returns false otherwise.
	 * Also returns false for super interfaces of XMLFacetInfo.
	 */
	function isXMLFacetInfo(node) {
	    return node.kind() == "XMLFacetInfo" && node.RAMLVersion() == "RAML10";
	}
	exports.isXMLFacetInfo = isXMLFacetInfo;
	/**
	 * Custom type guard for ArrayTypeDeclaration. Returns true if node is instance of ArrayTypeDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of ArrayTypeDeclaration.
	 */
	function isArrayTypeDeclaration(node) {
	    return node.kind() == "ArrayTypeDeclaration" && node.RAMLVersion() == "RAML10";
	}
	exports.isArrayTypeDeclaration = isArrayTypeDeclaration;
	/**
	 * Custom type guard for UnionTypeDeclaration. Returns true if node is instance of UnionTypeDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of UnionTypeDeclaration.
	 */
	function isUnionTypeDeclaration(node) {
	    return node.kind() == "UnionTypeDeclaration" && node.RAMLVersion() == "RAML10";
	}
	exports.isUnionTypeDeclaration = isUnionTypeDeclaration;
	/**
	 * Custom type guard for ObjectTypeDeclaration. Returns true if node is instance of ObjectTypeDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of ObjectTypeDeclaration.
	 */
	function isObjectTypeDeclaration(node) {
	    return node.kind() == "ObjectTypeDeclaration" && node.RAMLVersion() == "RAML10";
	}
	exports.isObjectTypeDeclaration = isObjectTypeDeclaration;
	/**
	 * Custom type guard for StringTypeDeclaration. Returns true if node is instance of StringTypeDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of StringTypeDeclaration.
	 */
	function isStringTypeDeclaration(node) {
	    return node.kind() == "StringTypeDeclaration" && node.RAMLVersion() == "RAML10";
	}
	exports.isStringTypeDeclaration = isStringTypeDeclaration;
	/**
	 * Custom type guard for BooleanTypeDeclaration. Returns true if node is instance of BooleanTypeDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of BooleanTypeDeclaration.
	 */
	function isBooleanTypeDeclaration(node) {
	    return node.kind() == "BooleanTypeDeclaration" && node.RAMLVersion() == "RAML10";
	}
	exports.isBooleanTypeDeclaration = isBooleanTypeDeclaration;
	/**
	 * Custom type guard for NumberTypeDeclaration. Returns true if node is instance of NumberTypeDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of NumberTypeDeclaration.
	 */
	function isNumberTypeDeclaration(node) {
	    return node.kind() == "NumberTypeDeclaration" && node.RAMLVersion() == "RAML10";
	}
	exports.isNumberTypeDeclaration = isNumberTypeDeclaration;
	/**
	 * Custom type guard for IntegerTypeDeclaration. Returns true if node is instance of IntegerTypeDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of IntegerTypeDeclaration.
	 */
	function isIntegerTypeDeclaration(node) {
	    return node.kind() == "IntegerTypeDeclaration" && node.RAMLVersion() == "RAML10";
	}
	exports.isIntegerTypeDeclaration = isIntegerTypeDeclaration;
	/**
	 * Custom type guard for DateOnlyTypeDeclaration. Returns true if node is instance of DateOnlyTypeDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of DateOnlyTypeDeclaration.
	 */
	function isDateOnlyTypeDeclaration(node) {
	    return node.kind() == "DateOnlyTypeDeclaration" && node.RAMLVersion() == "RAML10";
	}
	exports.isDateOnlyTypeDeclaration = isDateOnlyTypeDeclaration;
	/**
	 * Custom type guard for TimeOnlyTypeDeclaration. Returns true if node is instance of TimeOnlyTypeDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of TimeOnlyTypeDeclaration.
	 */
	function isTimeOnlyTypeDeclaration(node) {
	    return node.kind() == "TimeOnlyTypeDeclaration" && node.RAMLVersion() == "RAML10";
	}
	exports.isTimeOnlyTypeDeclaration = isTimeOnlyTypeDeclaration;
	/**
	 * Custom type guard for DateTimeOnlyTypeDeclaration. Returns true if node is instance of DateTimeOnlyTypeDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of DateTimeOnlyTypeDeclaration.
	 */
	function isDateTimeOnlyTypeDeclaration(node) {
	    return node.kind() == "DateTimeOnlyTypeDeclaration" && node.RAMLVersion() == "RAML10";
	}
	exports.isDateTimeOnlyTypeDeclaration = isDateTimeOnlyTypeDeclaration;
	/**
	 * Custom type guard for DateTimeTypeDeclaration. Returns true if node is instance of DateTimeTypeDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of DateTimeTypeDeclaration.
	 */
	function isDateTimeTypeDeclaration(node) {
	    return node.kind() == "DateTimeTypeDeclaration" && node.RAMLVersion() == "RAML10";
	}
	exports.isDateTimeTypeDeclaration = isDateTimeTypeDeclaration;
	/**
	 * Custom type guard for FileTypeDeclaration. Returns true if node is instance of FileTypeDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of FileTypeDeclaration.
	 */
	function isFileTypeDeclaration(node) {
	    return node.kind() == "FileTypeDeclaration" && node.RAMLVersion() == "RAML10";
	}
	exports.isFileTypeDeclaration = isFileTypeDeclaration;
	/**
	 * Custom type guard for Response. Returns true if node is instance of Response. Returns false otherwise.
	 * Also returns false for super interfaces of Response.
	 */
	function isResponse(node) {
	    return node.kind() == "Response" && node.RAMLVersion() == "RAML10";
	}
	exports.isResponse = isResponse;
	/**
	 * Custom type guard for SecuritySchemePart. Returns true if node is instance of SecuritySchemePart. Returns false otherwise.
	 * Also returns false for super interfaces of SecuritySchemePart.
	 */
	function isSecuritySchemePart(node) {
	    return node.kind() == "SecuritySchemePart" && node.RAMLVersion() == "RAML10";
	}
	exports.isSecuritySchemePart = isSecuritySchemePart;
	/**
	 * Custom type guard for SecuritySchemeRef. Returns true if node is instance of SecuritySchemeRef. Returns false otherwise.
	 * Also returns false for super interfaces of SecuritySchemeRef.
	 */
	function isSecuritySchemeRef(node) {
	    return node.kind() == "SecuritySchemeRef" && node.RAMLVersion() == "RAML10";
	}
	exports.isSecuritySchemeRef = isSecuritySchemeRef;
	/**
	 * Custom type guard for AbstractSecurityScheme. Returns true if node is instance of AbstractSecurityScheme. Returns false otherwise.
	 * Also returns false for super interfaces of AbstractSecurityScheme.
	 */
	function isAbstractSecurityScheme(node) {
	    return node.kind() == "AbstractSecurityScheme" && node.RAMLVersion() == "RAML10";
	}
	exports.isAbstractSecurityScheme = isAbstractSecurityScheme;
	/**
	 * Custom type guard for SecuritySchemeSettings. Returns true if node is instance of SecuritySchemeSettings. Returns false otherwise.
	 * Also returns false for super interfaces of SecuritySchemeSettings.
	 */
	function isSecuritySchemeSettings(node) {
	    return node.kind() == "SecuritySchemeSettings" && node.RAMLVersion() == "RAML10";
	}
	exports.isSecuritySchemeSettings = isSecuritySchemeSettings;
	/**
	 * Custom type guard for OAuth1SecuritySchemeSettings. Returns true if node is instance of OAuth1SecuritySchemeSettings. Returns false otherwise.
	 * Also returns false for super interfaces of OAuth1SecuritySchemeSettings.
	 */
	function isOAuth1SecuritySchemeSettings(node) {
	    return node.kind() == "OAuth1SecuritySchemeSettings" && node.RAMLVersion() == "RAML10";
	}
	exports.isOAuth1SecuritySchemeSettings = isOAuth1SecuritySchemeSettings;
	/**
	 * Custom type guard for OAuth2SecuritySchemeSettings. Returns true if node is instance of OAuth2SecuritySchemeSettings. Returns false otherwise.
	 * Also returns false for super interfaces of OAuth2SecuritySchemeSettings.
	 */
	function isOAuth2SecuritySchemeSettings(node) {
	    return node.kind() == "OAuth2SecuritySchemeSettings" && node.RAMLVersion() == "RAML10";
	}
	exports.isOAuth2SecuritySchemeSettings = isOAuth2SecuritySchemeSettings;
	/**
	 * Custom type guard for OAuth2SecurityScheme. Returns true if node is instance of OAuth2SecurityScheme. Returns false otherwise.
	 * Also returns false for super interfaces of OAuth2SecurityScheme.
	 */
	function isOAuth2SecurityScheme(node) {
	    return node.kind() == "OAuth2SecurityScheme" && node.RAMLVersion() == "RAML10";
	}
	exports.isOAuth2SecurityScheme = isOAuth2SecurityScheme;
	/**
	 * Custom type guard for OAuth1SecurityScheme. Returns true if node is instance of OAuth1SecurityScheme. Returns false otherwise.
	 * Also returns false for super interfaces of OAuth1SecurityScheme.
	 */
	function isOAuth1SecurityScheme(node) {
	    return node.kind() == "OAuth1SecurityScheme" && node.RAMLVersion() == "RAML10";
	}
	exports.isOAuth1SecurityScheme = isOAuth1SecurityScheme;
	/**
	 * Custom type guard for PassThroughSecurityScheme. Returns true if node is instance of PassThroughSecurityScheme. Returns false otherwise.
	 * Also returns false for super interfaces of PassThroughSecurityScheme.
	 */
	function isPassThroughSecurityScheme(node) {
	    return node.kind() == "PassThroughSecurityScheme" && node.RAMLVersion() == "RAML10";
	}
	exports.isPassThroughSecurityScheme = isPassThroughSecurityScheme;
	/**
	 * Custom type guard for BasicSecurityScheme. Returns true if node is instance of BasicSecurityScheme. Returns false otherwise.
	 * Also returns false for super interfaces of BasicSecurityScheme.
	 */
	function isBasicSecurityScheme(node) {
	    return node.kind() == "BasicSecurityScheme" && node.RAMLVersion() == "RAML10";
	}
	exports.isBasicSecurityScheme = isBasicSecurityScheme;
	/**
	 * Custom type guard for DigestSecurityScheme. Returns true if node is instance of DigestSecurityScheme. Returns false otherwise.
	 * Also returns false for super interfaces of DigestSecurityScheme.
	 */
	function isDigestSecurityScheme(node) {
	    return node.kind() == "DigestSecurityScheme" && node.RAMLVersion() == "RAML10";
	}
	exports.isDigestSecurityScheme = isDigestSecurityScheme;
	/**
	 * Custom type guard for CustomSecurityScheme. Returns true if node is instance of CustomSecurityScheme. Returns false otherwise.
	 * Also returns false for super interfaces of CustomSecurityScheme.
	 */
	function isCustomSecurityScheme(node) {
	    return node.kind() == "CustomSecurityScheme" && node.RAMLVersion() == "RAML10";
	}
	exports.isCustomSecurityScheme = isCustomSecurityScheme;
	/**
	 * Custom type guard for Method. Returns true if node is instance of Method. Returns false otherwise.
	 * Also returns false for super interfaces of Method.
	 */
	function isMethod(node) {
	    return node.kind() == "Method" && node.RAMLVersion() == "RAML10";
	}
	exports.isMethod = isMethod;
	/**
	 * Custom type guard for ResourceTypeRef. Returns true if node is instance of ResourceTypeRef. Returns false otherwise.
	 * Also returns false for super interfaces of ResourceTypeRef.
	 */
	function isResourceTypeRef(node) {
	    return node.kind() == "ResourceTypeRef" && node.RAMLVersion() == "RAML10";
	}
	exports.isResourceTypeRef = isResourceTypeRef;
	/**
	 * Custom type guard for ResourceType. Returns true if node is instance of ResourceType. Returns false otherwise.
	 * Also returns false for super interfaces of ResourceType.
	 */
	function isResourceType(node) {
	    return node.kind() == "ResourceType" && node.RAMLVersion() == "RAML10";
	}
	exports.isResourceType = isResourceType;
	/**
	 * Custom type guard for ResourceBase. Returns true if node is instance of ResourceBase. Returns false otherwise.
	 * Also returns false for super interfaces of ResourceBase.
	 */
	function isResourceBase(node) {
	    return node.kind() == "ResourceBase" && node.RAMLVersion() == "RAML10";
	}
	exports.isResourceBase = isResourceBase;
	/**
	 * Custom type guard for Resource. Returns true if node is instance of Resource. Returns false otherwise.
	 * Also returns false for super interfaces of Resource.
	 */
	function isResource(node) {
	    return node.kind() == "Resource" && node.RAMLVersion() == "RAML10";
	}
	exports.isResource = isResource;
	/**
	 * Custom type guard for DocumentationItem. Returns true if node is instance of DocumentationItem. Returns false otherwise.
	 * Also returns false for super interfaces of DocumentationItem.
	 */
	function isDocumentationItem(node) {
	    return node.kind() == "DocumentationItem" && node.RAMLVersion() == "RAML10";
	}
	exports.isDocumentationItem = isDocumentationItem;
	/**
	 * Custom type guard for Library. Returns true if node is instance of Library. Returns false otherwise.
	 * Also returns false for super interfaces of Library.
	 */
	function isLibrary(node) {
	    return node.kind() == "Library" && node.RAMLVersion() == "RAML10";
	}
	exports.isLibrary = isLibrary;
	/**
	 * Custom type guard for Overlay. Returns true if node is instance of Overlay. Returns false otherwise.
	 * Also returns false for super interfaces of Overlay.
	 */
	function isOverlay(node) {
	    return node.kind() == "Overlay" && node.RAMLVersion() == "RAML10";
	}
	exports.isOverlay = isOverlay;
	/**
	 * Custom type guard for Extension. Returns true if node is instance of Extension. Returns false otherwise.
	 * Also returns false for super interfaces of Extension.
	 */
	function isExtension(node) {
	    return node.kind() == "Extension" && node.RAMLVersion() == "RAML10";
	}
	exports.isExtension = isExtension;
	/**
	 * Check if the AST node represents fragment
	 */
	function isFragment(node) {
	    return node.highLevel().parent() == null;
	}
	exports.isFragment = isFragment;
	/**
	 * Convert fragment representing node to FragmentDeclaration instance.
	 */
	function asFragment(node) {
	    return isFragment(node) ? node : null;
	}
	exports.asFragment = asFragment;
	//# sourceMappingURL=raml10parserapi.js.map

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * Custom type guard for Api. Returns true if node is instance of Api. Returns false otherwise.
	 * Also returns false for super interfaces of Api.
	 */
	function isApi(node) {
	    return node.kind() == "Api" && node.RAMLVersion() == "RAML08";
	}
	exports.isApi = isApi;
	/**
	 * Custom type guard for FullUriTemplateString. Returns true if node is instance of FullUriTemplateString. Returns false otherwise.
	 * Also returns false for super interfaces of FullUriTemplateString.
	 */
	function isFullUriTemplateString(node) {
	    return node.kind() == "FullUriTemplateString" && node.RAMLVersion() == "RAML08";
	}
	exports.isFullUriTemplateString = isFullUriTemplateString;
	/**
	 * Custom type guard for UriTemplate. Returns true if node is instance of UriTemplate. Returns false otherwise.
	 * Also returns false for super interfaces of UriTemplate.
	 */
	function isUriTemplate(node) {
	    return node.kind() == "UriTemplate" && node.RAMLVersion() == "RAML08";
	}
	exports.isUriTemplate = isUriTemplate;
	/**
	 * Custom type guard for StringType. Returns true if node is instance of StringType. Returns false otherwise.
	 * Also returns false for super interfaces of StringType.
	 */
	function isStringType(node) {
	    return node.kind() == "StringType" && node.RAMLVersion() == "RAML08";
	}
	exports.isStringType = isStringType;
	/**
	 * Custom type guard for ValueType. Returns true if node is instance of ValueType. Returns false otherwise.
	 * Also returns false for super interfaces of ValueType.
	 */
	function isValueType(node) {
	    return node.kind() == "ValueType" && node.RAMLVersion() == "RAML08";
	}
	exports.isValueType = isValueType;
	/**
	 * Custom type guard for AnyType. Returns true if node is instance of AnyType. Returns false otherwise.
	 * Also returns false for super interfaces of AnyType.
	 */
	function isAnyType(node) {
	    return node.kind() == "AnyType" && node.RAMLVersion() == "RAML08";
	}
	exports.isAnyType = isAnyType;
	/**
	 * Custom type guard for NumberType. Returns true if node is instance of NumberType. Returns false otherwise.
	 * Also returns false for super interfaces of NumberType.
	 */
	function isNumberType(node) {
	    return node.kind() == "NumberType" && node.RAMLVersion() == "RAML08";
	}
	exports.isNumberType = isNumberType;
	/**
	 * Custom type guard for BooleanType. Returns true if node is instance of BooleanType. Returns false otherwise.
	 * Also returns false for super interfaces of BooleanType.
	 */
	function isBooleanType(node) {
	    return node.kind() == "BooleanType" && node.RAMLVersion() == "RAML08";
	}
	exports.isBooleanType = isBooleanType;
	/**
	 * Custom type guard for Reference. Returns true if node is instance of Reference. Returns false otherwise.
	 * Also returns false for super interfaces of Reference.
	 */
	function isReference(node) {
	    return node.kind() == "Reference" && node.RAMLVersion() == "RAML08";
	}
	exports.isReference = isReference;
	/**
	 * Custom type guard for ResourceTypeRef. Returns true if node is instance of ResourceTypeRef. Returns false otherwise.
	 * Also returns false for super interfaces of ResourceTypeRef.
	 */
	function isResourceTypeRef(node) {
	    return node.kind() == "ResourceTypeRef" && node.RAMLVersion() == "RAML08";
	}
	exports.isResourceTypeRef = isResourceTypeRef;
	/**
	 * Custom type guard for ResourceType. Returns true if node is instance of ResourceType. Returns false otherwise.
	 * Also returns false for super interfaces of ResourceType.
	 */
	function isResourceType(node) {
	    return node.kind() == "ResourceType" && node.RAMLVersion() == "RAML08";
	}
	exports.isResourceType = isResourceType;
	/**
	 * Custom type guard for Method. Returns true if node is instance of Method. Returns false otherwise.
	 * Also returns false for super interfaces of Method.
	 */
	function isMethod(node) {
	    return node.kind() == "Method" && node.RAMLVersion() == "RAML08";
	}
	exports.isMethod = isMethod;
	/**
	 * Custom type guard for MethodBase. Returns true if node is instance of MethodBase. Returns false otherwise.
	 * Also returns false for super interfaces of MethodBase.
	 */
	function isMethodBase(node) {
	    return node.kind() == "MethodBase" && node.RAMLVersion() == "RAML08";
	}
	exports.isMethodBase = isMethodBase;
	/**
	 * Custom type guard for Response. Returns true if node is instance of Response. Returns false otherwise.
	 * Also returns false for super interfaces of Response.
	 */
	function isResponse(node) {
	    return node.kind() == "Response" && node.RAMLVersion() == "RAML08";
	}
	exports.isResponse = isResponse;
	/**
	 * Custom type guard for StatusCodeString. Returns true if node is instance of StatusCodeString. Returns false otherwise.
	 * Also returns false for super interfaces of StatusCodeString.
	 */
	function isStatusCodeString(node) {
	    return node.kind() == "StatusCodeString" && node.RAMLVersion() == "RAML08";
	}
	exports.isStatusCodeString = isStatusCodeString;
	/**
	 * Custom type guard for Parameter. Returns true if node is instance of Parameter. Returns false otherwise.
	 * Also returns false for super interfaces of Parameter.
	 */
	function isParameter(node) {
	    return node.kind() == "Parameter" && node.RAMLVersion() == "RAML08";
	}
	exports.isParameter = isParameter;
	/**
	 * Custom type guard for ParameterLocation. Returns true if node is instance of ParameterLocation. Returns false otherwise.
	 * Also returns false for super interfaces of ParameterLocation.
	 */
	function isParameterLocation(node) {
	    return node.kind() == "ParameterLocation" && node.RAMLVersion() == "RAML08";
	}
	exports.isParameterLocation = isParameterLocation;
	/**
	 * Custom type guard for MarkdownString. Returns true if node is instance of MarkdownString. Returns false otherwise.
	 * Also returns false for super interfaces of MarkdownString.
	 */
	function isMarkdownString(node) {
	    return node.kind() == "MarkdownString" && node.RAMLVersion() == "RAML08";
	}
	exports.isMarkdownString = isMarkdownString;
	/**
	 * Custom type guard for StringTypeDeclaration. Returns true if node is instance of StringTypeDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of StringTypeDeclaration.
	 */
	function isStringTypeDeclaration(node) {
	    return node.kind() == "StringTypeDeclaration" && node.RAMLVersion() == "RAML08";
	}
	exports.isStringTypeDeclaration = isStringTypeDeclaration;
	/**
	 * Custom type guard for BooleanTypeDeclaration. Returns true if node is instance of BooleanTypeDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of BooleanTypeDeclaration.
	 */
	function isBooleanTypeDeclaration(node) {
	    return node.kind() == "BooleanTypeDeclaration" && node.RAMLVersion() == "RAML08";
	}
	exports.isBooleanTypeDeclaration = isBooleanTypeDeclaration;
	/**
	 * Custom type guard for NumberTypeDeclaration. Returns true if node is instance of NumberTypeDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of NumberTypeDeclaration.
	 */
	function isNumberTypeDeclaration(node) {
	    return node.kind() == "NumberTypeDeclaration" && node.RAMLVersion() == "RAML08";
	}
	exports.isNumberTypeDeclaration = isNumberTypeDeclaration;
	/**
	 * Custom type guard for IntegerTypeDeclaration. Returns true if node is instance of IntegerTypeDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of IntegerTypeDeclaration.
	 */
	function isIntegerTypeDeclaration(node) {
	    return node.kind() == "IntegerTypeDeclaration" && node.RAMLVersion() == "RAML08";
	}
	exports.isIntegerTypeDeclaration = isIntegerTypeDeclaration;
	/**
	 * Custom type guard for DateTypeDeclaration. Returns true if node is instance of DateTypeDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of DateTypeDeclaration.
	 */
	function isDateTypeDeclaration(node) {
	    return node.kind() == "DateTypeDeclaration" && node.RAMLVersion() == "RAML08";
	}
	exports.isDateTypeDeclaration = isDateTypeDeclaration;
	/**
	 * Custom type guard for FileTypeDeclaration. Returns true if node is instance of FileTypeDeclaration. Returns false otherwise.
	 * Also returns false for super interfaces of FileTypeDeclaration.
	 */
	function isFileTypeDeclaration(node) {
	    return node.kind() == "FileTypeDeclaration" && node.RAMLVersion() == "RAML08";
	}
	exports.isFileTypeDeclaration = isFileTypeDeclaration;
	/**
	 * Custom type guard for BodyLike. Returns true if node is instance of BodyLike. Returns false otherwise.
	 * Also returns false for super interfaces of BodyLike.
	 */
	function isBodyLike(node) {
	    return node.kind() == "BodyLike" && node.RAMLVersion() == "RAML08";
	}
	exports.isBodyLike = isBodyLike;
	/**
	 * Custom type guard for SchemaString. Returns true if node is instance of SchemaString. Returns false otherwise.
	 * Also returns false for super interfaces of SchemaString.
	 */
	function isSchemaString(node) {
	    return node.kind() == "SchemaString" && node.RAMLVersion() == "RAML08";
	}
	exports.isSchemaString = isSchemaString;
	/**
	 * Custom type guard for JSonSchemaString. Returns true if node is instance of JSonSchemaString. Returns false otherwise.
	 * Also returns false for super interfaces of JSonSchemaString.
	 */
	function isJSonSchemaString(node) {
	    return node.kind() == "JSonSchemaString" && node.RAMLVersion() == "RAML08";
	}
	exports.isJSonSchemaString = isJSonSchemaString;
	/**
	 * Custom type guard for XMLSchemaString. Returns true if node is instance of XMLSchemaString. Returns false otherwise.
	 * Also returns false for super interfaces of XMLSchemaString.
	 */
	function isXMLSchemaString(node) {
	    return node.kind() == "XMLSchemaString" && node.RAMLVersion() == "RAML08";
	}
	exports.isXMLSchemaString = isXMLSchemaString;
	/**
	 * Custom type guard for ExampleString. Returns true if node is instance of ExampleString. Returns false otherwise.
	 * Also returns false for super interfaces of ExampleString.
	 */
	function isExampleString(node) {
	    return node.kind() == "ExampleString" && node.RAMLVersion() == "RAML08";
	}
	exports.isExampleString = isExampleString;
	/**
	 * Custom type guard for JSONExample. Returns true if node is instance of JSONExample. Returns false otherwise.
	 * Also returns false for super interfaces of JSONExample.
	 */
	function isJSONExample(node) {
	    return node.kind() == "JSONExample" && node.RAMLVersion() == "RAML08";
	}
	exports.isJSONExample = isJSONExample;
	/**
	 * Custom type guard for XMLExample. Returns true if node is instance of XMLExample. Returns false otherwise.
	 * Also returns false for super interfaces of XMLExample.
	 */
	function isXMLExample(node) {
	    return node.kind() == "XMLExample" && node.RAMLVersion() == "RAML08";
	}
	exports.isXMLExample = isXMLExample;
	/**
	 * Custom type guard for XMLBody. Returns true if node is instance of XMLBody. Returns false otherwise.
	 * Also returns false for super interfaces of XMLBody.
	 */
	function isXMLBody(node) {
	    return node.kind() == "XMLBody" && node.RAMLVersion() == "RAML08";
	}
	exports.isXMLBody = isXMLBody;
	/**
	 * Custom type guard for JSONBody. Returns true if node is instance of JSONBody. Returns false otherwise.
	 * Also returns false for super interfaces of JSONBody.
	 */
	function isJSONBody(node) {
	    return node.kind() == "JSONBody" && node.RAMLVersion() == "RAML08";
	}
	exports.isJSONBody = isJSONBody;
	/**
	 * Custom type guard for SecuritySchemeRef. Returns true if node is instance of SecuritySchemeRef. Returns false otherwise.
	 * Also returns false for super interfaces of SecuritySchemeRef.
	 */
	function isSecuritySchemeRef(node) {
	    return node.kind() == "SecuritySchemeRef" && node.RAMLVersion() == "RAML08";
	}
	exports.isSecuritySchemeRef = isSecuritySchemeRef;
	/**
	 * Custom type guard for AbstractSecurityScheme. Returns true if node is instance of AbstractSecurityScheme. Returns false otherwise.
	 * Also returns false for super interfaces of AbstractSecurityScheme.
	 */
	function isAbstractSecurityScheme(node) {
	    return node.kind() == "AbstractSecurityScheme" && node.RAMLVersion() == "RAML08";
	}
	exports.isAbstractSecurityScheme = isAbstractSecurityScheme;
	/**
	 * Custom type guard for SecuritySchemePart. Returns true if node is instance of SecuritySchemePart. Returns false otherwise.
	 * Also returns false for super interfaces of SecuritySchemePart.
	 */
	function isSecuritySchemePart(node) {
	    return node.kind() == "SecuritySchemePart" && node.RAMLVersion() == "RAML08";
	}
	exports.isSecuritySchemePart = isSecuritySchemePart;
	/**
	 * Custom type guard for TraitRef. Returns true if node is instance of TraitRef. Returns false otherwise.
	 * Also returns false for super interfaces of TraitRef.
	 */
	function isTraitRef(node) {
	    return node.kind() == "TraitRef" && node.RAMLVersion() == "RAML08";
	}
	exports.isTraitRef = isTraitRef;
	/**
	 * Custom type guard for Trait. Returns true if node is instance of Trait. Returns false otherwise.
	 * Also returns false for super interfaces of Trait.
	 */
	function isTrait(node) {
	    return node.kind() == "Trait" && node.RAMLVersion() == "RAML08";
	}
	exports.isTrait = isTrait;
	/**
	 * Custom type guard for SecuritySchemeSettings. Returns true if node is instance of SecuritySchemeSettings. Returns false otherwise.
	 * Also returns false for super interfaces of SecuritySchemeSettings.
	 */
	function isSecuritySchemeSettings(node) {
	    return node.kind() == "SecuritySchemeSettings" && node.RAMLVersion() == "RAML08";
	}
	exports.isSecuritySchemeSettings = isSecuritySchemeSettings;
	/**
	 * Custom type guard for OAuth1SecuritySchemeSettings. Returns true if node is instance of OAuth1SecuritySchemeSettings. Returns false otherwise.
	 * Also returns false for super interfaces of OAuth1SecuritySchemeSettings.
	 */
	function isOAuth1SecuritySchemeSettings(node) {
	    return node.kind() == "OAuth1SecuritySchemeSettings" && node.RAMLVersion() == "RAML08";
	}
	exports.isOAuth1SecuritySchemeSettings = isOAuth1SecuritySchemeSettings;
	/**
	 * Custom type guard for FixedUri. Returns true if node is instance of FixedUri. Returns false otherwise.
	 * Also returns false for super interfaces of FixedUri.
	 */
	function isFixedUri(node) {
	    return node.kind() == "FixedUri" && node.RAMLVersion() == "RAML08";
	}
	exports.isFixedUri = isFixedUri;
	/**
	 * Custom type guard for OAuth2SecuritySchemeSettings. Returns true if node is instance of OAuth2SecuritySchemeSettings. Returns false otherwise.
	 * Also returns false for super interfaces of OAuth2SecuritySchemeSettings.
	 */
	function isOAuth2SecuritySchemeSettings(node) {
	    return node.kind() == "OAuth2SecuritySchemeSettings" && node.RAMLVersion() == "RAML08";
	}
	exports.isOAuth2SecuritySchemeSettings = isOAuth2SecuritySchemeSettings;
	/**
	 * Custom type guard for OAuth2SecurityScheme. Returns true if node is instance of OAuth2SecurityScheme. Returns false otherwise.
	 * Also returns false for super interfaces of OAuth2SecurityScheme.
	 */
	function isOAuth2SecurityScheme(node) {
	    return node.kind() == "OAuth2SecurityScheme" && node.RAMLVersion() == "RAML08";
	}
	exports.isOAuth2SecurityScheme = isOAuth2SecurityScheme;
	/**
	 * Custom type guard for OAuth1SecurityScheme. Returns true if node is instance of OAuth1SecurityScheme. Returns false otherwise.
	 * Also returns false for super interfaces of OAuth1SecurityScheme.
	 */
	function isOAuth1SecurityScheme(node) {
	    return node.kind() == "OAuth1SecurityScheme" && node.RAMLVersion() == "RAML08";
	}
	exports.isOAuth1SecurityScheme = isOAuth1SecurityScheme;
	/**
	 * Custom type guard for BasicSecurityScheme. Returns true if node is instance of BasicSecurityScheme. Returns false otherwise.
	 * Also returns false for super interfaces of BasicSecurityScheme.
	 */
	function isBasicSecurityScheme(node) {
	    return node.kind() == "BasicSecurityScheme" && node.RAMLVersion() == "RAML08";
	}
	exports.isBasicSecurityScheme = isBasicSecurityScheme;
	/**
	 * Custom type guard for DigestSecurityScheme. Returns true if node is instance of DigestSecurityScheme. Returns false otherwise.
	 * Also returns false for super interfaces of DigestSecurityScheme.
	 */
	function isDigestSecurityScheme(node) {
	    return node.kind() == "DigestSecurityScheme" && node.RAMLVersion() == "RAML08";
	}
	exports.isDigestSecurityScheme = isDigestSecurityScheme;
	/**
	 * Custom type guard for CustomSecurityScheme. Returns true if node is instance of CustomSecurityScheme. Returns false otherwise.
	 * Also returns false for super interfaces of CustomSecurityScheme.
	 */
	function isCustomSecurityScheme(node) {
	    return node.kind() == "CustomSecurityScheme" && node.RAMLVersion() == "RAML08";
	}
	exports.isCustomSecurityScheme = isCustomSecurityScheme;
	/**
	 * Custom type guard for MimeType. Returns true if node is instance of MimeType. Returns false otherwise.
	 * Also returns false for super interfaces of MimeType.
	 */
	function isMimeType(node) {
	    return node.kind() == "MimeType" && node.RAMLVersion() == "RAML08";
	}
	exports.isMimeType = isMimeType;
	/**
	 * Custom type guard for RelativeUriString. Returns true if node is instance of RelativeUriString. Returns false otherwise.
	 * Also returns false for super interfaces of RelativeUriString.
	 */
	function isRelativeUriString(node) {
	    return node.kind() == "RelativeUriString" && node.RAMLVersion() == "RAML08";
	}
	exports.isRelativeUriString = isRelativeUriString;
	/**
	 * Custom type guard for GlobalSchema. Returns true if node is instance of GlobalSchema. Returns false otherwise.
	 * Also returns false for super interfaces of GlobalSchema.
	 */
	function isGlobalSchema(node) {
	    return node.kind() == "GlobalSchema" && node.RAMLVersion() == "RAML08";
	}
	exports.isGlobalSchema = isGlobalSchema;
	/**
	 * Custom type guard for RAMLSimpleElement. Returns true if node is instance of RAMLSimpleElement. Returns false otherwise.
	 * Also returns false for super interfaces of RAMLSimpleElement.
	 */
	function isRAMLSimpleElement(node) {
	    return node.kind() == "RAMLSimpleElement" && node.RAMLVersion() == "RAML08";
	}
	exports.isRAMLSimpleElement = isRAMLSimpleElement;
	/**
	 * Custom type guard for DocumentationItem. Returns true if node is instance of DocumentationItem. Returns false otherwise.
	 * Also returns false for super interfaces of DocumentationItem.
	 */
	function isDocumentationItem(node) {
	    return node.kind() == "DocumentationItem" && node.RAMLVersion() == "RAML08";
	}
	exports.isDocumentationItem = isDocumentationItem;
	/**
	 * Custom type guard for Resource. Returns true if node is instance of Resource. Returns false otherwise.
	 * Also returns false for super interfaces of Resource.
	 */
	function isResource(node) {
	    return node.kind() == "Resource" && node.RAMLVersion() == "RAML08";
	}
	exports.isResource = isResource;
	//# sourceMappingURL=raml08parserapi.js.map

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var universe = __webpack_require__(22);
	/////////////////////// properties
	function isDocumentationProperty(p) {
	    return p.nameId() === universe.Universe10.Api.properties.documentation.name ||
	        p.nameId() === universe.Universe08.Api.properties.documentation.name;
	}
	exports.isDocumentationProperty = isDocumentationProperty;
	function isUsagePropertyName(name) {
	    return name === universe.Universe10.Trait.properties.usage.name ||
	        name === universe.Universe08.Trait.properties.usage.name ||
	        name === universe.Universe10.ResourceType.properties.usage.name ||
	        name === universe.Universe08.ResourceType.properties.usage.name ||
	        name === universe.Universe10.Library.properties.usage.name ||
	        name === universe.Universe10.Overlay.properties.usage.name ||
	        name === universe.Universe10.Extension.properties.usage.name;
	}
	exports.isUsagePropertyName = isUsagePropertyName;
	function isUsageProperty(p) {
	    return isUsagePropertyName(p.nameId());
	}
	exports.isUsageProperty = isUsageProperty;
	function isMasterRefProperty(p) {
	    return p.nameId() == universe.Universe10.Overlay.properties.extends.name ||
	        p.nameId() == universe.Universe10.Extension.properties.extends.name;
	}
	exports.isMasterRefProperty = isMasterRefProperty;
	function isDescriptionPropertyName(name) {
	    return name === universe.Universe10.TypeDeclaration.properties.description.name ||
	        name === "description";
	    //TODO too long to actually list every element having a description, so a couple of checks to cause compile error, and a simple equals check. Also we do not want to affect performance that much.
	}
	exports.isDescriptionPropertyName = isDescriptionPropertyName;
	function isDescriptionProperty(p) {
	    return isDescriptionPropertyName(p.nameId());
	}
	exports.isDescriptionProperty = isDescriptionProperty;
	function isRequiredPropertyName(name) {
	    return name === universe.Universe10.TypeDeclaration.properties.required.name ||
	        name === universe.Universe08.Parameter.properties.required.name ||
	        name === "required";
	    //TODO too long to actually list every element having displayname, so a couple of checks to cause compile error, and a simple equals check. Also we do not want to affect performance that much.
	}
	exports.isRequiredPropertyName = isRequiredPropertyName;
	function isDisplayNamePropertyName(name) {
	    return name === universe.Universe10.TypeDeclaration.properties.displayName.name ||
	        name === "displayName";
	    //TODO too long to actually list every element having displayname, so a couple of checks to cause compile error, and a simple equals check. Also we do not want to affect performance that much.
	}
	exports.isDisplayNamePropertyName = isDisplayNamePropertyName;
	function isDisplayNameProperty(p) {
	    return isDisplayNamePropertyName(p.nameId());
	}
	exports.isDisplayNameProperty = isDisplayNameProperty;
	function isRequiredProperty(p) {
	    return isRequiredPropertyName(p.nameId());
	}
	exports.isRequiredProperty = isRequiredProperty;
	function isTitlePropertyName(name) {
	    return name === universe.Universe10.Api.properties.title.name ||
	        name === universe.Universe08.Api.properties.title.name ||
	        name === universe.Universe10.DocumentationItem.properties.title.name ||
	        name === universe.Universe08.DocumentationItem.properties.title.name ||
	        name === universe.Universe10.Overlay.properties.title.name ||
	        name === universe.Universe10.Extension.properties.title.name;
	}
	exports.isTitlePropertyName = isTitlePropertyName;
	function isTitleProperty(p) {
	    return isTitlePropertyName(p.nameId());
	}
	exports.isTitleProperty = isTitleProperty;
	function isHeadersProperty(p) {
	    return isHeadersPropertyName(p.nameId());
	}
	exports.isHeadersProperty = isHeadersProperty;
	function isHeadersPropertyName(name) {
	    return name === universe.Universe08.MethodBase.properties.headers.name ||
	        name === universe.Universe08.Response.properties.headers.name ||
	        name === universe.Universe08.SecuritySchemePart.properties.headers.name ||
	        name === universe.Universe10.MethodBase.properties.headers.name ||
	        name === universe.Universe10.Response.properties.headers.name;
	}
	exports.isHeadersPropertyName = isHeadersPropertyName;
	function isFormParametersProperty(p) {
	    return isFormParametersPropertyName(p.nameId());
	}
	exports.isFormParametersProperty = isFormParametersProperty;
	function isFormParametersPropertyName(name) {
	    return name === universe.Universe08.BodyLike.properties.formParameters.name;
	}
	exports.isFormParametersPropertyName = isFormParametersPropertyName;
	function isQueryParametersProperty(p) {
	    return isQueryParametersPropertyName(p.nameId());
	}
	exports.isQueryParametersProperty = isQueryParametersProperty;
	function isQueryParametersPropertyName(name) {
	    return name === universe.Universe08.MethodBase.properties.queryParameters.name ||
	        name === universe.Universe08.SecuritySchemePart.properties.queryParameters.name ||
	        name === universe.Universe10.MethodBase.properties.queryParameters.name;
	}
	exports.isQueryParametersPropertyName = isQueryParametersPropertyName;
	function isAnnotationsProperty(p) {
	    return p.nameId() === universe.Universe10.Api.properties.annotations.name ||
	        //p.nameId() === universe.Universe10.AbstractSecurityScheme.properties.annotations.name ||
	        p.nameId() === universe.Universe10.TypeDeclaration.properties.annotations.name ||
	        p.nameId() === universe.Universe10.Response.properties.annotations.name;
	}
	exports.isAnnotationsProperty = isAnnotationsProperty;
	function isAnnotationProperty(p) {
	    return p.nameId() === universe.Universe10.AnnotationRef.properties.annotation.name;
	}
	exports.isAnnotationProperty = isAnnotationProperty;
	function isIsProperty(p) {
	    return p.nameId() === universe.Universe10.MethodBase.properties.is.name ||
	        p.nameId() === universe.Universe08.Method.properties.is.name ||
	        p.nameId() === universe.Universe10.ResourceBase.properties.is.name ||
	        p.nameId() === universe.Universe08.ResourceType.properties.is.name ||
	        p.nameId() === universe.Universe08.Resource.properties.is.name;
	}
	exports.isIsProperty = isIsProperty;
	function isSecuredByProperty(p) {
	    return p.nameId() === universe.Universe10.Api.properties.securedBy.name ||
	        p.nameId() === universe.Universe08.Api.properties.securedBy.name ||
	        p.nameId() === universe.Universe10.MethodBase.properties.securedBy.name ||
	        p.nameId() === universe.Universe08.MethodBase.properties.securedBy.name ||
	        p.nameId() === universe.Universe08.ResourceType.properties.securedBy.name ||
	        p.nameId() === universe.Universe08.Resource.properties.securedBy.name ||
	        p.nameId() === universe.Universe10.ResourceBase.properties.securedBy.name;
	}
	exports.isSecuredByProperty = isSecuredByProperty;
	function isSecuritySchemesProperty(p) {
	    return p.nameId() === universe.Universe10.LibraryBase.properties.securitySchemes.name ||
	        p.nameId() === universe.Universe08.Api.properties.securitySchemes.name;
	}
	exports.isSecuritySchemesProperty = isSecuritySchemesProperty;
	function isSecuritySchemeProperty(p) {
	    return p.nameId() === universe.Universe10.SecuritySchemeRef.properties.securityScheme.name ||
	        p.nameId() === universe.Universe08.SecuritySchemeRef.properties.securityScheme.name;
	}
	exports.isSecuritySchemeProperty = isSecuritySchemeProperty;
	function isTypeProperty(p) {
	    return p.nameId() === universe.Universe10.AbstractSecurityScheme.properties.type.name ||
	        p.nameId() === universe.Universe08.AbstractSecurityScheme.properties.type.name ||
	        p.nameId() === universe.Universe08.ResourceType.properties.type.name ||
	        p.nameId() === universe.Universe08.Resource.properties.type.name ||
	        p.nameId() === universe.Universe08.Parameter.properties.type.name ||
	        p.nameId() === universe.Universe10.ResourceBase.properties.type.name ||
	        p.nameId() === universe.Universe10.TypeDeclaration.properties.type.name;
	}
	exports.isTypeProperty = isTypeProperty;
	function isPropertiesProperty(p) {
	    return p.nameId() === universe.Universe10.ObjectTypeDeclaration.properties.properties.name;
	}
	exports.isPropertiesProperty = isPropertiesProperty;
	function isResponsesProperty(p) {
	    return p.nameId() === universe.Universe10.MethodBase.properties.responses.name ||
	        p.nameId() === universe.Universe08.MethodBase.properties.responses.name;
	}
	exports.isResponsesProperty = isResponsesProperty;
	function isProtocolsProperty(p) {
	    return p.nameId() === universe.Universe10.Api.properties.protocols.name ||
	        p.nameId() === universe.Universe08.Api.properties.protocols.name ||
	        p.nameId() === universe.Universe10.MethodBase.properties.protocols.name;
	}
	exports.isProtocolsProperty = isProtocolsProperty;
	function isNameProperty(p) {
	    return p.nameId() === universe.Universe10.TypeDeclaration.properties.name.name ||
	        p.nameId() === universe.Universe10.TypeDeclaration.properties.name.name ||
	        p.nameId() === universe.Universe08.AbstractSecurityScheme.properties.name.name ||
	        p.nameId() === universe.Universe10.AbstractSecurityScheme.properties.name.name ||
	        p.nameId() === universe.Universe08.Trait.properties.name.name ||
	        p.nameId() === universe.Universe10.Trait.properties.name.name ||
	        p.nameId() === "name";
	    //TODO too long to actually list every element having a name, so a couple of checks to cause compile error, and a simple equals check. Also we do not want to affect performance that much.
	}
	exports.isNameProperty = isNameProperty;
	function isBodyProperty(p) {
	    return p.nameId() === universe.Universe10.MethodBase.properties.body.name ||
	        p.nameId() === universe.Universe08.MethodBase.properties.body.name ||
	        p.nameId() === universe.Universe10.Response.properties.body.name ||
	        p.nameId() === universe.Universe08.Response.properties.body.name;
	}
	exports.isBodyProperty = isBodyProperty;
	function isDefaultValue(p) {
	    return p.nameId() === universe.Universe10.TypeDeclaration.properties.default.name ||
	        p.nameId() === universe.Universe08.Parameter.properties.default.name;
	}
	exports.isDefaultValue = isDefaultValue;
	function isSchemaProperty(p) {
	    return p.nameId() === universe.Universe08.BodyLike.properties.schema.name ||
	        p.nameId() === universe.Universe08.XMLBody.properties.schema.name ||
	        p.nameId() === universe.Universe08.JSONBody.properties.schema.name ||
	        p.nameId() === universe.Universe10.TypeDeclaration.properties.schema.name;
	}
	exports.isSchemaProperty = isSchemaProperty;
	function isTraitsProperty(p) {
	    return p.nameId() === universe.Universe08.Api.properties.traits.name ||
	        p.nameId() === universe.Universe10.LibraryBase.properties.traits.name;
	}
	exports.isTraitsProperty = isTraitsProperty;
	function isTraitProperty(p) {
	    return p.nameId() === universe.Universe08.TraitRef.properties.trait.name ||
	        p.nameId() === universe.Universe10.TraitRef.properties.trait.name;
	}
	exports.isTraitProperty = isTraitProperty;
	function isResourceTypesProperty(p) {
	    return p.nameId() === universe.Universe08.Api.properties.resourceTypes.name ||
	        p.nameId() === universe.Universe10.LibraryBase.properties.resourceTypes.name;
	}
	exports.isResourceTypesProperty = isResourceTypesProperty;
	function isResourceTypeProperty(p) {
	    return p.nameId() === universe.Universe08.ResourceTypeRef.properties.resourceType.name ||
	        p.nameId() === universe.Universe10.ResourceTypeRef.properties.resourceType.name;
	}
	exports.isResourceTypeProperty = isResourceTypeProperty;
	function isFacetsProperty(p) {
	    return p.nameId() === universe.Universe10.TypeDeclaration.properties.facets.name;
	}
	exports.isFacetsProperty = isFacetsProperty;
	function isSchemasProperty(p) {
	    return p.nameId() === universe.Universe08.Api.properties.schemas.name ||
	        p.nameId() === universe.Universe10.LibraryBase.properties.schemas.name;
	}
	exports.isSchemasProperty = isSchemasProperty;
	//export function isSignatureProperty(p:hl.IProperty) : boolean {
	//    return p.nameId() === universe.Universe10.Method.properties.signature.name ||
	//    p.nameId() === universe.Universe10.Resource.properties.signature.name;
	//}
	function isResourcesProperty(p) {
	    return p.nameId() === universe.Universe10.Api.properties.resources.name ||
	        p.nameId() === universe.Universe08.Api.properties.resources.name ||
	        p.nameId() === universe.Universe10.Resource.properties.resources.name ||
	        p.nameId() === universe.Universe08.Resource.properties.resources.name;
	}
	exports.isResourcesProperty = isResourcesProperty;
	function isMethodsProperty(p) {
	    return p.nameId() === universe.Universe10.ResourceBase.properties.methods.name ||
	        p.nameId() === universe.Universe08.Resource.properties.methods.name ||
	        p.nameId() === universe.Universe08.ResourceType.properties.methods.name;
	}
	exports.isMethodsProperty = isMethodsProperty;
	function isTypesProperty(p) {
	    return p.nameId() === universe.Universe10.LibraryBase.properties.types.name;
	}
	exports.isTypesProperty = isTypesProperty;
	function isExampleProperty(p) {
	    return p.nameId() === universe.Universe10.TypeDeclaration.properties.example.name ||
	        p.nameId() === "example";
	    //TODO too long to actually list every element having an example, so a couple of checks to cause compile error, and a simple equals check. Also we do not want to affect performance that much.
	}
	exports.isExampleProperty = isExampleProperty;
	function isEnumProperty(p) {
	    return p.nameId() === universe.Universe10.StringTypeDeclaration.properties.enum.name
	        || p.nameId() === universe.Universe10.NumberTypeDeclaration.properties.enum.name
	        || p.nameId() === universe.Universe08.StringTypeDeclaration.properties.enum.name;
	}
	exports.isEnumProperty = isEnumProperty;
	function isExamplesProperty(p) {
	    return p.nameId() === universe.Universe10.TypeDeclaration.properties.example.name || p.nameId() === universe.Universe10.TypeDeclaration.properties.examples.name;
	}
	exports.isExamplesProperty = isExamplesProperty;
	function isValueProperty(p) {
	    return p.nameId() === universe.Universe08.GlobalSchema.properties.value.name;
	}
	exports.isValueProperty = isValueProperty;
	function isUriParametersProperty(p) {
	    return p.nameId() === universe.Universe08.Api.properties.uriParameters.name ||
	        p.nameId() === universe.Universe08.ResourceType.properties.uriParameters.name ||
	        p.nameId() === universe.Universe08.Resource.properties.uriParameters.name ||
	        p.nameId() === universe.Universe10.ResourceBase.properties.uriParameters.name;
	}
	exports.isUriParametersProperty = isUriParametersProperty;
	function isBaseUriParametersProperty(p) {
	    return p.nameId() === universe.Universe08.Resource.properties.baseUriParameters.name ||
	        p.nameId() === universe.Universe08.Api.properties.baseUriParameters.name ||
	        p.nameId() === universe.Universe10.Api.properties.baseUriParameters.name;
	}
	exports.isBaseUriParametersProperty = isBaseUriParametersProperty;
	function isRAMLVersionProperty(p) {
	    return p.nameId() === universe.Universe08.Api.properties.RAMLVersion.name ||
	        p.nameId() === universe.Universe10.Api.properties.RAMLVersion.name;
	}
	exports.isRAMLVersionProperty = isRAMLVersionProperty;
	function isUsesProperty(p) {
	    return p.nameId() === universe.Universe10.FragmentDeclaration.properties.uses.name;
	}
	exports.isUsesProperty = isUsesProperty;
	function isAnnotationTypesProperty(p) {
	    return p.nameId() === universe.Universe10.LibraryBase.properties.annotationTypes.name;
	}
	exports.isAnnotationTypesProperty = isAnnotationTypesProperty;
	/////////////////////// types
	function isMethodType(type) {
	    return type.key() == universe.Universe10.Method ||
	        type.key() == universe.Universe08.Method;
	}
	exports.isMethodType = isMethodType;
	function isApiType(type) {
	    return type.key() == universe.Universe10.Api ||
	        type.key() == universe.Universe08.Api;
	}
	exports.isApiType = isApiType;
	function isBooleanTypeType(type) {
	    return type.key() == universe.Universe10.BooleanType ||
	        type.key() == universe.Universe08.BooleanType;
	}
	exports.isBooleanTypeType = isBooleanTypeType;
	function isMarkdownStringType(type) {
	    return type.key() == universe.Universe10.MarkdownString ||
	        type.key() == universe.Universe08.MarkdownString;
	}
	exports.isMarkdownStringType = isMarkdownStringType;
	function isResourceType(type) {
	    return type.key() == universe.Universe10.Resource ||
	        type.key() == universe.Universe08.Resource;
	}
	exports.isResourceType = isResourceType;
	function isTraitType(type) {
	    return type.key() == universe.Universe10.Trait ||
	        type.key() == universe.Universe08.Trait;
	}
	exports.isTraitType = isTraitType;
	function isTraitRefType(type) {
	    return type.key() == universe.Universe10.TraitRef ||
	        type.key() == universe.Universe08.TraitRef;
	}
	exports.isTraitRefType = isTraitRefType;
	function isResourceTypeRefType(type) {
	    return type.key() == universe.Universe10.ResourceTypeRef ||
	        type.key() == universe.Universe08.ResourceTypeRef;
	}
	exports.isResourceTypeRefType = isResourceTypeRefType;
	function isGlobalSchemaType(type) {
	    return type.key() == universe.Universe08.GlobalSchema;
	}
	exports.isGlobalSchemaType = isGlobalSchemaType;
	function isSecuritySchemaType(type) {
	    return type.key() == universe.Universe10.AbstractSecurityScheme ||
	        type.key() == universe.Universe08.AbstractSecurityScheme;
	}
	exports.isSecuritySchemaType = isSecuritySchemaType;
	function isSecuritySchemaTypeDescendant(type) {
	    return type.isAssignableFrom(universe.Universe10.AbstractSecurityScheme.name);
	}
	exports.isSecuritySchemaTypeDescendant = isSecuritySchemaTypeDescendant;
	function isSecuritySchemeRefType(type) {
	    return type.key() == universe.Universe10.SecuritySchemeRef ||
	        type.key() == universe.Universe08.SecuritySchemeRef;
	}
	exports.isSecuritySchemeRefType = isSecuritySchemeRefType;
	function isTypeDeclarationType(type) {
	    return type.key() == universe.Universe10.TypeDeclaration;
	}
	exports.isTypeDeclarationType = isTypeDeclarationType;
	function isResponseType(type) {
	    return type.key() == universe.Universe10.Response ||
	        type.key() == universe.Universe08.Response;
	}
	exports.isResponseType = isResponseType;
	function isBodyLikeType(type) {
	    return type.key() == universe.Universe08.BodyLike;
	}
	exports.isBodyLikeType = isBodyLikeType;
	function isOverlayType(type) {
	    return type.key() == universe.Universe10.Overlay;
	}
	exports.isOverlayType = isOverlayType;
	function isAnnotationTypeType(type) {
	    return false;
	}
	exports.isAnnotationTypeType = isAnnotationTypeType;
	function isResourceTypeType(type) {
	    return type.key() == universe.Universe10.ResourceType ||
	        type.key() == universe.Universe08.ResourceType;
	}
	exports.isResourceTypeType = isResourceTypeType;
	function isSchemaStringType(type) {
	    return type.key() == universe.Universe10.SchemaString ||
	        type.key() == universe.Universe08.SchemaString;
	}
	exports.isSchemaStringType = isSchemaStringType;
	function isMethodBaseType(type) {
	    return type.key() == universe.Universe10.MethodBase ||
	        type.key() == universe.Universe08.MethodBase;
	}
	exports.isMethodBaseType = isMethodBaseType;
	function isLibraryType(type) {
	    return type.key() == universe.Universe10.Library;
	}
	exports.isLibraryType = isLibraryType;
	function isStringTypeType(type) {
	    return type.key() == universe.Universe10.StringType ||
	        type.key() == universe.Universe08.StringType;
	}
	exports.isStringTypeType = isStringTypeType;
	function isExampleSpecType(type) {
	    return type.key() == universe.Universe10.ExampleSpec;
	}
	exports.isExampleSpecType = isExampleSpecType;
	function isExtensionType(type) {
	    return type.key() == universe.Universe10.Extension;
	}
	exports.isExtensionType = isExtensionType;
	function isTypeDeclarationTypeOrDescendant(type) {
	    return type.isAssignableFrom(universe.Universe10.TypeDeclaration.name);
	}
	exports.isTypeDeclarationTypeOrDescendant = isTypeDeclarationTypeOrDescendant;
	function isDocumentationType(type) {
	    return type.key() == universe.Universe10.DocumentationItem ||
	        type.key() == universe.Universe08.DocumentationItem;
	}
	exports.isDocumentationType = isDocumentationType;
	function isAnnotationRefTypeOrDescendant(type) {
	    return type.isAssignableFrom(universe.Universe10.AnnotationRef.name);
	}
	exports.isAnnotationRefTypeOrDescendant = isAnnotationRefTypeOrDescendant;
	function isApiSibling(type) {
	    return type.isAssignableFrom(universe.Universe10.Api.name) || type.isAssignableFrom(universe.Universe08.Api.name);
	}
	exports.isApiSibling = isApiSibling;
	function isLibraryBaseSibling(type) {
	    return type.isAssignableFrom(universe.Universe10.LibraryBase.name);
	}
	exports.isLibraryBaseSibling = isLibraryBaseSibling;
	function isResourceBaseSibling(type) {
	    return type.isAssignableFrom(universe.Universe10.ResourceBase.name) || type.isAssignableFrom(universe.Universe08.Resource.name);
	}
	exports.isResourceBaseSibling = isResourceBaseSibling;
	function isObjectTypeDeclarationSibling(type) {
	    return type.isAssignableFrom(universe.Universe10.ObjectTypeDeclaration.name);
	}
	exports.isObjectTypeDeclarationSibling = isObjectTypeDeclarationSibling;
	function isTypeDeclarationDescendant(type) {
	    return type.isAssignableFrom(universe.Universe10.TypeDeclaration.name);
	}
	exports.isTypeDeclarationDescendant = isTypeDeclarationDescendant;
	/**
	 * @deprecated use 'isTypeDeclarationDescendant'
	 */
	function isTypeDeclarationSibling(type) {
	    return type.isAssignableFrom(universe.Universe10.TypeDeclaration.name);
	}
	exports.isTypeDeclarationSibling = isTypeDeclarationSibling;
	function isMethodBaseSibling(type) {
	    return type.isAssignableFrom(universe.Universe10.MethodBase.name) ||
	        type.isAssignableFrom(universe.Universe08.MethodBase.name);
	}
	exports.isMethodBaseSibling = isMethodBaseSibling;
	function isSecuritySchemePartType(type) {
	    return type.key() == universe.Universe10.SecuritySchemePart ||
	        type.key() == universe.Universe08.SecuritySchemePart;
	}
	exports.isSecuritySchemePartType = isSecuritySchemePartType;
	function isMediaTypeProperty(p) {
	    return p.nameId() === universe.Universe08.Api.properties.mediaType.name ||
	        p.nameId() === universe.Universe10.Api.properties.mediaType.name;
	}
	exports.isMediaTypeProperty = isMediaTypeProperty;
	function isRAML08Type(type) {
	    return type.universe().version() == "RAML08";
	}
	exports.isRAML08Type = isRAML08Type;
	function isRAML10Type(type) {
	    return type.universe().version() == "RAML10";
	}
	exports.isRAML10Type = isRAML10Type;
	function isRAML08Node(node) {
	    return isRAML08Type(node.definition());
	}
	exports.isRAML08Node = isRAML08Node;
	function isRAML08Attribute(node) {
	    return isRAML08Type(node.definition());
	}
	exports.isRAML08Attribute = isRAML08Attribute;
	function isRAML10Node(node) {
	    return isRAML10Type(node.definition());
	}
	exports.isRAML10Node = isRAML10Node;
	function isRAML10Attribute(node) {
	    return isRAML10Type(node.definition());
	}
	exports.isRAML10Attribute = isRAML10Attribute;
	//# sourceMappingURL=universeHelpers.js.map

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();

	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};

	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');

	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isAbsolute ? '/' : '') + path;
	};

	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};

	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};


	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	};

	exports.sep = '/';
	exports.delimiter = ':';

	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	};


	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};


	exports.extname = function(path) {
	  return splitPath(path)[3];
	};

	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}

	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59)))

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/main.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var defs = __webpack_require__(36);
	var hl = __webpack_require__(10);
	var _ = __webpack_require__(63);
	var proxy = __webpack_require__(39);
	var def = defs;
	var builder = __webpack_require__(26);
	var search = __webpack_require__(23);
	var mutators = __webpack_require__(40);
	var linter = __webpack_require__(25);
	var expander = __webpack_require__(24);
	var typeBuilder = __webpack_require__(41);
	var universes = __webpack_require__(22);
	var jsyaml = __webpack_require__(27);
	var textutil = __webpack_require__(42);
	var services = def;
	var yaml = __webpack_require__(72);
	var wrapperHelper = __webpack_require__(33);
	var factory10 = __webpack_require__(43);
	var factory08 = __webpack_require__(44);
	var universeHelpers = __webpack_require__(14);
	var resourceRegistry = __webpack_require__(28);
	var rTypes = defs.rt;
	var contentprovider = __webpack_require__(31);
	function qName(x, context) {
	    //var dr=search.declRoot(context);
	    var nm = x.name();
	    if (context.lowLevel() instanceof proxy.LowLevelProxyNode) {
	        if (x.lowLevel() instanceof proxy.LowLevelProxyNode) {
	            return nm;
	        }
	        var rootUnit = context.root().lowLevel().unit();
	        var resolver = rootUnit.project().namespaceResolver();
	        var unit = x.lowLevel().unit();
	        var ns = resolver.resolveNamespace(rootUnit, unit);
	        if (ns != null) {
	            return ns + "." + nm;
	        }
	    }
	    if (x.lowLevel().unit() != context.lowLevel().unit()) {
	        var root = context;
	        while (true) {
	            if (root.lowLevel().includePath() || root.parent() == null) {
	                if (!root.unitMap) {
	                    root.unitMap = {};
	                    root.asElement().elements().forEach(function (x) {
	                        if (x.definition().key() == universes.Universe10.UsesDeclaration) {
	                            var mm = x.attr("value");
	                            if (mm) {
	                                var unit = x.root().lowLevel().unit().resolve(mm.value());
	                                if (unit != null) {
	                                    var key = x.attr("key");
	                                    if (key) {
	                                        root.unitMap[unit.absolutePath()] = key.value();
	                                    }
	                                }
	                            }
	                        }
	                    });
	                }
	                var prefix = root.unitMap[x.lowLevel().unit().absolutePath()];
	                if (prefix) {
	                    return prefix + "." + nm;
	                }
	            }
	            if (!root.parent()) {
	                break;
	            }
	            else {
	                root = root.parent();
	            }
	        }
	    }
	    return nm;
	}
	exports.qName = qName;
	var BasicASTNode = (function () {
	    function BasicASTNode(_node, _parent) {
	        this._node = _node;
	        this._parent = _parent;
	        this._implicit = false;
	        this.values = {};
	        if (_node) {
	            _node.setHighLevelParseResult(this);
	        }
	    }
	    BasicASTNode.prototype.getKind = function () {
	        return hl.NodeKind.BASIC;
	    };
	    BasicASTNode.prototype.asAttr = function () {
	        return null;
	    };
	    BasicASTNode.prototype.asElement = function () {
	        return null;
	    };
	    BasicASTNode.prototype.hashkey = function () {
	        if (!this._hashkey)
	            this._hashkey = this.parent() ? this.parent().hashkey() + "/" + this.name() : this.name();
	        return this._hashkey;
	    };
	    BasicASTNode.prototype.root = function () {
	        if (this.parent()) {
	            return this.parent().root();
	        }
	        return this;
	    };
	    BasicASTNode.prototype.version = function () {
	        return "";
	    };
	    BasicASTNode.prototype.getLowLevelStart = function () {
	        if (this.lowLevel().kind() === jsyaml.Kind.SCALAR) {
	            return this.lowLevel().start();
	        }
	        return this.lowLevel().keyStart();
	    };
	    BasicASTNode.prototype.getLowLevelEnd = function () {
	        if (this.lowLevel().kind() === jsyaml.Kind.SCALAR) {
	            return this.lowLevel().end();
	        }
	        return this.lowLevel().keyEnd();
	    };
	    BasicASTNode.prototype.isSameNode = function (n) {
	        if (n) {
	            if (n.lowLevel().actual() == this.lowLevel().actual()) {
	                return true;
	            }
	        }
	        return false;
	    };
	    BasicASTNode.prototype.checkContextValue = function (name, value, thisObj) {
	        var vl = this.computedValue(name);
	        if (vl && vl.indexOf(value) != -1) {
	            return true; //FIXME
	        }
	        return value == vl || value == 'false';
	    };
	    BasicASTNode.prototype.printDetails = function (indent) {
	        return (indent ? indent : "") + "Unkown\n";
	    };
	    /**
	     * Used for test comparison of two trees. Touching this will require AST tests update.
	     * @param indent
	     * @returns {string}
	     */
	    BasicASTNode.prototype.testSerialize = function (indent) {
	        return (indent ? indent : "") + "Unkown\n";
	    };
	    BasicASTNode.prototype.errors = function () {
	        var errors = [];
	        var q = createBasicValidationAcceptor(errors);
	        this.validate(q);
	        return errors;
	    };
	    BasicASTNode.prototype.markCh = function () {
	        var n = this.lowLevel();
	        while (n instanceof proxy.LowLevelProxyNode) {
	            n = n.originalNode();
	        }
	        n = n._node ? n._node : n;
	        if (n['markCh']) {
	            return true;
	        }
	        n['markCh'] = 1;
	    };
	    BasicASTNode.prototype.unmarkCh = function () {
	        var n = this.lowLevel();
	        while (n instanceof proxy.LowLevelProxyNode) {
	            n = n.originalNode();
	        }
	        n = n._node ? n._node : n;
	        delete n['markCh'];
	    };
	    BasicASTNode.prototype.validate = function (v) {
	        linter.validate(this, v);
	    };
	    BasicASTNode.prototype.allowRecursive = function () {
	        return false;
	    };
	    BasicASTNode.prototype.setComputed = function (name, v) {
	        this.values[name] = v;
	    };
	    BasicASTNode.prototype.computedValue = function (name) {
	        var vl = this.values[name];
	        if (!vl && this.parent()) {
	            return this.parent().computedValue(name);
	        }
	        return vl;
	    };
	    BasicASTNode.prototype.lowLevel = function () {
	        return this._node;
	    };
	    BasicASTNode.prototype.name = function () {
	        var c = this.lowLevel().key();
	        if (!c) {
	            return "";
	        }
	        return c;
	    };
	    BasicASTNode.prototype.optional = function () {
	        var llNode = this.lowLevel();
	        var ownValue = llNode.optional();
	        if (llNode.key() != null) {
	            return ownValue;
	        }
	        var p = this.property();
	        if (!p || !p.isMultiValue()) {
	            return ownValue;
	        }
	        var llParent = llNode.parent();
	        while (llParent && llParent.highLevelNode() == null) {
	            if (llParent.kind() == yaml.Kind.MAPPING) {
	                return llParent.optional();
	            }
	            llParent = llParent.parent();
	        }
	        return ownValue;
	    };
	    BasicASTNode.prototype.parent = function () {
	        return this._parent;
	    };
	    BasicASTNode.prototype.setParent = function (parent) {
	        this._parent = parent;
	    };
	    BasicASTNode.prototype.isElement = function () {
	        return false;
	    };
	    BasicASTNode.prototype.directChildren = function () {
	        return this.children();
	    };
	    BasicASTNode.prototype.children = function () {
	        return [];
	    };
	    BasicASTNode.prototype.isAttached = function () {
	        return this.parent() != null;
	    };
	    BasicASTNode.prototype.isImplicit = function () {
	        return this._implicit;
	    };
	    BasicASTNode.prototype.isAttr = function () {
	        return false;
	    };
	    BasicASTNode.prototype.isUnknown = function () {
	        return true;
	    };
	    BasicASTNode.prototype.id = function () {
	        var _this = this;
	        if (this.cachedId) {
	            return this.cachedId;
	        }
	        if (this._parent) {
	            var parentId = this.parent().id();
	            parentId += "." + this.name();
	            var sameName = this.parent().directChildren().filter(function (x) { return x.name() == _this.name(); });
	            if (sameName.length > 1) {
	                var ind = sameName.indexOf(this);
	                parentId += "[" + ind + "]";
	            }
	            this.cachedId = parentId;
	            return parentId;
	        }
	        this.cachedId = "";
	        return this.cachedId;
	    };
	    BasicASTNode.prototype.localId = function () {
	        return this.name();
	    };
	    BasicASTNode.prototype.fullLocalId = function () {
	        var _this = this;
	        if (this.cachedFullId) {
	            return this.cachedFullId;
	        }
	        if (this._parent) {
	            var result = ".";
	            if (this.property() != null && universeHelpers.isAnnotationsProperty(this.property())) {
	                result += this.lowLevel().key();
	            }
	            else {
	                result += this.name();
	            }
	            var sameName = this.parent().directChildren().filter(function (x) { return x.name() == _this.name(); });
	            if (sameName.length > 1) {
	                var ind = sameName.indexOf(this);
	                result += "[" + ind + "]";
	            }
	            this.cachedFullId = result;
	            return result;
	        }
	        this.cachedFullId = this.localId();
	        return this.cachedFullId;
	    };
	    BasicASTNode.prototype.property = function () {
	        return null;
	    };
	    return BasicASTNode;
	}());
	exports.BasicASTNode = BasicASTNode;
	var StructuredValue = (function () {
	    function StructuredValue(node, _parent, _pr, kv) {
	        if (kv === void 0) { kv = null; }
	        this.node = node;
	        this._parent = _parent;
	        this.kv = kv;
	        this._pr = _pr;
	    }
	    StructuredValue.prototype.valueName = function () {
	        var res = null;
	        if (this.kv) {
	            res = this.kv;
	        }
	        res = this.node.key();
	        if (this._pr && this._pr.isAnnotation()) {
	            if (res && res.charAt(0) == '(') {
	                res = res.substring(1, res.length - 1);
	            }
	        }
	        return res;
	    };
	    StructuredValue.prototype.children = function () {
	        return this.node.children().map(function (x) { return new StructuredValue(x, null, null); });
	    };
	    StructuredValue.prototype.lowLevel = function () {
	        return this.node;
	    };
	    StructuredValue.prototype.toHighLevel = function (parent) {
	        if (!parent && this._parent)
	            parent = this._parent;
	        if (this._hl) {
	            return this._hl;
	        }
	        var vn = this.valueName();
	        var cands = search.referenceTargets(this._pr, parent).filter(function (x) { return qName(x, parent) == vn; });
	        if (cands && cands[0]) {
	            var tp = cands[0].localType();
	            var node = new ASTNodeImpl(this.node, parent, tp, this._pr);
	            if (this._pr) {
	                this._pr.childRestrictions().forEach(function (y) {
	                    node.setComputed(y.name, y.value);
	                });
	            }
	            this._hl = node;
	            return node;
	        }
	        //if (this._pr.range()){
	        //    var node=new ASTNodeImpl(parent.lowLevel(),parent,this._pr.range(),this._pr);
	        //    if (this._pr){
	        //        this._pr.childRestrictions().forEach(y=>{
	        //            node.setComputed(y.name,y.value)
	        //        })
	        //    }
	        //    return node;
	        //}
	        return null;
	    };
	    StructuredValue.prototype.toHighLevel2 = function (parent) {
	        if (!parent && this._parent)
	            parent = this._parent;
	        var vn = this.valueName();
	        var cands = search.referenceTargets(this._pr, parent).filter(function (x) { return qName(x, parent) == vn; });
	        if (cands && cands[0]) {
	            var tp = cands[0].localType();
	            var node = new ASTNodeImpl(this.node, parent, tp, this._pr);
	            if (this._pr) {
	                this._pr.childRestrictions().forEach(function (y) {
	                    node.setComputed(y.name, y.value);
	                });
	            }
	            return node;
	        }
	        if (this._pr.range()) {
	            var node = new ASTNodeImpl(this.node.parent(), parent, this._pr.range(), this._pr);
	            if (this._pr) {
	                this._pr.childRestrictions().forEach(function (y) {
	                    node.setComputed(y.name, y.value);
	                });
	            }
	            return node;
	        }
	        return null;
	    };
	    return StructuredValue;
	}());
	exports.StructuredValue = StructuredValue;
	var ASTPropImpl = (function (_super) {
	    __extends(ASTPropImpl, _super);
	    function ASTPropImpl(node, parent, _def, _prop, fromKey) {
	        if (fromKey === void 0) { fromKey = false; }
	        _super.call(this, node, parent);
	        this._def = _def;
	        this._prop = _prop;
	        this.fromKey = fromKey;
	    }
	    ASTPropImpl.prototype.definition = function () {
	        return this._def;
	    };
	    ASTPropImpl.prototype.asAttr = function () {
	        return this;
	    };
	    ASTPropImpl.prototype.errors = function () {
	        var errors = [];
	        var q = createBasicValidationAcceptor(errors);
	        this.parent().validate(q);
	        return errors;
	    };
	    ASTPropImpl.prototype.isString = function () {
	        if (this._def) {
	            if (this._def.key() === universes.Universe08.StringType || this._def.key() == universes.Universe10.StringType) {
	                return true;
	            }
	        }
	        return false;
	    };
	    ASTPropImpl.prototype.isAnnotatedScalar = function () {
	        if (!this.property().isAnnotation() && !this.property().isKey()) {
	            return this.lowLevel().isAnnotatedScalar();
	        }
	        return false;
	    };
	    ASTPropImpl.prototype.annotations = function () {
	        var ch = this.lowLevel().children();
	        var annotations = [];
	        var u = this.definition().universe().type(universes.Universe10.Annotable.name);
	        if (!u) {
	            return annotations;
	        }
	        var pr = u.property("annotations");
	        for (var i = 0; i < ch.length; i++) {
	            var child = ch[i];
	            var key = child.key();
	            if (key != null && key[0] == ("(") && key[key.length - 1] == (")")) {
	                var attr = new ASTPropImpl(child, this.parent(), pr.range(), pr);
	                annotations.push(attr);
	            }
	        }
	        return annotations;
	    };
	    ASTPropImpl.prototype.getKind = function () {
	        return hl.NodeKind.ATTRIBUTE;
	    };
	    ASTPropImpl.prototype.owningWrapper = function () {
	        return {
	            node: this.parent().wrapperNode(),
	            property: this.name()
	        };
	    };
	    ASTPropImpl.prototype.patchType = function (t) {
	        this._def = t;
	    };
	    ASTPropImpl.prototype.findReferenceDeclaration = function () {
	        var _this = this;
	        var targets = search.referenceTargets(this.property(), this.parent());
	        var vl = this.value();
	        if (vl instanceof StructuredValue) {
	            var st = vl;
	            var nm = st.valueName();
	        }
	        else {
	            var nm = "" + vl;
	        }
	        var t = _.find(targets, function (x) { return qName(x, _this.parent()) == nm; });
	        return t;
	    };
	    ASTPropImpl.prototype.findReferencedValue = function () {
	        var c = this.findReferenceDeclaration();
	        if (c) {
	            var vl = c.attr("value");
	            var ck = c.definition().key();
	            if (ck === universes.Universe08.GlobalSchema) {
	                if (vl) {
	                    var actualValue = vl.value();
	                    if (actualValue) {
	                        var rf = linter.isValid(this._def, this.parent(), actualValue, vl.property());
	                        return rf;
	                    }
	                }
	                return null;
	            }
	        }
	        return c;
	    };
	    ASTPropImpl.prototype.isElement = function () {
	        return false;
	    };
	    ASTPropImpl.prototype.property = function () {
	        return this._prop;
	    };
	    ASTPropImpl.prototype.convertMultivalueToString = function (value) {
	        //|\n  xxx\n  yyy\n  zzz
	        var gap = 0;
	        var pos = 2;
	        while (value[pos] == ' ') {
	            gap++;
	            pos++;
	        }
	        //console.log('gap: ' + gap);
	        var lines = textutil.splitOnLines(value);
	        lines = lines.map(function (line) {
	            //console.log('line: ' + line);
	            return line.substring(gap, line.length);
	        });
	        return lines.join('');
	    };
	    ASTPropImpl.prototype.overrideValue = function (value) {
	        this._value = value;
	    };
	    ASTPropImpl.prototype.value = function () {
	        if (this._value) {
	            return this._value;
	        }
	        this._value = this.calcValue();
	        return this._value;
	    };
	    ASTPropImpl.prototype.calcValue = function () {
	        if (this._computed) {
	            return this.computedValue(this.property().nameId());
	        }
	        if (this.fromKey) {
	            var parent = this.parent();
	            var definition = parent.definition();
	            if (definition.universe().version() == "RAML08") {
	                return this._node.key();
	            }
	            if (universeHelpers.isNameProperty(this.property())) {
	                if (definition.isAssignableFrom(universes.Universe10.TypeDeclaration.name)) {
	                    var requiredAttr = parent.attr("required");
	                    if (requiredAttr && requiredAttr.value() != null) {
	                        return this._node.optional() ? this._node.key() + "?" : this._node.key();
	                    }
	                }
	            }
	            return this._node.key();
	        }
	        if (this.property().isAnnotation() && this._node.key() && this._node.key() != 'annotations') {
	            return new StructuredValue(this._node, this.parent(), this._prop);
	        }
	        var isString = this.property() != null
	            && !(this.parent() == null || this.parent().definition() == null ||
	                (universeHelpers.isTypeProperty(this.property())
	                    && universeHelpers.isTypeDeclarationSibling(this.parent().definition())))
	            && universeHelpers.isStringTypeType(this.property().range());
	        var actualValue = this._node.value(isString); //TODO FIXME
	        if (this.property().isSelfNode()) {
	            if (!actualValue || actualValue instanceof jsyaml.ASTNode) {
	                actualValue = this._node;
	                if (actualValue.children().length == 0) {
	                    actualValue = null;
	                }
	            }
	        }
	        if (actualValue instanceof jsyaml.ASTNode || actualValue instanceof proxy.LowLevelProxyNode) {
	            var isAnnotatedScalar = false;
	            if (!this.property().range().hasStructure()) {
	                if (this._node.isAnnotatedScalar()) {
	                    this._node.children().forEach(function (x) {
	                        if (x.key() === "value") {
	                            actualValue = x.value(isString);
	                            isAnnotatedScalar = true;
	                        }
	                    });
	                }
	            }
	            if (!isAnnotatedScalar) {
	                if (this._sval) {
	                    return this._sval;
	                }
	                this._sval = new StructuredValue(actualValue, this.parent(), this._prop);
	                return this._sval;
	            }
	        }
	        if (typeof (actualValue) == 'string' && textutil.isMultiLineValue(actualValue)) {
	            var res = this.convertMultivalueToString(actualValue);
	            //console.log('converted: [' + textutil.replaceNewlines(res) + ']');
	            return res;
	        }
	        if (actualValue == null && this._node.children().length > 0
	            && this.property() && universeHelpers.isTypeProperty(this.property())
	            && this.parent() && universeHelpers.isTypeDeclarationSibling(this.parent().definition())) {
	            return new StructuredValue(this._node, this.parent(), this._prop);
	        }
	        return actualValue;
	    };
	    ASTPropImpl.prototype.name = function () {
	        return this._prop.nameId();
	    };
	    ASTPropImpl.prototype.printDetails = function (indent) {
	        var className = this.definition().nameId();
	        var definitionClassName = this.property().range().nameId();
	        var result = (indent ? indent : "") +
	            (this.name() + " : " + className
	                + "[" + definitionClassName + "]"
	                + "  =  " + this.value()) + (this.property().isKey() && this.optional() ? "?" : "")
	            + "\n";
	        if (this.value() instanceof StructuredValue) {
	            var structuredHighLevel = this.value().toHighLevel();
	            if (structuredHighLevel && structuredHighLevel.printDetails) {
	                result += structuredHighLevel.printDetails(indent + "\t");
	            }
	        }
	        return result;
	    };
	    /**
	     * Used for test comparison of two trees. Touching this will require AST tests update.
	     * @param indent
	     * @returns {string}
	     */
	    ASTPropImpl.prototype.testSerialize = function (indent) {
	        var className = this.definition().nameId();
	        var result = (indent ? indent : "") +
	            (this.name() + " : " + className
	                + "  =  " + this.value()) +
	            "\n";
	        if (this.value() instanceof StructuredValue) {
	            var structuredHighLevel = this.value().toHighLevel();
	            if (structuredHighLevel && structuredHighLevel.testSerialize) {
	                result += structuredHighLevel.testSerialize((indent ? indent : "") + "  ");
	            }
	            else {
	                var lowLevel = this.value().lowLevel();
	                var dumpObject = lowLevel.dumpToObject();
	                var dump = JSON.stringify(dumpObject);
	                var indentedDump = "";
	                var dumpLines = dump.split("\n");
	                dumpLines.forEach(function (dumpLine) { return indentedDump += ((indent ? indent : "") + "  " + dumpLine + "\n"); });
	                result += indentedDump + "\n";
	            }
	        }
	        return result;
	    };
	    ASTPropImpl.prototype.isAttr = function () {
	        return true;
	    };
	    ASTPropImpl.prototype.isUnknown = function () {
	        return false;
	    };
	    ASTPropImpl.prototype.setValue = function (value) {
	        mutators.setValue(this, value);
	        this._value = null;
	    };
	    ASTPropImpl.prototype.setKey = function (value) {
	        mutators.setKey(this, value);
	        this._value = null;
	    };
	    ASTPropImpl.prototype.children = function () {
	        return [];
	    };
	    ASTPropImpl.prototype.addStringValue = function (value) {
	        mutators.addStringValue(this, value);
	        this._value = null;
	    };
	    ASTPropImpl.prototype.addStructuredValue = function (sv) {
	        mutators.addStructuredValue(this, sv);
	        this._value = null;
	    };
	    ASTPropImpl.prototype.addValue = function (value) {
	        if (!this.property().isMultiValue())
	            throw new Error("setValue(string) only apply to multi-values properties");
	        if (typeof value == 'string') {
	            this.addStringValue(value);
	        }
	        else {
	            this.addStructuredValue(value);
	        }
	        this._value = null;
	    };
	    ASTPropImpl.prototype.isEmbedded = function () {
	        var keyname = this.lowLevel().asMapping().key.value;
	        //console.log('propery: ' + this.property().name());
	        //console.log('mapping: ' + keyname);
	        return this.property().canBeValue() && keyname != this.property().nameId();
	    };
	    ASTPropImpl.prototype.remove = function () {
	        mutators.removeAttr(this);
	    };
	    ASTPropImpl.prototype.setValues = function (values) {
	        mutators.setValues(this, values);
	        this._value = null;
	    };
	    ASTPropImpl.prototype.isEmpty = function () {
	        if (!this.property().isMultiValue())
	            throw new Error("isEmpty() only apply to multi-values attributes");
	        //console.log('remove: ' + this.name());
	        var node = this.parent();
	        var llnode = node.lowLevel();
	        //node.lowLevel().show('Parent:');
	        var attrs = node.attributes(this.name());
	        //console.log('attributes: ' + attrs.length);
	        if (attrs.length == 0) {
	            return true;
	        }
	        else if (attrs.length == 1) {
	            var anode = attrs[0].lowLevel();
	            //console.log('attribute : ' + anode.kindName());
	            //anode.show("ATTR:");
	            if (anode.isMapping() && anode.value() == null) {
	                // that's crazy but it means zero length array indeed )
	                return true;
	            }
	            else {
	                return false;
	            }
	        }
	        else {
	            return false;
	        }
	    };
	    ASTPropImpl.prototype.isFromKey = function () {
	        return this.fromKey;
	    };
	    return ASTPropImpl;
	}(BasicASTNode));
	exports.ASTPropImpl = ASTPropImpl;
	var nodeBuilder = new builder.BasicNodeBuilder();
	(function (OverlayMergeMode) {
	    OverlayMergeMode[OverlayMergeMode["MERGE"] = 0] = "MERGE";
	    OverlayMergeMode[OverlayMergeMode["AGGREGATE"] = 1] = "AGGREGATE";
	})(exports.OverlayMergeMode || (exports.OverlayMergeMode = {}));
	var OverlayMergeMode = exports.OverlayMergeMode;
	var LowLevelWrapperForTypeSystem = (function (_super) {
	    __extends(LowLevelWrapperForTypeSystem, _super);
	    function LowLevelWrapperForTypeSystem(_node, _highLevelRoot) {
	        _super.call(this);
	        this._node = _node;
	        this._highLevelRoot = _highLevelRoot;
	        var v = _highLevelRoot.root();
	        var mst = v.getMaster();
	        if (mst && this._node === _highLevelRoot.lowLevel()) {
	            var master = _highLevelRoot.getMasterCounterPart();
	            if (master) {
	                this._toMerge = new LowLevelWrapperForTypeSystem(master.lowLevel(), master);
	            }
	        }
	    }
	    LowLevelWrapperForTypeSystem.prototype.contentProvider = function () {
	        var root = this._node && this._node.includeBaseUnit() && ((this._node.includePath && this._node.includePath()) ? this._node.includeBaseUnit().resolve(this._node.includePath()) : this._node.includeBaseUnit());
	        return new contentprovider.ContentProvider(root);
	    };
	    LowLevelWrapperForTypeSystem.prototype.key = function () {
	        var vl = this._node.key();
	        if (this._node.optional()) {
	            vl = vl + "?";
	        }
	        return vl;
	    };
	    LowLevelWrapperForTypeSystem.prototype.value = function () {
	        var vk = this._node.valueKind();
	        if (vk === yaml.Kind.SEQ) {
	            return this.children().map(function (x) { return x.value(); });
	        }
	        else if (vk === yaml.Kind.MAP || vk === yaml.Kind.ANCHOR_REF) {
	            var vl = this._node.dumpToObject(false);
	            return vl[this.key()];
	        }
	        else if (this._node.kind() == yaml.Kind.MAP) {
	            var vl = this._node.dumpToObject(false);
	            return vl;
	        }
	        if (vk === yaml.Kind.INCLUDE_REF) {
	            var resolved = null;
	            var includePath = this._node.includePath();
	            try {
	                resolved = this._node.unit().resolve(includePath);
	            }
	            catch (e) { }
	            if (resolved != null && resolved.isRAMLUnit()) {
	                var includedAST = resolved.ast();
	                var includedWrapper = new LowLevelWrapperForTypeSystem(includedAST, resolved.highLevel().asElement());
	                if (includedAST.kind() == yaml.Kind.SEQ) {
	                    return includedWrapper.children().map(function (x) { return x.value(); });
	                }
	                else {
	                    return includedWrapper.value();
	                }
	            }
	        }
	        var val = this._node.value();
	        // if(val==null){
	        //     val = this._node.value(true);
	        // }
	        return val;
	    };
	    LowLevelWrapperForTypeSystem.prototype.children = function () {
	        var _this = this;
	        if (this._children) {
	            return this._children;
	        }
	        if (this.key() == "uses" && !this._node.parent().parent()) {
	            this._children = this._node.children().map(function (x) { return new UsesNodeWrapperFoTypeSystem(x, _this._highLevelRoot); });
	        }
	        else {
	            this._children = this._node.children().map(function (x) { return new LowLevelWrapperForTypeSystem(x, _this._highLevelRoot); });
	        }
	        this.childByKey = {};
	        for (var i = 0; i < this._children.length; i++) {
	            var c = this._children[i];
	            this.childByKey[c.key()] = c;
	        }
	        if (this._toMerge) {
	            var mrg = this._toMerge.children();
	            for (var i = 0; i < mrg.length; i++) {
	                var c = mrg[i];
	                var existing = this.childByKey[c.key()];
	                if (existing) {
	                    existing._toMerge = c;
	                }
	                else {
	                    this._children.push(c);
	                    this.childByKey[c.key()] = c;
	                }
	            }
	        }
	        return this._children;
	    };
	    LowLevelWrapperForTypeSystem.prototype.childWithKey = function (k) {
	        if (!this._children) {
	            this.children();
	        }
	        return this.childByKey[k];
	    };
	    LowLevelWrapperForTypeSystem.prototype.kind = function () {
	        var vk = this._node.valueKind();
	        if (vk == yaml.Kind.MAPPING || vk === null) {
	            return rTypes.NodeKind.MAP;
	        }
	        if (vk == yaml.Kind.MAP) {
	            return rTypes.NodeKind.MAP;
	        }
	        var knd = this._node.kind();
	        if (knd == yaml.Kind.MAP) {
	            return rTypes.NodeKind.MAP;
	        }
	        if (vk == yaml.Kind.SEQ) {
	            return rTypes.NodeKind.ARRAY;
	        }
	        if (vk == yaml.Kind.INCLUDE_REF) {
	            if (this._node.children().length > 0) {
	                //we can safely assume that it is map in the type system in this case
	                return rTypes.NodeKind.MAP;
	            }
	        }
	        return rTypes.NodeKind.SCALAR;
	    };
	    LowLevelWrapperForTypeSystem.prototype.getSource = function () {
	        if (!this._node)
	            return null;
	        var highLevelNode = this._node.highLevelNode();
	        if (!highLevelNode) {
	            var position = this._node.start();
	            var result = search.deepFindNode(this._highLevelRoot, position, position, true, false);
	            if (result) {
	                this._node.setHighLevelParseResult(result);
	                if (result instanceof ASTNodeImpl) {
	                    this._node.setHighLevelNode(result);
	                }
	            }
	            return result;
	        }
	        return highLevelNode;
	    };
	    LowLevelWrapperForTypeSystem.prototype.node = function () {
	        return this._node;
	    };
	    return LowLevelWrapperForTypeSystem;
	}(defs.SourceProvider));
	exports.LowLevelWrapperForTypeSystem = LowLevelWrapperForTypeSystem;
	var UsesNodeWrapperFoTypeSystem = (function (_super) {
	    __extends(UsesNodeWrapperFoTypeSystem, _super);
	    function UsesNodeWrapperFoTypeSystem() {
	        _super.apply(this, arguments);
	    }
	    UsesNodeWrapperFoTypeSystem.prototype.children = function () {
	        var s = this._node.unit().resolve(this.value());
	        if (s && s.isRAMLUnit()) {
	            return new LowLevelWrapperForTypeSystem(s.ast(), this._highLevelRoot).children();
	        }
	        return [];
	    };
	    UsesNodeWrapperFoTypeSystem.prototype.anchor = function () {
	        return this._node.actual();
	    };
	    UsesNodeWrapperFoTypeSystem.prototype.childWithKey = function (k) {
	        var mm = this.children();
	        for (var i = 0; i < mm.length; i++) {
	            if (mm[i].key() == k) {
	                return mm[i];
	            }
	        }
	        return null;
	    };
	    return UsesNodeWrapperFoTypeSystem;
	}(LowLevelWrapperForTypeSystem));
	exports.UsesNodeWrapperFoTypeSystem = UsesNodeWrapperFoTypeSystem;
	var ASTNodeImpl = (function (_super) {
	    __extends(ASTNodeImpl, _super);
	    function ASTNodeImpl(node, parent, _def, _prop) {
	        _super.call(this, node, parent);
	        this._def = _def;
	        this._prop = _prop;
	        this._expanded = false;
	        this._allowQuestion = false;
	        this._subTypesCache = null;
	        this._auxChecked = false;
	        /**
	         * Depending on the merge mode, overlays and extensions are either merged with the master, or their trees are joined via aggregation
	         * @type {OverlayMergeMode}
	         */
	        this.overlayMergeMode = OverlayMergeMode.MERGE;
	        if (node) {
	            node.setHighLevelNode(this);
	        }
	        if (node instanceof proxy.LowLevelProxyNode) {
	            this._expanded = true;
	        }
	    }
	    ASTNodeImpl.prototype.createIssue = function (error) {
	        return linter.toIssue(error, this);
	    };
	    ASTNodeImpl.prototype.validate = function (v) {
	        var k = this.definition().key();
	        if (k == universes.Universe10.Api || k == universes.Universe08.Api || k == universes.Universe10.Extension) {
	            if (!this.isExpanded()) {
	                var nm = expander.expandTraitsAndResourceTypes(this.wrapperNode());
	                var hlnode = nm.highLevel();
	                hlnode.resetChildren();
	                hlnode.children();
	                hlnode._expanded = true;
	                hlnode.clearTypesCache();
	                hlnode.validate(v);
	                return;
	            }
	        }
	        if (k == universes.Universe10.Overlay || k == universes.Universe10.Extension) {
	            this.clearTypesCache();
	        }
	        linter.validate(this, v);
	    };
	    ASTNodeImpl.prototype.clearTypesCache = function () {
	        this._types = null;
	        var c = this.lowLevel().actual();
	        c.types = null;
	    };
	    ASTNodeImpl.prototype.types = function () {
	        var _this = this;
	        if (!this._types) {
	            if (this.parent() && (this.definition().key() !== universes.Universe10.Library)) {
	                return this.parent().types();
	            }
	            else {
	                var c = this.lowLevel().actual();
	                if (c.types) {
	                    return c.types;
	                }
	                this._types = rTypes.parseFromAST(new LowLevelWrapperForTypeSystem(this.lowLevel(), this));
	                this._types.types().forEach(function (x) {
	                    var convertedType = typeBuilder.convertType(_this, x);
	                    // if (defs.instanceOfHasExtra(convertedType)) {
	                    convertedType.putExtra(defs.USER_DEFINED_EXTRA, true);
	                    // }
	                });
	                c.types = this._types;
	            }
	        }
	        return this._types;
	    };
	    ASTNodeImpl.prototype.setTypes = function (t) {
	        this._types = t;
	    };
	    ASTNodeImpl.prototype.parsedType = function () {
	        if (!this._ptype) {
	            if (this.property() && this.property().nameId() == universes.Universe10.MethodBase.properties.body.name) {
	                var isParametrizedType = this.isParametrizedType();
	                this._ptype = rTypes.parseTypeFromAST(this.name(), new LowLevelWrapperForTypeSystem(this.lowLevel(), this), this.types(), true, false, false, isParametrizedType);
	            }
	            else {
	                var annotation = this.property() && this.property().nameId() == universes.Universe10.LibraryBase.properties.annotationTypes.name;
	                var tl = (!this.property()) || (this.property().nameId() == universes.Universe10.LibraryBase.properties.types.name || this.property().nameId() == universes.Universe10.LibraryBase.properties.schemas.name);
	                if (!annotation && this.parent() == null) {
	                    var localUniverse = this.universe();
	                    if (localUniverse && localUniverse.getOriginalTopLevelText()
	                        && localUniverse.getOriginalTopLevelText() == "AnnotationTypeDeclaration") {
	                        annotation = true;
	                    }
	                }
	                this._ptype = rTypes.parseTypeFromAST(this.name(), new LowLevelWrapperForTypeSystem(this.lowLevel(), this), this.types(), false, annotation, tl);
	            }
	            if (this.property() && universeHelpers.isTypesProperty(this.property())
	                && this.parent() && universeHelpers.isApiType(this.parent().definition())) {
	                //top level types declared via "types"
	                // this._ptype.setExtra()
	                if (this._ptype.putExtra) {
	                    this._ptype.putExtra(defs.DEFINED_IN_TYPES_EXTRA, true);
	                }
	            }
	            var potentialHasExtra = this._ptype;
	            potentialHasExtra.putExtra(defs.USER_DEFINED_EXTRA, true);
	            this._ptype.putExtra(defs.SOURCE_EXTRA, this);
	        }
	        return this._ptype;
	    };
	    ASTNodeImpl.prototype.isParametrizedType = function () {
	        var isParametrizedType = false;
	        var typeAttr = this.attr(universes.Universe10.TypeDeclaration.properties.type.name);
	        if (typeAttr) {
	            var typeAttrValue = typeAttr.value();
	            if (typeof typeAttrValue == "string") {
	                if (typeAttrValue.indexOf("<<") >= 0) {
	                    var parent = this.parent();
	                    while (parent != null) {
	                        if (universeHelpers.isResourceTypeType(parent.definition())
	                            || universeHelpers.isTraitType(parent.definition())) {
	                            isParametrizedType = true;
	                            break;
	                        }
	                        parent = parent.parent();
	                    }
	                }
	            }
	        }
	        return isParametrizedType;
	    };
	    ASTNodeImpl.prototype.localType = function () {
	        return typeBuilder.typeFromNode(this);
	    };
	    ASTNodeImpl.prototype.patchProp = function (pr) {
	        this._prop = pr;
	    };
	    ASTNodeImpl.prototype.getKind = function () {
	        return hl.NodeKind.NODE;
	    };
	    ASTNodeImpl.prototype.wrapperNode = function () {
	        if (!this._wrapperNode) {
	            if (universeHelpers.isExampleSpecType(this.definition())) {
	                var typeYamlNode = yaml.newMap([yaml.newMapping(yaml.newScalar("example"), this.lowLevel().actual())]);
	                var typesNode = yaml.newMapping(yaml.newScalar("types"), yaml.newMap([yaml.newMapping(yaml.newScalar("__AUX_TYPE__"), typeYamlNode)]));
	                var yamlNode = yaml.newMap([typesNode]);
	                var llNode = new jsyaml.ASTNode(yamlNode, this.lowLevel().unit(), null, null, null);
	                var types = rTypes.parseFromAST(new LowLevelWrapperForTypeSystem(llNode, this));
	                var nominal = rTypes.toNominal(types.types()[0], function (x) { return null; });
	                var spec = wrapperHelper.examplesFromNominal(nominal, this, true, false);
	                return spec[0];
	            }
	            else {
	                //forcing discrimination
	                this.children();
	                this._wrapperNode = this.buildWrapperNode();
	            }
	        }
	        return this._wrapperNode;
	    };
	    ASTNodeImpl.prototype.asElement = function () {
	        return this;
	    };
	    ASTNodeImpl.prototype.buildWrapperNode = function () {
	        var ramlVersion = this.definition().universe().version();
	        if (ramlVersion == 'RAML10') {
	            return factory10.buildWrapperNode(this);
	        }
	        else if (ramlVersion == 'RAML08') {
	            return factory08.buildWrapperNode(this);
	        }
	        return null;
	    };
	    ASTNodeImpl.prototype.propertiesAllowedToUse = function () {
	        var _this = this;
	        return this.definition().allProperties().filter(function (x) { return _this.isAllowedToUse(x); });
	    };
	    ASTNodeImpl.prototype.isAllowedToUse = function (p) {
	        var _this = this;
	        var ok = true;
	        if (p.getAdapter(services.RAMLPropertyService).isSystem()) {
	            return false;
	        }
	        p.getContextRequirements().forEach(function (y) {
	            if (y.name.indexOf('(') != -1) {
	                //TODO HANDLE IT LATER
	                return true;
	            }
	            var vl = _this.computedValue(y.name);
	            if (vl) {
	                ok = ok && (vl == y.value);
	            }
	            else {
	                if (y.value) {
	                    ok = false;
	                }
	            }
	        });
	        return ok;
	    };
	    ASTNodeImpl.prototype.allowRecursive = function () {
	        if (this.definition().getAdapter(services.RAMLService).isUserDefined()) {
	            return true;
	        }
	        return false;
	    };
	    ASTNodeImpl.prototype.setWrapperNode = function (node) {
	        this._wrapperNode = node;
	    };
	    ASTNodeImpl.prototype.setAssociatedType = function (d) {
	        this._associatedDef = d;
	    };
	    ASTNodeImpl.prototype.associatedType = function () {
	        return this._associatedDef;
	    };
	    ASTNodeImpl.prototype.knownIds = function () {
	        //initializing ids if needed
	        //TODO refactor workaround
	        this.isAuxilary();
	        if (this._knownIds) {
	            return this._knownIds;
	        }
	        else {
	            return {};
	        }
	    };
	    ASTNodeImpl.prototype.findById = function (id) {
	        var _this = this;
	        //we dont need re-indexing each time someone asks
	        //node byu ID from a sub-nodes. Root most probably
	        //already has everything indexed
	        var currentRoot = this.root();
	        if (currentRoot != this) {
	            return currentRoot.findById(id);
	        }
	        if (!this._knownIds) {
	            this._knownIds = {};
	            var all = search.allChildren(this);
	            all.forEach(function (x) { return _this._knownIds[x.id()] = x; });
	        }
	        if (this.isAuxilary()) {
	            if (!this._slaveIds) {
	                this._slaveIds = {};
	                var all = search.allChildren(this);
	                all.forEach(function (x) { return _this._slaveIds[x.id()] = x; });
	            }
	            var nodeIndexedInSlave = this._slaveIds[id];
	            if (nodeIndexedInSlave)
	                return nodeIndexedInSlave;
	        }
	        return this._knownIds[id];
	    };
	    ASTNodeImpl.prototype.isAuxilary = function () {
	        if (this._isAux) {
	            return true;
	        }
	        if (this._auxChecked) {
	            return false;
	        }
	        this._auxChecked = true;
	        var masterApi = this.getMaster();
	        if (masterApi) {
	            this._isAux = true;
	            this.initilizeKnownIDs(masterApi);
	            return true;
	        }
	        return false;
	    };
	    ASTNodeImpl.prototype.initilizeKnownIDs = function (api) {
	        var _this = this;
	        this._knownIds = {};
	        var allChildren = search.allChildren(api);
	        allChildren.forEach(function (x) { return _this._knownIds[x.id()] = x; });
	        this._knownIds[""] = api;
	    };
	    ASTNodeImpl.prototype.getMaster = function () {
	        if (this.masterApi) {
	            return this.masterApi;
	        }
	        return this.calculateMasterByRef();
	    };
	    /**
	     * Forcefully sets a master unit for this API, which may be different from the one, current unit points to
	     * via masterRef.
	     * @param master
	     */
	    ASTNodeImpl.prototype.overrideMaster = function (master) {
	        this.masterApi = master;
	        this.resetAuxilaryState();
	    };
	    ASTNodeImpl.prototype.setMergeMode = function (mergeMode) {
	        this.overlayMergeMode = mergeMode;
	        this.resetAuxilaryState();
	    };
	    ASTNodeImpl.prototype.getMergeMode = function () {
	        return this.overlayMergeMode;
	    };
	    ASTNodeImpl.prototype.calculateMasterByRef = function () {
	        var unit = this.lowLevel().unit();
	        if (!unit)
	            return null;
	        var masterReferenceNode = unit.getMasterReferenceNode();
	        if (!masterReferenceNode || !masterReferenceNode.value()) {
	            return null;
	        }
	        var lc = this.lowLevel();
	        if (lc.master) {
	            return lc.master;
	        }
	        var masterPath = masterReferenceNode.value();
	        var masterUnit = this.lowLevel().unit().project().resolve(this.lowLevel().unit().path(), masterPath);
	        if (!masterUnit) {
	            return null;
	        }
	        var result = masterUnit.expandedHighLevel();
	        result.setMergeMode(this.overlayMergeMode);
	        lc.master = result;
	        return result;
	    };
	    ASTNodeImpl.prototype.resetAuxilaryState = function () {
	        this._isAux = false;
	        this._auxChecked = false;
	        this._knownIds = null;
	        this.clearChildrenCache();
	    };
	    ASTNodeImpl.prototype.printDetails = function (indent) {
	        var result = "";
	        if (!indent)
	            indent = "";
	        var classname = this.definition().nameId();
	        var definitionClasName = this.property() ? this.property().range().nameId() : "";
	        var parentPropertyName = this.property() ? this.property().nameId() : "";
	        result += indent + classname + "[" + definitionClasName + "]" + " <--- " + parentPropertyName + "\n";
	        this.children().forEach(function (child) {
	            result += child.printDetails(indent + "\t");
	        });
	        return result;
	    };
	    /**
	     * Used for test comparison of two trees. Touching this will require AST tests update.
	     * @param indent
	     * @returns {string}
	     */
	    ASTNodeImpl.prototype.testSerialize = function (indent) {
	        var result = "";
	        if (!indent)
	            indent = "";
	        var classname = this.definition().nameId();
	        var parentPropertyName = this.property() ? this.property().nameId() : "";
	        result += indent + classname + " <-- " + parentPropertyName + "\n";
	        this.children().forEach(function (child) {
	            if (child.testSerialize) {
	                result += child.testSerialize(indent + "  ");
	            }
	        });
	        return result;
	    };
	    ASTNodeImpl.prototype.getExtractedChildren = function () {
	        var r = this.root();
	        if (r.isAuxilary()) {
	            if (r._knownIds) {
	                var i = r._knownIds[this.id()];
	                if (i) {
	                    var v = i.children();
	                    return v;
	                }
	            }
	            return [];
	        }
	        return [];
	    };
	    ASTNodeImpl.prototype.getMasterCounterPart = function () {
	        var r = this.root();
	        if (r.isAuxilary()) {
	            if (r._knownIds) {
	                var i = r._knownIds[this.id()];
	                return i;
	            }
	            return null;
	        }
	        return null;
	    };
	    ASTNodeImpl.prototype.getExtractedLowLevelChildren = function (n) {
	        var r = this.root();
	        if (r.isAuxilary()) {
	            if (r._knownLowLevelIds) {
	                var i = r._knownLowLevelIds[this.id()];
	                if (i) {
	                    return i.children();
	                }
	            }
	            return [];
	        }
	        return [];
	    };
	    ASTNodeImpl.prototype.allowsQuestion = function () {
	        return this._allowQuestion || this.definition().getAdapter(services.RAMLService).getAllowQuestion();
	    };
	    ASTNodeImpl.prototype.findReferences = function () {
	        var _this = this;
	        var rs = [];
	        search.refFinder(this.root(), this, rs);
	        //TODO FIX ME
	        if (rs.length > 1) {
	            rs = rs.filter(function (x) { return x != _this && x.parent() != _this; });
	        }
	        //filtering out equal results
	        var filteredReferences = [];
	        rs.forEach(function (ref) {
	            if (!_.find(filteredReferences, function (existing) { return existing == ref; })) {
	                filteredReferences.push(ref);
	            }
	        });
	        return filteredReferences;
	    };
	    ASTNodeImpl.prototype.setNamePatch = function (s) {
	        this._patchedName = s;
	    };
	    ASTNodeImpl.prototype.isNamePatch = function () {
	        return this._patchedName;
	    };
	    ASTNodeImpl.prototype.name = function () {
	        if (this._patchedName) {
	            return this._patchedName;
	        }
	        var ka = _.find(this.directChildren(), function (x) { return x.property() && x.property().getAdapter(services.RAMLPropertyService).isKey(); });
	        if (ka && ka instanceof ASTPropImpl) {
	            var c = null;
	            var defClass = this.definition();
	            var ramlVersion = defClass.universe().version();
	            if (defClass && ramlVersion == "RAML10" && ka.isFromKey()) {
	                var key = this._node.key();
	                c = this._node.optional() ? key + "?" : key;
	            }
	            else {
	                c = ka.value();
	            }
	            return c;
	        }
	        return _super.prototype.name.call(this);
	    };
	    ASTNodeImpl.prototype.findElementAtOffset = function (n) {
	        return this._findNode(this, n, n);
	    };
	    ASTNodeImpl.prototype.isElement = function () {
	        return true;
	    };
	    ASTNodeImpl.prototype.universe = function () {
	        if (this._universe) {
	            return this._universe;
	        }
	        return this.definition().universe();
	    };
	    ASTNodeImpl.prototype.setUniverse = function (u) {
	        this._universe = u;
	    };
	    ASTNodeImpl.prototype._findNode = function (n, offset, end) {
	        var _this = this;
	        if (n == null) {
	            return null;
	        }
	        if (n.lowLevel()) {
	            //var node:ASTNode=<ASTNode>n;
	            if (n.lowLevel().start() <= offset && n.lowLevel().end() >= end) {
	                var res = n;
	                //TODO INCLUDES
	                n.elements().forEach(function (x) {
	                    if (x.lowLevel().unit() != n.lowLevel().unit()) {
	                        return;
	                    }
	                    var m = _this._findNode(x, offset, end);
	                    if (m) {
	                        res = m;
	                    }
	                });
	                return res;
	            }
	        }
	        return null;
	    };
	    ASTNodeImpl.prototype.isStub = function () {
	        return (!this.lowLevel().unit()) || this.lowLevel().unit().isStubUnit();
	    };
	    ASTNodeImpl.prototype.add = function (node) {
	        mutators.addToNode(this, node);
	    };
	    ASTNodeImpl.prototype.remove = function (node) {
	        mutators.removeNodeFrom(this, node);
	    };
	    ASTNodeImpl.prototype.dump = function (flavor) {
	        return this._node.dump();
	    };
	    ASTNodeImpl.prototype.patchType = function (d) {
	        this._def = d;
	        var ass = this._associatedDef;
	        this._associatedDef = null;
	        this._children = null;
	        this._mergedChildren = null;
	    };
	    ASTNodeImpl.prototype.children = function () {
	        var lowLevel = this.lowLevel();
	        if (lowLevel && lowLevel.isValueInclude && lowLevel.isValueInclude() && resourceRegistry.isWaitingFor(lowLevel.includePath())) {
	            this._children = null;
	            return [];
	        }
	        if (this._children) {
	            if (this._mergedChildren) {
	                return this._mergedChildren;
	            }
	            this._mergedChildren = this.mergeChildren(this._children, this.getExtractedChildren());
	            return this._mergedChildren;
	        }
	        if (this._node) {
	            this._children = nodeBuilder.process(this, this._node.children());
	            this._children = this._children.filter(function (x) { return x != null; });
	            //FIXME
	            return this.mergeChildren(this._children, this.getExtractedChildren());
	        }
	        return [];
	    };
	    ASTNodeImpl.prototype.mergeChildren = function (originalChildren, masterChildren) {
	        var _this = this;
	        var root = this.root();
	        if (root.overlayMergeMode == OverlayMergeMode.AGGREGATE) {
	            //simply joining the sets
	            return originalChildren.concat(masterChildren);
	        }
	        else if (root.overlayMergeMode == OverlayMergeMode.MERGE) {
	            var result = [];
	            originalChildren.forEach(function (originalChild) {
	                var masterCounterpart = _.find(masterChildren, function (masterChild) { return masterChild.fullLocalId() == originalChild.fullLocalId(); });
	                if (!masterCounterpart) {
	                    //we dont have a counterpart, so simply adding to result
	                    result.push(originalChild);
	                }
	                else {
	                    //there is a counterpart, so deciding what to do:
	                    _this.mergeChild(result, originalChild, masterCounterpart);
	                }
	            });
	            masterChildren.forEach(function (masterChild) {
	                var originalCounterpart = _.find(originalChildren, function (originalChild) { return masterChild.fullLocalId() == originalChild.fullLocalId(); });
	                if (!originalCounterpart) {
	                    //we dont have a counterpart, so simply adding to result
	                    result.push(masterChild);
	                }
	            });
	            return result;
	        }
	        return null;
	    };
	    ASTNodeImpl.prototype.mergeLowLevelChildren = function (originalChildren, masterChildren) {
	        var _this = this;
	        var root = this.root();
	        if (root.overlayMergeMode == OverlayMergeMode.AGGREGATE) {
	            //simply joining the sets
	            return originalChildren.concat(masterChildren);
	        }
	        else if (root.overlayMergeMode == OverlayMergeMode.MERGE) {
	            var result = [];
	            originalChildren.forEach(function (originalChild) {
	                var masterCounterpart = _.find(masterChildren, function (masterChild) { return masterChild.key() == originalChild.key(); });
	                if (!masterCounterpart) {
	                    //we dont have a counterpart, so simply adding to result
	                    result.push(originalChild);
	                }
	                else {
	                    //there is a counterpart, so deciding what to do:
	                    _this.mergeLowLevelChild(result, originalChild, masterCounterpart);
	                }
	            });
	            masterChildren.forEach(function (masterChild) {
	                var originalCounterpart = _.find(originalChildren, function (originalChild) { return masterChild.key() == originalChild.key(); });
	                if (!originalCounterpart) {
	                    //we dont have a counterpart, so simply adding to result
	                    result.push(masterChild);
	                }
	            });
	            return result;
	        }
	        return null;
	    };
	    ASTNodeImpl.prototype.mergeLowLevelChild = function (result, originalChild, masterChild) {
	        if (originalChild.kind() != masterChild.kind()) {
	            //should not happen theoretically
	            result.push(originalChild);
	            result.push(masterChild);
	            return;
	        }
	        result.push(originalChild);
	    };
	    ASTNodeImpl.prototype.mergeChild = function (result, originalChild, masterChild) {
	        if (originalChild.getKind() != masterChild.getKind()) {
	            //should not happen theoretically
	            result.push(originalChild);
	            result.push(masterChild);
	            return;
	        }
	        if (originalChild.getKind() == hl.NodeKind.NODE) {
	            result.push(originalChild);
	            return;
	        }
	        else if (originalChild.getKind() == hl.NodeKind.ATTRIBUTE) {
	            //if ((<ASTPropImpl>originalChild).name() == "displayName" ||
	            //    (<ASTPropImpl>originalChild).name() == "title") {
	            //    console.log("OriginalChildForDisplayName: " + (<ASTPropImpl>originalChild).value())
	            //    console.log("MasterChildForDisplayName: " + (<ASTPropImpl>masterChild).value())
	            //
	            //}
	            result.push(originalChild);
	            return;
	        }
	        else if (originalChild.getKind() == hl.NodeKind.BASIC) {
	            //we do not know what to do with basic nodes, so adding both.
	            result.push(originalChild);
	            result.push(masterChild);
	            return;
	        }
	    };
	    ASTNodeImpl.prototype.directChildren = function () {
	        if (this._children) {
	            return this._children;
	        }
	        if (this._node) {
	            this._children = nodeBuilder.process(this, this._node.children());
	            return this._children;
	        }
	        return [];
	    };
	    ASTNodeImpl.prototype.resetChildren = function () {
	        this._children = null;
	        this._mergedChildren = null;
	    };
	    ASTNodeImpl.prototype.isEmptyRamlFile = function () {
	        var llroot = this.lowLevel().root();
	        return llroot.isScalar();
	    };
	    ASTNodeImpl.prototype.initRamlFile = function () {
	        mutators.initEmptyRAMLFile(this);
	    };
	    ASTNodeImpl.prototype.createAttr = function (n, v) {
	        mutators.createAttr(this, n, v);
	    };
	    ASTNodeImpl.prototype.isAttr = function () {
	        return false;
	    };
	    ASTNodeImpl.prototype.isUnknown = function () {
	        return false;
	    };
	    ASTNodeImpl.prototype.value = function () {
	        return this._node.value();
	    };
	    ASTNodeImpl.prototype.valuesOf = function (propName) {
	        var pr = this._def.property(propName);
	        if (pr != null) {
	            return this.elements().filter(function (x) { return x.property() == pr; });
	        }
	        return [];
	    };
	    ASTNodeImpl.prototype.attr = function (n) {
	        return _.find(this.attrs(), function (y) { return y.name() == n; });
	    };
	    ASTNodeImpl.prototype.attrOrCreate = function (name) {
	        var a = this.attr(name);
	        if (!a)
	            this.createAttr(name, '');
	        return this.attr(name);
	    };
	    ASTNodeImpl.prototype.attrValue = function (n) {
	        var a = this.attr(n);
	        return a ? a.value() : null;
	    };
	    ASTNodeImpl.prototype.attributes = function (n) {
	        return _.filter(this.attrs(), function (y) { return y.name() == n; });
	    };
	    ASTNodeImpl.prototype.attrs = function () {
	        var rs = this.children().filter(function (x) { return x.isAttr(); });
	        if (this._patchedName) {
	            var kp = _.find(this.definition().allProperties(), function (x) { return x.getAdapter(services.RAMLPropertyService).isKey(); });
	            if (kp) {
	                var mm = new ASTPropImpl(this.lowLevel(), this, kp.range(), kp, true);
	                mm._value = this._patchedName;
	                return [mm].concat(rs);
	            }
	        }
	        return rs;
	    };
	    ASTNodeImpl.prototype.elements = function () {
	        return this.children()
	            .filter(function (x) { return !x.isAttr() && !x.isUnknown(); });
	    };
	    ASTNodeImpl.prototype.element = function (n) {
	        var r = this.elementsOfKind(n);
	        if (r.length > 0) {
	            return r[0];
	        }
	        return null;
	    };
	    ASTNodeImpl.prototype.elementsOfKind = function (n) {
	        var r = this.elements().filter(function (x) { return x.property().nameId() == n; });
	        return r;
	    };
	    ASTNodeImpl.prototype.definition = function () {
	        return this._def;
	    };
	    ASTNodeImpl.prototype.property = function () {
	        return this._prop;
	    };
	    ASTNodeImpl.prototype.isExpanded = function () {
	        return this._expanded;
	    };
	    ASTNodeImpl.prototype.copy = function () {
	        return new ASTNodeImpl(this.lowLevel().copy(), this.parent(), this.definition(), this.property());
	    };
	    ASTNodeImpl.prototype.clearChildrenCache = function () {
	        this._children = null;
	        this._mergedChildren = null;
	    };
	    ASTNodeImpl.prototype.optionalProperties = function () {
	        var def = this.definition();
	        if (def == null) {
	            return [];
	        }
	        var result = [];
	        var map = {};
	        var children = this.lowLevel().children();
	        children.forEach(function (x) {
	            if (x.optional()) {
	                map[x.key()] = true;
	            }
	        });
	        var props = def.allProperties();
	        props.forEach(function (x) {
	            var prop = x;
	            if (map[prop.nameId()]) {
	                result.push(prop.nameId());
	            }
	        });
	        return result;
	    };
	    return ASTNodeImpl;
	}(BasicASTNode));
	exports.ASTNodeImpl = ASTNodeImpl;
	exports.universeProvider = __webpack_require__(35);
	var getDefinitionSystemType = function (contents, ast) {
	    var rfl = ramlFirstLine(contents);
	    var spec = (rfl && rfl[1]) || "";
	    var ptype = (rfl && rfl.length > 2 && rfl[2]) || "Api";
	    var originalPType = rfl && rfl.length > 2 && rfl[2];
	    var localUniverse = spec == "1.0" ? new def.Universe(null, "RAML10", exports.universeProvider("RAML10"), "RAML10") : new def.Universe(null, "RAML08", exports.universeProvider("RAML08"));
	    if (ptype == 'API') {
	        ptype = "Api";
	    }
	    else if (ptype == 'NamedExample') {
	        ptype = "ExampleSpec";
	    }
	    else if (ptype == 'DataType') {
	        ptype = "TypeDeclaration";
	    }
	    else if (ptype == 'SecurityScheme') {
	        ptype = "AbstractSecurityScheme";
	    }
	    else if (ptype == 'AnnotationTypeDeclaration') {
	        ptype = "TypeDeclaration";
	    }
	    localUniverse.setOriginalTopLevelText(originalPType);
	    localUniverse.setTopLevel(ptype);
	    localUniverse.setTypedVersion(spec);
	    // localUniverse.setDescription(spec);
	    return { ptype: ptype, localUniverse: localUniverse };
	};
	function ramlFirstLine(content) {
	    return content.match(/^\s*#%RAML\s+(\d\.\d)\s*(\w*)\s*$/m);
	}
	exports.ramlFirstLine = ramlFirstLine;
	function getFragmentDefenitionName(highLevelNode) {
	    var contents = highLevelNode.lowLevel() && highLevelNode.lowLevel().unit() && highLevelNode.lowLevel().unit().contents();
	    if (contents == null) {
	        return null;
	    }
	    return getDefinitionSystemType(contents, highLevelNode.lowLevel()).ptype;
	}
	exports.getFragmentDefenitionName = getFragmentDefenitionName;
	function fromUnit(l) {
	    if (l == null)
	        return null;
	    var contents = l.contents();
	    var ast = l.ast();
	    var __ret = getDefinitionSystemType(contents, ast);
	    var ptype = __ret.ptype;
	    var localUniverse = __ret.localUniverse;
	    var apiType = localUniverse.type(ptype);
	    if (!apiType)
	        apiType = localUniverse.type("Api");
	    var api = new ASTNodeImpl(ast, null, apiType, null);
	    api.setUniverse(localUniverse);
	    //forcing discrimination
	    api.children();
	    return api;
	}
	exports.fromUnit = fromUnit;
	function createBasicValidationAcceptor(errors) {
	    var q = {
	        accept: function (c) {
	            errors.push(c);
	        },
	        begin: function () {
	        },
	        end: function () {
	        },
	        acceptUnique: function (issue) {
	            for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
	                var e = errors_1[_i];
	                if (e.start == issue.start && e.message == issue.message) {
	                    return;
	                }
	            }
	            this.accept(issue);
	        }
	    };
	    return q;
	}
	exports.createBasicValidationAcceptor = createBasicValidationAcceptor;
	//# sourceMappingURL=highLevelImpl.js.map

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var jsyaml = __webpack_require__(27);
	var hlimpl = __webpack_require__(16);
	var yaml = __webpack_require__(72);
	//*** THis is not needed any more *///
	function createStub0(parent, property, key) {
	    var p = parent.definition().property(property);
	    if (!p)
	        return null;
	    var nc = p.range();
	    var node = createStubNode(nc, p, key);
	    return node;
	}
	exports.createStub0 = createStub0;
	function genStructuredValue(type, name, mappings, parent) {
	    var map = yaml.newMap(mappings.map(function (mapping) { return yaml.newMapping(yaml.newScalar(mapping.key), yaml.newScalar(mapping.value)); }));
	    var node = new jsyaml.ASTNode(map, (parent ? parent.lowLevel().unit() : null), parent ? parent.lowLevel() : null, null, null);
	    return new hlimpl.StructuredValue(node, parent, parent ? parent.definition().property(type) : null, name);
	}
	exports.genStructuredValue = genStructuredValue;
	function createStub(parent, property, key) {
	    var p = parent.definition().property(property);
	    if (!p)
	        return null;
	    var nc = p.range();
	    var su = parent.lowLevel().unit().stub();
	    var node = createStubNode(nc, p, key, su);
	    node.isInEdit = true;
	    node.lowLevel()._unit = su;
	    node._parent = parent.copy();
	    node._parent.lowLevel()._unit = su;
	    return node;
	}
	exports.createStub = createStub;
	function createResourceStub(parent, key) {
	    return createStub(parent, "resources", key);
	}
	exports.createResourceStub = createResourceStub;
	function createMethodStub(parent, key) {
	    return createStub(parent, 'methods', key);
	}
	exports.createMethodStub = createMethodStub;
	function createResponseStub(parent, key) {
	    return createStub(parent, 'responses', key);
	}
	exports.createResponseStub = createResponseStub;
	function createBodyStub(parent, key) {
	    return createStub(parent, 'body', key);
	}
	exports.createBodyStub = createBodyStub;
	function createUriParameterStub(parent, key) {
	    return createStub(parent, 'uriParameters', key);
	}
	exports.createUriParameterStub = createUriParameterStub;
	function createQueryParameterStub(parent, key) {
	    return createStub(parent, 'queryParameters', key);
	}
	exports.createQueryParameterStub = createQueryParameterStub;
	function createAttr(_property, val) {
	    var lowLevel = jsyaml.createMapping(_property.nameId(), val);
	    var nm = new hlimpl.ASTPropImpl(lowLevel, null, _property.range(), _property);
	    return nm;
	}
	exports.createAttr = createAttr;
	function createStubNode(t, p, key, unit) {
	    if (key === void 0) { key = null; }
	    var lowLevel = jsyaml.createNode(key ? key : "key", null, unit);
	    var nm = new hlimpl.ASTNodeImpl(lowLevel, null, t, p);
	    if (!lowLevel.unit()) {
	        lowLevel._unit = unit;
	    }
	    nm.children();
	    return nm;
	}
	exports.createStubNode = createStubNode;
	//# sourceMappingURL=stubs.js.map

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(63);
	var textutil = __webpack_require__(42);
	var wrapper = __webpack_require__(20);
	var SchemaToModelGenerator = (function () {
	    function SchemaToModelGenerator() {
	    }
	    SchemaToModelGenerator.prototype.generateText = function (schema) {
	        var _this = this;
	        var obj = JSON.parse(schema);
	        var items = obj['items'];
	        if (!items)
	            return '';
	        var text = '';
	        var itemsArray = (items instanceof Array) ? items : [items];
	        text += 'types:\n';
	        itemsArray.forEach(function (e) {
	            //console.log('Item: ' + e.title + ' ' + e.type);
	            text += '  - ' + e.title + ':\n';
	            text += _this.generateObj(e, 3);
	        });
	        return text;
	    };
	    SchemaToModelGenerator.prototype.generateObj = function (e, lev) {
	        var text = '';
	        text += textutil.indent(lev, 'type: ' + e.type) + '\n';
	        if (!e.properties)
	            return;
	        text += textutil.indent(lev, 'properties:\n');
	        //console.log('props: ' + e.properties);
	        for (var name in e.properties) {
	            //console.log('  property: ' + JSON.stringify(p));
	            var p = e.properties[name];
	            text += textutil.indent(lev + 1, name + ':\n');
	            //console.log('  property ' + name + ': ' + p.type);
	            if (p.type == 'object') {
	                text += this.generateObj(p, lev + 2);
	            }
	            else {
	                text += textutil.indent(lev + 2, 'type: ' + p.type) + '\n';
	            }
	        }
	        return text;
	    };
	    SchemaToModelGenerator.prototype.generateTo = function (api, schema, title) {
	        var _this = this;
	        var obj = JSON.parse(schema);
	        var items = obj['items'];
	        if (!items) {
	            if (obj.title)
	                title = obj.title;
	            //console.log('title: ' + title);
	            var type = new wrapper.ObjectTypeDeclarationImpl(title);
	            this.generateObjTo(type, obj);
	            new wrapper.BasicSecuritySchemeImpl(api).addToProp(type, 'types');
	            return [title];
	        }
	        else {
	            var itemsArray = (items instanceof Array) ? items : [items];
	            var types = [];
	            itemsArray.forEach(function (e) {
	                var type = new wrapper.ObjectTypeDeclarationImpl(e.title);
	                _this.generateObjTo(type, e);
	                new wrapper.BasicSecuritySchemeImpl(api).addToProp(type, 'types');
	                types.push(e.title);
	            });
	            return types;
	        }
	    };
	    SchemaToModelGenerator.prototype.generateObjTo = function (type, e) {
	        type.setType(e.type);
	        //console.log('type: ' + type.definition().name());
	        //util.showTypeProperties(type.definition());
	        //type.attrOrCreate('type').setValue(e.type);
	        if (!e.properties)
	            return;
	        //text += textutil.indent(lev, 'properties:\n');
	        //console.log('props: ' + e.properties);
	        for (var name in e.properties) {
	            var p = e.properties[name];
	            var field = this.makeTypeField(name, p);
	            if (p.type == 'array') {
	            }
	            //console.log('  property: ' + JSON.stringify(p));
	            //text += textutil.indent(lev+1, name + ':\n');
	            //console.log('  property ' + name + ': ' + p.type);
	            type.addToProp(field, 'properties');
	        }
	    };
	    SchemaToModelGenerator.prototype.makeTypeField = function (name, p) {
	        var field = this.makeType(name, p.type);
	        if (p.type)
	            field.setType(p.type);
	        if (p.type == 'number') {
	            var n = field;
	            if (p.minimum != undefined)
	                (n).setMinimum(p.minimum);
	            if (p.maximum != undefined)
	                (n).setMaximum(p.maximum);
	        }
	        if (p.type == 'array') {
	            var itype = p.items.type;
	            field.setType(itype + '[]');
	            var a = field;
	            if (p.minItems != undefined)
	                a.setMinItems(p.minItems);
	            if (p.maxItems != undefined)
	                a.setMaxItems(p.maxItems);
	            if (p.uniqueItems != undefined)
	                a.setUniqueItems(p.uniqueItems);
	        }
	        if (p.type == 'object') {
	            this.generateObjTo(field, p);
	        }
	        return field;
	    };
	    SchemaToModelGenerator.prototype.makeType = function (name, type) {
	        if (type == 'number')
	            return new wrapper.NumberTypeDeclarationImpl(name);
	        if (type == 'string')
	            return new wrapper.StringTypeDeclarationImpl(name);
	        if (type == 'array')
	            return new wrapper.ArrayTypeDeclarationImpl(name);
	        return new wrapper.ObjectTypeDeclarationImpl(name);
	    };
	    SchemaToModelGenerator.prototype.generateItemsTo = function (a, obj) {
	        var items = obj['items'];
	        if (!items)
	            return;
	        var itemsArray = (items instanceof Array) ? items : [items];
	        itemsArray.forEach(function (item) {
	            //TODO add items here
	        });
	    };
	    return SchemaToModelGenerator;
	}());
	exports.SchemaToModelGenerator = SchemaToModelGenerator;
	var ModelToSchemaGenerator = (function () {
	    function ModelToSchemaGenerator() {
	    }
	    ModelToSchemaGenerator.prototype.generateSchema = function (node) {
	        var obj = this.generateType(node);
	        obj["$schema"] = "http://json-schema.org/draft-04/schema#";
	        return obj;
	    };
	    ModelToSchemaGenerator.prototype.isSimpleType = function (name) {
	        return name == 'string' || name == 'number' || name == 'boolean' || name == 'object';
	    };
	    ModelToSchemaGenerator.prototype.generateType = function (type) {
	        var typelist = this.allTypes(type);
	        var obj = {};
	        obj.title = type.attrValue('name');
	        var properties = {};
	        if (type.attrValue('type')) {
	            // support multiple inheritance
	            var types = type.attributes('type');
	            //var properties = {};
	            var inherited = false;
	            var simple = false;
	            for (var i in types) {
	                var typevalue = types[i].value();
	                var ll = types[i].lowLevel();
	                obj.type = '';
	                if (ll.isValueInclude()) {
	                    var schema = JSON.parse(typevalue);
	                    obj.type = 'object';
	                    obj.properties = schema.properties;
	                }
	                else {
	                    //console.log('type value: ' + typevalue);
	                    if (this.isSimpleType(typevalue)) {
	                        obj.type = typevalue;
	                        simple = true;
	                        if (inherited)
	                            throw new Error("couldn't mix user defined and basic types in inheritance");
	                    }
	                    else {
	                        var t = this.resolveType(type, typevalue);
	                        if (t) {
	                            var ppp = this.generateTypeExp(typevalue, typelist);
	                            //console.log('res: ' + typevalue + '\n' + JSON.stringify(ppp));
	                            //_.extend(properties, ppp.properties);
	                            if (obj.properties) {
	                                _.extend(obj.properties, ppp.properties);
	                            }
	                            else {
	                                obj.properties = ppp.properties;
	                            }
	                            obj.type = 'object';
	                            inherited = true;
	                            if (simple)
	                                throw new Error("couldn't mix user defined and basic types in inheritance");
	                        }
	                        else {
	                            var ppp = this.generateTypeExp(typevalue, typelist);
	                            //console.log('xtype: ' + typevalue + '\n' + JSON.stringify(ppp));
	                            obj.type = 'object';
	                            inherited = true;
	                            if (ppp.anyOf) {
	                                obj.anyOf = ppp.anyOf;
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        else {
	            obj.type = 'object';
	        }
	        //var ps = this.generateProperties(type);
	        //this.generatePropertiesTo(properties, type);
	        var ownProps = this.generateProperties(type);
	        //_.extend(properties, ownProps);
	        //if(Object.getOwnPropertyNames(properties).length > 0) {
	        if (obj.properties) {
	            //console.log('own.p : ' + obj.properties);
	            //console.log('own: ' + JSON.stringify(ownProps));
	            //console.log('obj.p1: ' + obj.properties);
	            _.extend(obj.properties, ownProps);
	        }
	        else {
	            obj.properties = ownProps;
	        }
	        return obj;
	    };
	    ModelToSchemaGenerator.prototype.makeUnion = function (typelist, types) {
	        var _this = this;
	        var anyof = [];
	        typelist.forEach(function (t) {
	            t = t.trim();
	            if (types[t]) {
	                anyof.push({
	                    type: 'object',
	                    properties: _this.generateType(types[t]).properties
	                });
	            }
	            else {
	                anyof.push({ type: t });
	            }
	        });
	        return anyof;
	    };
	    ModelToSchemaGenerator.prototype.generateTypeExp = function (type, types) {
	        var obj = {};
	        //console.log('type: ' + type);
	        if (textutil.endsWith(type, '[]')) {
	            obj.type = 'array';
	            obj.items = { type: type.substring(0, type.length - 2) };
	        }
	        else if (type.indexOf('|') > 0) {
	            var typelist = type.split('|');
	            obj.anyOf = this.makeUnion(typelist, types);
	        }
	        else {
	            if (types[type]) {
	                var schema = this.generateType(types[type]);
	                obj.type = 'object';
	                obj.properties = schema.properties;
	            }
	            else {
	                obj.type = type;
	            }
	        }
	        return obj;
	    };
	    ModelToSchemaGenerator.prototype.allTypes = function (node) {
	        var api = node.root();
	        var modelTypes = api.elementsOfKind('types');
	        var types = {};
	        modelTypes.forEach(function (type) {
	            //console.log('  types: ' + type.name());
	            types[type.name()] = type;
	        });
	        return types;
	    };
	    ModelToSchemaGenerator.prototype.resolveType = function (node, name) {
	        var types = this.allTypes(node);
	        return types[name];
	    };
	    ModelToSchemaGenerator.prototype.generateProperty = function (node, optional) {
	        var _this = this;
	        var types = this.allTypes(node);
	        var obj = {};
	        var props = node.definition().allProperties();
	        props.forEach(function (p) {
	            if (p.nameId() == 'name')
	                return;
	            var value = node.attrValue(p.nameId());
	            if (!(value != null && value != undefined && value != 'undefined'))
	                return;
	            if (p.nameId() == 'type') {
	                var t = _this.generateTypeExp(value, types);
	                _.extend(obj, t);
	            }
	            else if (p.nameId() == 'enum') {
	                var values = node.attributes('enum');
	                var arr = values.map(function (a) { return a.value(); });
	                obj.enum = arr;
	            }
	            else {
	                obj[p.nameId()] = value;
	            }
	        });
	        if (optional)
	            obj.required = false;
	        var elements = node.elements();
	        var properties = this.generateProperties(node);
	        if (Object.getOwnPropertyNames(properties).length > 0) {
	            obj.properties = properties;
	        }
	        return obj;
	    };
	    ModelToSchemaGenerator.prototype.generateProperties = function (node) {
	        var _this = this;
	        var props = {};
	        var elements = node.elements();
	        var empty = true;
	        elements.forEach(function (p) {
	            var name = p.attrValue('name');
	            if (typeof name !== 'string') {
	                return;
	            }
	            name = name.trim();
	            var optional = p.optional();
	            props[name] = _this.generateProperty(p, optional);
	            empty = false;
	        });
	        return props;
	    };
	    return ModelToSchemaGenerator;
	}());
	exports.ModelToSchemaGenerator = ModelToSchemaGenerator;
	//# sourceMappingURL=schemaModelGen.js.map

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var parser10impl = __webpack_require__(20);
	var defSys = __webpack_require__(36);
	var jsyaml = __webpack_require__(27);
	var ll = __webpack_require__(11);
	function createTypeDeclaration(typeName) {
	    return new parser10impl.TypeDeclarationImpl(typeName);
	}
	exports.createTypeDeclaration = createTypeDeclaration;
	function createObjectTypeDeclaration(typeName) {
	    return new parser10impl.ObjectTypeDeclarationImpl(typeName);
	}
	exports.createObjectTypeDeclaration = createObjectTypeDeclaration;
	//TODO it would be probably better to generate modification interface too
	function setTypeDeclarationSchema(type, schema) {
	    type.setSchema(schema);
	}
	exports.setTypeDeclarationSchema = setTypeDeclarationSchema;
	function setTypeDeclarationExample(type, example) {
	    var exampleSpecType = defSys.getUniverse("RAML10").type(defSys.universesInfo.Universe10.ExampleSpec.name);
	    var examplePropName = defSys.universesInfo.Universe10.TypeDeclaration.properties.example.name;
	    var hlParent = type.highLevel();
	    var llParent = hlParent.lowLevel();
	    var exampleNodes = hlParent.children().filter(function (x) { return x.lowLevel().key() == examplePropName; });
	    var llNode = jsyaml.createNode(examplePropName);
	    ll.setAttr(llNode, example);
	    if (exampleNodes.length > 0) {
	        ll.removeNode(llParent, exampleNodes[0].lowLevel());
	        exampleNodes[0]._node = llNode;
	        ll.insertNode(llParent, llNode);
	    }
	    hlParent.createAttr && hlParent.createAttr(examplePropName, example);
	}
	exports.setTypeDeclarationExample = setTypeDeclarationExample;
	function addChild(parent, child) {
	    parent.add(child);
	}
	exports.addChild = addChild;
	//# sourceMappingURL=parserMod.js.map

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * <p>See <a href="http://raml.org">http://raml.org</a> for more information about RAML.</p>
	 *
	 * <p>This parser is at a beta state of development, as part of the API Workbench development cycle (<a href="http://apiworkbench.com">http://apiworkbench.com</a>).</p>
	 *
	 * <p><a href="https://github.com/raml-org/raml-js-parser-2/blob/master/documentation/GettingStarted.md">Getting Started Guide</a> describes the first steps with the parser.</p>
	 *
	 * <h2>Installation</h2>
	 *
	 * <pre><code>git clone https://github.com/raml-org/raml-js-parser-2
	 *
	 * cd raml-js-parser-2
	 *
	 * npm install
	 *
	 * node test/test.js  //here you should observe JSON representation of XKCD API in your console
	 *
	 * node test/testAsync.js  //same as above but in asynchronous mode
	 * </code></pre>
	 *
	 * <h2>Usage</h2>
	 *
	 * <ul>
	 * <li>For parser usage example refer to <code>test/test.js</code></li>
	 * <li>For asynchrounous usage example refer to <code>test/testAsync.js</code></li>
	 * </ul>
	 **/
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var stubs = __webpack_require__(17);
	var def = __webpack_require__(36);
	var core = __webpack_require__(46);
	var apiLoader = __webpack_require__(9);
	var helper = __webpack_require__(33);
	var AnnotableImpl = (function (_super) {
	    __extends(AnnotableImpl, _super);
	    function AnnotableImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
	     **/
	    AnnotableImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    AnnotableImpl.prototype.wrapperClassName = function () { return "AnnotableImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    AnnotableImpl.prototype.kind = function () { return "Annotable"; };
	    /**
	     * @return RAML version of the node
	     **/
	    AnnotableImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    AnnotableImpl.prototype.scalarsAnnotations = function () { return new AnnotableScalarsAnnotationsImpl(this.highLevel()); };
	    return AnnotableImpl;
	}(core.BasicNodeImpl));
	exports.AnnotableImpl = AnnotableImpl;
	var ValueTypeImpl = (function (_super) {
	    __extends(ValueTypeImpl, _super);
	    function ValueTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ValueTypeImpl.prototype.wrapperClassName = function () { return "ValueTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ValueTypeImpl.prototype.kind = function () { return "ValueType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ValueTypeImpl.prototype.RAMLVersion = function () { return "undefined"; };
	    /**
	     * @return JS representation of the node value
	     **/
	    ValueTypeImpl.prototype.value = function () { return this.attr.value(); };
	    return ValueTypeImpl;
	}(core.AttributeNodeImpl));
	exports.ValueTypeImpl = ValueTypeImpl;
	var StringTypeImpl = (function (_super) {
	    __extends(StringTypeImpl, _super);
	    function StringTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    StringTypeImpl.prototype.wrapperClassName = function () { return "StringTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    StringTypeImpl.prototype.kind = function () { return "StringType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    StringTypeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * @return String representation of the node value
	     **/
	    StringTypeImpl.prototype.value = function () { return this.attr.value(); };
	    return StringTypeImpl;
	}(ValueTypeImpl));
	exports.StringTypeImpl = StringTypeImpl;
	/**
	 * This type currently serves both for absolute and relative urls
	 **/
	var UriTemplateImpl = (function (_super) {
	    __extends(UriTemplateImpl, _super);
	    function UriTemplateImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    UriTemplateImpl.prototype.wrapperClassName = function () { return "UriTemplateImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    UriTemplateImpl.prototype.kind = function () { return "UriTemplate"; };
	    /**
	     * @return RAML version of the node
	     **/
	    UriTemplateImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return UriTemplateImpl;
	}(StringTypeImpl));
	exports.UriTemplateImpl = UriTemplateImpl;
	/**
	 * This  type describes relative uri templates
	 **/
	var RelativeUriStringImpl = (function (_super) {
	    __extends(RelativeUriStringImpl, _super);
	    function RelativeUriStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    RelativeUriStringImpl.prototype.wrapperClassName = function () { return "RelativeUriStringImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    RelativeUriStringImpl.prototype.kind = function () { return "RelativeUriString"; };
	    /**
	     * @return RAML version of the node
	     **/
	    RelativeUriStringImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return RelativeUriStringImpl;
	}(UriTemplateImpl));
	exports.RelativeUriStringImpl = RelativeUriStringImpl;
	/**
	 * This  type describes absolute uri templates
	 **/
	var FullUriTemplateStringImpl = (function (_super) {
	    __extends(FullUriTemplateStringImpl, _super);
	    function FullUriTemplateStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    FullUriTemplateStringImpl.prototype.wrapperClassName = function () { return "FullUriTemplateStringImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    FullUriTemplateStringImpl.prototype.kind = function () { return "FullUriTemplateString"; };
	    /**
	     * @return RAML version of the node
	     **/
	    FullUriTemplateStringImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return FullUriTemplateStringImpl;
	}(UriTemplateImpl));
	exports.FullUriTemplateStringImpl = FullUriTemplateStringImpl;
	var StatusCodeStringImpl = (function (_super) {
	    __extends(StatusCodeStringImpl, _super);
	    function StatusCodeStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    StatusCodeStringImpl.prototype.wrapperClassName = function () { return "StatusCodeStringImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    StatusCodeStringImpl.prototype.kind = function () { return "StatusCodeString"; };
	    /**
	     * @return RAML version of the node
	     **/
	    StatusCodeStringImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return StatusCodeStringImpl;
	}(StringTypeImpl));
	exports.StatusCodeStringImpl = StatusCodeStringImpl;
	/**
	 * This  type describes fixed uris
	 **/
	var FixedUriStringImpl = (function (_super) {
	    __extends(FixedUriStringImpl, _super);
	    function FixedUriStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    FixedUriStringImpl.prototype.wrapperClassName = function () { return "FixedUriStringImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    FixedUriStringImpl.prototype.kind = function () { return "FixedUriString"; };
	    /**
	     * @return RAML version of the node
	     **/
	    FixedUriStringImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return FixedUriStringImpl;
	}(StringTypeImpl));
	exports.FixedUriStringImpl = FixedUriStringImpl;
	var ContentTypeImpl = (function (_super) {
	    __extends(ContentTypeImpl, _super);
	    function ContentTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ContentTypeImpl.prototype.wrapperClassName = function () { return "ContentTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ContentTypeImpl.prototype.kind = function () { return "ContentType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ContentTypeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return ContentTypeImpl;
	}(StringTypeImpl));
	exports.ContentTypeImpl = ContentTypeImpl;
	/**
	 * [GitHub Flavored Markdown](https://help.github.com/articles/github-flavored-markdown/)
	 **/
	var MarkdownStringImpl = (function (_super) {
	    __extends(MarkdownStringImpl, _super);
	    function MarkdownStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    MarkdownStringImpl.prototype.wrapperClassName = function () { return "MarkdownStringImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    MarkdownStringImpl.prototype.kind = function () { return "MarkdownString"; };
	    /**
	     * @return RAML version of the node
	     **/
	    MarkdownStringImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return MarkdownStringImpl;
	}(StringTypeImpl));
	exports.MarkdownStringImpl = MarkdownStringImpl;
	/**
	 * Schema at this moment only two subtypes are supported (json schema and xsd)
	 **/
	var SchemaStringImpl = (function (_super) {
	    __extends(SchemaStringImpl, _super);
	    function SchemaStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    SchemaStringImpl.prototype.wrapperClassName = function () { return "SchemaStringImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    SchemaStringImpl.prototype.kind = function () { return "SchemaString"; };
	    /**
	     * @return RAML version of the node
	     **/
	    SchemaStringImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return SchemaStringImpl;
	}(StringTypeImpl));
	exports.SchemaStringImpl = SchemaStringImpl;
	/**
	 * This sub type of the string represents mime types
	 **/
	var MimeTypeImpl = (function (_super) {
	    __extends(MimeTypeImpl, _super);
	    function MimeTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    MimeTypeImpl.prototype.wrapperClassName = function () { return "MimeTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    MimeTypeImpl.prototype.kind = function () { return "MimeType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    MimeTypeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return MimeTypeImpl;
	}(StringTypeImpl));
	exports.MimeTypeImpl = MimeTypeImpl;
	var AnyTypeImpl = (function (_super) {
	    __extends(AnyTypeImpl, _super);
	    function AnyTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    AnyTypeImpl.prototype.wrapperClassName = function () { return "AnyTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    AnyTypeImpl.prototype.kind = function () { return "AnyType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    AnyTypeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return AnyTypeImpl;
	}(ValueTypeImpl));
	exports.AnyTypeImpl = AnyTypeImpl;
	var NumberTypeImpl = (function (_super) {
	    __extends(NumberTypeImpl, _super);
	    function NumberTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    NumberTypeImpl.prototype.wrapperClassName = function () { return "NumberTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    NumberTypeImpl.prototype.kind = function () { return "NumberType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    NumberTypeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * @return Number representation of the node value
	     **/
	    NumberTypeImpl.prototype.value = function () { return this.attr.value(); };
	    return NumberTypeImpl;
	}(ValueTypeImpl));
	exports.NumberTypeImpl = NumberTypeImpl;
	var IntegerTypeImpl = (function (_super) {
	    __extends(IntegerTypeImpl, _super);
	    function IntegerTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    IntegerTypeImpl.prototype.wrapperClassName = function () { return "IntegerTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    IntegerTypeImpl.prototype.kind = function () { return "IntegerType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    IntegerTypeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return IntegerTypeImpl;
	}(ValueTypeImpl));
	exports.IntegerTypeImpl = IntegerTypeImpl;
	var NullTypeImpl = (function (_super) {
	    __extends(NullTypeImpl, _super);
	    function NullTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    NullTypeImpl.prototype.wrapperClassName = function () { return "NullTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    NullTypeImpl.prototype.kind = function () { return "NullType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    NullTypeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return NullTypeImpl;
	}(ValueTypeImpl));
	exports.NullTypeImpl = NullTypeImpl;
	var TimeOnlyTypeImpl = (function (_super) {
	    __extends(TimeOnlyTypeImpl, _super);
	    function TimeOnlyTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    TimeOnlyTypeImpl.prototype.wrapperClassName = function () { return "TimeOnlyTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    TimeOnlyTypeImpl.prototype.kind = function () { return "TimeOnlyType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    TimeOnlyTypeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return TimeOnlyTypeImpl;
	}(ValueTypeImpl));
	exports.TimeOnlyTypeImpl = TimeOnlyTypeImpl;
	var DateOnlyTypeImpl = (function (_super) {
	    __extends(DateOnlyTypeImpl, _super);
	    function DateOnlyTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    DateOnlyTypeImpl.prototype.wrapperClassName = function () { return "DateOnlyTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    DateOnlyTypeImpl.prototype.kind = function () { return "DateOnlyType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    DateOnlyTypeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return DateOnlyTypeImpl;
	}(ValueTypeImpl));
	exports.DateOnlyTypeImpl = DateOnlyTypeImpl;
	var DateTimeOnlyTypeImpl = (function (_super) {
	    __extends(DateTimeOnlyTypeImpl, _super);
	    function DateTimeOnlyTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    DateTimeOnlyTypeImpl.prototype.wrapperClassName = function () { return "DateTimeOnlyTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    DateTimeOnlyTypeImpl.prototype.kind = function () { return "DateTimeOnlyType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    DateTimeOnlyTypeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return DateTimeOnlyTypeImpl;
	}(ValueTypeImpl));
	exports.DateTimeOnlyTypeImpl = DateTimeOnlyTypeImpl;
	var DateTimeTypeImpl = (function (_super) {
	    __extends(DateTimeTypeImpl, _super);
	    function DateTimeTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    DateTimeTypeImpl.prototype.wrapperClassName = function () { return "DateTimeTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    DateTimeTypeImpl.prototype.kind = function () { return "DateTimeType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    DateTimeTypeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return DateTimeTypeImpl;
	}(ValueTypeImpl));
	exports.DateTimeTypeImpl = DateTimeTypeImpl;
	var FileTypeImpl = (function (_super) {
	    __extends(FileTypeImpl, _super);
	    function FileTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    FileTypeImpl.prototype.wrapperClassName = function () { return "FileTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    FileTypeImpl.prototype.kind = function () { return "FileType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    FileTypeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return FileTypeImpl;
	}(ValueTypeImpl));
	exports.FileTypeImpl = FileTypeImpl;
	var BooleanTypeImpl = (function (_super) {
	    __extends(BooleanTypeImpl, _super);
	    function BooleanTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    BooleanTypeImpl.prototype.wrapperClassName = function () { return "BooleanTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    BooleanTypeImpl.prototype.kind = function () { return "BooleanType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    BooleanTypeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * @return Boolean representation of the node value
	     **/
	    BooleanTypeImpl.prototype.value = function () { return this.attr.value(); };
	    return BooleanTypeImpl;
	}(ValueTypeImpl));
	exports.BooleanTypeImpl = BooleanTypeImpl;
	/**
	 * Elements to which this Annotation can be applied (enum)
	 **/
	var AnnotationTargetImpl = (function (_super) {
	    __extends(AnnotationTargetImpl, _super);
	    function AnnotationTargetImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    AnnotationTargetImpl.prototype.wrapperClassName = function () { return "AnnotationTargetImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    AnnotationTargetImpl.prototype.kind = function () { return "AnnotationTarget"; };
	    /**
	     * @return RAML version of the node
	     **/
	    AnnotationTargetImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return AnnotationTargetImpl;
	}(ValueTypeImpl));
	exports.AnnotationTargetImpl = AnnotationTargetImpl;
	var ReferenceImpl = (function (_super) {
	    __extends(ReferenceImpl, _super);
	    function ReferenceImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ReferenceImpl.prototype.wrapperClassName = function () { return "ReferenceImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ReferenceImpl.prototype.kind = function () { return "Reference"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ReferenceImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * @return StructuredValue object representing the node value
	     **/
	    ReferenceImpl.prototype.value = function () { return core.toStructuredValue(this.attr); };
	    ReferenceImpl.prototype.structuredValue = function () {
	        return helper.structuredValue(this);
	    };
	    ReferenceImpl.prototype.name = function () {
	        return helper.referenceName(this);
	    };
	    return ReferenceImpl;
	}(core.AttributeNodeImpl));
	exports.ReferenceImpl = ReferenceImpl;
	var TraitRefImpl = (function (_super) {
	    __extends(TraitRefImpl, _super);
	    function TraitRefImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    TraitRefImpl.prototype.wrapperClassName = function () { return "TraitRefImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    TraitRefImpl.prototype.kind = function () { return "TraitRef"; };
	    /**
	     * @return RAML version of the node
	     **/
	    TraitRefImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    TraitRefImpl.prototype.trait = function () {
	        return helper.referencedTrait(this);
	    };
	    return TraitRefImpl;
	}(ReferenceImpl));
	exports.TraitRefImpl = TraitRefImpl;
	var OperationImpl = (function (_super) {
	    __extends(OperationImpl, _super);
	    function OperationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createOperation(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * An APIs resources MAY be filtered (to return a subset of results) or altered (such as transforming  a response body from JSON to XML format) by the use of query strings. If the resource or its method supports a query string, the query string MUST be defined by the queryParameters property
	     **/
	    OperationImpl.prototype.queryParameters = function () {
	        return _super.prototype.elements.call(this, 'queryParameters');
	    };
	    /**
	     * Headers that allowed at this position
	     **/
	    OperationImpl.prototype.headers = function () {
	        return _super.prototype.elements.call(this, 'headers');
	    };
	    /**
	     * Specifies the query string needed by this method. Mutually exclusive with queryParameters.
	     **/
	    OperationImpl.prototype.queryString = function () {
	        return _super.prototype.element.call(this, 'queryString');
	    };
	    /**
	     * Information about the expected responses to a request
	     **/
	    OperationImpl.prototype.responses = function () {
	        return _super.prototype.elements.call(this, 'responses');
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    OperationImpl.prototype.wrapperClassName = function () { return "OperationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    OperationImpl.prototype.kind = function () { return "Operation"; };
	    /**
	     * @return RAML version of the node
	     **/
	    OperationImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return OperationImpl;
	}(AnnotableImpl));
	exports.OperationImpl = OperationImpl;
	var TypeDeclarationImpl = (function (_super) {
	    __extends(TypeDeclarationImpl, _super);
	    function TypeDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createTypeDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * name of the parameter
	     **/
	    TypeDeclarationImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     * @hidden
	     * Set name value
	     **/
	    TypeDeclarationImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    /**
	     * The displayName attribute specifies the type display name. It is a friendly name used only for  display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself).
	     **/
	    TypeDeclarationImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     * @hidden
	     * Set displayName value
	     **/
	    TypeDeclarationImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /**
	     * When extending from a type you can define new facets (which can then be set to concrete values by subtypes).
	     **/
	    TypeDeclarationImpl.prototype.facets = function () {
	        return _super.prototype.elements.call(this, 'facets');
	    };
	    /**
	     * Alias for the equivalent "type" property, for compatibility with RAML 0.8. Deprecated - API definitions should use the "type" property, as the "schema" alias for that property name may be removed in a future RAML version. The "type" property allows for XML and JSON schemas.
	     * @hidden
	     **/
	    TypeDeclarationImpl.prototype.schema_original = function () {
	        return _super.prototype.attributes.call(this, 'schema', this.toString);
	    };
	    /**
	     * @hidden
	     * Set schema value
	     **/
	    TypeDeclarationImpl.prototype.setSchema = function (param) {
	        this.highLevel().attrOrCreate("schema").setValue("" + param);
	        return this;
	    };
	    /**
	     * A base type which the current type extends, or more generally a type expression.
	     * @hidden
	     **/
	    TypeDeclarationImpl.prototype.type_original = function () {
	        return _super.prototype.attributes.call(this, 'type', this.toString);
	    };
	    /**
	     * @hidden
	     * Set type value
	     **/
	    TypeDeclarationImpl.prototype.setType = function (param) {
	        this.highLevel().attrOrCreate("type").setValue("" + param);
	        return this;
	    };
	    /**
	     * Location of the parameter (can not be edited by user)
	     **/
	    TypeDeclarationImpl.prototype.location = function () {
	        return _super.prototype.attribute.call(this, 'location', function (attr) { return new ModelLocationImpl(attr); });
	    };
	    /**
	     * Kind of location
	     **/
	    TypeDeclarationImpl.prototype.locationKind = function () {
	        return _super.prototype.attribute.call(this, 'locationKind', function (attr) { return new LocationKindImpl(attr); });
	    };
	    /**
	     * Provides default value for a property
	     **/
	    TypeDeclarationImpl.prototype["default"] = function () {
	        return _super.prototype.attribute.call(this, 'default', this.toAny);
	    };
	    /**
	     * @hidden
	     * Set default value
	     **/
	    TypeDeclarationImpl.prototype.setDefault = function (param) {
	        this.highLevel().attrOrCreate("default").setValue("" + param);
	        return this;
	    };
	    /**
	     * An example of this type instance represented as string or yaml map/sequence. This can be used, e.g., by documentation generators to generate sample values for an object of this type. Cannot be present if the examples property is present.
	     * @hidden
	     **/
	    TypeDeclarationImpl.prototype.example_original = function () {
	        return _super.prototype.element.call(this, 'example');
	    };
	    /**
	     * An example of this type instance represented as string. This can be used, e.g., by documentation generators to generate sample values for an object of this type. Cannot be present if the example property is present.
	     * @hidden
	     **/
	    TypeDeclarationImpl.prototype.examples_original = function () {
	        return _super.prototype.elements.call(this, 'examples');
	    };
	    /**
	     * Sets if property is optional or not
	     **/
	    TypeDeclarationImpl.prototype.required = function () {
	        return _super.prototype.attribute.call(this, 'required', this.toBoolean);
	    };
	    /**
	     * @hidden
	     * Set required value
	     **/
	    TypeDeclarationImpl.prototype.setRequired = function (param) {
	        this.highLevel().attrOrCreate("required").setValue("" + param);
	        return this;
	    };
	    /**
	     * A longer, human-friendly description of the type
	     **/
	    TypeDeclarationImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    TypeDeclarationImpl.prototype.xml = function () {
	        return _super.prototype.element.call(this, 'xml');
	    };
	    /**
	     * Restrictions on where annotations of this type can be applied. If this property is specified, annotations of this type may only be applied on a property corresponding to one of the target names specified as the value of this property.
	     **/
	    TypeDeclarationImpl.prototype.allowedTargets = function () {
	        return _super.prototype.attributes.call(this, 'allowedTargets', function (attr) { return new AnnotationTargetImpl(attr); });
	    };
	    /**
	     * Whether the type represents annotation
	     **/
	    TypeDeclarationImpl.prototype.isAnnotation = function () {
	        return _super.prototype.attribute.call(this, 'isAnnotation', this.toBoolean);
	    };
	    /**
	     * @hidden
	     * Set isAnnotation value
	     **/
	    TypeDeclarationImpl.prototype.setIsAnnotation = function (param) {
	        this.highLevel().attrOrCreate("isAnnotation").setValue("" + param);
	        return this;
	    };
	    /**
	     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
	     **/
	    TypeDeclarationImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    TypeDeclarationImpl.prototype.uses = function () {
	        return _super.prototype.elements.call(this, 'uses');
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    TypeDeclarationImpl.prototype.wrapperClassName = function () { return "TypeDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    TypeDeclarationImpl.prototype.kind = function () { return "TypeDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    TypeDeclarationImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Runtime representation of type represented by this AST node
	     **/
	    TypeDeclarationImpl.prototype.runtimeType = function () {
	        return helper.runtimeType(this);
	    };
	    /**
	     * validate an instance against type
	     **/
	    TypeDeclarationImpl.prototype.validateInstance = function (value) {
	        return helper.validateInstance(this, value);
	    };
	    /**
	     * validate an instance against type
	     **/
	    TypeDeclarationImpl.prototype.validateInstanceWithDetailedStatuses = function (value) {
	        return helper.validateInstanceWithDetailedStatuses(this, value);
	    };
	    /**
	     * An example of this type instance represented as string or yaml map/sequence. This can be used, e.g., by documentation generators to generate sample values for an object of this type. Cannot be present if the examples property is present.
	     **/
	    TypeDeclarationImpl.prototype.example = function () {
	        return helper.getTypeExample(this);
	    };
	    /**
	     * An example of this type instance represented as string. This can be used, e.g., by documentation generators to generate sample values for an object of this type. Cannot be present if the example property is present.
	     **/
	    TypeDeclarationImpl.prototype.examples = function () {
	        return helper.getTypeExamples(this);
	    };
	    TypeDeclarationImpl.prototype.fixedFacets = function () {
	        return helper.typeFixedFacets(this);
	    };
	    /**
	     * A base type which the current type extends, or more generally a type expression.
	     **/
	    TypeDeclarationImpl.prototype["type"] = function () {
	        return helper.typeValue(this);
	    };
	    /**
	     * Alias for the equivalent "type" property, for compatibility with RAML 0.8. Deprecated - API definitions should use the "type" property, as the "schema" alias for that property name may be removed in a future RAML version. The "type" property allows for XML and JSON schemas.
	     **/
	    TypeDeclarationImpl.prototype.schema = function () {
	        return helper.schemaValue(this);
	    };
	    /**
	     * Inlined supertype definition.
	     **/
	    TypeDeclarationImpl.prototype.structuredType = function () {
	        return helper.typeStructuredValue(this);
	    };
	    TypeDeclarationImpl.prototype.parametrizedProperties = function () {
	        return helper.getTemplateParametrizedProperties(this);
	    };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    TypeDeclarationImpl.prototype.scalarsAnnotations = function () { return new TypeDeclarationScalarsAnnotationsImpl(this.highLevel()); };
	    return TypeDeclarationImpl;
	}(AnnotableImpl));
	exports.TypeDeclarationImpl = TypeDeclarationImpl;
	var ModelLocationImpl = (function () {
	    function ModelLocationImpl(attr) {
	        this.attr = attr;
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ModelLocationImpl.prototype.wrapperClassName = function () { return "ModelLocationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ModelLocationImpl.prototype.kind = function () { return "ModelLocation"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ModelLocationImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return ModelLocationImpl;
	}());
	exports.ModelLocationImpl = ModelLocationImpl;
	var LocationKindImpl = (function () {
	    function LocationKindImpl(attr) {
	        this.attr = attr;
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    LocationKindImpl.prototype.wrapperClassName = function () { return "LocationKindImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    LocationKindImpl.prototype.kind = function () { return "LocationKind"; };
	    /**
	     * @return RAML version of the node
	     **/
	    LocationKindImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return LocationKindImpl;
	}());
	exports.LocationKindImpl = LocationKindImpl;
	var UsesDeclarationImpl = (function (_super) {
	    __extends(UsesDeclarationImpl, _super);
	    function UsesDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createUsesDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * Name prefix (without dot) used to refer imported declarations
	     **/
	    UsesDeclarationImpl.prototype.key = function () {
	        return _super.prototype.attribute.call(this, 'key', this.toString);
	    };
	    /**
	     * @hidden
	     * Set key value
	     **/
	    UsesDeclarationImpl.prototype.setKey = function (param) {
	        this.highLevel().attrOrCreate("key").setValue("" + param);
	        return this;
	    };
	    /**
	     * Content of the schema
	     **/
	    UsesDeclarationImpl.prototype.value = function () {
	        return _super.prototype.attribute.call(this, 'value', this.toString);
	    };
	    /**
	     * @hidden
	     * Set value value
	     **/
	    UsesDeclarationImpl.prototype.setValue = function (param) {
	        this.highLevel().attrOrCreate("value").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    UsesDeclarationImpl.prototype.wrapperClassName = function () { return "UsesDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    UsesDeclarationImpl.prototype.kind = function () { return "UsesDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    UsesDeclarationImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Returns the root node of the AST, uses statement refers.
	     **/
	    UsesDeclarationImpl.prototype.ast = function () {
	        return helper.referencedNode(this);
	    };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    UsesDeclarationImpl.prototype.scalarsAnnotations = function () { return new UsesDeclarationScalarsAnnotationsImpl(this.highLevel()); };
	    return UsesDeclarationImpl;
	}(AnnotableImpl));
	exports.UsesDeclarationImpl = UsesDeclarationImpl;
	/**
	 * Annotable scalar properties annotations accessor
	 **/
	var AnnotableScalarsAnnotationsImpl = (function () {
	    function AnnotableScalarsAnnotationsImpl(node) {
	        this.node = node;
	    }
	    /**
	     * Annotable.annotations annotations
	     **/
	    AnnotableScalarsAnnotationsImpl.prototype.annotations = function () {
	        var attrs = this.node.attributes("annotations");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    return AnnotableScalarsAnnotationsImpl;
	}());
	exports.AnnotableScalarsAnnotationsImpl = AnnotableScalarsAnnotationsImpl;
	/**
	 * UsesDeclaration scalar properties annotations accessor
	 **/
	var UsesDeclarationScalarsAnnotationsImpl = (function (_super) {
	    __extends(UsesDeclarationScalarsAnnotationsImpl, _super);
	    function UsesDeclarationScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * UsesDeclaration.value annotations
	     **/
	    UsesDeclarationScalarsAnnotationsImpl.prototype.value = function () {
	        var attr = this.node.attr("value");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    return UsesDeclarationScalarsAnnotationsImpl;
	}(AnnotableScalarsAnnotationsImpl));
	exports.UsesDeclarationScalarsAnnotationsImpl = UsesDeclarationScalarsAnnotationsImpl;
	var XMLFacetInfoImpl = (function (_super) {
	    __extends(XMLFacetInfoImpl, _super);
	    function XMLFacetInfoImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createXMLFacetInfo(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * If attribute is set to true, a type instance should be serialized as an XML attribute. It can only be true for scalar types.
	     **/
	    XMLFacetInfoImpl.prototype.attribute = function () {
	        return _super.prototype.attribute.call(this, 'attribute', this.toBoolean);
	    };
	    /**
	     * @hidden
	     * Set attribute value
	     **/
	    XMLFacetInfoImpl.prototype.setAttribute = function (param) {
	        this.highLevel().attrOrCreate("attribute").setValue("" + param);
	        return this;
	    };
	    /**
	     * If wrapped is set to true, a type instance should be wrapped in its own XML element. It can not be true for scalar types and it can not be true at the same moment when attribute is true.
	     **/
	    XMLFacetInfoImpl.prototype.wrapped = function () {
	        return _super.prototype.attribute.call(this, 'wrapped', this.toBoolean);
	    };
	    /**
	     * @hidden
	     * Set wrapped value
	     **/
	    XMLFacetInfoImpl.prototype.setWrapped = function (param) {
	        this.highLevel().attrOrCreate("wrapped").setValue("" + param);
	        return this;
	    };
	    /**
	     * Allows to override the name of the XML element or XML attribute in it's XML representation.
	     **/
	    XMLFacetInfoImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     * @hidden
	     * Set name value
	     **/
	    XMLFacetInfoImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    /**
	     * Allows to configure the name of the XML namespace.
	     **/
	    XMLFacetInfoImpl.prototype.namespace = function () {
	        return _super.prototype.attribute.call(this, 'namespace', this.toString);
	    };
	    /**
	     * @hidden
	     * Set namespace value
	     **/
	    XMLFacetInfoImpl.prototype.setNamespace = function (param) {
	        this.highLevel().attrOrCreate("namespace").setValue("" + param);
	        return this;
	    };
	    /**
	     * Allows to configure the prefix which will be used during serialization to XML.
	     **/
	    XMLFacetInfoImpl.prototype.prefix = function () {
	        return _super.prototype.attribute.call(this, 'prefix', this.toString);
	    };
	    /**
	     * @hidden
	     * Set prefix value
	     **/
	    XMLFacetInfoImpl.prototype.setPrefix = function (param) {
	        this.highLevel().attrOrCreate("prefix").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    XMLFacetInfoImpl.prototype.wrapperClassName = function () { return "XMLFacetInfoImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    XMLFacetInfoImpl.prototype.kind = function () { return "XMLFacetInfo"; };
	    /**
	     * @return RAML version of the node
	     **/
	    XMLFacetInfoImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    XMLFacetInfoImpl.prototype.scalarsAnnotations = function () { return new XMLFacetInfoScalarsAnnotationsImpl(this.highLevel()); };
	    return XMLFacetInfoImpl;
	}(AnnotableImpl));
	exports.XMLFacetInfoImpl = XMLFacetInfoImpl;
	/**
	 * XMLFacetInfo scalar properties annotations accessor
	 **/
	var XMLFacetInfoScalarsAnnotationsImpl = (function (_super) {
	    __extends(XMLFacetInfoScalarsAnnotationsImpl, _super);
	    function XMLFacetInfoScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * XMLFacetInfo.attribute annotations
	     **/
	    XMLFacetInfoScalarsAnnotationsImpl.prototype.attribute = function () {
	        var attr = this.node.attr("attribute");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * XMLFacetInfo.wrapped annotations
	     **/
	    XMLFacetInfoScalarsAnnotationsImpl.prototype.wrapped = function () {
	        var attr = this.node.attr("wrapped");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * XMLFacetInfo.name annotations
	     **/
	    XMLFacetInfoScalarsAnnotationsImpl.prototype.name = function () {
	        var attr = this.node.attr("name");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * XMLFacetInfo.namespace annotations
	     **/
	    XMLFacetInfoScalarsAnnotationsImpl.prototype.namespace = function () {
	        var attr = this.node.attr("namespace");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * XMLFacetInfo.prefix annotations
	     **/
	    XMLFacetInfoScalarsAnnotationsImpl.prototype.prefix = function () {
	        var attr = this.node.attr("prefix");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    return XMLFacetInfoScalarsAnnotationsImpl;
	}(AnnotableScalarsAnnotationsImpl));
	exports.XMLFacetInfoScalarsAnnotationsImpl = XMLFacetInfoScalarsAnnotationsImpl;
	var ArrayTypeDeclarationImpl = (function (_super) {
	    __extends(ArrayTypeDeclarationImpl, _super);
	    function ArrayTypeDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createArrayTypeDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * Should items in array be unique
	     **/
	    ArrayTypeDeclarationImpl.prototype.uniqueItems = function () {
	        return _super.prototype.attribute.call(this, 'uniqueItems', this.toBoolean);
	    };
	    /**
	     * @hidden
	     * Set uniqueItems value
	     **/
	    ArrayTypeDeclarationImpl.prototype.setUniqueItems = function (param) {
	        this.highLevel().attrOrCreate("uniqueItems").setValue("" + param);
	        return this;
	    };
	    /**
	     * Array component type.
	     * @hidden
	     **/
	    ArrayTypeDeclarationImpl.prototype.items_original = function () {
	        return _super.prototype.element.call(this, 'items');
	    };
	    /**
	     * Minimum amount of items in array
	     **/
	    ArrayTypeDeclarationImpl.prototype.minItems = function () {
	        return _super.prototype.attribute.call(this, 'minItems', this.toNumber);
	    };
	    /**
	     * @hidden
	     * Set minItems value
	     **/
	    ArrayTypeDeclarationImpl.prototype.setMinItems = function (param) {
	        this.highLevel().attrOrCreate("minItems").setValue("" + param);
	        return this;
	    };
	    /**
	     * Maximum amount of items in array
	     **/
	    ArrayTypeDeclarationImpl.prototype.maxItems = function () {
	        return _super.prototype.attribute.call(this, 'maxItems', this.toNumber);
	    };
	    /**
	     * @hidden
	     * Set maxItems value
	     **/
	    ArrayTypeDeclarationImpl.prototype.setMaxItems = function (param) {
	        this.highLevel().attrOrCreate("maxItems").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ArrayTypeDeclarationImpl.prototype.wrapperClassName = function () { return "ArrayTypeDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ArrayTypeDeclarationImpl.prototype.kind = function () { return "ArrayTypeDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ArrayTypeDeclarationImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Array component type.
	     **/
	    ArrayTypeDeclarationImpl.prototype.items = function () {
	        return helper.getItems(this);
	    };
	    /**
	     * Returns anonymous type defined by "items" keyword, or a component type if declaration can be found.
	     * Does not resolve type expressions. Only returns component type declaration if it is actually defined
	     * somewhere in AST.
	     **/
	    ArrayTypeDeclarationImpl.prototype.findComponentTypeDeclaration = function () {
	        return helper.findComponentTypeDeclaration(this);
	    };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    ArrayTypeDeclarationImpl.prototype.scalarsAnnotations = function () { return new ArrayTypeDeclarationScalarsAnnotationsImpl(this.highLevel()); };
	    return ArrayTypeDeclarationImpl;
	}(TypeDeclarationImpl));
	exports.ArrayTypeDeclarationImpl = ArrayTypeDeclarationImpl;
	/**
	 * TypeDeclaration scalar properties annotations accessor
	 **/
	var TypeDeclarationScalarsAnnotationsImpl = (function (_super) {
	    __extends(TypeDeclarationScalarsAnnotationsImpl, _super);
	    function TypeDeclarationScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * TypeDeclaration.displayName annotations
	     **/
	    TypeDeclarationScalarsAnnotationsImpl.prototype.displayName = function () {
	        var attr = this.node.attr("displayName");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * TypeDeclaration.schema annotations
	     **/
	    TypeDeclarationScalarsAnnotationsImpl.prototype.schema = function () {
	        var attrs = this.node.attributes("schema");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    /**
	     * TypeDeclaration.type annotations
	     **/
	    TypeDeclarationScalarsAnnotationsImpl.prototype["type"] = function () {
	        var attrs = this.node.attributes("type");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    /**
	     * TypeDeclaration.location annotations
	     **/
	    TypeDeclarationScalarsAnnotationsImpl.prototype.location = function () {
	        var attr = this.node.attr("location");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * TypeDeclaration.locationKind annotations
	     **/
	    TypeDeclarationScalarsAnnotationsImpl.prototype.locationKind = function () {
	        var attr = this.node.attr("locationKind");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * TypeDeclaration.default annotations
	     **/
	    TypeDeclarationScalarsAnnotationsImpl.prototype["default"] = function () {
	        var attr = this.node.attr("default");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * TypeDeclaration.required annotations
	     **/
	    TypeDeclarationScalarsAnnotationsImpl.prototype.required = function () {
	        var attr = this.node.attr("required");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * TypeDeclaration.description annotations
	     **/
	    TypeDeclarationScalarsAnnotationsImpl.prototype.description = function () {
	        var attr = this.node.attr("description");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * TypeDeclaration.allowedTargets annotations
	     **/
	    TypeDeclarationScalarsAnnotationsImpl.prototype.allowedTargets = function () {
	        var attrs = this.node.attributes("allowedTargets");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    /**
	     * TypeDeclaration.isAnnotation annotations
	     **/
	    TypeDeclarationScalarsAnnotationsImpl.prototype.isAnnotation = function () {
	        var attr = this.node.attr("isAnnotation");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * TypeDeclaration.annotations annotations
	     **/
	    TypeDeclarationScalarsAnnotationsImpl.prototype.annotations = function () {
	        var attrs = this.node.attributes("annotations");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    return TypeDeclarationScalarsAnnotationsImpl;
	}(AnnotableScalarsAnnotationsImpl));
	exports.TypeDeclarationScalarsAnnotationsImpl = TypeDeclarationScalarsAnnotationsImpl;
	/**
	 * ArrayTypeDeclaration scalar properties annotations accessor
	 **/
	var ArrayTypeDeclarationScalarsAnnotationsImpl = (function (_super) {
	    __extends(ArrayTypeDeclarationScalarsAnnotationsImpl, _super);
	    function ArrayTypeDeclarationScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * ArrayTypeDeclaration.uniqueItems annotations
	     **/
	    ArrayTypeDeclarationScalarsAnnotationsImpl.prototype.uniqueItems = function () {
	        var attr = this.node.attr("uniqueItems");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * ArrayTypeDeclaration.minItems annotations
	     **/
	    ArrayTypeDeclarationScalarsAnnotationsImpl.prototype.minItems = function () {
	        var attr = this.node.attr("minItems");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * ArrayTypeDeclaration.maxItems annotations
	     **/
	    ArrayTypeDeclarationScalarsAnnotationsImpl.prototype.maxItems = function () {
	        var attr = this.node.attr("maxItems");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    return ArrayTypeDeclarationScalarsAnnotationsImpl;
	}(TypeDeclarationScalarsAnnotationsImpl));
	exports.ArrayTypeDeclarationScalarsAnnotationsImpl = ArrayTypeDeclarationScalarsAnnotationsImpl;
	var UnionTypeDeclarationImpl = (function (_super) {
	    __extends(UnionTypeDeclarationImpl, _super);
	    function UnionTypeDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createUnionTypeDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    UnionTypeDeclarationImpl.prototype.wrapperClassName = function () { return "UnionTypeDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    UnionTypeDeclarationImpl.prototype.kind = function () { return "UnionTypeDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    UnionTypeDeclarationImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return UnionTypeDeclarationImpl;
	}(TypeDeclarationImpl));
	exports.UnionTypeDeclarationImpl = UnionTypeDeclarationImpl;
	var ObjectTypeDeclarationImpl = (function (_super) {
	    __extends(ObjectTypeDeclarationImpl, _super);
	    function ObjectTypeDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createObjectTypeDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * The properties that instances of this type may or must have.
	     **/
	    ObjectTypeDeclarationImpl.prototype.properties = function () {
	        return _super.prototype.elements.call(this, 'properties');
	    };
	    /**
	     * The minimum number of properties allowed for instances of this type.
	     **/
	    ObjectTypeDeclarationImpl.prototype.minProperties = function () {
	        return _super.prototype.attribute.call(this, 'minProperties', this.toNumber);
	    };
	    /**
	     * @hidden
	     * Set minProperties value
	     **/
	    ObjectTypeDeclarationImpl.prototype.setMinProperties = function (param) {
	        this.highLevel().attrOrCreate("minProperties").setValue("" + param);
	        return this;
	    };
	    /**
	     * The maximum number of properties allowed for instances of this type.
	     **/
	    ObjectTypeDeclarationImpl.prototype.maxProperties = function () {
	        return _super.prototype.attribute.call(this, 'maxProperties', this.toNumber);
	    };
	    /**
	     * @hidden
	     * Set maxProperties value
	     **/
	    ObjectTypeDeclarationImpl.prototype.setMaxProperties = function (param) {
	        this.highLevel().attrOrCreate("maxProperties").setValue("" + param);
	        return this;
	    };
	    /**
	     * A Boolean that indicates if an object instance has additional properties.
	     **/
	    ObjectTypeDeclarationImpl.prototype.additionalProperties = function () {
	        return _super.prototype.attribute.call(this, 'additionalProperties', this.toBoolean);
	    };
	    /**
	     * @hidden
	     * Set additionalProperties value
	     **/
	    ObjectTypeDeclarationImpl.prototype.setAdditionalProperties = function (param) {
	        this.highLevel().attrOrCreate("additionalProperties").setValue("" + param);
	        return this;
	    };
	    /**
	     * Type property name to be used as discriminator, or boolean
	     **/
	    ObjectTypeDeclarationImpl.prototype.discriminator = function () {
	        return _super.prototype.attribute.call(this, 'discriminator', this.toString);
	    };
	    /**
	     * @hidden
	     * Set discriminator value
	     **/
	    ObjectTypeDeclarationImpl.prototype.setDiscriminator = function (param) {
	        this.highLevel().attrOrCreate("discriminator").setValue("" + param);
	        return this;
	    };
	    /**
	     * The value of discriminator for the type.
	     **/
	    ObjectTypeDeclarationImpl.prototype.discriminatorValue = function () {
	        return _super.prototype.attribute.call(this, 'discriminatorValue', this.toString);
	    };
	    /**
	     * @hidden
	     * Set discriminatorValue value
	     **/
	    ObjectTypeDeclarationImpl.prototype.setDiscriminatorValue = function (param) {
	        this.highLevel().attrOrCreate("discriminatorValue").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ObjectTypeDeclarationImpl.prototype.wrapperClassName = function () { return "ObjectTypeDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ObjectTypeDeclarationImpl.prototype.kind = function () { return "ObjectTypeDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ObjectTypeDeclarationImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    ObjectTypeDeclarationImpl.prototype.scalarsAnnotations = function () { return new ObjectTypeDeclarationScalarsAnnotationsImpl(this.highLevel()); };
	    return ObjectTypeDeclarationImpl;
	}(TypeDeclarationImpl));
	exports.ObjectTypeDeclarationImpl = ObjectTypeDeclarationImpl;
	/**
	 * ObjectTypeDeclaration scalar properties annotations accessor
	 **/
	var ObjectTypeDeclarationScalarsAnnotationsImpl = (function (_super) {
	    __extends(ObjectTypeDeclarationScalarsAnnotationsImpl, _super);
	    function ObjectTypeDeclarationScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * ObjectTypeDeclaration.minProperties annotations
	     **/
	    ObjectTypeDeclarationScalarsAnnotationsImpl.prototype.minProperties = function () {
	        var attr = this.node.attr("minProperties");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * ObjectTypeDeclaration.maxProperties annotations
	     **/
	    ObjectTypeDeclarationScalarsAnnotationsImpl.prototype.maxProperties = function () {
	        var attr = this.node.attr("maxProperties");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * ObjectTypeDeclaration.additionalProperties annotations
	     **/
	    ObjectTypeDeclarationScalarsAnnotationsImpl.prototype.additionalProperties = function () {
	        var attr = this.node.attr("additionalProperties");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * ObjectTypeDeclaration.discriminator annotations
	     **/
	    ObjectTypeDeclarationScalarsAnnotationsImpl.prototype.discriminator = function () {
	        var attr = this.node.attr("discriminator");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * ObjectTypeDeclaration.discriminatorValue annotations
	     **/
	    ObjectTypeDeclarationScalarsAnnotationsImpl.prototype.discriminatorValue = function () {
	        var attr = this.node.attr("discriminatorValue");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    return ObjectTypeDeclarationScalarsAnnotationsImpl;
	}(TypeDeclarationScalarsAnnotationsImpl));
	exports.ObjectTypeDeclarationScalarsAnnotationsImpl = ObjectTypeDeclarationScalarsAnnotationsImpl;
	/**
	 * Value must be a string
	 **/
	var StringTypeDeclarationImpl = (function (_super) {
	    __extends(StringTypeDeclarationImpl, _super);
	    function StringTypeDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createStringTypeDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * Regular expression that this string should path
	     **/
	    StringTypeDeclarationImpl.prototype.pattern = function () {
	        return _super.prototype.attribute.call(this, 'pattern', this.toString);
	    };
	    /**
	     * @hidden
	     * Set pattern value
	     **/
	    StringTypeDeclarationImpl.prototype.setPattern = function (param) {
	        this.highLevel().attrOrCreate("pattern").setValue("" + param);
	        return this;
	    };
	    /**
	     * Minimum length of the string
	     **/
	    StringTypeDeclarationImpl.prototype.minLength = function () {
	        return _super.prototype.attribute.call(this, 'minLength', this.toNumber);
	    };
	    /**
	     * @hidden
	     * Set minLength value
	     **/
	    StringTypeDeclarationImpl.prototype.setMinLength = function (param) {
	        this.highLevel().attrOrCreate("minLength").setValue("" + param);
	        return this;
	    };
	    /**
	     * Maximum length of the string
	     **/
	    StringTypeDeclarationImpl.prototype.maxLength = function () {
	        return _super.prototype.attribute.call(this, 'maxLength', this.toNumber);
	    };
	    /**
	     * @hidden
	     * Set maxLength value
	     **/
	    StringTypeDeclarationImpl.prototype.setMaxLength = function (param) {
	        this.highLevel().attrOrCreate("maxLength").setValue("" + param);
	        return this;
	    };
	    /**
	     * (Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error.
	     **/
	    StringTypeDeclarationImpl.prototype.enum = function () {
	        return _super.prototype.attributes.call(this, 'enum', this.toString);
	    };
	    /**
	     * @hidden
	     * Set enum value
	     **/
	    StringTypeDeclarationImpl.prototype.setEnum = function (param) {
	        this.highLevel().attrOrCreate("enum").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    StringTypeDeclarationImpl.prototype.wrapperClassName = function () { return "StringTypeDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    StringTypeDeclarationImpl.prototype.kind = function () { return "StringTypeDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    StringTypeDeclarationImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    StringTypeDeclarationImpl.prototype.scalarsAnnotations = function () { return new StringTypeDeclarationScalarsAnnotationsImpl(this.highLevel()); };
	    return StringTypeDeclarationImpl;
	}(TypeDeclarationImpl));
	exports.StringTypeDeclarationImpl = StringTypeDeclarationImpl;
	/**
	 * StringTypeDeclaration scalar properties annotations accessor
	 **/
	var StringTypeDeclarationScalarsAnnotationsImpl = (function (_super) {
	    __extends(StringTypeDeclarationScalarsAnnotationsImpl, _super);
	    function StringTypeDeclarationScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * StringTypeDeclaration.pattern annotations
	     **/
	    StringTypeDeclarationScalarsAnnotationsImpl.prototype.pattern = function () {
	        var attr = this.node.attr("pattern");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * StringTypeDeclaration.minLength annotations
	     **/
	    StringTypeDeclarationScalarsAnnotationsImpl.prototype.minLength = function () {
	        var attr = this.node.attr("minLength");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * StringTypeDeclaration.maxLength annotations
	     **/
	    StringTypeDeclarationScalarsAnnotationsImpl.prototype.maxLength = function () {
	        var attr = this.node.attr("maxLength");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * StringTypeDeclaration.enum annotations
	     **/
	    StringTypeDeclarationScalarsAnnotationsImpl.prototype.enum = function () {
	        var attrs = this.node.attributes("enum");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    return StringTypeDeclarationScalarsAnnotationsImpl;
	}(TypeDeclarationScalarsAnnotationsImpl));
	exports.StringTypeDeclarationScalarsAnnotationsImpl = StringTypeDeclarationScalarsAnnotationsImpl;
	/**
	 * Value must be a boolean
	 **/
	var BooleanTypeDeclarationImpl = (function (_super) {
	    __extends(BooleanTypeDeclarationImpl, _super);
	    function BooleanTypeDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createBooleanTypeDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    BooleanTypeDeclarationImpl.prototype.wrapperClassName = function () { return "BooleanTypeDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    BooleanTypeDeclarationImpl.prototype.kind = function () { return "BooleanTypeDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    BooleanTypeDeclarationImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return BooleanTypeDeclarationImpl;
	}(TypeDeclarationImpl));
	exports.BooleanTypeDeclarationImpl = BooleanTypeDeclarationImpl;
	/**
	 * Value MUST be a number. Indicate floating point numbers as defined by YAML.
	 **/
	var NumberTypeDeclarationImpl = (function (_super) {
	    __extends(NumberTypeDeclarationImpl, _super);
	    function NumberTypeDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createNumberTypeDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * (Optional, applicable only for parameters of type number or integer) The minimum attribute specifies the parameter's minimum value.
	     **/
	    NumberTypeDeclarationImpl.prototype.minimum = function () {
	        return _super.prototype.attribute.call(this, 'minimum', this.toNumber);
	    };
	    /**
	     * @hidden
	     * Set minimum value
	     **/
	    NumberTypeDeclarationImpl.prototype.setMinimum = function (param) {
	        this.highLevel().attrOrCreate("minimum").setValue("" + param);
	        return this;
	    };
	    /**
	     * (Optional, applicable only for parameters of type number or integer) The maximum attribute specifies the parameter's maximum value.
	     **/
	    NumberTypeDeclarationImpl.prototype.maximum = function () {
	        return _super.prototype.attribute.call(this, 'maximum', this.toNumber);
	    };
	    /**
	     * @hidden
	     * Set maximum value
	     **/
	    NumberTypeDeclarationImpl.prototype.setMaximum = function (param) {
	        this.highLevel().attrOrCreate("maximum").setValue("" + param);
	        return this;
	    };
	    /**
	     * (Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error.
	     **/
	    NumberTypeDeclarationImpl.prototype.enum = function () {
	        return _super.prototype.attributes.call(this, 'enum', this.toString);
	    };
	    /**
	     * @hidden
	     * Set enum value
	     **/
	    NumberTypeDeclarationImpl.prototype.setEnum = function (param) {
	        this.highLevel().attrOrCreate("enum").setValue("" + param);
	        return this;
	    };
	    /**
	     * Value format
	     **/
	    NumberTypeDeclarationImpl.prototype.format = function () {
	        return _super.prototype.attribute.call(this, 'format', this.toString);
	    };
	    /**
	     * @hidden
	     * Set format value
	     **/
	    NumberTypeDeclarationImpl.prototype.setFormat = function (param) {
	        this.highLevel().attrOrCreate("format").setValue("" + param);
	        return this;
	    };
	    /**
	     * A numeric instance is valid against "multipleOf" if the result of the division of the instance by this keyword's value is an integer.
	     **/
	    NumberTypeDeclarationImpl.prototype.multipleOf = function () {
	        return _super.prototype.attribute.call(this, 'multipleOf', this.toNumber);
	    };
	    /**
	     * @hidden
	     * Set multipleOf value
	     **/
	    NumberTypeDeclarationImpl.prototype.setMultipleOf = function (param) {
	        this.highLevel().attrOrCreate("multipleOf").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    NumberTypeDeclarationImpl.prototype.wrapperClassName = function () { return "NumberTypeDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    NumberTypeDeclarationImpl.prototype.kind = function () { return "NumberTypeDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    NumberTypeDeclarationImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    NumberTypeDeclarationImpl.prototype.scalarsAnnotations = function () { return new NumberTypeDeclarationScalarsAnnotationsImpl(this.highLevel()); };
	    return NumberTypeDeclarationImpl;
	}(TypeDeclarationImpl));
	exports.NumberTypeDeclarationImpl = NumberTypeDeclarationImpl;
	/**
	 * Value MUST be a integer.
	 **/
	var IntegerTypeDeclarationImpl = (function (_super) {
	    __extends(IntegerTypeDeclarationImpl, _super);
	    function IntegerTypeDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createIntegerTypeDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * Value format
	     **/
	    IntegerTypeDeclarationImpl.prototype.format = function () {
	        return _super.prototype.attribute.call(this, 'format', this.toString);
	    };
	    /**
	     * @hidden
	     * Set format value
	     **/
	    IntegerTypeDeclarationImpl.prototype.setFormat = function (param) {
	        this.highLevel().attrOrCreate("format").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    IntegerTypeDeclarationImpl.prototype.wrapperClassName = function () { return "IntegerTypeDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    IntegerTypeDeclarationImpl.prototype.kind = function () { return "IntegerTypeDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    IntegerTypeDeclarationImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    IntegerTypeDeclarationImpl.prototype.scalarsAnnotations = function () { return new IntegerTypeDeclarationScalarsAnnotationsImpl(this.highLevel()); };
	    return IntegerTypeDeclarationImpl;
	}(NumberTypeDeclarationImpl));
	exports.IntegerTypeDeclarationImpl = IntegerTypeDeclarationImpl;
	/**
	 * NumberTypeDeclaration scalar properties annotations accessor
	 **/
	var NumberTypeDeclarationScalarsAnnotationsImpl = (function (_super) {
	    __extends(NumberTypeDeclarationScalarsAnnotationsImpl, _super);
	    function NumberTypeDeclarationScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * NumberTypeDeclaration.minimum annotations
	     **/
	    NumberTypeDeclarationScalarsAnnotationsImpl.prototype.minimum = function () {
	        var attr = this.node.attr("minimum");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * NumberTypeDeclaration.maximum annotations
	     **/
	    NumberTypeDeclarationScalarsAnnotationsImpl.prototype.maximum = function () {
	        var attr = this.node.attr("maximum");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * NumberTypeDeclaration.enum annotations
	     **/
	    NumberTypeDeclarationScalarsAnnotationsImpl.prototype.enum = function () {
	        var attrs = this.node.attributes("enum");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    /**
	     * NumberTypeDeclaration.format annotations
	     **/
	    NumberTypeDeclarationScalarsAnnotationsImpl.prototype.format = function () {
	        var attr = this.node.attr("format");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * NumberTypeDeclaration.multipleOf annotations
	     **/
	    NumberTypeDeclarationScalarsAnnotationsImpl.prototype.multipleOf = function () {
	        var attr = this.node.attr("multipleOf");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    return NumberTypeDeclarationScalarsAnnotationsImpl;
	}(TypeDeclarationScalarsAnnotationsImpl));
	exports.NumberTypeDeclarationScalarsAnnotationsImpl = NumberTypeDeclarationScalarsAnnotationsImpl;
	/**
	 * IntegerTypeDeclaration scalar properties annotations accessor
	 **/
	var IntegerTypeDeclarationScalarsAnnotationsImpl = (function (_super) {
	    __extends(IntegerTypeDeclarationScalarsAnnotationsImpl, _super);
	    function IntegerTypeDeclarationScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * IntegerTypeDeclaration.format annotations
	     **/
	    IntegerTypeDeclarationScalarsAnnotationsImpl.prototype.format = function () {
	        var attr = this.node.attr("format");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    return IntegerTypeDeclarationScalarsAnnotationsImpl;
	}(NumberTypeDeclarationScalarsAnnotationsImpl));
	exports.IntegerTypeDeclarationScalarsAnnotationsImpl = IntegerTypeDeclarationScalarsAnnotationsImpl;
	/**
	 * the "full-date" notation of RFC3339, namely yyyy-mm-dd (no implications about time or timezone-offset)
	 **/
	var DateOnlyTypeDeclarationImpl = (function (_super) {
	    __extends(DateOnlyTypeDeclarationImpl, _super);
	    function DateOnlyTypeDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createDateOnlyTypeDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    DateOnlyTypeDeclarationImpl.prototype.wrapperClassName = function () { return "DateOnlyTypeDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    DateOnlyTypeDeclarationImpl.prototype.kind = function () { return "DateOnlyTypeDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    DateOnlyTypeDeclarationImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return DateOnlyTypeDeclarationImpl;
	}(TypeDeclarationImpl));
	exports.DateOnlyTypeDeclarationImpl = DateOnlyTypeDeclarationImpl;
	/**
	 * the "partial-time" notation of RFC3339, namely hh:mm:ss[.ff...] (no implications about date or timezone-offset)
	 **/
	var TimeOnlyTypeDeclarationImpl = (function (_super) {
	    __extends(TimeOnlyTypeDeclarationImpl, _super);
	    function TimeOnlyTypeDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createTimeOnlyTypeDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    TimeOnlyTypeDeclarationImpl.prototype.wrapperClassName = function () { return "TimeOnlyTypeDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    TimeOnlyTypeDeclarationImpl.prototype.kind = function () { return "TimeOnlyTypeDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    TimeOnlyTypeDeclarationImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return TimeOnlyTypeDeclarationImpl;
	}(TypeDeclarationImpl));
	exports.TimeOnlyTypeDeclarationImpl = TimeOnlyTypeDeclarationImpl;
	/**
	 * combined date-only and time-only with a separator of "T", namely yyyy-mm-ddThh:mm:ss[.ff...] (no implications about timezone-offset)
	 **/
	var DateTimeOnlyTypeDeclarationImpl = (function (_super) {
	    __extends(DateTimeOnlyTypeDeclarationImpl, _super);
	    function DateTimeOnlyTypeDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createDateTimeOnlyTypeDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    DateTimeOnlyTypeDeclarationImpl.prototype.wrapperClassName = function () { return "DateTimeOnlyTypeDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    DateTimeOnlyTypeDeclarationImpl.prototype.kind = function () { return "DateTimeOnlyTypeDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    DateTimeOnlyTypeDeclarationImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return DateTimeOnlyTypeDeclarationImpl;
	}(TypeDeclarationImpl));
	exports.DateTimeOnlyTypeDeclarationImpl = DateTimeOnlyTypeDeclarationImpl;
	/**
	 * a timestamp, either in the "date-time" notation of RFC3339, if format is omitted or is set to rfc3339, or in the format defined in RFC2616, if format is set to rfc2616.
	 **/
	var DateTimeTypeDeclarationImpl = (function (_super) {
	    __extends(DateTimeTypeDeclarationImpl, _super);
	    function DateTimeTypeDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createDateTimeTypeDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * Format used for this date time rfc3339 or rfc2616
	     **/
	    DateTimeTypeDeclarationImpl.prototype.format = function () {
	        return _super.prototype.attribute.call(this, 'format', this.toString);
	    };
	    /**
	     * @hidden
	     * Set format value
	     **/
	    DateTimeTypeDeclarationImpl.prototype.setFormat = function (param) {
	        this.highLevel().attrOrCreate("format").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    DateTimeTypeDeclarationImpl.prototype.wrapperClassName = function () { return "DateTimeTypeDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    DateTimeTypeDeclarationImpl.prototype.kind = function () { return "DateTimeTypeDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    DateTimeTypeDeclarationImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    DateTimeTypeDeclarationImpl.prototype.scalarsAnnotations = function () { return new DateTimeTypeDeclarationScalarsAnnotationsImpl(this.highLevel()); };
	    return DateTimeTypeDeclarationImpl;
	}(TypeDeclarationImpl));
	exports.DateTimeTypeDeclarationImpl = DateTimeTypeDeclarationImpl;
	/**
	 * DateTimeTypeDeclaration scalar properties annotations accessor
	 **/
	var DateTimeTypeDeclarationScalarsAnnotationsImpl = (function (_super) {
	    __extends(DateTimeTypeDeclarationScalarsAnnotationsImpl, _super);
	    function DateTimeTypeDeclarationScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * DateTimeTypeDeclaration.format annotations
	     **/
	    DateTimeTypeDeclarationScalarsAnnotationsImpl.prototype.format = function () {
	        var attr = this.node.attr("format");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    return DateTimeTypeDeclarationScalarsAnnotationsImpl;
	}(TypeDeclarationScalarsAnnotationsImpl));
	exports.DateTimeTypeDeclarationScalarsAnnotationsImpl = DateTimeTypeDeclarationScalarsAnnotationsImpl;
	/**
	 * (Applicable only to Form properties) Value is a file. Client generators SHOULD use this type to handle file uploads correctly.
	 **/
	var FileTypeDeclarationImpl = (function (_super) {
	    __extends(FileTypeDeclarationImpl, _super);
	    function FileTypeDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createFileTypeDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * It should also include a new property: fileTypes, which should be a list of valid content-type strings for the file. The file type * /* should be a valid value.
	     **/
	    FileTypeDeclarationImpl.prototype.fileTypes = function () {
	        return _super.prototype.attributes.call(this, 'fileTypes', function (attr) { return new ContentTypeImpl(attr); });
	    };
	    /**
	     * The minLength attribute specifies the parameter value's minimum number of bytes.
	     **/
	    FileTypeDeclarationImpl.prototype.minLength = function () {
	        return _super.prototype.attribute.call(this, 'minLength', this.toNumber);
	    };
	    /**
	     * @hidden
	     * Set minLength value
	     **/
	    FileTypeDeclarationImpl.prototype.setMinLength = function (param) {
	        this.highLevel().attrOrCreate("minLength").setValue("" + param);
	        return this;
	    };
	    /**
	     * The maxLength attribute specifies the parameter value's maximum number of bytes.
	     **/
	    FileTypeDeclarationImpl.prototype.maxLength = function () {
	        return _super.prototype.attribute.call(this, 'maxLength', this.toNumber);
	    };
	    /**
	     * @hidden
	     * Set maxLength value
	     **/
	    FileTypeDeclarationImpl.prototype.setMaxLength = function (param) {
	        this.highLevel().attrOrCreate("maxLength").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    FileTypeDeclarationImpl.prototype.wrapperClassName = function () { return "FileTypeDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    FileTypeDeclarationImpl.prototype.kind = function () { return "FileTypeDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    FileTypeDeclarationImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    FileTypeDeclarationImpl.prototype.scalarsAnnotations = function () { return new FileTypeDeclarationScalarsAnnotationsImpl(this.highLevel()); };
	    return FileTypeDeclarationImpl;
	}(TypeDeclarationImpl));
	exports.FileTypeDeclarationImpl = FileTypeDeclarationImpl;
	/**
	 * FileTypeDeclaration scalar properties annotations accessor
	 **/
	var FileTypeDeclarationScalarsAnnotationsImpl = (function (_super) {
	    __extends(FileTypeDeclarationScalarsAnnotationsImpl, _super);
	    function FileTypeDeclarationScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * FileTypeDeclaration.fileTypes annotations
	     **/
	    FileTypeDeclarationScalarsAnnotationsImpl.prototype.fileTypes = function () {
	        var attrs = this.node.attributes("fileTypes");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    /**
	     * FileTypeDeclaration.minLength annotations
	     **/
	    FileTypeDeclarationScalarsAnnotationsImpl.prototype.minLength = function () {
	        var attr = this.node.attr("minLength");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * FileTypeDeclaration.maxLength annotations
	     **/
	    FileTypeDeclarationScalarsAnnotationsImpl.prototype.maxLength = function () {
	        var attr = this.node.attr("maxLength");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    return FileTypeDeclarationScalarsAnnotationsImpl;
	}(TypeDeclarationScalarsAnnotationsImpl));
	exports.FileTypeDeclarationScalarsAnnotationsImpl = FileTypeDeclarationScalarsAnnotationsImpl;
	var ResponseImpl = (function (_super) {
	    __extends(ResponseImpl, _super);
	    function ResponseImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createResponse(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * Responses MUST be a map of one or more HTTP status codes, where each status code itself is a map that describes that status code.
	     **/
	    ResponseImpl.prototype.code = function () {
	        return _super.prototype.attribute.call(this, 'code', function (attr) { return new StatusCodeStringImpl(attr); });
	    };
	    /**
	     * Detailed information about any response headers returned by this method
	     **/
	    ResponseImpl.prototype.headers = function () {
	        return _super.prototype.elements.call(this, 'headers');
	    };
	    /**
	     * The body of the response: a body declaration
	     **/
	    ResponseImpl.prototype.body = function () {
	        return _super.prototype.elements.call(this, 'body');
	    };
	    /**
	     * A longer, human-friendly description of the response
	     **/
	    ResponseImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
	     **/
	    ResponseImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ResponseImpl.prototype.wrapperClassName = function () { return "ResponseImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ResponseImpl.prototype.kind = function () { return "Response"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ResponseImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * true for codes < 400 and false otherwise
	     **/
	    ResponseImpl.prototype.isOkRange = function () {
	        return helper.isOkRange(this);
	    };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    ResponseImpl.prototype.scalarsAnnotations = function () { return new ResponseScalarsAnnotationsImpl(this.highLevel()); };
	    return ResponseImpl;
	}(AnnotableImpl));
	exports.ResponseImpl = ResponseImpl;
	/**
	 * Response scalar properties annotations accessor
	 **/
	var ResponseScalarsAnnotationsImpl = (function (_super) {
	    __extends(ResponseScalarsAnnotationsImpl, _super);
	    function ResponseScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Response.description annotations
	     **/
	    ResponseScalarsAnnotationsImpl.prototype.description = function () {
	        var attr = this.node.attr("description");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * Response.annotations annotations
	     **/
	    ResponseScalarsAnnotationsImpl.prototype.annotations = function () {
	        var attrs = this.node.attributes("annotations");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    return ResponseScalarsAnnotationsImpl;
	}(AnnotableScalarsAnnotationsImpl));
	exports.ResponseScalarsAnnotationsImpl = ResponseScalarsAnnotationsImpl;
	var SecuritySchemePartImpl = (function (_super) {
	    __extends(SecuritySchemePartImpl, _super);
	    function SecuritySchemePartImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchemePart(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * Annotations to be applied to this security scheme part. Annotations are any property whose key begins with "(" and ends with ")" and whose name (the part between the beginning and ending parentheses) is a declared annotation name.
	     **/
	    SecuritySchemePartImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    SecuritySchemePartImpl.prototype.wrapperClassName = function () { return "SecuritySchemePartImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    SecuritySchemePartImpl.prototype.kind = function () { return "SecuritySchemePart"; };
	    /**
	     * @return RAML version of the node
	     **/
	    SecuritySchemePartImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    SecuritySchemePartImpl.prototype.scalarsAnnotations = function () { return new SecuritySchemePartScalarsAnnotationsImpl(this.highLevel()); };
	    return SecuritySchemePartImpl;
	}(OperationImpl));
	exports.SecuritySchemePartImpl = SecuritySchemePartImpl;
	/**
	 * SecuritySchemePart scalar properties annotations accessor
	 **/
	var SecuritySchemePartScalarsAnnotationsImpl = (function (_super) {
	    __extends(SecuritySchemePartScalarsAnnotationsImpl, _super);
	    function SecuritySchemePartScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * SecuritySchemePart.annotations annotations
	     **/
	    SecuritySchemePartScalarsAnnotationsImpl.prototype.annotations = function () {
	        var attrs = this.node.attributes("annotations");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    return SecuritySchemePartScalarsAnnotationsImpl;
	}(AnnotableScalarsAnnotationsImpl));
	exports.SecuritySchemePartScalarsAnnotationsImpl = SecuritySchemePartScalarsAnnotationsImpl;
	var MethodBaseImpl = (function (_super) {
	    __extends(MethodBaseImpl, _super);
	    function MethodBaseImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createMethodBase(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * Some method verbs expect the resource to be sent as a request body. For example, to create a resource, the request must include the details of the resource to create. Resources CAN have alternate representations. For example, an API might support both JSON and XML representations. A method's body is defined in the body property as a hashmap, in which the key MUST be a valid media type.
	     **/
	    MethodBaseImpl.prototype.body = function () {
	        return _super.prototype.elements.call(this, 'body');
	    };
	    /**
	     * A method can override the protocols specified in the resource or at the API root, by employing this property.
	     **/
	    MethodBaseImpl.prototype.protocols = function () {
	        return _super.prototype.attributes.call(this, 'protocols', this.toString);
	    };
	    /**
	     * @hidden
	     * Set protocols value
	     **/
	    MethodBaseImpl.prototype.setProtocols = function (param) {
	        this.highLevel().attrOrCreate("protocols").setValue("" + param);
	        return this;
	    };
	    /**
	     * Instantiation of applyed traits
	     **/
	    MethodBaseImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /**
	     * securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource. To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.
	     **/
	    MethodBaseImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemeRefImpl(attr); });
	    };
	    MethodBaseImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    MethodBaseImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     * @hidden
	     * Set displayName value
	     **/
	    MethodBaseImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    MethodBaseImpl.prototype.wrapperClassName = function () { return "MethodBaseImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    MethodBaseImpl.prototype.kind = function () { return "MethodBase"; };
	    /**
	     * @return RAML version of the node
	     **/
	    MethodBaseImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    MethodBaseImpl.prototype.scalarsAnnotations = function () { return new MethodBaseScalarsAnnotationsImpl(this.highLevel()); };
	    return MethodBaseImpl;
	}(OperationImpl));
	exports.MethodBaseImpl = MethodBaseImpl;
	var SecuritySchemeRefImpl = (function (_super) {
	    __extends(SecuritySchemeRefImpl, _super);
	    function SecuritySchemeRefImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    SecuritySchemeRefImpl.prototype.wrapperClassName = function () { return "SecuritySchemeRefImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    SecuritySchemeRefImpl.prototype.kind = function () { return "SecuritySchemeRef"; };
	    /**
	     * @return RAML version of the node
	     **/
	    SecuritySchemeRefImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    SecuritySchemeRefImpl.prototype.securitySchemeName = function () {
	        return helper.securitySchemeName(this);
	    };
	    SecuritySchemeRefImpl.prototype.securityScheme = function () {
	        return helper.securityScheme(this);
	    };
	    return SecuritySchemeRefImpl;
	}(ReferenceImpl));
	exports.SecuritySchemeRefImpl = SecuritySchemeRefImpl;
	/**
	 * Declares globally referable security scheme definition
	 **/
	var AbstractSecuritySchemeImpl = (function (_super) {
	    __extends(AbstractSecuritySchemeImpl, _super);
	    function AbstractSecuritySchemeImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createAbstractSecurityScheme(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * Name of the security scheme
	     **/
	    AbstractSecuritySchemeImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     * @hidden
	     * Set name value
	     **/
	    AbstractSecuritySchemeImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    /**
	     * The securitySchemes property MUST be used to specify an API's security mechanisms, including the required settings and the authentication methods that the API supports. one authentication method is allowed if the API supports them.
	     **/
	    AbstractSecuritySchemeImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', this.toString);
	    };
	    /**
	     * @hidden
	     * Set type value
	     **/
	    AbstractSecuritySchemeImpl.prototype.setType = function (param) {
	        this.highLevel().attrOrCreate("type").setValue("" + param);
	        return this;
	    };
	    /**
	     * The description MAY be used to describe a securityScheme.
	     **/
	    AbstractSecuritySchemeImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     * A description of the request components related to Security that are determined by the scheme: the headers, query parameters or responses. As a best practice, even for standard security schemes, API designers SHOULD describe these properties of security schemes. Including the security scheme description completes an API documentation.
	     **/
	    AbstractSecuritySchemeImpl.prototype.describedBy = function () {
	        return _super.prototype.element.call(this, 'describedBy');
	    };
	    /**
	     * The displayName attribute specifies the security scheme display name. It is a friendly name used only for  display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself).
	     **/
	    AbstractSecuritySchemeImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     * @hidden
	     * Set displayName value
	     **/
	    AbstractSecuritySchemeImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /**
	     * The settings attribute MAY be used to provide security scheme-specific information. The required attributes vary depending on the type of security scheme is being declared. It describes the minimum set of properties which any processing application MUST provide and validate if it chooses to implement the security scheme. Processing applications MAY choose to recognize other properties for things such as token lifetime, preferred cryptographic algorithms, and more.
	     **/
	    AbstractSecuritySchemeImpl.prototype.settings = function () {
	        return _super.prototype.element.call(this, 'settings');
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    AbstractSecuritySchemeImpl.prototype.wrapperClassName = function () { return "AbstractSecuritySchemeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    AbstractSecuritySchemeImpl.prototype.kind = function () { return "AbstractSecurityScheme"; };
	    /**
	     * @return RAML version of the node
	     **/
	    AbstractSecuritySchemeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    AbstractSecuritySchemeImpl.prototype.scalarsAnnotations = function () { return new AbstractSecuritySchemeScalarsAnnotationsImpl(this.highLevel()); };
	    return AbstractSecuritySchemeImpl;
	}(AnnotableImpl));
	exports.AbstractSecuritySchemeImpl = AbstractSecuritySchemeImpl;
	var SecuritySchemeSettingsImpl = (function (_super) {
	    __extends(SecuritySchemeSettingsImpl, _super);
	    function SecuritySchemeSettingsImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchemeSettings(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    SecuritySchemeSettingsImpl.prototype.wrapperClassName = function () { return "SecuritySchemeSettingsImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    SecuritySchemeSettingsImpl.prototype.kind = function () { return "SecuritySchemeSettings"; };
	    /**
	     * @return RAML version of the node
	     **/
	    SecuritySchemeSettingsImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return SecuritySchemeSettingsImpl;
	}(AnnotableImpl));
	exports.SecuritySchemeSettingsImpl = SecuritySchemeSettingsImpl;
	var OAuth1SecuritySchemeSettingsImpl = (function (_super) {
	    __extends(OAuth1SecuritySchemeSettingsImpl, _super);
	    function OAuth1SecuritySchemeSettingsImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth1SecuritySchemeSettings(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * The URI of the Temporary Credential Request endpoint as defined in RFC5849 Section 2.1
	     **/
	    OAuth1SecuritySchemeSettingsImpl.prototype.requestTokenUri = function () {
	        return _super.prototype.attribute.call(this, 'requestTokenUri', function (attr) { return new FixedUriStringImpl(attr); });
	    };
	    /**
	     * The URI of the Resource Owner Authorization endpoint as defined in RFC5849 Section 2.2
	     **/
	    OAuth1SecuritySchemeSettingsImpl.prototype.authorizationUri = function () {
	        return _super.prototype.attribute.call(this, 'authorizationUri', function (attr) { return new FixedUriStringImpl(attr); });
	    };
	    /**
	     * The URI of the Token Request endpoint as defined in RFC5849 Section 2.3
	     **/
	    OAuth1SecuritySchemeSettingsImpl.prototype.tokenCredentialsUri = function () {
	        return _super.prototype.attribute.call(this, 'tokenCredentialsUri', function (attr) { return new FixedUriStringImpl(attr); });
	    };
	    /**
	     * List of the signature methods used by the server. Available methods: HMAC-SHA1, RSA-SHA1, PLAINTEXT
	     **/
	    OAuth1SecuritySchemeSettingsImpl.prototype.signatures = function () {
	        return _super.prototype.attributes.call(this, 'signatures', this.toString);
	    };
	    /**
	     * @hidden
	     * Set signatures value
	     **/
	    OAuth1SecuritySchemeSettingsImpl.prototype.setSignatures = function (param) {
	        this.highLevel().attrOrCreate("signatures").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    OAuth1SecuritySchemeSettingsImpl.prototype.wrapperClassName = function () { return "OAuth1SecuritySchemeSettingsImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    OAuth1SecuritySchemeSettingsImpl.prototype.kind = function () { return "OAuth1SecuritySchemeSettings"; };
	    /**
	     * @return RAML version of the node
	     **/
	    OAuth1SecuritySchemeSettingsImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    OAuth1SecuritySchemeSettingsImpl.prototype.scalarsAnnotations = function () { return new OAuth1SecuritySchemeSettingsScalarsAnnotationsImpl(this.highLevel()); };
	    return OAuth1SecuritySchemeSettingsImpl;
	}(SecuritySchemeSettingsImpl));
	exports.OAuth1SecuritySchemeSettingsImpl = OAuth1SecuritySchemeSettingsImpl;
	/**
	 * OAuth1SecuritySchemeSettings scalar properties annotations accessor
	 **/
	var OAuth1SecuritySchemeSettingsScalarsAnnotationsImpl = (function (_super) {
	    __extends(OAuth1SecuritySchemeSettingsScalarsAnnotationsImpl, _super);
	    function OAuth1SecuritySchemeSettingsScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * OAuth1SecuritySchemeSettings.requestTokenUri annotations
	     **/
	    OAuth1SecuritySchemeSettingsScalarsAnnotationsImpl.prototype.requestTokenUri = function () {
	        var attr = this.node.attr("requestTokenUri");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * OAuth1SecuritySchemeSettings.authorizationUri annotations
	     **/
	    OAuth1SecuritySchemeSettingsScalarsAnnotationsImpl.prototype.authorizationUri = function () {
	        var attr = this.node.attr("authorizationUri");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * OAuth1SecuritySchemeSettings.tokenCredentialsUri annotations
	     **/
	    OAuth1SecuritySchemeSettingsScalarsAnnotationsImpl.prototype.tokenCredentialsUri = function () {
	        var attr = this.node.attr("tokenCredentialsUri");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * OAuth1SecuritySchemeSettings.signatures annotations
	     **/
	    OAuth1SecuritySchemeSettingsScalarsAnnotationsImpl.prototype.signatures = function () {
	        var attrs = this.node.attributes("signatures");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    return OAuth1SecuritySchemeSettingsScalarsAnnotationsImpl;
	}(AnnotableScalarsAnnotationsImpl));
	exports.OAuth1SecuritySchemeSettingsScalarsAnnotationsImpl = OAuth1SecuritySchemeSettingsScalarsAnnotationsImpl;
	var OAuth2SecuritySchemeSettingsImpl = (function (_super) {
	    __extends(OAuth2SecuritySchemeSettingsImpl, _super);
	    function OAuth2SecuritySchemeSettingsImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth2SecuritySchemeSettings(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * The URI of the Token Endpoint as defined in RFC6749 Section 3.2. Not required forby implicit grant type.
	     **/
	    OAuth2SecuritySchemeSettingsImpl.prototype.accessTokenUri = function () {
	        return _super.prototype.attribute.call(this, 'accessTokenUri', function (attr) { return new FixedUriStringImpl(attr); });
	    };
	    /**
	     * The URI of the Authorization Endpoint as defined in RFC6749 Section 3.1. Required forby authorization_code and implicit grant types.
	     **/
	    OAuth2SecuritySchemeSettingsImpl.prototype.authorizationUri = function () {
	        return _super.prototype.attribute.call(this, 'authorizationUri', function (attr) { return new FixedUriStringImpl(attr); });
	    };
	    /**
	     * A list of the Authorization grants supported by the API as defined in RFC6749 Sections 4.1, 4.2, 4.3 and 4.4, can be any of: authorization_code, password, client_credentials, implicit, or any absolute url.
	     **/
	    OAuth2SecuritySchemeSettingsImpl.prototype.authorizationGrants = function () {
	        return _super.prototype.attributes.call(this, 'authorizationGrants', this.toString);
	    };
	    /**
	     * @hidden
	     * Set authorizationGrants value
	     **/
	    OAuth2SecuritySchemeSettingsImpl.prototype.setAuthorizationGrants = function (param) {
	        this.highLevel().attrOrCreate("authorizationGrants").setValue("" + param);
	        return this;
	    };
	    /**
	     * A list of scopes supported by the security scheme as defined in RFC6749 Section 3.3
	     **/
	    OAuth2SecuritySchemeSettingsImpl.prototype.scopes = function () {
	        return _super.prototype.attributes.call(this, 'scopes', this.toString);
	    };
	    /**
	     * @hidden
	     * Set scopes value
	     **/
	    OAuth2SecuritySchemeSettingsImpl.prototype.setScopes = function (param) {
	        this.highLevel().attrOrCreate("scopes").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    OAuth2SecuritySchemeSettingsImpl.prototype.wrapperClassName = function () { return "OAuth2SecuritySchemeSettingsImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    OAuth2SecuritySchemeSettingsImpl.prototype.kind = function () { return "OAuth2SecuritySchemeSettings"; };
	    /**
	     * @return RAML version of the node
	     **/
	    OAuth2SecuritySchemeSettingsImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    OAuth2SecuritySchemeSettingsImpl.prototype.scalarsAnnotations = function () { return new OAuth2SecuritySchemeSettingsScalarsAnnotationsImpl(this.highLevel()); };
	    return OAuth2SecuritySchemeSettingsImpl;
	}(SecuritySchemeSettingsImpl));
	exports.OAuth2SecuritySchemeSettingsImpl = OAuth2SecuritySchemeSettingsImpl;
	/**
	 * OAuth2SecuritySchemeSettings scalar properties annotations accessor
	 **/
	var OAuth2SecuritySchemeSettingsScalarsAnnotationsImpl = (function (_super) {
	    __extends(OAuth2SecuritySchemeSettingsScalarsAnnotationsImpl, _super);
	    function OAuth2SecuritySchemeSettingsScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * OAuth2SecuritySchemeSettings.accessTokenUri annotations
	     **/
	    OAuth2SecuritySchemeSettingsScalarsAnnotationsImpl.prototype.accessTokenUri = function () {
	        var attr = this.node.attr("accessTokenUri");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * OAuth2SecuritySchemeSettings.authorizationUri annotations
	     **/
	    OAuth2SecuritySchemeSettingsScalarsAnnotationsImpl.prototype.authorizationUri = function () {
	        var attr = this.node.attr("authorizationUri");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * OAuth2SecuritySchemeSettings.authorizationGrants annotations
	     **/
	    OAuth2SecuritySchemeSettingsScalarsAnnotationsImpl.prototype.authorizationGrants = function () {
	        var attrs = this.node.attributes("authorizationGrants");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    /**
	     * OAuth2SecuritySchemeSettings.scopes annotations
	     **/
	    OAuth2SecuritySchemeSettingsScalarsAnnotationsImpl.prototype.scopes = function () {
	        var attrs = this.node.attributes("scopes");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    return OAuth2SecuritySchemeSettingsScalarsAnnotationsImpl;
	}(AnnotableScalarsAnnotationsImpl));
	exports.OAuth2SecuritySchemeSettingsScalarsAnnotationsImpl = OAuth2SecuritySchemeSettingsScalarsAnnotationsImpl;
	/**
	 * Declares globally referable security scheme definition
	 **/
	var OAuth2SecuritySchemeImpl = (function (_super) {
	    __extends(OAuth2SecuritySchemeImpl, _super);
	    function OAuth2SecuritySchemeImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth2SecurityScheme(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    OAuth2SecuritySchemeImpl.prototype.settings = function () {
	        return _super.prototype.element.call(this, 'settings');
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    OAuth2SecuritySchemeImpl.prototype.wrapperClassName = function () { return "OAuth2SecuritySchemeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    OAuth2SecuritySchemeImpl.prototype.kind = function () { return "OAuth2SecurityScheme"; };
	    /**
	     * @return RAML version of the node
	     **/
	    OAuth2SecuritySchemeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return OAuth2SecuritySchemeImpl;
	}(AbstractSecuritySchemeImpl));
	exports.OAuth2SecuritySchemeImpl = OAuth2SecuritySchemeImpl;
	/**
	 * Declares globally referable security scheme definition
	 **/
	var OAuth1SecuritySchemeImpl = (function (_super) {
	    __extends(OAuth1SecuritySchemeImpl, _super);
	    function OAuth1SecuritySchemeImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth1SecurityScheme(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    OAuth1SecuritySchemeImpl.prototype.settings = function () {
	        return _super.prototype.element.call(this, 'settings');
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    OAuth1SecuritySchemeImpl.prototype.wrapperClassName = function () { return "OAuth1SecuritySchemeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    OAuth1SecuritySchemeImpl.prototype.kind = function () { return "OAuth1SecurityScheme"; };
	    /**
	     * @return RAML version of the node
	     **/
	    OAuth1SecuritySchemeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return OAuth1SecuritySchemeImpl;
	}(AbstractSecuritySchemeImpl));
	exports.OAuth1SecuritySchemeImpl = OAuth1SecuritySchemeImpl;
	/**
	 * Declares globally referable security scheme definition
	 **/
	var PassThroughSecuritySchemeImpl = (function (_super) {
	    __extends(PassThroughSecuritySchemeImpl, _super);
	    function PassThroughSecuritySchemeImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createPassThroughSecurityScheme(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    PassThroughSecuritySchemeImpl.prototype.settings = function () {
	        return _super.prototype.element.call(this, 'settings');
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    PassThroughSecuritySchemeImpl.prototype.wrapperClassName = function () { return "PassThroughSecuritySchemeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    PassThroughSecuritySchemeImpl.prototype.kind = function () { return "PassThroughSecurityScheme"; };
	    /**
	     * @return RAML version of the node
	     **/
	    PassThroughSecuritySchemeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return PassThroughSecuritySchemeImpl;
	}(AbstractSecuritySchemeImpl));
	exports.PassThroughSecuritySchemeImpl = PassThroughSecuritySchemeImpl;
	/**
	 * Declares globally referable security scheme definition
	 **/
	var BasicSecuritySchemeImpl = (function (_super) {
	    __extends(BasicSecuritySchemeImpl, _super);
	    function BasicSecuritySchemeImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createBasicSecurityScheme(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    BasicSecuritySchemeImpl.prototype.wrapperClassName = function () { return "BasicSecuritySchemeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    BasicSecuritySchemeImpl.prototype.kind = function () { return "BasicSecurityScheme"; };
	    /**
	     * @return RAML version of the node
	     **/
	    BasicSecuritySchemeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return BasicSecuritySchemeImpl;
	}(AbstractSecuritySchemeImpl));
	exports.BasicSecuritySchemeImpl = BasicSecuritySchemeImpl;
	/**
	 * Declares globally referable security scheme definition
	 **/
	var DigestSecuritySchemeImpl = (function (_super) {
	    __extends(DigestSecuritySchemeImpl, _super);
	    function DigestSecuritySchemeImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createDigestSecurityScheme(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    DigestSecuritySchemeImpl.prototype.wrapperClassName = function () { return "DigestSecuritySchemeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    DigestSecuritySchemeImpl.prototype.kind = function () { return "DigestSecurityScheme"; };
	    /**
	     * @return RAML version of the node
	     **/
	    DigestSecuritySchemeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return DigestSecuritySchemeImpl;
	}(AbstractSecuritySchemeImpl));
	exports.DigestSecuritySchemeImpl = DigestSecuritySchemeImpl;
	/**
	 * Declares globally referable security scheme definition
	 **/
	var CustomSecuritySchemeImpl = (function (_super) {
	    __extends(CustomSecuritySchemeImpl, _super);
	    function CustomSecuritySchemeImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createCustomSecurityScheme(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    CustomSecuritySchemeImpl.prototype.wrapperClassName = function () { return "CustomSecuritySchemeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    CustomSecuritySchemeImpl.prototype.kind = function () { return "CustomSecurityScheme"; };
	    /**
	     * @return RAML version of the node
	     **/
	    CustomSecuritySchemeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return CustomSecuritySchemeImpl;
	}(AbstractSecuritySchemeImpl));
	exports.CustomSecuritySchemeImpl = CustomSecuritySchemeImpl;
	/**
	 * AbstractSecurityScheme scalar properties annotations accessor
	 **/
	var AbstractSecuritySchemeScalarsAnnotationsImpl = (function (_super) {
	    __extends(AbstractSecuritySchemeScalarsAnnotationsImpl, _super);
	    function AbstractSecuritySchemeScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * AbstractSecurityScheme.type annotations
	     **/
	    AbstractSecuritySchemeScalarsAnnotationsImpl.prototype["type"] = function () {
	        var attr = this.node.attr("type");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * AbstractSecurityScheme.description annotations
	     **/
	    AbstractSecuritySchemeScalarsAnnotationsImpl.prototype.description = function () {
	        var attr = this.node.attr("description");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * AbstractSecurityScheme.displayName annotations
	     **/
	    AbstractSecuritySchemeScalarsAnnotationsImpl.prototype.displayName = function () {
	        var attr = this.node.attr("displayName");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    return AbstractSecuritySchemeScalarsAnnotationsImpl;
	}(AnnotableScalarsAnnotationsImpl));
	exports.AbstractSecuritySchemeScalarsAnnotationsImpl = AbstractSecuritySchemeScalarsAnnotationsImpl;
	var MethodImpl = (function (_super) {
	    __extends(MethodImpl, _super);
	    function MethodImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createMethod(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * Method that can be called
	     **/
	    MethodImpl.prototype.method = function () {
	        return _super.prototype.attribute.call(this, 'method', this.toString);
	    };
	    /**
	     * @hidden
	     * Set method value
	     **/
	    MethodImpl.prototype.setMethod = function (param) {
	        this.highLevel().attrOrCreate("method").setValue("" + param);
	        return this;
	    };
	    /**
	     * The displayName attribute specifies the method display name. It is a friendly name used only for  display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself).
	     **/
	    MethodImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     * @hidden
	     * Set displayName value
	     **/
	    MethodImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    MethodImpl.prototype.wrapperClassName = function () { return "MethodImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    MethodImpl.prototype.kind = function () { return "Method"; };
	    /**
	     * @return RAML version of the node
	     **/
	    MethodImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * For methods of Resources returns parent resource. For methods of ResourceTypes returns null.
	     **/
	    MethodImpl.prototype.parentResource = function () {
	        return helper.parentResource(this);
	    };
	    /**
	     * Api owning the resource as a sibling
	     **/
	    MethodImpl.prototype.ownerApi = function () {
	        return helper.ownerApi(this);
	    };
	    /**
	     * For methods of Resources: `{parent Resource relative path} {methodName}`.
	     * For methods of ResourceTypes: `{parent ResourceType name} {methodName}`.
	     * For other methods throws Exception.
	     **/
	    MethodImpl.prototype.methodId = function () {
	        return helper.methodId(this);
	    };
	    /**
	     * Returns security schemes, resource or method is secured with. If no security schemes are set at resource or method level,
	     * returns schemes defined with `securedBy` at API level.
	     * @deprecated
	     **/
	    MethodImpl.prototype.allSecuredBy = function () {
	        return helper.allSecuredBy(this);
	    };
	    MethodImpl.prototype.parametrizedProperties = function () {
	        return helper.getTemplateParametrizedProperties(this);
	    };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    MethodImpl.prototype.scalarsAnnotations = function () { return new MethodScalarsAnnotationsImpl(this.highLevel()); };
	    return MethodImpl;
	}(MethodBaseImpl));
	exports.MethodImpl = MethodImpl;
	/**
	 * MethodBase scalar properties annotations accessor
	 **/
	var MethodBaseScalarsAnnotationsImpl = (function (_super) {
	    __extends(MethodBaseScalarsAnnotationsImpl, _super);
	    function MethodBaseScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * MethodBase.protocols annotations
	     **/
	    MethodBaseScalarsAnnotationsImpl.prototype.protocols = function () {
	        var attrs = this.node.attributes("protocols");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    /**
	     * MethodBase.is annotations
	     **/
	    MethodBaseScalarsAnnotationsImpl.prototype.is = function () {
	        var attrs = this.node.attributes("is");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    /**
	     * MethodBase.securedBy annotations
	     **/
	    MethodBaseScalarsAnnotationsImpl.prototype.securedBy = function () {
	        var attrs = this.node.attributes("securedBy");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    /**
	     * MethodBase.description annotations
	     **/
	    MethodBaseScalarsAnnotationsImpl.prototype.description = function () {
	        var attr = this.node.attr("description");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * MethodBase.displayName annotations
	     **/
	    MethodBaseScalarsAnnotationsImpl.prototype.displayName = function () {
	        var attr = this.node.attr("displayName");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    return MethodBaseScalarsAnnotationsImpl;
	}(AnnotableScalarsAnnotationsImpl));
	exports.MethodBaseScalarsAnnotationsImpl = MethodBaseScalarsAnnotationsImpl;
	/**
	 * Method scalar properties annotations accessor
	 **/
	var MethodScalarsAnnotationsImpl = (function (_super) {
	    __extends(MethodScalarsAnnotationsImpl, _super);
	    function MethodScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Method.displayName annotations
	     **/
	    MethodScalarsAnnotationsImpl.prototype.displayName = function () {
	        var attr = this.node.attr("displayName");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    return MethodScalarsAnnotationsImpl;
	}(MethodBaseScalarsAnnotationsImpl));
	exports.MethodScalarsAnnotationsImpl = MethodScalarsAnnotationsImpl;
	var TraitImpl = (function (_super) {
	    __extends(TraitImpl, _super);
	    function TraitImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createTrait(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * Name of the trait
	     **/
	    TraitImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     * @hidden
	     * Set name value
	     **/
	    TraitImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    /**
	     * Instructions on how and when the trait should be used.
	     **/
	    TraitImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /**
	     * @hidden
	     * Set usage value
	     **/
	    TraitImpl.prototype.setUsage = function (param) {
	        this.highLevel().attrOrCreate("usage").setValue("" + param);
	        return this;
	    };
	    /**
	     * The displayName attribute specifies the trait display name. It is a friendly name used only for  display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself).
	     **/
	    TraitImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     * @hidden
	     * Set displayName value
	     **/
	    TraitImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    TraitImpl.prototype.uses = function () {
	        return _super.prototype.elements.call(this, 'uses');
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    TraitImpl.prototype.wrapperClassName = function () { return "TraitImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    TraitImpl.prototype.kind = function () { return "Trait"; };
	    /**
	     * @return RAML version of the node
	     **/
	    TraitImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    TraitImpl.prototype.parametrizedProperties = function () {
	        return helper.getTemplateParametrizedProperties(this);
	    };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    TraitImpl.prototype.scalarsAnnotations = function () { return new TraitScalarsAnnotationsImpl(this.highLevel()); };
	    return TraitImpl;
	}(MethodBaseImpl));
	exports.TraitImpl = TraitImpl;
	/**
	 * Trait scalar properties annotations accessor
	 **/
	var TraitScalarsAnnotationsImpl = (function (_super) {
	    __extends(TraitScalarsAnnotationsImpl, _super);
	    function TraitScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Trait.usage annotations
	     **/
	    TraitScalarsAnnotationsImpl.prototype.usage = function () {
	        var attr = this.node.attr("usage");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * Trait.displayName annotations
	     **/
	    TraitScalarsAnnotationsImpl.prototype.displayName = function () {
	        var attr = this.node.attr("displayName");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    return TraitScalarsAnnotationsImpl;
	}(MethodBaseScalarsAnnotationsImpl));
	exports.TraitScalarsAnnotationsImpl = TraitScalarsAnnotationsImpl;
	var ResourceTypeRefImpl = (function (_super) {
	    __extends(ResourceTypeRefImpl, _super);
	    function ResourceTypeRefImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ResourceTypeRefImpl.prototype.wrapperClassName = function () { return "ResourceTypeRefImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ResourceTypeRefImpl.prototype.kind = function () { return "ResourceTypeRef"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ResourceTypeRefImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    ResourceTypeRefImpl.prototype.resourceType = function () {
	        return helper.referencedResourceType(this);
	    };
	    return ResourceTypeRefImpl;
	}(ReferenceImpl));
	exports.ResourceTypeRefImpl = ResourceTypeRefImpl;
	var ResourceBaseImpl = (function (_super) {
	    __extends(ResourceBaseImpl, _super);
	    function ResourceBaseImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createResourceBase(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * Methods that are part of this resource type definition
	     **/
	    ResourceBaseImpl.prototype.methods = function () {
	        return _super.prototype.elements.call(this, 'methods');
	    };
	    /**
	     * A list of the traits to apply to all methods declared (implicitly or explicitly) for this resource. Individual methods may override this declaration
	     **/
	    ResourceBaseImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /**
	     * The resource type which this resource inherits.
	     **/
	    ResourceBaseImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', function (attr) { return new ResourceTypeRefImpl(attr); });
	    };
	    ResourceBaseImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     * The security schemes that apply to all methods declared (implicitly or explicitly) for this resource.
	     **/
	    ResourceBaseImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemeRefImpl(attr); });
	    };
	    /**
	     * Detailed information about any URI parameters of this resource
	     * @hidden
	     **/
	    ResourceBaseImpl.prototype.uriParameters_original = function () {
	        return _super.prototype.elements.call(this, 'uriParameters');
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ResourceBaseImpl.prototype.wrapperClassName = function () { return "ResourceBaseImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ResourceBaseImpl.prototype.kind = function () { return "ResourceBase"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ResourceBaseImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Detailed information about any URI parameters of this resource
	     **/
	    ResourceBaseImpl.prototype.uriParameters = function () {
	        return helper.uriParametersPrimary(this);
	    };
	    /**
	     * Retrieve an ordered list of all uri parameters including those which are not described in the `uriParameters` node.
	     * Consider a fragment of RAML specification:
	     * ```yaml
	     * /resource/{objectId}/{propertyId}:
	     * uriParameters:
	     * objectId:
	     * ```
	     * Here `propertyId` uri parameter is not described in the `uriParameters` node,
	     * but it is among Resource.allUriParameters().
	     * @deprecated
	     **/
	    ResourceBaseImpl.prototype.allUriParameters = function () {
	        return helper.uriParameters(this);
	    };
	    /**
	     * Returns security schemes, resource or method is secured with. If no security schemes are set at resource or method level,
	     * returns schemes defined with `securedBy` at API level.
	     * @deprecated
	     **/
	    ResourceBaseImpl.prototype.allSecuredBy = function () {
	        return helper.allSecuredBy(this);
	    };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    ResourceBaseImpl.prototype.scalarsAnnotations = function () { return new ResourceBaseScalarsAnnotationsImpl(this.highLevel()); };
	    return ResourceBaseImpl;
	}(AnnotableImpl));
	exports.ResourceBaseImpl = ResourceBaseImpl;
	var ResourceImpl = (function (_super) {
	    __extends(ResourceImpl, _super);
	    function ResourceImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createResource(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * Relative URL of this resource from the parent resource
	     **/
	    ResourceImpl.prototype.relativeUri = function () {
	        return _super.prototype.attribute.call(this, 'relativeUri', function (attr) { return new RelativeUriStringImpl(attr); });
	    };
	    /**
	     * The displayName attribute specifies the resource display name. It is a friendly name used only for  display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself).
	     **/
	    ResourceImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     * @hidden
	     * Set displayName value
	     **/
	    ResourceImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /**
	     * A nested resource is identified as any property whose name begins with a slash ("/") and is therefore treated as a relative URI.
	     **/
	    ResourceImpl.prototype.resources = function () {
	        return _super.prototype.elements.call(this, 'resources');
	    };
	    /**
	     * A longer, human-friendly description of the resource.
	     **/
	    ResourceImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
	     **/
	    ResourceImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ResourceImpl.prototype.wrapperClassName = function () { return "ResourceImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ResourceImpl.prototype.kind = function () { return "Resource"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ResourceImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Path relative to API root
	     **/
	    ResourceImpl.prototype.completeRelativeUri = function () {
	        return helper.completeRelativeUri(this);
	    };
	    /**
	     * baseUri of owning Api concatenated with completeRelativeUri
	     **/
	    ResourceImpl.prototype.absoluteUri = function () {
	        return helper.absoluteUri(this);
	    };
	    /**
	     * Parent resource for non top level resources
	     **/
	    ResourceImpl.prototype.parentResource = function () {
	        return helper.parent(this);
	    };
	    /**
	     * Get child resource by its relative path
	     **/
	    ResourceImpl.prototype.childResource = function (relPath) {
	        return helper.childResource(this, relPath);
	    };
	    /**
	     * Get child method by its name
	     **/
	    ResourceImpl.prototype.childMethod = function (method) {
	        return helper.childMethod(this, method);
	    };
	    /**
	     * Api owning the resource as a sibling
	     **/
	    ResourceImpl.prototype.ownerApi = function () {
	        return helper.ownerApi(this);
	    };
	    /**
	     * Retrieve an ordered list of all absolute uri parameters. Returns a union of `Api.baseUriParameters()`
	     * for `Api` owning the `Resource` and `Resource.uriParameters()`.
	     **/
	    ResourceImpl.prototype.absoluteUriParameters = function () {
	        return helper.absoluteUriParameters(this);
	    };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    ResourceImpl.prototype.scalarsAnnotations = function () { return new ResourceScalarsAnnotationsImpl(this.highLevel()); };
	    return ResourceImpl;
	}(ResourceBaseImpl));
	exports.ResourceImpl = ResourceImpl;
	/**
	 * ResourceBase scalar properties annotations accessor
	 **/
	var ResourceBaseScalarsAnnotationsImpl = (function (_super) {
	    __extends(ResourceBaseScalarsAnnotationsImpl, _super);
	    function ResourceBaseScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * ResourceBase.is annotations
	     **/
	    ResourceBaseScalarsAnnotationsImpl.prototype.is = function () {
	        var attrs = this.node.attributes("is");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    /**
	     * ResourceBase.type annotations
	     **/
	    ResourceBaseScalarsAnnotationsImpl.prototype["type"] = function () {
	        var attr = this.node.attr("type");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * ResourceBase.description annotations
	     **/
	    ResourceBaseScalarsAnnotationsImpl.prototype.description = function () {
	        var attr = this.node.attr("description");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * ResourceBase.securedBy annotations
	     **/
	    ResourceBaseScalarsAnnotationsImpl.prototype.securedBy = function () {
	        var attrs = this.node.attributes("securedBy");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    return ResourceBaseScalarsAnnotationsImpl;
	}(AnnotableScalarsAnnotationsImpl));
	exports.ResourceBaseScalarsAnnotationsImpl = ResourceBaseScalarsAnnotationsImpl;
	/**
	 * Resource scalar properties annotations accessor
	 **/
	var ResourceScalarsAnnotationsImpl = (function (_super) {
	    __extends(ResourceScalarsAnnotationsImpl, _super);
	    function ResourceScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Resource.displayName annotations
	     **/
	    ResourceScalarsAnnotationsImpl.prototype.displayName = function () {
	        var attr = this.node.attr("displayName");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * Resource.description annotations
	     **/
	    ResourceScalarsAnnotationsImpl.prototype.description = function () {
	        var attr = this.node.attr("description");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * Resource.annotations annotations
	     **/
	    ResourceScalarsAnnotationsImpl.prototype.annotations = function () {
	        var attrs = this.node.attributes("annotations");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    return ResourceScalarsAnnotationsImpl;
	}(ResourceBaseScalarsAnnotationsImpl));
	exports.ResourceScalarsAnnotationsImpl = ResourceScalarsAnnotationsImpl;
	var ResourceTypeImpl = (function (_super) {
	    __extends(ResourceTypeImpl, _super);
	    function ResourceTypeImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createResourceType(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * The displayName attribute specifies the resource type display name. It is a friendly name used only for  display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself).
	     **/
	    ResourceTypeImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     * @hidden
	     * Set displayName value
	     **/
	    ResourceTypeImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /**
	     * Name of the resource type
	     **/
	    ResourceTypeImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     * @hidden
	     * Set name value
	     **/
	    ResourceTypeImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    /**
	     * Instructions on how and when the resource type should be used.
	     **/
	    ResourceTypeImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /**
	     * @hidden
	     * Set usage value
	     **/
	    ResourceTypeImpl.prototype.setUsage = function (param) {
	        this.highLevel().attrOrCreate("usage").setValue("" + param);
	        return this;
	    };
	    ResourceTypeImpl.prototype.uses = function () {
	        return _super.prototype.elements.call(this, 'uses');
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ResourceTypeImpl.prototype.wrapperClassName = function () { return "ResourceTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ResourceTypeImpl.prototype.kind = function () { return "ResourceType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ResourceTypeImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    ResourceTypeImpl.prototype.parametrizedProperties = function () {
	        return helper.getTemplateParametrizedProperties(this);
	    };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    ResourceTypeImpl.prototype.scalarsAnnotations = function () { return new ResourceTypeScalarsAnnotationsImpl(this.highLevel()); };
	    return ResourceTypeImpl;
	}(ResourceBaseImpl));
	exports.ResourceTypeImpl = ResourceTypeImpl;
	/**
	 * ResourceType scalar properties annotations accessor
	 **/
	var ResourceTypeScalarsAnnotationsImpl = (function (_super) {
	    __extends(ResourceTypeScalarsAnnotationsImpl, _super);
	    function ResourceTypeScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * ResourceType.displayName annotations
	     **/
	    ResourceTypeScalarsAnnotationsImpl.prototype.displayName = function () {
	        var attr = this.node.attr("displayName");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * ResourceType.usage annotations
	     **/
	    ResourceTypeScalarsAnnotationsImpl.prototype.usage = function () {
	        var attr = this.node.attr("usage");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    return ResourceTypeScalarsAnnotationsImpl;
	}(ResourceBaseScalarsAnnotationsImpl));
	exports.ResourceTypeScalarsAnnotationsImpl = ResourceTypeScalarsAnnotationsImpl;
	/**
	 * Annotations allow you to attach information to your API
	 **/
	var AnnotationRefImpl = (function (_super) {
	    __extends(AnnotationRefImpl, _super);
	    function AnnotationRefImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    AnnotationRefImpl.prototype.wrapperClassName = function () { return "AnnotationRefImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    AnnotationRefImpl.prototype.kind = function () { return "AnnotationRef"; };
	    /**
	     * @return RAML version of the node
	     **/
	    AnnotationRefImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    AnnotationRefImpl.prototype.annotation = function () {
	        return helper.referencedAnnotation(this);
	    };
	    return AnnotationRefImpl;
	}(ReferenceImpl));
	exports.AnnotationRefImpl = AnnotationRefImpl;
	var DocumentationItemImpl = (function (_super) {
	    __extends(DocumentationItemImpl, _super);
	    function DocumentationItemImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createDocumentationItem(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * Title of documentation section
	     **/
	    DocumentationItemImpl.prototype.title = function () {
	        return _super.prototype.attribute.call(this, 'title', this.toString);
	    };
	    /**
	     * @hidden
	     * Set title value
	     **/
	    DocumentationItemImpl.prototype.setTitle = function (param) {
	        this.highLevel().attrOrCreate("title").setValue("" + param);
	        return this;
	    };
	    /**
	     * Content of documentation section
	     **/
	    DocumentationItemImpl.prototype.content = function () {
	        return _super.prototype.attribute.call(this, 'content', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    DocumentationItemImpl.prototype.uses = function () {
	        return _super.prototype.elements.call(this, 'uses');
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    DocumentationItemImpl.prototype.wrapperClassName = function () { return "DocumentationItemImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    DocumentationItemImpl.prototype.kind = function () { return "DocumentationItem"; };
	    /**
	     * @return RAML version of the node
	     **/
	    DocumentationItemImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    DocumentationItemImpl.prototype.scalarsAnnotations = function () { return new DocumentationItemScalarsAnnotationsImpl(this.highLevel()); };
	    return DocumentationItemImpl;
	}(AnnotableImpl));
	exports.DocumentationItemImpl = DocumentationItemImpl;
	/**
	 * DocumentationItem scalar properties annotations accessor
	 **/
	var DocumentationItemScalarsAnnotationsImpl = (function (_super) {
	    __extends(DocumentationItemScalarsAnnotationsImpl, _super);
	    function DocumentationItemScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * DocumentationItem.title annotations
	     **/
	    DocumentationItemScalarsAnnotationsImpl.prototype.title = function () {
	        var attr = this.node.attr("title");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * DocumentationItem.content annotations
	     **/
	    DocumentationItemScalarsAnnotationsImpl.prototype.content = function () {
	        var attr = this.node.attr("content");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    return DocumentationItemScalarsAnnotationsImpl;
	}(AnnotableScalarsAnnotationsImpl));
	exports.DocumentationItemScalarsAnnotationsImpl = DocumentationItemScalarsAnnotationsImpl;
	var FragmentDeclarationImpl = (function (_super) {
	    __extends(FragmentDeclarationImpl, _super);
	    function FragmentDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createFragmentDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    FragmentDeclarationImpl.prototype.uses = function () {
	        return _super.prototype.elements.call(this, 'uses');
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    FragmentDeclarationImpl.prototype.wrapperClassName = function () { return "FragmentDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    FragmentDeclarationImpl.prototype.kind = function () { return "FragmentDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    FragmentDeclarationImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    return FragmentDeclarationImpl;
	}(AnnotableImpl));
	exports.FragmentDeclarationImpl = FragmentDeclarationImpl;
	var LibraryBaseImpl = (function (_super) {
	    __extends(LibraryBaseImpl, _super);
	    function LibraryBaseImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createLibraryBase(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * Alias for the equivalent "types" property, for compatibility with RAML 0.8. Deprecated - API definitions should use the "types" property, as the "schemas" alias for that property name may be removed in a future RAML version. The "types" property allows for XML and JSON schemas.
	     **/
	    LibraryBaseImpl.prototype.schemas = function () {
	        return _super.prototype.elements.call(this, 'schemas');
	    };
	    /**
	     * Declarations of (data) types for use within this API
	     **/
	    LibraryBaseImpl.prototype.types = function () {
	        return _super.prototype.elements.call(this, 'types');
	    };
	    /**
	     * Declarations of traits for use within this API
	     * @hidden
	     **/
	    LibraryBaseImpl.prototype.traits_original = function () {
	        return _super.prototype.elements.call(this, 'traits');
	    };
	    /**
	     * Declarations of resource types for use within this API
	     * @hidden
	     **/
	    LibraryBaseImpl.prototype.resourceTypes_original = function () {
	        return _super.prototype.elements.call(this, 'resourceTypes');
	    };
	    /**
	     * Declarations of annotation types for use by annotations
	     **/
	    LibraryBaseImpl.prototype.annotationTypes = function () {
	        return _super.prototype.elements.call(this, 'annotationTypes');
	    };
	    /**
	     * Declarations of security schemes for use within this API.
	     **/
	    LibraryBaseImpl.prototype.securitySchemes = function () {
	        return _super.prototype.elements.call(this, 'securitySchemes');
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    LibraryBaseImpl.prototype.wrapperClassName = function () { return "LibraryBaseImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    LibraryBaseImpl.prototype.kind = function () { return "LibraryBase"; };
	    /**
	     * @return RAML version of the node
	     **/
	    LibraryBaseImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Declarations of traits for use within this API
	     **/
	    LibraryBaseImpl.prototype.traits = function () {
	        return helper.traitsPrimary(this);
	    };
	    /**
	     * Retrieve all traits including those defined in libraries
	     * @deprecated
	     **/
	    LibraryBaseImpl.prototype.allTraits = function () {
	        return helper.allTraits(this);
	    };
	    /**
	     * Declarations of resource types for use within this API
	     **/
	    LibraryBaseImpl.prototype.resourceTypes = function () {
	        return helper.resourceTypesPrimary(this);
	    };
	    /**
	     * Retrieve all resource types including those defined in libraries
	     * @deprecated
	     **/
	    LibraryBaseImpl.prototype.allResourceTypes = function () {
	        return helper.allResourceTypes(this);
	    };
	    return LibraryBaseImpl;
	}(FragmentDeclarationImpl));
	exports.LibraryBaseImpl = LibraryBaseImpl;
	var LibraryImpl = (function (_super) {
	    __extends(LibraryImpl, _super);
	    function LibraryImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createLibrary(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * contains description of why library exist
	     **/
	    LibraryImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /**
	     * @hidden
	     * Set usage value
	     **/
	    LibraryImpl.prototype.setUsage = function (param) {
	        this.highLevel().attrOrCreate("usage").setValue("" + param);
	        return this;
	    };
	    /**
	     * Namespace which the library is imported under
	     **/
	    LibraryImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     * @hidden
	     * Set name value
	     **/
	    LibraryImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    LibraryImpl.prototype.wrapperClassName = function () { return "LibraryImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    LibraryImpl.prototype.kind = function () { return "Library"; };
	    /**
	     * @return RAML version of the node
	     **/
	    LibraryImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    LibraryImpl.prototype.scalarsAnnotations = function () { return new LibraryScalarsAnnotationsImpl(this.highLevel()); };
	    return LibraryImpl;
	}(LibraryBaseImpl));
	exports.LibraryImpl = LibraryImpl;
	/**
	 * Library scalar properties annotations accessor
	 **/
	var LibraryScalarsAnnotationsImpl = (function (_super) {
	    __extends(LibraryScalarsAnnotationsImpl, _super);
	    function LibraryScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Library.usage annotations
	     **/
	    LibraryScalarsAnnotationsImpl.prototype.usage = function () {
	        var attr = this.node.attr("usage");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    return LibraryScalarsAnnotationsImpl;
	}(AnnotableScalarsAnnotationsImpl));
	exports.LibraryScalarsAnnotationsImpl = LibraryScalarsAnnotationsImpl;
	var ApiImpl = (function (_super) {
	    __extends(ApiImpl, _super);
	    function ApiImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createApi(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * Short plain-text label for the API
	     **/
	    ApiImpl.prototype.title = function () {
	        return _super.prototype.attribute.call(this, 'title', this.toString);
	    };
	    /**
	     * @hidden
	     * Set title value
	     **/
	    ApiImpl.prototype.setTitle = function (param) {
	        this.highLevel().attrOrCreate("title").setValue("" + param);
	        return this;
	    };
	    /**
	     * A longer, human-friendly description of the API
	     **/
	    ApiImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     * The version of the API, e.g. 'v1'
	     **/
	    ApiImpl.prototype.version = function () {
	        return _super.prototype.attribute.call(this, 'version', this.toString);
	    };
	    /**
	     * @hidden
	     * Set version value
	     **/
	    ApiImpl.prototype.setVersion = function (param) {
	        this.highLevel().attrOrCreate("version").setValue("" + param);
	        return this;
	    };
	    /**
	     * A URI that's to be used as the base of all the resources' URIs. Often used as the base of the URL of each resource, containing the location of the API. Can be a template URI.
	     **/
	    ApiImpl.prototype.baseUri = function () {
	        return _super.prototype.attribute.call(this, 'baseUri', function (attr) { return new FullUriTemplateStringImpl(attr); });
	    };
	    /**
	     * Named parameters used in the baseUri (template)
	     * @hidden
	     **/
	    ApiImpl.prototype.baseUriParameters_original = function () {
	        return _super.prototype.elements.call(this, 'baseUriParameters');
	    };
	    /**
	     * The protocols supported by the API
	     **/
	    ApiImpl.prototype.protocols = function () {
	        return _super.prototype.attributes.call(this, 'protocols', this.toString);
	    };
	    /**
	     * @hidden
	     * Set protocols value
	     **/
	    ApiImpl.prototype.setProtocols = function (param) {
	        this.highLevel().attrOrCreate("protocols").setValue("" + param);
	        return this;
	    };
	    /**
	     * The default media type to use for request and response bodies (payloads), e.g. "application/json"
	     **/
	    ApiImpl.prototype.mediaType = function () {
	        return _super.prototype.attributes.call(this, 'mediaType', function (attr) { return new MimeTypeImpl(attr); });
	    };
	    /**
	     * The security schemes that apply to every resource and method in the API
	     **/
	    ApiImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemeRefImpl(attr); });
	    };
	    /**
	     * The resources of the API, identified as relative URIs that begin with a slash (/). Every property whose key begins with a slash (/), and is either at the root of the API definition or is the child property of a resource property, is a resource property, e.g.: /users, /{groupId}, etc
	     **/
	    ApiImpl.prototype.resources = function () {
	        return _super.prototype.elements.call(this, 'resources');
	    };
	    /**
	     * Additional overall documentation for the API
	     **/
	    ApiImpl.prototype.documentation = function () {
	        return _super.prototype.elements.call(this, 'documentation');
	    };
	    /**
	     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
	     **/
	    ApiImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ApiImpl.prototype.wrapperClassName = function () { return "ApiImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ApiImpl.prototype.kind = function () { return "Api"; };
	    /**
	     * @return RAML version of the node
	     * @hidden
	     **/
	    ApiImpl.prototype.RAMLVersion_original = function () { return "RAML10"; };
	    /**
	     * Equivalent API with traits and resource types expanded
	     * @expLib whether to apply library expansion or not
	     **/
	    ApiImpl.prototype.expand = function (expLib) {
	        if (expLib === void 0) { expLib = false; }
	        return helper.expandSpec(this, expLib);
	    };
	    /**
	     * Get child resource by its relative path
	     **/
	    ApiImpl.prototype.childResource = function (relPath) {
	        return helper.childResource(this, relPath);
	    };
	    /**
	     * Retrieve all resources of the Api
	     **/
	    ApiImpl.prototype.allResources = function () {
	        return helper.allResources(this);
	    };
	    /**
	     * Named parameters used in the baseUri (template)
	     **/
	    ApiImpl.prototype.baseUriParameters = function () {
	        return helper.baseUriParametersPrimary(this);
	    };
	    /**
	     * Retrieve an ordered list of all base uri parameters regardless of whether they are described in `baseUriParameters` or not
	     * Consider a fragment of RAML specification:
	     * ```yaml
	     * version: v1
	     * baseUri: https://{organization}.example.com/{version}/{service}
	     * baseUriParameters:
	     * service:
	     * ```
	     * Here `version` and `organization` are base uri parameters which are not described in the `baseUriParameters` node,
	     * but they are among `Api.allBaseUriParameters()`.
	     * @deprecated
	     **/
	    ApiImpl.prototype.allBaseUriParameters = function () {
	        return helper.baseUriParameters(this);
	    };
	    /**
	     * Protocols used by the API. Returns the `protocols` property value if it is specified.
	     * Otherwise, returns protocol, specified in the base URI.
	     * @deprecated
	     **/
	    ApiImpl.prototype.allProtocols = function () {
	        return helper.allProtocols(this);
	    };
	    /**
	     * @return RAML version of the node
	     **/
	    ApiImpl.prototype.RAMLVersion = function () {
	        return helper.RAMLVersion(this);
	    };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    ApiImpl.prototype.scalarsAnnotations = function () { return new ApiScalarsAnnotationsImpl(this.highLevel()); };
	    return ApiImpl;
	}(LibraryBaseImpl));
	exports.ApiImpl = ApiImpl;
	var OverlayImpl = (function (_super) {
	    __extends(OverlayImpl, _super);
	    function OverlayImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createOverlay(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * contains description of why overlay exist
	     **/
	    OverlayImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /**
	     * @hidden
	     * Set usage value
	     **/
	    OverlayImpl.prototype.setUsage = function (param) {
	        this.highLevel().attrOrCreate("usage").setValue("" + param);
	        return this;
	    };
	    /**
	     * Location of a valid RAML API definition (or overlay or extension), the overlay is applied to.
	     **/
	    OverlayImpl.prototype.extends = function () {
	        return _super.prototype.attribute.call(this, 'extends', this.toString);
	    };
	    /**
	     * @hidden
	     * Set extends value
	     **/
	    OverlayImpl.prototype.setExtends = function (param) {
	        this.highLevel().attrOrCreate("extends").setValue("" + param);
	        return this;
	    };
	    /**
	     * Short plain-text label for the API
	     **/
	    OverlayImpl.prototype.title = function () {
	        return _super.prototype.attribute.call(this, 'title', this.toString);
	    };
	    /**
	     * @hidden
	     * Set title value
	     **/
	    OverlayImpl.prototype.setTitle = function (param) {
	        this.highLevel().attrOrCreate("title").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    OverlayImpl.prototype.wrapperClassName = function () { return "OverlayImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    OverlayImpl.prototype.kind = function () { return "Overlay"; };
	    /**
	     * @return RAML version of the node
	     **/
	    OverlayImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    OverlayImpl.prototype.scalarsAnnotations = function () { return new OverlayScalarsAnnotationsImpl(this.highLevel()); };
	    return OverlayImpl;
	}(ApiImpl));
	exports.OverlayImpl = OverlayImpl;
	/**
	 * Api scalar properties annotations accessor
	 **/
	var ApiScalarsAnnotationsImpl = (function (_super) {
	    __extends(ApiScalarsAnnotationsImpl, _super);
	    function ApiScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Api.title annotations
	     **/
	    ApiScalarsAnnotationsImpl.prototype.title = function () {
	        var attr = this.node.attr("title");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * Api.description annotations
	     **/
	    ApiScalarsAnnotationsImpl.prototype.description = function () {
	        var attr = this.node.attr("description");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * Api.version annotations
	     **/
	    ApiScalarsAnnotationsImpl.prototype.version = function () {
	        var attr = this.node.attr("version");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * Api.baseUri annotations
	     **/
	    ApiScalarsAnnotationsImpl.prototype.baseUri = function () {
	        var attr = this.node.attr("baseUri");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * Api.protocols annotations
	     **/
	    ApiScalarsAnnotationsImpl.prototype.protocols = function () {
	        var attrs = this.node.attributes("protocols");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    /**
	     * Api.mediaType annotations
	     **/
	    ApiScalarsAnnotationsImpl.prototype.mediaType = function () {
	        var attrs = this.node.attributes("mediaType");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    /**
	     * Api.securedBy annotations
	     **/
	    ApiScalarsAnnotationsImpl.prototype.securedBy = function () {
	        var attrs = this.node.attributes("securedBy");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    /**
	     * Api.annotations annotations
	     **/
	    ApiScalarsAnnotationsImpl.prototype.annotations = function () {
	        var attrs = this.node.attributes("annotations");
	        return attrs.map(function (x) {
	            var annotationAttrs = x.annotations();
	            var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	            return result;
	        });
	    };
	    return ApiScalarsAnnotationsImpl;
	}(AnnotableScalarsAnnotationsImpl));
	exports.ApiScalarsAnnotationsImpl = ApiScalarsAnnotationsImpl;
	/**
	 * Overlay scalar properties annotations accessor
	 **/
	var OverlayScalarsAnnotationsImpl = (function (_super) {
	    __extends(OverlayScalarsAnnotationsImpl, _super);
	    function OverlayScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Overlay.usage annotations
	     **/
	    OverlayScalarsAnnotationsImpl.prototype.usage = function () {
	        var attr = this.node.attr("usage");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * Overlay.extends annotations
	     **/
	    OverlayScalarsAnnotationsImpl.prototype.extends = function () {
	        var attr = this.node.attr("extends");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * Overlay.title annotations
	     **/
	    OverlayScalarsAnnotationsImpl.prototype.title = function () {
	        var attr = this.node.attr("title");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    return OverlayScalarsAnnotationsImpl;
	}(ApiScalarsAnnotationsImpl));
	exports.OverlayScalarsAnnotationsImpl = OverlayScalarsAnnotationsImpl;
	var ExtensionImpl = (function (_super) {
	    __extends(ExtensionImpl, _super);
	    function ExtensionImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createExtension(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * contains description of why extension exist
	     **/
	    ExtensionImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /**
	     * @hidden
	     * Set usage value
	     **/
	    ExtensionImpl.prototype.setUsage = function (param) {
	        this.highLevel().attrOrCreate("usage").setValue("" + param);
	        return this;
	    };
	    /**
	     * Location of a valid RAML API definition (or overlay or extension), the extension is applied to
	     **/
	    ExtensionImpl.prototype.extends = function () {
	        return _super.prototype.attribute.call(this, 'extends', this.toString);
	    };
	    /**
	     * @hidden
	     * Set extends value
	     **/
	    ExtensionImpl.prototype.setExtends = function (param) {
	        this.highLevel().attrOrCreate("extends").setValue("" + param);
	        return this;
	    };
	    /**
	     * Short plain-text label for the API
	     **/
	    ExtensionImpl.prototype.title = function () {
	        return _super.prototype.attribute.call(this, 'title', this.toString);
	    };
	    /**
	     * @hidden
	     * Set title value
	     **/
	    ExtensionImpl.prototype.setTitle = function (param) {
	        this.highLevel().attrOrCreate("title").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ExtensionImpl.prototype.wrapperClassName = function () { return "ExtensionImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ExtensionImpl.prototype.kind = function () { return "Extension"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ExtensionImpl.prototype.RAMLVersion = function () { return "RAML10"; };
	    /**
	     * Scalar properties annotations accessor
	     **/
	    ExtensionImpl.prototype.scalarsAnnotations = function () { return new ExtensionScalarsAnnotationsImpl(this.highLevel()); };
	    return ExtensionImpl;
	}(ApiImpl));
	exports.ExtensionImpl = ExtensionImpl;
	/**
	 * Extension scalar properties annotations accessor
	 **/
	var ExtensionScalarsAnnotationsImpl = (function (_super) {
	    __extends(ExtensionScalarsAnnotationsImpl, _super);
	    function ExtensionScalarsAnnotationsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Extension.usage annotations
	     **/
	    ExtensionScalarsAnnotationsImpl.prototype.usage = function () {
	        var attr = this.node.attr("usage");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * Extension.extends annotations
	     **/
	    ExtensionScalarsAnnotationsImpl.prototype.extends = function () {
	        var attr = this.node.attr("extends");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    /**
	     * Extension.title annotations
	     **/
	    ExtensionScalarsAnnotationsImpl.prototype.title = function () {
	        var attr = this.node.attr("title");
	        if (attr == null) {
	            return [];
	        }
	        var annotationAttrs = attr.annotations();
	        var result = core.attributesToValues(annotationAttrs, function (a) { return new AnnotationRefImpl(a); });
	        return result;
	    };
	    return ExtensionScalarsAnnotationsImpl;
	}(ApiScalarsAnnotationsImpl));
	exports.ExtensionScalarsAnnotationsImpl = ExtensionScalarsAnnotationsImpl;
	/**
	 * @hidden
	 **/
	function createApi(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("Api");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createLibraryBase(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("LibraryBase");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createFragmentDeclaration(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("FragmentDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createAnnotable(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("Annotable");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createTypeInstance(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("TypeInstance");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createTypeInstanceProperty(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("TypeInstanceProperty");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createTrait(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("Trait");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createMethodBase(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("MethodBase");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createOperation(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("Operation");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createTypeDeclaration(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("TypeDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createExampleSpec(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("ExampleSpec");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createUsesDeclaration(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("UsesDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createXMLFacetInfo(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("XMLFacetInfo");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createArrayTypeDeclaration(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("ArrayTypeDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createUnionTypeDeclaration(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("UnionTypeDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createObjectTypeDeclaration(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("ObjectTypeDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createStringTypeDeclaration(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("StringTypeDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createBooleanTypeDeclaration(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("BooleanTypeDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createNumberTypeDeclaration(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("NumberTypeDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createIntegerTypeDeclaration(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("IntegerTypeDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createDateOnlyTypeDeclaration(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("DateOnlyTypeDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createTimeOnlyTypeDeclaration(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("TimeOnlyTypeDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createDateTimeOnlyTypeDeclaration(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("DateTimeOnlyTypeDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createDateTimeTypeDeclaration(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("DateTimeTypeDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createFileTypeDeclaration(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("FileTypeDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createResponse(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("Response");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createSecuritySchemePart(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("SecuritySchemePart");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createAbstractSecurityScheme(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("AbstractSecurityScheme");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createSecuritySchemeSettings(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("SecuritySchemeSettings");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createOAuth1SecuritySchemeSettings(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("OAuth1SecuritySchemeSettings");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createOAuth2SecuritySchemeSettings(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("OAuth2SecuritySchemeSettings");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createOAuth2SecurityScheme(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("OAuth2SecurityScheme");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createOAuth1SecurityScheme(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("OAuth1SecurityScheme");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createPassThroughSecurityScheme(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("PassThroughSecurityScheme");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createBasicSecurityScheme(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("BasicSecurityScheme");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createDigestSecurityScheme(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("DigestSecurityScheme");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createCustomSecurityScheme(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("CustomSecurityScheme");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createMethod(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("Method");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createResourceType(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("ResourceType");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createResourceBase(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("ResourceBase");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createResource(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("Resource");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createDocumentationItem(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("DocumentationItem");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createLibrary(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("Library");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createOverlay(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("Overlay");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createExtension(key) {
	    var universe = def.getUniverse("RAML10");
	    var nc = universe.type("Extension");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	function loadApiSync(apiPath, arg1, arg2) {
	    return apiLoader.loadApi(apiPath, arg1, arg2).getOrElse(null);
	}
	exports.loadApiSync = loadApiSync;
	function loadRAMLSync(ramlPath, arg1, arg2) {
	    return apiLoader.loadApi(ramlPath, arg1, arg2).getOrElse(null);
	}
	exports.loadRAMLSync = loadRAMLSync;
	function loadApi(apiPath, arg1, arg2) {
	    return apiLoader.loadApiAsync(apiPath, arg1, arg2);
	}
	exports.loadApi = loadApi;
	function loadRAML(ramlPath, arg1, arg2) {
	    return apiLoader.loadRAMLAsync(ramlPath, arg1, arg2);
	}
	exports.loadRAML = loadRAML;
	/**
	 * Gets AST node by runtime type, if runtime type matches any.
	 * @param runtimeType - runtime type to find the match for
	 */
	function getLanguageElementByRuntimeType(runtimeType) {
	    return apiLoader.getLanguageElementByRuntimeType(runtimeType);
	}
	exports.getLanguageElementByRuntimeType = getLanguageElementByRuntimeType;
	//# sourceMappingURL=raml10parser.js.map

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../typings/main.d.ts" />
	"use strict";
	var invariant = __webpack_require__(67);
	var exists = function (v) { return (v != null); };
	var globalEmptyOpt;
	var Opt = (function () {
	    function Opt(_value) {
	        var _this = this;
	        this._value = _value;
	        this._isDefined = false;
	        this._isEmpty = true;
	        this._arr = undefined;
	        this.getOrThrow = function () {
	            invariant(_this._isDefined, 'Opt is empty. Use `Opt#getOrElse` or check `Opt#isDefined`.');
	            return _this._value;
	        };
	        this.value = function () { return _this._value; };
	        this.isDefined = function () { return _this._isDefined; };
	        this.isEmpty = function () { return _this._isEmpty; };
	        this.toArray = function () { return _this._arr || (_this._arr = _this._isDefined ? [_this._value] : []); };
	        this.getOrElse = function (v) { return _this._isDefined ? _this._value : v; };
	        this.getOrElseF = function (v) { return _this._isDefined ? _this._value : v(); };
	        this.map = function (f) { return _this._isEmpty ? Opt.empty() : new Opt(f(_this._value)); };
	        this.flatMap = function (f) { return _this.map(f).getOrElse(Opt.empty()); };
	        this.equals = function (other) {
	            invariant(other instanceof Opt, 'Expected other to be an `Opt`, but got `%s`', typeof other);
	            return (_this._isDefined === other.isDefined()) && (_this._value === other.value());
	        };
	        if (exists(this._value)) {
	            this._isDefined = true;
	            this._isEmpty = false;
	        }
	    }
	    Opt.prototype.forEach = function (fn) {
	        if (this.isDefined()) {
	            fn(this._value);
	        }
	    };
	    /**
	     * You can always create an empty option by hand just by calling new Opt<T>()
	     * but calling this method will return a global instance instead of allocating a new one each time
	     */
	    Opt.empty = function () { return (globalEmptyOpt || (globalEmptyOpt = new Opt())); };
	    return Opt;
	}());
	module.exports = Opt;
	//# sourceMappingURL=Opt.js.map

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ramlDs = __webpack_require__(36);
	module.exports = ramlDs.universesInfo;
	//# sourceMappingURL=universe.js.map

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/main.d.ts" />
	"use strict";
	var defs = __webpack_require__(36);
	var hl = __webpack_require__(10);
	var _ = __webpack_require__(63);
	var def = __webpack_require__(36);
	// import high=require("../highLevelAST");
	var hlimpl = __webpack_require__(16);
	var universes = __webpack_require__(22);
	var ramlServices = def;
	var sourceFinder = __webpack_require__(45);
	var resourceRegistry = __webpack_require__(28);
	exports.declRoot = function (h) {
	    var declRoot = h;
	    while (true) {
	        if (declRoot.definition().key() == universes.Universe10.Library) {
	            break;
	        }
	        var np = declRoot.parent();
	        if (!np) {
	            break;
	        }
	        declRoot = np;
	    }
	    return declRoot;
	};
	function globalDeclarations(h) {
	    var result = [];
	    var visitedUnits = {};
	    while (h.parent() != null) {
	        if (h.lowLevel().includePath()) {
	            result = result.concat(findDeclarations(h, visitedUnits));
	        }
	        h = h.parent();
	    }
	    result = result.concat(findDeclarations(h, visitedUnits));
	    return result;
	}
	exports.globalDeclarations = globalDeclarations;
	function getUserDefinedPropertySource(property) {
	    var result = property.node();
	    if (result && hl.isParseResult(result)) {
	        return result;
	    }
	    var sourceProvider = sourceFinder.getNominalPropertySource2(property);
	    if (!sourceProvider)
	        return null;
	    return sourceProvider.getSource();
	}
	function mark(h, rs) {
	    var n = h.lowLevel();
	    n = n._node ? n._node : n;
	    if (n['mark']) {
	        return rs;
	    }
	    n['mark'] = rs;
	    return null;
	}
	function unmark(h) {
	    var n = h.lowLevel();
	    n = n._node ? n._node : n;
	    delete n['mark'];
	}
	function findDeclarations(h, visitedUnits, rs) {
	    if (visitedUnits === void 0) { visitedUnits = {}; }
	    if (rs === void 0) { rs = []; }
	    var aPath = h.lowLevel().unit().absolutePath();
	    visitedUnits[aPath] = true;
	    if (!(h instanceof hlimpl.ASTNodeImpl)) {
	        return rs;
	    }
	    var skipAll = false;
	    h.elements().forEach(function (x) {
	        if (x.definition().key() == universes.Universe10.UsesDeclaration) {
	            if (skipAll) {
	                return;
	            }
	            var mm = x.attr("value");
	            if (mm) {
	                var unit = x.root().lowLevel().unit().resolve(mm.value());
	                if (unit && resourceRegistry.isWaitingFor(unit.absolutePath())) {
	                    skipAll = true;
	                    return;
	                }
	                if (unit != null && unit.isRAMLUnit() && !visitedUnits[unit.absolutePath()]) {
	                    if (unit.highLevel().isElement()) {
	                        findDeclarations(unit.highLevel().asElement(), visitedUnits, rs);
	                    }
	                }
	            }
	        }
	        else {
	            rs.push(x);
	        }
	    });
	    return rs;
	}
	exports.findDeclarations = findDeclarations;
	function getIndent2(offset, text) {
	    var spaces = "";
	    for (var i = offset - 1; i >= 0; i--) {
	        var c = text.charAt(i);
	        if (c == ' ' || c == '\t') {
	            if (spaces) {
	                spaces += c;
	            }
	            else {
	                spaces = c;
	            }
	        }
	        else if (c == '\r' || c == '\n') {
	            return spaces;
	        }
	    }
	}
	function deepFindNode(n, offset, end, goToOtherUnits, returnAttrs) {
	    if (goToOtherUnits === void 0) { goToOtherUnits = true; }
	    if (returnAttrs === void 0) { returnAttrs = true; }
	    if (n == null) {
	        return null;
	    }
	    if (n.lowLevel()) {
	        //var node:ASTNode=<ASTNode>n;
	        if (n.lowLevel().start() <= offset && n.lowLevel().end() >= end) {
	            if (n instanceof hlimpl.ASTNodeImpl) {
	                var hn = n;
	                var all = goToOtherUnits ? hn.children() : hn.directChildren();
	                for (var i = 0; i < all.length; i++) {
	                    if (!goToOtherUnits && all[i].lowLevel().unit() != n.lowLevel().unit()) {
	                        continue;
	                    }
	                    var node = deepFindNode(all[i], offset, end, goToOtherUnits);
	                    if (node) {
	                        if (!returnAttrs && node instanceof hlimpl.ASTPropImpl) {
	                            node = node.parent();
	                        }
	                        return node;
	                    }
	                }
	                return n;
	            }
	            else if (n instanceof hlimpl.ASTPropImpl) {
	                var attr = n;
	                if (!attr.property().isKey()) {
	                    var vl = attr.value();
	                    if (vl instanceof hlimpl.StructuredValue) {
	                        var st = vl;
	                        var hl = st.toHighLevel2();
	                        if (hl) {
	                            if (!goToOtherUnits && hl.lowLevel().unit() != n.lowLevel().unit()) {
	                                return null;
	                            }
	                        }
	                        var node = deepFindNode(hl, offset, end, goToOtherUnits);
	                        if (node) {
	                            if (!returnAttrs && node instanceof hlimpl.ASTPropImpl) {
	                                node = node.parent();
	                            }
	                            return node;
	                        }
	                    }
	                    if (returnAttrs)
	                        return attr;
	                    else
	                        return attr.parent();
	                }
	                return null;
	            }
	            return null;
	        }
	    }
	    return null;
	}
	exports.deepFindNode = deepFindNode;
	function getValueAt(text, offset) {
	    var sp = -1;
	    for (var i = offset - 1; i >= 0; i--) {
	        var c = text.charAt(i);
	        if (c == '\r' || c == '\n' || c == ' ' || c == '\t' || c == '"' || c == '\'' || c == ':') {
	            sp = i + 1;
	            break;
	        }
	    }
	    var ep = -1;
	    for (var i = offset; i < text.length; i++) {
	        var c = text.charAt(i);
	        if (c == '\r' || c == '\n' || c == ' ' || c == '\t' || c == '"' || c == '\'' || c == ':') {
	            ep = i;
	            break;
	        }
	    }
	    if (sp != -1 && ep != -1) {
	        return text.substring(sp, ep);
	    }
	    return "";
	}
	function extractName(cleaned, offset) {
	    var txt = "";
	    for (var i = offset; i >= 0; i--) {
	        var c = cleaned[i];
	        if (c == ' ' || c == '\r' || c == '\n' || c == '|' || c == '[' || c == ']' || c == ':' || c == '(' || c == ')') {
	            break;
	        }
	        txt = c + txt;
	    }
	    for (var i = offset + 1; i < cleaned.length; i++) {
	        var c = cleaned[i];
	        if (c == ' ' || c == '\r' || c == '\n' || c == '|' || c == '[' || c == ']' || c == ':' || c == '(' || c == ')') {
	            break;
	        }
	        txt = txt + c;
	    }
	    return txt;
	}
	exports.extractName = extractName;
	var searchInTheValue = function (offset, content, attr, hlnode, p) {
	    if (p === void 0) { p = attr.property(); }
	    var targets = referenceTargets(p, hlnode);
	    var txt = extractName(content, offset);
	    var t = _.find(targets, function (x) { return hlimpl.qName(x, hlnode) == txt; });
	    if (t) {
	        //TODO EXTRACT COMMON OPEN NODE FUNC
	        return t;
	    }
	    if (p instanceof defs.UserDefinedProp) {
	        var up = p;
	        return getUserDefinedPropertySource(up);
	    }
	    return null;
	};
	function findUsages(unit, offset) {
	    var decl = findDeclaration(unit, offset);
	    if (decl) {
	        if (decl instanceof hlimpl.ASTNodeImpl) {
	            var hnode = decl;
	            return { node: hnode, results: hnode.findReferences() };
	        }
	        if (decl instanceof hlimpl.ASTPropImpl) {
	        }
	    }
	    var node = deepFindNode(hlimpl.fromUnit(unit), offset, offset, false);
	    if (node instanceof hlimpl.ASTNodeImpl) {
	        return { node: node, results: node.findReferences() };
	    }
	    if (node instanceof hlimpl.ASTPropImpl) {
	        var prop = node;
	        if (prop.property().canBeValue()) {
	            return { node: prop.parent(), results: prop.parent().findReferences() };
	        }
	    }
	    return { node: null, results: [] };
	}
	exports.findUsages = findUsages;
	function referenceTargets(p0, c) {
	    var p = p0;
	    if (p.getAdapter(ramlServices.RAMLPropertyService).isTypeExpr()) {
	        var definitionNodes = globalDeclarations(c).filter(function (node) {
	            var nc = node.definition().key();
	            if (nc === universes.Universe08.GlobalSchema) {
	                return true;
	            }
	            return node.definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name);
	        });
	        return definitionNodes;
	    }
	    if (p.getAdapter(ramlServices.RAMLPropertyService).isDescriminating()) {
	        var subTypes = nodesDeclaringType(p.range(), c);
	        return subTypes;
	    }
	    if (p.isReference()) {
	        var rt = p.referencesTo();
	        var subTypes = nodesDeclaringType(rt, c);
	        return subTypes;
	    }
	    if (p.range().hasValueTypeInHierarchy()) {
	        var vt = p.range().getAdapter(ramlServices.RAMLService);
	        if (vt.globallyDeclaredBy().length > 0) {
	            var definitionNodes = globalDeclarations(c).filter(function (z) { return _.find(vt.globallyDeclaredBy(), function (x) { return x == z.definition(); }) != null; });
	            return definitionNodes;
	        }
	    }
	    return [];
	}
	exports.referenceTargets = referenceTargets;
	function enumValues(p, c) {
	    if (c) {
	        var rs = [];
	        //TODO FIXME it is very very weird idea but I need to get it working right now
	        if (p.getAdapter(ramlServices.RAMLPropertyService).isTypeExpr()) {
	            var definitionNodes = globalDeclarations(c).filter(function (node) {
	                var nc = node.definition().key();
	                if (nc === universes.Universe08.GlobalSchema) {
	                    return true;
	                }
	                return (node.definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name));
	                //return true;
	            });
	            rs = definitionNodes.map(function (x) { return hlimpl.qName(x, c); });
	            var de = c.definition().universe().type(universes.Universe10.TypeDeclaration.name);
	            if (de) {
	                var subTypes = de.allSubTypes();
	                rs = rs.concat(subTypes.map(function (x) { return (x).getAdapter(ramlServices.RAMLService).descriminatorValue(); }));
	            }
	            return rs;
	        }
	        else {
	            var rangeKey = p.range().key();
	            if (rangeKey == universes.Universe08.SchemaString
	                || rangeKey == universes.Universe10.SchemaString) {
	                if (p.range().universe().version() == "RAML10") {
	                    if (p.range().hasValueTypeInHierarchy()) {
	                        var definitionNodes = globalDeclarations(c).filter(function (node) {
	                            return node.definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name);
	                        });
	                        rs = definitionNodes.map(function (x) { return hlimpl.qName(x, c); });
	                    }
	                }
	            }
	        }
	        if (p.getAdapter(ramlServices.RAMLPropertyService).isDescriminating()) {
	            var subTypes = subTypesWithLocals(p.domain(), c);
	            rs = rs.concat(subTypes.map(function (x) { return (x).getAdapter(ramlServices.RAMLService).descriminatorValue(); }));
	        }
	        else if (p.isReference()) {
	            rs = nodesDeclaringType(p.referencesTo(), c).map(function (x) { return hlimpl.qName(x, c); });
	        }
	        else if (p.range().hasValueTypeInHierarchy()) {
	            var vt = p.range().getAdapter(ramlServices.RAMLService);
	            if (vt.globallyDeclaredBy().length > 0) {
	                var definitionNodes = globalDeclarations(c).filter(function (z) {
	                    return _.find(vt.globallyDeclaredBy(), function (x) { return x == z.definition(); }) != null;
	                });
	                rs = rs.concat(definitionNodes.map(function (x) { return hlimpl.qName(x, c); }));
	            }
	        }
	        if (p.isAllowNull()) {
	            rs.push("null");
	        }
	        if (p.enumOptions()) {
	            rs = rs.concat(p.enumOptions());
	        }
	        return rs;
	    }
	    if (p.enumOptions() && typeof p.enumOptions() == 'string') {
	        return [p.enumOptions() + ""];
	    }
	    return p.enumOptions();
	}
	exports.enumValues = enumValues;
	function getLibraryName(node) {
	    if (node.isElement() && node.asElement().definition().key() != universes.Universe10.Library) {
	        return null;
	    }
	    return node.asElement().attrValue("name");
	}
	function findDeclarationByNode(node, nodePart) {
	    var unit = node.lowLevel().unit();
	    if (!unit) {
	        return null;
	    }
	    var start = node.lowLevel().start();
	    var end = node.lowLevel().end();
	    if (nodePart && nodePart == LocationKind.KEY_COMPLETION) {
	        start = node.lowLevel().keyStart();
	        end = node.lowLevel().keyEnd();
	    }
	    else if (nodePart && nodePart == LocationKind.VALUE_COMPLETION) {
	        start = node.lowLevel().valueStart();
	        end = node.lowLevel().valueEnd();
	    }
	    if (start == -1 || end == -1) {
	        return null;
	    }
	    var offset = Math.floor((start + end) / 2);
	    return findDeclaration(unit, offset, nodePart);
	}
	exports.findDeclarationByNode = findDeclarationByNode;
	function findDeclaration(unit, offset, nodePart) {
	    var node = deepFindNode(hlimpl.fromUnit(unit), offset, offset, false);
	    var result = null;
	    //TODO This should be changed after next refactoring
	    if (node.isElement()) {
	        if (node.asElement().definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name)) {
	            node.asElement().directChildren().forEach(function (x) {
	                if (x.isUnknown()) {
	                    //facets are not in hierarchy now
	                    if (x.getLowLevelStart() < offset && x.getLowLevelEnd() > offset) {
	                        var tp = node.asElement().localType();
	                        tp.allFacets().forEach(function (f) {
	                            if (f.nameId() == x.lowLevel().key()) {
	                                if (f instanceof def.UserDefinedProp) {
	                                    var up = getUserDefinedPropertySource(f);
	                                    result = up;
	                                }
	                            }
	                        });
	                    }
	                }
	            });
	        }
	    }
	    if (!node.property()) {
	        return node;
	    }
	    if (node.property().nameId() == "example") {
	        var nm = node.parent().localType();
	        node.lowLevel().children().forEach(function (y) {
	            if (y.key() == "example") {
	                y.children().forEach(function (x) {
	                    if (x.start() < offset && x.end() > offset) {
	                        var tp = node.parent().asElement().localType();
	                        tp.allProperties().forEach(function (f) {
	                            if (f.nameId() == x.key()) {
	                                if (f instanceof def.UserDefinedProp) {
	                                    var up = getUserDefinedPropertySource(f);
	                                    result = up;
	                                }
	                            }
	                        });
	                    }
	                });
	            }
	        });
	    }
	    if (result) {
	        return result;
	    }
	    var kind = nodePart != null ? nodePart : determineCompletionKind(unit.contents(), offset);
	    if (kind == LocationKind.VALUE_COMPLETION) {
	        var hlnode = node;
	        if (node instanceof hlimpl.ASTPropImpl) {
	            var attr = node;
	            if (attr) {
	                if (attr.value()) {
	                    if (attr.value() instanceof hlimpl.StructuredValue) {
	                        var sval = attr.value();
	                        var hlvalue = sval.toHighLevel();
	                        if (hlvalue) {
	                            var newAttr = _.find(hlvalue.attrs(), function (x) { return x.lowLevel().start() < offset && x.lowLevel().end() >= offset; });
	                            if (newAttr) {
	                                return searchInTheValue(offset, unit.contents(), newAttr, hlvalue, attr.property());
	                            }
	                        }
	                    }
	                    else {
	                        return searchInTheValue(offset, unit.contents(), attr, hlnode);
	                    }
	                }
	            }
	        }
	        else {
	            var nodeProperty = hlnode.property();
	            if (nodeProperty) {
	                return searchInTheValue(offset, unit.contents(), null, hlnode, nodeProperty);
	            }
	        }
	    }
	    if (kind == LocationKind.KEY_COMPLETION || kind == LocationKind.SEQUENCE_KEY_COPLETION) {
	        var hlnode = node;
	        var pp = node.property();
	        if (pp instanceof defs.UserDefinedProp) {
	            var up = pp;
	            return getUserDefinedPropertySource(up);
	        }
	        if (node instanceof hlimpl.ASTNodeImpl) {
	            if (hlnode.definition() instanceof defs.UserDefinedClass) {
	                var uc = hlnode.definition();
	                if (uc.isAssignableFrom("TypeDeclaration")) {
	                    return node;
	                }
	                return uc.getAdapter(ramlServices.RAMLService).getDeclaringNode();
	            }
	        }
	        if (node instanceof hlimpl.ASTPropImpl) {
	            var pr = node;
	            if (isExampleNodeContent(pr)) {
	                var contentType = findExampleContentType(pr);
	                if (contentType) {
	                    var documentationRoot = parseDocumentationContent(pr, contentType);
	                    if (documentationRoot) {
	                        var node = deepFindNode(documentationRoot, offset, offset);
	                        pp = node.property();
	                        if (pp instanceof defs.UserDefinedProp) {
	                            var up = pp;
	                            return getUserDefinedPropertySource(up);
	                        }
	                        if (node instanceof hlimpl.ASTNodeImpl) {
	                            if (hlnode.definition() instanceof defs.UserDefinedClass) {
	                                var uc = hlnode.definition();
	                                return uc.getAdapter(ramlServices.RAMLService).getDeclaringNode();
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	    if (kind == LocationKind.PATH_COMPLETION) {
	        var inclpath = getValueAt(unit.contents(), offset);
	        if (inclpath) {
	            var ap = unit.resolve(inclpath);
	            return ap;
	        }
	    }
	}
	exports.findDeclaration = findDeclaration;
	function findExampleContentType(node) {
	    var potentialTypeNode = null;
	    if (node.isElement()) {
	        potentialTypeNode = node;
	    }
	    else if (node.isAttr()) {
	        potentialTypeNode = node.parent();
	    }
	    if (!potentialTypeNode.definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name)) {
	        var parent = potentialTypeNode.parent();
	        if (!parent)
	            return null;
	        if (parent.definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name)) {
	            potentialTypeNode = parent;
	        }
	        else {
	            parent = parent.parent();
	            if (parent == null)
	                return null;
	            if (parent.definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name)) {
	                potentialTypeNode = parent;
	            }
	            else {
	                return null;
	            }
	        }
	    }
	    return potentialTypeNode.localType();
	}
	exports.findExampleContentType = findExampleContentType;
	function parseDocumentationContent(attribute, type) {
	    if (!(attribute.value() instanceof hlimpl.StructuredValue)) {
	        return null;
	    }
	    return new hlimpl.ASTNodeImpl(attribute.value().lowLevel(), attribute.parent(), type, attribute.property());
	}
	exports.parseDocumentationContent = parseDocumentationContent;
	function parseStructuredExample(exampleNode, type) {
	    return new hlimpl.ASTNodeImpl(exampleNode.lowLevel(), exampleNode, type, exampleNode.property());
	}
	exports.parseStructuredExample = parseStructuredExample;
	function isExampleNode(node) {
	    return node.definition().key() == universes.Universe10.ExampleSpec;
	}
	exports.isExampleNode = isExampleNode;
	function isExampleNodeContent(node) {
	    var typeExampleName10 = universes.Universe10.TypeDeclaration.properties.example.name;
	    var objectName10 = universes.Universe10.ObjectTypeDeclaration.name;
	    if (!(node instanceof hlimpl.ASTPropImpl)) {
	        return false;
	    }
	    var property = node;
	    var parent = property.parent();
	    var parentProperty = parent && parent.property();
	    var parentPropertyName = parentProperty && parentProperty.nameId();
	    if (typeExampleName10 === property.name() && property.isString()) {
	        if (parent instanceof hlimpl.ASTNodeImpl && parent.definition().isAssignableFrom(objectName10)) {
	            return true;
	        }
	    }
	    return false;
	}
	exports.isExampleNodeContent = isExampleNodeContent;
	function determineCompletionKind(text, offset) {
	    var hasIn = false;
	    var hasSeq = false;
	    var canBeInComment = false;
	    var canBeAnnotation = false;
	    for (var i = offset - 1; i >= 0; i--) {
	        var c = text.charAt(i);
	        if (c == '(') {
	            canBeAnnotation = true;
	        }
	        else if (canBeAnnotation) {
	            if (c == '\r' || c == '\n') {
	                var hasClosing = false;
	                for (var j = offset - 1; j < text.length; j++) {
	                    var ch = text[j];
	                    if (ch == ')') {
	                        hasClosing = true;
	                    }
	                    if (ch == '\r' || ch == "\n") {
	                        break;
	                    }
	                    if (ch == ':') {
	                        canBeAnnotation = false;
	                        break;
	                    }
	                }
	                if (canBeAnnotation && hasClosing) {
	                    return LocationKind.ANNOTATION_COMPLETION;
	                }
	                else {
	                    break;
	                }
	            }
	            if (c == ' ' || c == '\t') {
	                continue;
	            }
	            else {
	                break;
	            }
	        }
	        else {
	            if (c == '\r' || c == '\n') {
	                break;
	            }
	            if (c == ':') {
	                break;
	            }
	        }
	    }
	    for (var i = offset - 1; i >= 0; i--) {
	        var c = text.charAt(i);
	        if (c == '#') {
	            if (i == 0) {
	                return LocationKind.VERSION_COMPLETION;
	            }
	            //subsequent check for include
	            for (var j = i - 1; j >= 0; j--) {
	                var currentChar = text.charAt(j);
	                if (currentChar == '\r' || currentChar == '\n') {
	                    break;
	                }
	                else if (currentChar == '!') {
	                    if (text.indexOf("!include", j) == j) {
	                        return LocationKind.PATH_COMPLETION;
	                    }
	                }
	            }
	            return LocationKind.INCOMMENT;
	        }
	        if (c == ':') {
	            if (hasIn) {
	                return LocationKind.DIRECTIVE_COMPLETION;
	            }
	            return LocationKind.VALUE_COMPLETION;
	        }
	        if (c == '\r' || c == '\n') {
	            //check for multiline literal
	            var insideOfMultiline = false;
	            var ind = getIndent2(offset, text);
	            for (var a = i; a > 0; a--) {
	                c = text.charAt(a);
	                //TODO this can be further improved
	                if (c == ':') {
	                    if (insideOfMultiline) {
	                        var ll = getIndent2(a, text);
	                        if (ll.length < ind.length) {
	                            return LocationKind.VALUE_COMPLETION;
	                        }
	                    }
	                    break;
	                }
	                if (c == '|') {
	                    insideOfMultiline = true;
	                    continue;
	                }
	                if (c == '\r' || c == '\n') {
	                    insideOfMultiline = false;
	                }
	                if (c != ' ' && c != '\t') {
	                    insideOfMultiline = false;
	                }
	            }
	            if (hasSeq) {
	                return LocationKind.SEQUENCE_KEY_COPLETION;
	            }
	            return LocationKind.KEY_COMPLETION;
	        }
	        if (c == '-') {
	            hasSeq = true;
	        }
	        if (c == '!') {
	            if (text.indexOf("!include", i) == i) {
	                return LocationKind.PATH_COMPLETION;
	            }
	            if (text.indexOf("!i", i) == i) {
	                hasIn = true;
	            }
	        }
	    }
	}
	exports.determineCompletionKind = determineCompletionKind;
	(function (LocationKind) {
	    LocationKind[LocationKind["VALUE_COMPLETION"] = 0] = "VALUE_COMPLETION";
	    LocationKind[LocationKind["KEY_COMPLETION"] = 1] = "KEY_COMPLETION";
	    LocationKind[LocationKind["PATH_COMPLETION"] = 2] = "PATH_COMPLETION";
	    LocationKind[LocationKind["DIRECTIVE_COMPLETION"] = 3] = "DIRECTIVE_COMPLETION";
	    LocationKind[LocationKind["VERSION_COMPLETION"] = 4] = "VERSION_COMPLETION";
	    LocationKind[LocationKind["ANNOTATION_COMPLETION"] = 5] = "ANNOTATION_COMPLETION";
	    LocationKind[LocationKind["SEQUENCE_KEY_COPLETION"] = 6] = "SEQUENCE_KEY_COPLETION";
	    LocationKind[LocationKind["INCOMMENT"] = 7] = "INCOMMENT";
	})(exports.LocationKind || (exports.LocationKind = {}));
	var LocationKind = exports.LocationKind;
	function resolveReference(point, path) {
	    if (!path) {
	        return null;
	    }
	    var sp = path.split("/");
	    var result = point;
	    for (var i = 0; i < sp.length; i++) {
	        if (sp[i] == '#') {
	            result = point.unit().ast();
	            continue;
	        }
	        result = _.find(result.children(), function (x) { return x.key() == sp[i]; });
	        if (!result) {
	            return null;
	        }
	    }
	    return result;
	}
	exports.resolveReference = resolveReference;
	/**
	 * return all sub types of given type visible from parent node
	 * @param range
	 * @param parentNode
	 * @returns ITypeDefinition[]
	 */
	function subTypesWithLocals(range, parentNode) {
	    if (range == null) {
	        return [];
	    }
	    var name = range.nameId();
	    parentNode = exports.declRoot(parentNode);
	    var actual = parentNode;
	    if (actual._subTypesCache) {
	        var cached = actual._subTypesCache[name];
	        if (cached) {
	            return cached;
	        }
	    }
	    else {
	        actual._subTypesCache = {};
	    }
	    var result = range.allSubTypes();
	    if (range.getAdapter(ramlServices.RAMLService).getRuntimeExtenders().length > 0 && parentNode) {
	        var decls = globalDeclarations(parentNode);
	        var extenders = range.getAdapter(ramlServices.RAMLService).getRuntimeExtenders();
	        var root = parentNode.root();
	        extenders.forEach(function (x) {
	            var definitionNodes = decls.filter(function (z) {
	                var def = z.definition().allSuperTypes();
	                def.push(z.definition());
	                var rr = (z.definition() == x) || (_.find(def, function (d) { return d == x; }) != null) || (_.find(def, function (d) { return d == range; }) != null);
	                return rr;
	            });
	            result = result.concat(definitionNodes.map(function (x) { return x.localType(); }));
	        });
	    }
	    result = _.unique(result);
	    actual._subTypesCache[name] = result;
	    return result;
	}
	exports.subTypesWithLocals = subTypesWithLocals;
	;
	function subTypesWithName(tname, parentNode, backup) {
	    parentNode = exports.declRoot(parentNode);
	    var decls = globalDeclarations(parentNode);
	    var declNode = _.find(decls, function (x) { return hlimpl.qName(x, parentNode) == tname && x.property() &&
	        (x.property().nameId() == universes.Universe10.LibraryBase.properties.types.name); });
	    return declNode.localType();
	}
	exports.subTypesWithName = subTypesWithName;
	;
	function schemasWithName(tname, parentNode, backup) {
	    parentNode = exports.declRoot(parentNode);
	    var decls = globalDeclarations(parentNode);
	    var declNode = _.find(decls, function (x) { return hlimpl.qName(x, parentNode) == tname && x.property() &&
	        (x.property().nameId() == universes.Universe10.LibraryBase.properties.schemas.name); });
	    return declNode.localType();
	}
	exports.schemasWithName = schemasWithName;
	;
	function nodesDeclaringType(range, n) {
	    var result = [];
	    var extenders = [range].concat(range.getAdapter(ramlServices.RAMLService).getRuntimeExtenders());
	    if (n) {
	        var root = n;
	        extenders.forEach(function (x) {
	            var definitionNodes = globalDeclarations(root).filter(function (z) { return z.definition().isAssignableFrom(x.nameId()); });
	            result = result.concat(definitionNodes);
	        });
	    }
	    var isElementType = !range.hasValueTypeInHierarchy();
	    if (isElementType && range.getAdapter(ramlServices.RAMLService).isInlinedTemplates() && n) {
	        var root = n;
	        //TODO I did not like it it might be written much better
	        var definitionNodes = globalDeclarations(root).filter(function (z) { return z.definition() == range; });
	        result = result.concat(definitionNodes);
	    }
	    else {
	        var root = n;
	        var q = {};
	        range.allSubTypes().forEach(function (x) { return q[x.nameId()] = true; });
	        q[range.nameId()] = true;
	        var definitionNodes = globalDeclarations(root).filter(function (z) { return q[z.definition().nameId()]; });
	        result = result.concat(definitionNodes);
	    }
	    return result;
	}
	exports.nodesDeclaringType = nodesDeclaringType;
	;
	function findAllSubTypes(p, n) {
	    var range = p.range();
	    return subTypesWithLocals(range, n);
	}
	exports.findAllSubTypes = findAllSubTypes;
	;
	function possibleNodes(p, c) {
	    if (c) {
	        if (p.isDescriminator()) {
	            var range = p.range();
	            var extenders = range.getAdapter(ramlServices.RAMLService).getRuntimeExtenders();
	            if (extenders.length > 0 && c) {
	                var result = [];
	                extenders.forEach(function (x) {
	                    var definitionNodes = globalDeclarations(c).filter(function (z) { return z.definition() == x; });
	                    result = result.concat(definitionNodes);
	                });
	                return result;
	            }
	            return [];
	        }
	        if (p.isReference()) {
	            return nodesDeclaringType(p.referencesTo(), c);
	        }
	        if (p.range().hasValueTypeInHierarchy()) {
	            var vt = p.range().getAdapter(ramlServices.RAMLService);
	            if (vt.globallyDeclaredBy && vt.globallyDeclaredBy().length > 0) {
	                var definitionNodes = globalDeclarations(c).filter(function (z) { return _.find(vt.globallyDeclaredBy(), function (x) { return x == z.definition(); }) != null; });
	                return definitionNodes;
	            }
	        }
	    }
	    return [];
	}
	function allChildren(node) {
	    var res = [];
	    gather(node, res);
	    return res;
	}
	exports.allChildren = allChildren;
	function gather(node, result) {
	    node.children().forEach(function (x) { result.push(x); gather(x, result); });
	}
	var testUsage = function (ck, x, node, result) {
	    var tp = ck.getAdapter(ramlServices.RAMLService).getDeclaringNode();
	    if (tp) {
	        if (node.isSameNode(tp)) {
	            result.push(x);
	            return;
	        }
	    }
	    if (ck.isArray()) {
	        testUsage(ck.array().componentType(), x, node, result);
	    }
	    if (ck.isUnion()) {
	        var uni = ck.union();
	        testUsage(uni.leftType(), x, node, result);
	        testUsage(uni.rightType(), x, node, result);
	    }
	    if (ck.superTypes().some(function (x) { return x.nameId() == node.name(); })) {
	        result.push(x);
	    }
	};
	function refFinder(root, node, result) {
	    root.elements().forEach(function (x) {
	        refFinder(x, node, result);
	        //console.log(x.name())
	        var ck = x.definition();
	        //testUsage(ck, x, node, result);
	    });
	    root.attrs().forEach(function (a) {
	        var pr = a.property();
	        var vl = a.value();
	        //if (pr.isTypeExpr()){
	        //    typeExpression.
	        //}
	        if (pr instanceof defs.UserDefinedProp) {
	            var up = pr.node();
	            if (up == node) {
	                result.push(a);
	            }
	            else if (up.lowLevel().start() == node.lowLevel().start()) {
	                if (up.lowLevel().unit() == node.lowLevel().unit()) {
	                    result.push(a);
	                }
	            }
	        }
	        if (isExampleNodeContent(a)) {
	            var contentType = findExampleContentType(a);
	            if (contentType) {
	                var documentationRoot = parseDocumentationContent(a, contentType);
	                if (documentationRoot) {
	                    refFinder(documentationRoot, node, result);
	                }
	            }
	        }
	        else if (pr.getAdapter(ramlServices.RAMLPropertyService).isTypeExpr() && typeof vl == "string") {
	            var tpa = root.localType();
	            testUsage(tpa, a, node, result);
	            var libraryName = getLibraryName(node);
	            if (libraryName && vl.indexOf(libraryName) != -1) {
	                var referencingLibrary = getLibraryDefiningNode(a);
	                if (referencingLibrary &&
	                    referencingLibrary.lowLevel().start() == node.lowLevel().start()) {
	                    result.push(a);
	                }
	            }
	        }
	        if (pr.isReference() || pr.isDescriminator()) {
	            if (typeof vl == 'string') {
	                var pn = possibleNodes(pr, root);
	                if (_.find(pn, function (x) { return x.name() == vl && x == node; })) {
	                    result.push(a);
	                }
	                var libraryName = getLibraryName(node);
	                if (libraryName && vl.indexOf(libraryName) != -1) {
	                    var referencingLibrary = getLibraryDefiningNode(a);
	                    if (referencingLibrary &&
	                        referencingLibrary.lowLevel().start() == node.lowLevel().start()) {
	                        result.push(a);
	                    }
	                }
	            }
	            else {
	                var st = vl;
	                if (st) {
	                    var vn = st.valueName();
	                    var pn = possibleNodes(pr, root);
	                    if (_.find(pn, function (x) { return x.name() == vn && x == node; })) {
	                        result.push(a);
	                    }
	                    var hnode = st.toHighLevel();
	                    if (hnode) {
	                        refFinder(hnode, node, result);
	                    }
	                    var libraryName = getLibraryName(node);
	                    if (libraryName && vn.indexOf(libraryName) != -1) {
	                        var referencingLibrary = getLibraryDefiningNode(hnode);
	                        if (referencingLibrary &&
	                            referencingLibrary.lowLevel().start() == node.lowLevel().start()) {
	                            result.push(a);
	                        }
	                    }
	                }
	            }
	        }
	        else {
	            var pn = possibleNodes(pr, root);
	            if (_.find(pn, function (x) { return x.name() == vl && x == node; })) {
	                result.push(a);
	            }
	        }
	    });
	}
	exports.refFinder = refFinder;
	/**
	 * Returns library node that definition of the current node is located in, or null
	 * if current node is not defined in a library.
	 */
	function getLibraryDefiningNode(nodeToCheck) {
	    if (!nodeToCheck.lowLevel) {
	        return null;
	    }
	    var lowLevelNode = nodeToCheck.lowLevel();
	    if (!lowLevelNode) {
	        return null;
	    }
	    if (lowLevelNode.key()) {
	        var offset = Math.floor((lowLevelNode.keyEnd() + lowLevelNode.keyStart()) / 2);
	        var result = getLibraryDefiningNodeByOffset(lowLevelNode.unit(), offset);
	        if (result)
	            return result;
	    }
	    if (lowLevelNode.value()) {
	        var offset = Math.floor((lowLevelNode.valueEnd() + lowLevelNode.valueStart()) / 2);
	        var result = getLibraryDefiningNodeByOffset(lowLevelNode.unit(), offset);
	        if (result)
	            return result;
	    }
	    return null;
	}
	function getLibraryDefiningNodeByOffset(unit, offset) {
	    var declaration = findDeclaration(unit, offset);
	    if (declaration && declaration.isElement && declaration.isElement()) {
	        var declarationNode = declaration.asElement();
	        var parent = declarationNode;
	        while (parent) {
	            if (parent.definition().key() == universes.Universe10.Library) {
	                return parent;
	            }
	            parent = parent.parent();
	        }
	    }
	    return null;
	}
	//# sourceMappingURL=search.js.map

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var hl = __webpack_require__(10);
	var hlimpl = __webpack_require__(16);
	var yaml = __webpack_require__(72);
	var util = __webpack_require__(32);
	var proxy = __webpack_require__(39);
	var RamlWrapperImpl = __webpack_require__(20);
	var RamlWrapper08Impl = __webpack_require__(47);
	var wrapperHelper = __webpack_require__(33);
	var wrapperHelper08 = __webpack_require__(48);
	var pluralize = __webpack_require__(70);
	var universeDef = __webpack_require__(22);
	var _ = __webpack_require__(63);
	var referencePatcher = __webpack_require__(49);
	var universeHelpers = __webpack_require__(14);
	var changeCase = __webpack_require__(71);
	function expandTraitsAndResourceTypes(api) {
	    if (!(api instanceof RamlWrapperImpl.ApiImpl || api instanceof RamlWrapper08Impl.ApiImpl)) {
	        return null;
	    }
	    return new TraitsAndResourceTypesExpander()
	        .expandTraitsAndResourceTypes(api);
	}
	exports.expandTraitsAndResourceTypes = expandTraitsAndResourceTypes;
	function expandLibraries(api) {
	    return new LibraryExpander().expandLibraries(api);
	}
	exports.expandLibraries = expandLibraries;
	function mergeAPIs(masterUnit, extensionsAndOverlays, mergeMode) {
	    var masterApi = hlimpl.fromUnit(masterUnit);
	    if (!masterApi)
	        throw new Error("couldn't load api from " + masterUnit.absolutePath());
	    if (!extensionsAndOverlays || extensionsAndOverlays.length == 0) {
	        return masterApi;
	    }
	    var highLevelNodes = [];
	    for (var i = 0; i < extensionsAndOverlays.length; i++) {
	        var unit = extensionsAndOverlays[i];
	        var hlNode = hlimpl.fromUnit(unit);
	        if (!hlNode) {
	            throw new Error("couldn't load api from " + unit.absolutePath());
	        }
	        highLevelNodes.push(hlNode);
	    }
	    var lastExtensionOrOverlay = mergeHighLevelNodes(masterApi, highLevelNodes, mergeMode);
	    return lastExtensionOrOverlay;
	}
	exports.mergeAPIs = mergeAPIs;
	function mergeHighLevelNodes(masterApi, highLevelNodes, mergeMode, rp, expand) {
	    if (rp === void 0) { rp = null; }
	    if (expand === void 0) { expand = false; }
	    var currentMaster = masterApi;
	    for (var _i = 0, highLevelNodes_1 = highLevelNodes; _i < highLevelNodes_1.length; _i++) {
	        var currentApi = highLevelNodes_1[_i];
	        if (expand && (currentMaster.lowLevel() instanceof proxy.LowLevelProxyNode)) {
	            currentMaster = new TraitsAndResourceTypesExpander().expandHighLevelNode(currentMaster, rp, masterApi.wrapperNode()).highLevel();
	        }
	        currentApi.overrideMaster(currentMaster);
	        currentApi.setMergeMode(mergeMode);
	        currentMaster = currentApi;
	    }
	    return currentMaster;
	}
	;
	var TraitsAndResourceTypesExpander = (function () {
	    function TraitsAndResourceTypesExpander() {
	    }
	    TraitsAndResourceTypesExpander.prototype.expandTraitsAndResourceTypes = function (api, rp, forceProxy) {
	        if (rp === void 0) { rp = null; }
	        if (forceProxy === void 0) { forceProxy = false; }
	        this.init(api);
	        var unit = api.highLevel().lowLevel().unit();
	        var hasFragments = unit.project().namespaceResolver().hasFragments(unit);
	        var hasTemplates = this.globalTraits.length != 0 || this.globalResourceTypes.length != 0;
	        if (!(hasTemplates || hasFragments) && !forceProxy) {
	            return api;
	        }
	        var hlNode = this.createHighLevelNode(api.highLevel(), false, rp);
	        if (api.definition().key() == universeDef.Universe10.Overlay) {
	            return hlNode.wrapperNode();
	        }
	        var result = this.expandHighLevelNode(hlNode, rp, api);
	        return result;
	    };
	    TraitsAndResourceTypesExpander.prototype.init = function (api) {
	        this.ramlVersion = api.highLevel().definition().universe().version();
	        this.globalTraits = this.ramlVersion == "RAML10"
	            ? wrapperHelper.allTraits(api)
	            : wrapperHelper08.allTraits(api);
	        this.globalResourceTypes = this.ramlVersion == "RAML10"
	            ? wrapperHelper.allResourceTypes(api)
	            : wrapperHelper08.allResourceTypes(api);
	    };
	    TraitsAndResourceTypesExpander.prototype.expandHighLevelNode = function (hlNode, rp, api) {
	        var _this = this;
	        this.init(api);
	        var result = hlNode.wrapperNode();
	        result.setAttributeDefaults(api.getDefaultsCalculator().isEnabled());
	        this.traitMap = {};
	        this.resourceTypeMap = {};
	        result.highLevel().setMergeMode(api.highLevel().getMergeMode());
	        var resources = result.resources();
	        resources.forEach(function (x) { return _this.processResource(x); });
	        if (this.ramlVersion == "RAML10") {
	            rp = rp || new referencePatcher.ReferencePatcher();
	            rp.process(hlNode);
	            hlNode.lowLevel().actual().referencePatcher = rp;
	        }
	        return result;
	    };
	    TraitsAndResourceTypesExpander.prototype.getTemplate = function (name, context, cache, globalList) {
	        var unitPath = context.lowLevel().unit().path();
	        var unitCache = cache[unitPath];
	        if (!unitCache) {
	            unitCache = {};
	            cache[unitPath] = unitCache;
	        }
	        var val = unitCache[name];
	        if (val !== undefined) {
	            return val;
	        }
	        val = null;
	        val = _.find(globalList, function (x) { return hlimpl.qName(x.highLevel(), context) == name; });
	        if (!val) {
	            val = null;
	        }
	        unitCache[name] = val;
	        return val;
	    };
	    TraitsAndResourceTypesExpander.prototype.createHighLevelNode = function (_api, merge, rp, forceProxy) {
	        if (merge === void 0) { merge = true; }
	        if (rp === void 0) { rp = null; }
	        if (forceProxy === void 0) { forceProxy = false; }
	        var api = _api;
	        var highLevelNodes = [];
	        var node = api;
	        while (node) {
	            var llNode = node.lowLevel();
	            var topComposite;
	            if (api.definition().key() != universeDef.Universe10.Overlay || forceProxy) {
	                topComposite = new proxy.LowLevelCompositeNode(llNode, null, null, this.ramlVersion);
	            }
	            else {
	                topComposite = llNode;
	            }
	            var nodeType = node.definition();
	            var newNode = new hlimpl.ASTNodeImpl(topComposite, null, nodeType, null);
	            highLevelNodes.push(newNode);
	            if (!merge) {
	                break;
	            }
	            node = node.getMaster();
	        }
	        var masterApi = highLevelNodes.pop();
	        highLevelNodes = highLevelNodes.reverse();
	        var mergeMode = api.getMergeMode();
	        return mergeHighLevelNodes(masterApi, highLevelNodes, mergeMode, rp, forceProxy);
	    };
	    TraitsAndResourceTypesExpander.prototype.processResource = function (resource) {
	        var _this = this;
	        var resourceData = this.collectResourceData(resource, resource);
	        var resourceLowLevel = resource.highLevel().lowLevel();
	        resourceData.filter(function (x) { return x.resourceType != null; }).forEach(function (x) {
	            var resourceTypeLowLevel = x.resourceType.node.highLevel().lowLevel();
	            var resourceTypeTransformer = x.resourceType.transformer;
	            resourceTypeTransformer.owner = resource;
	            resourceLowLevel.adopt(resourceTypeLowLevel, resourceTypeTransformer);
	        });
	        var methods = resource.methods();
	        methods.forEach(function (m) {
	            var methodLowLevel = m.highLevel().lowLevel();
	            var name = m.method();
	            var allTraits = [];
	            resourceData.forEach(function (x) {
	                var methodTraits = x.methodTraits[name];
	                if (methodTraits) {
	                    allTraits = allTraits.concat(methodTraits);
	                    methodTraits.forEach(function (x) {
	                        var traitLowLevel = x.node.highLevel().lowLevel();
	                        var traitTransformer = x.transformer;
	                        traitTransformer.owner = m;
	                        methodLowLevel.adopt(traitLowLevel, traitTransformer);
	                    });
	                }
	                var resourceTraits = x.traits;
	                if (resourceTraits) {
	                    allTraits = allTraits.concat(resourceTraits);
	                    resourceTraits.forEach(function (x) {
	                        var traitLowLevel = x.node.highLevel().lowLevel();
	                        var traitTransformer = x.transformer;
	                        traitTransformer.owner = m;
	                        methodLowLevel.adopt(traitLowLevel, traitTransformer);
	                    });
	                }
	            });
	            // if(resource.definition().universe().version()=="RAML10") {
	            //     this.appendTraitReferences(m, allTraits);
	            // }
	        });
	        var resources = resource.resources();
	        resources.forEach(function (x) { return _this.processResource(x); });
	    };
	    TraitsAndResourceTypesExpander.prototype.collectResourceData = function (original, obj, arr, transformer, nodesChain, occuredResourceTypes) {
	        var _this = this;
	        if (arr === void 0) { arr = []; }
	        if (nodesChain === void 0) { nodesChain = []; }
	        if (occuredResourceTypes === void 0) { occuredResourceTypes = {}; }
	        nodesChain = nodesChain.concat([obj.highLevel()]);
	        var ownTraits = this.extractTraits(obj, transformer, nodesChain);
	        var methodTraitsMap = {};
	        var methods = obj.methods();
	        methods.forEach(function (x) {
	            var methodTraits = _this.extractTraits(x, transformer, nodesChain);
	            if (methodTraits && methodTraits.length > 0) {
	                methodTraitsMap[x.method()] = methodTraits;
	            }
	        });
	        var rtData;
	        var rtRef = obj.type();
	        if (rtRef != null) {
	            var units = toUnits1(nodesChain);
	            rtData = this.readGenerictData(original, rtRef, obj.highLevel(), this.resourceTypeMap, this.globalResourceTypes, 'resource type', transformer, units);
	        }
	        var result = {
	            resourceType: rtData,
	            traits: ownTraits,
	            methodTraits: methodTraitsMap
	        };
	        arr.push(result);
	        if (rtData) {
	            var rt = rtData.node;
	            var qName = hlimpl.qName(rt.highLevel(), original.highLevel());
	            if (!occuredResourceTypes[qName]) {
	                occuredResourceTypes[qName] = true;
	                this.collectResourceData(original, rt, arr, rtData.transformer, nodesChain, occuredResourceTypes);
	            }
	            else {
	                result.resourceType = null;
	            }
	        }
	        return arr;
	    };
	    TraitsAndResourceTypesExpander.prototype.extractTraits = function (obj, _transformer, nodesChain, occuredTraits) {
	        var _this = this;
	        if (occuredTraits === void 0) { occuredTraits = {}; }
	        nodesChain = nodesChain.concat([obj.highLevel()]);
	        var arr = [];
	        for (var i = -1; i < arr.length; i++) {
	            var gd = i < 0 ? null : arr[i];
	            var _obj = gd ? gd.node : obj;
	            var units = gd ? gd.unitsChain : toUnits1(nodesChain);
	            var transformer = gd ? gd.transformer : _transformer;
	            if (!_obj['is']) {
	                continue;
	            }
	            _obj.is().forEach(function (x) {
	                var unitsChain = toUnits2(units, x.highLevel());
	                var traitData = _this.readGenerictData(obj, x, _obj.highLevel(), _this.traitMap, _this.globalTraits, 'trait', transformer, unitsChain);
	                if (traitData) {
	                    var name = traitData.name;
	                    //if (!occuredTraits[name]) {
	                    occuredTraits[name] = true;
	                    arr.push(traitData);
	                }
	            });
	        }
	        return arr;
	    };
	    TraitsAndResourceTypesExpander.prototype.readGenerictData = function (r, obj, context, cache, globalList, template, transformer, unitsChain) {
	        if (unitsChain === void 0) { unitsChain = []; }
	        var value = obj.value();
	        if (typeof (value) == 'string') {
	            if (transformer) {
	                value = transformer.transform(value).value;
	            }
	            var node = this.getTemplate(value, context, cache, globalList);
	            if (node) {
	                return {
	                    name: value,
	                    transformer: null,
	                    parentTransformer: transformer,
	                    node: node,
	                    ref: obj,
	                    unitsChain: unitsChain
	                };
	            }
	        }
	        else if (value instanceof hlimpl.StructuredValue) {
	            var sv = value;
	            var name = sv.valueName();
	            if (transformer) {
	                name = transformer.transform(name).value;
	            }
	            var scalarParams = {};
	            var structuredParams = {};
	            var node = this.getTemplate(name, context, cache, globalList);
	            ;
	            //var t = hlimpl.typeFromNode(node.highLevel());
	            if (node) {
	                if (this.ramlVersion == 'RAML08') {
	                    sv.children().forEach(function (x) { return scalarParams[x.valueName()] = x.lowLevel().value(); });
	                }
	                else {
	                    sv.children().forEach(function (x) {
	                        var llNode = x.lowLevel();
	                        if (llNode.valueKind() == yaml.Kind.SCALAR) {
	                            scalarParams[x.valueName()] = llNode.value();
	                        }
	                        else if (llNode.valueKind() == yaml.Kind.INCLUDE_REF) {
	                            if (llNode.children().length == 0) {
	                                scalarParams[x.valueName()] = llNode.value();
	                            }
	                            else {
	                                structuredParams[x.valueName()] = llNode;
	                            }
	                        }
	                        else {
	                            structuredParams[x.valueName()] = llNode;
	                        }
	                    });
	                }
	                var ds = new DefaultTransformer(r, null, unitsChain);
	                Object.keys(scalarParams).forEach(function (x) {
	                    var q = ds.transform(scalarParams[x]);
	                    //if (q.value){
	                    if (q) {
	                        if (typeof q !== "object") {
	                            scalarParams[x] = q;
	                        }
	                    }
	                    //}
	                });
	                var valTransformer = new ValueTransformer(template, name, unitsChain, scalarParams, structuredParams, transformer);
	                var resourceTypeTransformer = new DefaultTransformer(null, valTransformer, unitsChain);
	                return {
	                    name: name,
	                    transformer: resourceTypeTransformer,
	                    parentTransformer: transformer,
	                    node: node,
	                    ref: obj,
	                    unitsChain: unitsChain
	                };
	            }
	        }
	        return null;
	    };
	    TraitsAndResourceTypesExpander.prototype.appendTraitReferences = function (m, traits) {
	        if (traits.length == 0) {
	            return;
	        }
	        var traitsData = traits.map(function (x) {
	            return {
	                node: x.ref.highLevel().lowLevel(),
	                transformer: x.parentTransformer
	            };
	        });
	        referencePatcher.patchMethodIs(m.highLevel(), traitsData);
	    };
	    return TraitsAndResourceTypesExpander;
	}());
	exports.TraitsAndResourceTypesExpander = TraitsAndResourceTypesExpander;
	var LibraryExpander = (function () {
	    function LibraryExpander() {
	    }
	    LibraryExpander.prototype.expandLibraries = function (_api) {
	        var api = _api;
	        if (api == null) {
	            return null;
	        }
	        if (api.highLevel().lowLevel() instanceof proxy.LowLevelCompositeNode) {
	            api = api.highLevel().lowLevel().unit().highLevel().asElement().wrapperNode();
	        }
	        var expander = new TraitsAndResourceTypesExpander();
	        var rp = new referencePatcher.ReferencePatcher();
	        var hlNode = expander.createHighLevelNode(api.highLevel(), true, rp, true);
	        var result = expander.expandHighLevelNode(hlNode, rp, api);
	        this.processNode(rp, result.highLevel());
	        return result;
	    };
	    LibraryExpander.prototype.processNode = function (rp, hlNode) {
	        if (hlNode == null) {
	            return;
	        }
	        var master = hlNode.getMaster();
	        this.processNode(rp, master);
	        if (universeHelpers.isOverlayType(hlNode.definition())) {
	            rp.process(hlNode);
	        }
	        rp.expandLibraries(hlNode);
	    };
	    return LibraryExpander;
	}());
	exports.LibraryExpander = LibraryExpander;
	function toUnits1(nodes) {
	    var result = [];
	    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
	        var n = nodes_1[_i];
	        toUnits2(result, n, true);
	    }
	    return result;
	}
	function toUnits2(chainStart, node, append) {
	    if (append === void 0) { append = false; }
	    var result = append ? chainStart : chainStart.concat([]);
	    var unit = node.lowLevel().unit();
	    if (unit == null) {
	        return result;
	    }
	    if (result.length == 0) {
	        result.push(unit);
	    }
	    else {
	        var prevPath = result[result.length - 1].absolutePath();
	        if (unit.absolutePath() != prevPath) {
	            result.push(unit);
	        }
	    }
	    return result;
	}
	function toUnits(node) {
	    var nodes = [];
	    while (node) {
	        nodes.push(node);
	        node = node.parent();
	    }
	    return toUnits1(nodes);
	}
	exports.toUnits = toUnits;
	var TransformMatches = (function () {
	    function TransformMatches(name, transformer) {
	        this.name = name;
	        this.regexp = new RegExp(TransformMatches.leftTransformRegexp.source + name + TransformMatches.rightTransformRegexp.source);
	        this.transformer = transformer;
	    }
	    TransformMatches.leftTransformRegexp = /\|\s*!\s*/;
	    TransformMatches.rightTransformRegexp = /\s*$/;
	    return TransformMatches;
	}());
	var transformers = [
	    new TransformMatches("singularize", function (arg) { return pluralize.singular(arg); }),
	    new TransformMatches("pluralize", function (arg) { return pluralize.plural(arg); }),
	    new TransformMatches("uppercase", function (arg) { return arg ? arg.toUpperCase() : arg; }),
	    new TransformMatches("lowercase", function (arg) { return arg ? arg.toLowerCase() : arg; }),
	    new TransformMatches("lowercamelcase", function (arg) {
	        if (!arg) {
	            return arg;
	        }
	        return changeCase.camelCase(arg);
	    }),
	    new TransformMatches("uppercamelcase", function (arg) {
	        if (!arg) {
	            return arg;
	        }
	        var lowerCamelCase = changeCase.camelCase(arg);
	        return lowerCamelCase[0].toUpperCase() + lowerCamelCase.substring(1, lowerCamelCase.length);
	    }),
	    new TransformMatches("lowerunderscorecase", function (arg) {
	        if (!arg) {
	            return arg;
	        }
	        var snakeCase = changeCase.snake(arg);
	        return snakeCase.toLowerCase();
	    }),
	    new TransformMatches("upperunderscorecase", function (arg) {
	        if (!arg) {
	            return arg;
	        }
	        var snakeCase = changeCase.snake(arg);
	        return snakeCase.toUpperCase();
	    }),
	    new TransformMatches("lowerhyphencase", function (arg) {
	        if (!arg) {
	            return arg;
	        }
	        var paramCase = changeCase.param(arg);
	        return paramCase.toLowerCase();
	    }),
	    new TransformMatches("upperhyphencase", function (arg) {
	        if (!arg) {
	            return arg;
	        }
	        var paramCase = changeCase.param(arg);
	        return paramCase.toUpperCase();
	    })
	];
	function getTransformNames() {
	    return transformers.map(function (transformer) { return transformer.name; });
	}
	exports.getTransformNames = getTransformNames;
	function getTransformerForOccurence(occurence) {
	    var result;
	    for (var i = 0; i < transformers.length; i++) {
	        if (occurence.match(transformers[i].regexp)) {
	            result = transformers[i].transformer;
	            break;
	        }
	    }
	    return result;
	}
	exports.getTransformerForOccurence = getTransformerForOccurence;
	var TransformationBuffer = (function () {
	    function TransformationBuffer() {
	        this.buf = null;
	    }
	    TransformationBuffer.prototype.append = function (value) {
	        if (value !== "") {
	            if (this.buf != null) {
	                if (value != null) {
	                    if (typeof (this.buf) != "string") {
	                        this.buf = "" + this.buf;
	                    }
	                    this.buf += value;
	                }
	            }
	            else if (value !== "") {
	                this.buf = value;
	            }
	        }
	    };
	    TransformationBuffer.prototype.value = function () {
	        return this.buf != null ? this.buf : "";
	    };
	    return TransformationBuffer;
	}());
	var ValueTransformer = (function () {
	    function ValueTransformer(templateKind, templateName, unitsChain, params, structuredParams, vDelegate) {
	        this.templateKind = templateKind;
	        this.templateName = templateName;
	        this.unitsChain = unitsChain;
	        this.params = params;
	        this.structuredParams = structuredParams;
	        this.vDelegate = vDelegate;
	    }
	    ValueTransformer.prototype.transform = function (obj, toString, doBreak, callback) {
	        var undefParams = {};
	        var errors = [];
	        if (typeof (obj) === 'string') {
	            if (this.structuredParams && util.stringStartsWith(obj, "<<") && util.stringEndsWith(obj, ">>")) {
	                var paramName = obj.substring(2, obj.length - 2);
	                var structuredValue = this.structuredParams[paramName];
	                if (structuredValue != null) {
	                    return { value: structuredValue.value(toString), errors: errors };
	                }
	            }
	            var str = obj;
	            var buf = new TransformationBuffer();
	            var prev = 0;
	            for (var i = str.indexOf('<<'); i >= 0; i = str.indexOf('<<', prev)) {
	                buf.append(str.substring(prev, i));
	                var i0 = i;
	                i += '<<'.length;
	                prev = this.paramUpperBound(str, i);
	                if (prev == -1) {
	                    break;
	                }
	                var paramOccurence = str.substring(i, prev);
	                prev += '>>'.length;
	                var originalString = str.substring(i0, prev);
	                var val;
	                var paramName;
	                var transformer = getTransformerForOccurence(paramOccurence);
	                if (transformer) {
	                    var ind = paramOccurence.lastIndexOf('|');
	                    paramName = paramOccurence.substring(0, ind).trim();
	                    val = this.params[paramName];
	                    if (val && typeof (val) == "string" && val.indexOf("<<") >= 0 && this.vDelegate) {
	                        val = this.vDelegate.transform(val, toString, doBreak, callback).value;
	                    }
	                    if (val) {
	                        val = transformer(val);
	                    }
	                }
	                else {
	                    paramName = paramOccurence.trim();
	                    val = this.params[paramName];
	                    if (val && typeof (val) == "string" && val.indexOf("<<") >= 0 && this.vDelegate) {
	                        val = this.vDelegate.transform(val, toString, doBreak, callback).value;
	                    }
	                }
	                if (val === null || val === undefined) {
	                    undefParams[paramName] = true;
	                    val = originalString;
	                }
	                buf.append(val);
	            }
	            var upArr = Object.keys(undefParams);
	            if (upArr.length > 0) {
	                var errStr = upArr.join(', ').trim();
	                var message = "Undefined " + this.templateKind + " parameter" + (upArr.length > 1 ? 's' : '') + ": " + errStr;
	                var error = {
	                    code: hl.IssueCode.MISSING_REQUIRED_PROPERTY,
	                    isWarning: false,
	                    message: message,
	                    node: null,
	                    start: -1,
	                    end: -1,
	                    path: null
	                };
	                errors.push(error);
	            }
	            buf.append(str.substring(prev, str.length));
	            return { value: buf.value(), errors: errors };
	        }
	        else {
	            return { value: obj, errors: errors };
	        }
	    };
	    ValueTransformer.prototype.paramUpperBound = function (str, pos) {
	        var count = 0;
	        for (var i = pos; i < str.length; i++) {
	            if (util.stringStartsWith(str, "<<", i)) {
	                count++;
	                i++;
	            }
	            else if (util.stringStartsWith(str, ">>", i)) {
	                if (count == 0) {
	                    return i;
	                }
	                count--;
	                i++;
	            }
	        }
	        return str.length;
	    };
	    ValueTransformer.prototype.children = function (node) {
	        var substitution = this.substitutionNode(node);
	        if (substitution) {
	            return substitution.children();
	        }
	        return null;
	    };
	    ValueTransformer.prototype.valueKind = function (node) {
	        var substitution = this.substitutionNode(node);
	        if (substitution) {
	            return substitution.valueKind();
	        }
	        return null;
	    };
	    ValueTransformer.prototype.substitutionNode = function (node) {
	        var paramName = this.paramName(node);
	        return paramName && this.structuredParams[paramName];
	    };
	    ValueTransformer.prototype.paramName = function (node) {
	        var paramName = null;
	        if (node.valueKind() == yaml.Kind.SCALAR) {
	            var val = ("" + node.value()).trim();
	            if (util.stringStartsWith(val, "<<") && util.stringEndsWith(val, ">>")) {
	                paramName = val.substring(2, val.length - 2);
	            }
	        }
	        return paramName;
	    };
	    return ValueTransformer;
	}());
	exports.ValueTransformer = ValueTransformer;
	var DefaultTransformer = (function (_super) {
	    __extends(DefaultTransformer, _super);
	    function DefaultTransformer(owner, delegate, unitsChain) {
	        _super.call(this, delegate != null ? delegate.templateKind : "", delegate != null ? delegate.templateName : "", unitsChain);
	        this.owner = owner;
	        this.delegate = delegate;
	    }
	    DefaultTransformer.prototype.transform = function (obj, toString, doContinue, callback) {
	        if (obj == null || (doContinue != null && !doContinue())) {
	            return {
	                value: obj,
	                errors: []
	            };
	        }
	        var ownResult = {
	            value: obj,
	            errors: []
	        };
	        var gotDefaultParam = false;
	        defaultParameters.forEach(function (x) { return gotDefaultParam = gotDefaultParam || obj.toString().indexOf('<<' + x) >= 0; });
	        if (gotDefaultParam) {
	            this.initParams();
	            ownResult = _super.prototype.transform.call(this, obj, toString, doContinue, callback);
	        }
	        var result = this.delegate != null
	            ? this.delegate.transform(ownResult.value, toString, doContinue, callback)
	            : ownResult.value;
	        if (doContinue != null && doContinue() && callback != null) {
	            result.value = callback(result.value, this);
	        }
	        return result;
	    };
	    DefaultTransformer.prototype.initParams = function () {
	        var methodName;
	        var resourcePath = "";
	        var resourcePathName;
	        var ll = this.owner.highLevel().lowLevel();
	        var node = ll instanceof proxy.LowLevelProxyNode ? ll.originalNode().originalNode() : ll;
	        var last = null;
	        while (node) {
	            var key = node.key();
	            if (key != null) {
	                if (util.stringStartsWith(key, '/')) {
	                    if (!resourcePathName) {
	                        var arr = key.split('/');
	                        for (var i = arr.length - 1; i >= 0; i--) {
	                            var seg = arr[i];
	                            if (seg.indexOf('{') == -1) {
	                                resourcePathName = arr[i];
	                                break;
	                            }
	                            if (seg.length > 0) {
	                                last = seg;
	                            }
	                        }
	                    }
	                    resourcePath = key + resourcePath;
	                }
	                else {
	                    methodName = key;
	                }
	            }
	            node = node.parent();
	        }
	        if (!resourcePathName) {
	            if (last) {
	                resourcePathName = "";
	            }
	        }
	        this.params = {
	            resourcePath: resourcePath,
	            resourcePathName: resourcePathName
	        };
	        if (methodName) {
	            this.params['methodName'] = methodName;
	        }
	    };
	    DefaultTransformer.prototype.children = function (node) {
	        return this.delegate != null ? this.delegate.children(node) : null;
	    };
	    DefaultTransformer.prototype.valueKind = function (node) {
	        return this.delegate != null ? this.delegate.valueKind(node) : null;
	    };
	    return DefaultTransformer;
	}(ValueTransformer));
	exports.DefaultTransformer = DefaultTransformer;
	var defaultParameters = ['resourcePath', 'resourcePathName', 'methodName'];
	//# sourceMappingURL=expander.js.map

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/// <reference path="../../../typings/main.d.ts" />
	"use strict";
	var jsyaml = __webpack_require__(27);
	var json = __webpack_require__(50);
	var stringify = __webpack_require__(62);
	var proxy = __webpack_require__(39);
	var hl = __webpack_require__(10);
	var ll = __webpack_require__(11);
	var _ = __webpack_require__(63);
	var yaml = __webpack_require__(72);
	var def = __webpack_require__(36);
	var hlimpl = __webpack_require__(16);
	var path = __webpack_require__(15);
	var fs = __webpack_require__(38);
	var universes = __webpack_require__(22);
	var universeHelpers = __webpack_require__(14);
	var universeProvider = __webpack_require__(35);
	var services = def;
	var OverloadingValidator = __webpack_require__(51);
	var expander = __webpack_require__(24);
	var search = __webpack_require__(23);
	var rtypes = def.rt;
	var util = __webpack_require__(42);
	var contentprovider = __webpack_require__(31);
	var resourceRegistry = __webpack_require__(28);
	var su = def.getSchemaUtils();
	var mediaTypeParser = __webpack_require__(61);
	var xmlutil = __webpack_require__(52);
	var changeCase = __webpack_require__(71);
	var pluralize = __webpack_require__(70);
	var LinterSettings = (function () {
	    function LinterSettings() {
	        this.validateNotStrictExamples = true;
	    }
	    return LinterSettings;
	}());
	var settings = new LinterSettings();
	var loophole = __webpack_require__(78);
	function evalInSandbox(code, thisArg, args) {
	    return new loophole.Function(code).call(thisArg, args);
	}
	var MAX_RECURSION_LEVEL = 400;
	exports.RESERVED_TEMPLATE_PARAMETERS = {
	    "resourcePathName": "Part of the resource path following the rightmost \"/\"",
	    "methodName": "Method name",
	    "resourcePath": "Path of the resource"
	};
	var lintWithFile = function (customLinter, acceptor, astNode) {
	    if (fs.existsSync(customLinter)) {
	        try {
	            var content = fs.readFileSync(customLinter).toString();
	            var factr = new LinterExtensionsImpl(acceptor);
	            evalInSandbox(content, factr, null);
	            factr.visit(astNode);
	        }
	        catch (e) {
	            console.log("Error in custom linter");
	            console.log(e);
	        }
	    }
	};
	function checkPropertyQuard(n, v) {
	    var pr = n.property();
	    if (pr) {
	        pr.getContextRequirements().forEach(function (x) {
	            if (!n.checkContextValue(x.name, x.value, x.value)) {
	                v.accept(createIssue(hl.IssueCode.MISSED_CONTEXT_REQUIREMENT, x.name + " should be " + x.value + " to use property " + pr.nameId(), n));
	            }
	        });
	    }
	    return pr;
	}
	;
	function lintNode(astNode, acceptor) {
	    var fsEnabled;
	    try {
	        fsEnabled = astNode.lowLevel().unit().project().fsEnabled();
	    }
	    catch (exception) {
	        fsEnabled = true;
	    }
	    if (!fsEnabled) {
	        return;
	    }
	    if (typeof fs === "undefined") {
	        return;
	    }
	    if (!fs) {
	        return;
	    }
	    var fsMethods = ['exists', 'readFile', 'writeFile', 'readdir', 'existsSync', 'readFileSync', 'writeFileSync', 'readdirSync'];
	    var existingFsFields = Object.keys(fs);
	    for (var i = 0; i < fsMethods.length; i++) {
	        if (!fs[fsMethods[i]]) {
	            return;
	        }
	    }
	    var ps = astNode.lowLevel().unit().absolutePath();
	    var dr = path.dirname(ps);
	    var customLinter = path.resolve(dr, "raml-lint.js");
	    lintWithFile(customLinter, acceptor, astNode);
	    var dir = path.resolve(dr, ".raml");
	    if (fs.existsSync(dir)) {
	        var st = fs.statSync(dir);
	        if (st.isDirectory()) {
	            var files = fs.readdirSync(dir);
	            files.forEach(function (x) {
	                if (x.indexOf("-lint.js") != -1) {
	                    lintWithFile(path.resolve(dir, x), acceptor, astNode);
	                }
	                //console.log(x);
	            });
	        }
	    }
	}
	;
	var LinterExtensionsImpl = (function () {
	    function LinterExtensionsImpl(acceptor) {
	        this.acceptor = acceptor;
	        this.nodes = {};
	    }
	    LinterExtensionsImpl.prototype.error = function (w, message) {
	        this.acceptor.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, message, w.highLevel()));
	    };
	    LinterExtensionsImpl.prototype.errorOnProperty = function (w, property, message) {
	        var pr = w.highLevel().attr(property);
	        this.acceptor.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, message, pr));
	    };
	    LinterExtensionsImpl.prototype.warningOnProperty = function (w, property, message) {
	        var pr = w.highLevel().attr(property);
	        this.acceptor.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, message, pr, true));
	    };
	    LinterExtensionsImpl.prototype.warning = function (w, message) {
	        this.acceptor.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, message, w.highLevel(), true));
	    };
	    LinterExtensionsImpl.prototype.registerRule = function (nodeType, rule) {
	        var q = this.nodes[nodeType];
	        if (!q) {
	            q = [];
	            this.nodes[nodeType] = q;
	        }
	        q.push(rule);
	    };
	    LinterExtensionsImpl.prototype.visit = function (h) {
	        var _this = this;
	        var nd = h.definition();
	        this.process(nd, h);
	        nd.allSuperTypes().forEach(function (x) { return _this.process(x, h); });
	        h.elements().forEach(function (y) { return _this.visit(y); });
	    };
	    LinterExtensionsImpl.prototype.process = function (d, h) {
	        var _this = this;
	        if (d instanceof def.NodeClass) {
	            if (!d.getAdapter(services.RAMLService).getDeclaringNode()) {
	                var rules = this.nodes[d.nameId()];
	                if (rules) {
	                    rules.forEach(function (x) { return x(h.wrapperNode(), _this); });
	                }
	            }
	        }
	    };
	    return LinterExtensionsImpl;
	}());
	var StackNode = (function () {
	    function StackNode() {
	    }
	    StackNode.prototype.toString = function () {
	        if (this.prev) {
	            return this.value + "." + this.prev.toString();
	        }
	        return this.value;
	    };
	    StackNode.prototype.last = function () {
	        if (this.prev) {
	            return this.prev.last();
	        }
	        return this;
	    };
	    return StackNode;
	}());
	function isTypeOrSchema(d) {
	    return d.nameId() == universes.Universe10.TypeDeclaration.properties.type.name || d.nameId() == universes.Universe10.TypeDeclaration.properties.schema.name;
	}
	function isDefaultValueProp(d) {
	    if (!checkIfDomainIsUserDefined(d)) {
	        return false;
	    }
	    return (d.nameId() == universes.Universe10.TypeDeclaration.properties.default.name);
	}
	function isExampleProp(d) {
	    if (!checkIfDomainIsUserDefined(d)) {
	        return false;
	    }
	    return (d.nameId() == universes.Universe10.TypeDeclaration.properties.example.name);
	}
	function checkIfDomainIsUserDefined(d) {
	    if (!d.domain()) {
	        return false;
	    }
	    if (d.domain().getAdapter(services.RAMLService).isUserDefined()) {
	        return false;
	    }
	    return true;
	}
	function isSecuredBy(d) {
	    if (!checkIfDomainIsUserDefined(d)) {
	        return false;
	    }
	    return (d.nameId() == universes.Universe08.MethodBase.properties.securedBy.name);
	}
	/**
	 * For descendants of templates returns template type. Returns null for all other nodes.
	 */
	function typeOfContainingTemplate(h) {
	    var declRoot = h;
	    while (true) {
	        if (declRoot.definition().getAdapter(services.RAMLService).isInlinedTemplates()) {
	            return declRoot.definition().nameId();
	        }
	        var np = declRoot.parent();
	        if (!np) {
	            break;
	        }
	        else {
	            declRoot = np;
	        }
	    }
	    return null;
	}
	function restrictUnknownNodeError(node) {
	    var parentNode = node.parent();
	    var issue = null;
	    var parentDef = parentNode.definition();
	    if (parentNode && parentDef instanceof def.UserDefinedClass) {
	        var parentProperty = parentNode.property();
	        if (universeHelpers.isIsProperty(parentProperty)
	            || universeHelpers.isTypeProperty(parentProperty)) {
	            var paramName = node.name();
	            if (exports.RESERVED_TEMPLATE_PARAMETERS[paramName] != null) {
	                //Handling reserved parameter names;
	                issue = createIssue(hl.IssueCode.INVALID_PROPERTY, "Invalid parameter name: " + paramName + " is reserved", node);
	            }
	            else {
	                issue = createIssue(hl.IssueCode.UNKNOWN_NODE, "Unused parameter: " + paramName, node);
	            }
	        }
	    }
	    if (!issue) {
	        var propName = node.name();
	        var universe08 = universeProvider("RAML08");
	        var isRAML08 = parentDef.universe().version() == universe08.version();
	        if (isRAML08) {
	            var parameterTypeName = universes.Universe08.Parameter.name;
	            var typeDeclarationTypeName = universes.Universe10.TypeDeclaration.name;
	            if (isRAML08 && parentDef.isAssignableFrom(parameterTypeName)) {
	                var possibleDefs = universe08.type(parameterTypeName).allSubTypes().filter(function (x) {
	                    return universes.Universe08[x.nameId()]['properties'][propName] != null;
	                });
	                var possibleDefsMap = {};
	                for (var i = 0; i < possibleDefs.length; i++) {
	                    var x = possibleDefs[i];
	                    if (possibleDefsMap[x.nameId()]) {
	                        continue;
	                    }
	                    var valueRequirements = x.valueRequirements();
	                    if (!(valueRequirements && valueRequirements.length != 0)) {
	                        continue;
	                    }
	                    var typeRquirements = valueRequirements.filter(function (x) { return x.name == 'type'; }).map(function (x) { return x.value; });
	                    if (typeRquirements.length == 0) {
	                        continue;
	                    }
	                    var runtimeName = typeRquirements[0];
	                    possibleDefsMap[x.nameId()] = runtimeName;
	                    x.allSubTypes().forEach(function (y) { return possibleDefs.push(y); });
	                }
	                var runtimeNames = Object.keys(possibleDefsMap).map(function (x) { return possibleDefsMap[x]; }).sort();
	                ;
	                if (runtimeNames.length > 0) {
	                    var namesStr = runtimeNames.map(function (x, i) {
	                        var x1 = "'" + x + "'";
	                        if (i == runtimeNames.length - 1) {
	                            return x1;
	                        }
	                        if (i == runtimeNames.length - 2) {
	                            return x1 + ' or ';
	                        }
	                        return x1 + ', ';
	                    }).join('');
	                    var message = "Property '" + propName + "' can only be used if type is " + namesStr;
	                    issue = createIssue(hl.IssueCode.ILLEGAL_PROPERTY, message, node);
	                }
	            }
	        }
	    }
	    return issue;
	}
	;
	function validateBasic(node, v, requiredOnly) {
	    if (requiredOnly === void 0) { requiredOnly = false; }
	    var parentNode = node.parent();
	    var llValue = node.lowLevel().value();
	    if (node.lowLevel()) {
	        if (node.lowLevel().keyKind() == yaml.Kind.MAP) {
	            v.accept(createIssue(hl.IssueCode.UNKNOWN_NODE, "Node key can not be map", node));
	        }
	        if (node.lowLevel().keyKind() == yaml.Kind.SEQ) {
	            if (llValue == null) {
	                var isPattern = false;
	                if (node.isElement()) {
	                    if (node.asElement().definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name)) {
	                        isPattern = true;
	                    }
	                }
	                if (!isPattern) {
	                    v.accept(createIssue(hl.IssueCode.UNKNOWN_NODE, "Node key can not be sequence", node));
	                }
	            }
	        }
	        if (parentNode == null) {
	            node.lowLevel().errors().forEach(function (x) {
	                var ps = x.mark ? x.mark.position : 0;
	                var em = {
	                    code: hl.IssueCode.YAML_ERROR,
	                    message: x.message,
	                    node: null,
	                    start: ps,
	                    end: ps + 1,
	                    isWarning: false,
	                    path: node.lowLevel().unit() == node.root().lowLevel().unit() ? null : node.lowLevel().unit().path(),
	                    unit: node.lowLevel().unit()
	                };
	                v.accept(em);
	            });
	        }
	    }
	    // if (node.errorMessage){
	    //     v.accept(createIssue(hl.IssueCode.UNKNOWN_NODE, node.errorMessage, node));
	    //     return;
	    // }
	    if (node.isUnknown()) {
	        if (node.name().indexOf("<<") != -1) {
	            if (typeOfContainingTemplate(parentNode) != null) {
	                new TraitVariablesValidator().validateName(node, v);
	                return;
	            }
	        }
	        if (node.needSequence) {
	            v.accept(createIssue(hl.IssueCode.UNKNOWN_NODE, "node: " + node.name() + " should be wrapped in sequence", node));
	        }
	        if (node.needMap) {
	            v.accept(createIssue(hl.IssueCode.UNKNOWN_NODE, (node.knownProperty ? node.knownProperty.nameId() : "") + " should be a map in RAML 1.0", node));
	            return;
	        }
	        if (node.unresolvedRef) {
	            v.accept(createIssue(hl.IssueCode.UNKNOWN_NODE, "reference: " + llValue + " can not be resolved", node));
	        }
	        if (node.knownProperty) {
	            //if (!node.lowLevel().)
	            if (node.lowLevel().includeErrors().length == 0) {
	                if (typeOfContainingTemplate(parentNode)
	                    && util.startsWith(llValue, "<<")
	                    && util.endsWith(llValue, ">>")) {
	                    return;
	                }
	                if (node.name() == "body" && node.computedValue("mediaType")) {
	                    return;
	                }
	                if (node.lowLevel().value() != '~') {
	                    v.accept(createIssue(hl.IssueCode.UNKNOWN_NODE, "property " + node.name() + " can not have scalar value", node));
	                }
	            }
	        }
	        else {
	            var issue = restrictUnknownNodeError(node);
	            if (!issue) {
	                issue = createIssue(hl.IssueCode.UNKNOWN_NODE, "Unknown node: " + node.name(), node);
	            }
	            v.accept(issue);
	        }
	    }
	    if (node.markCh() && !node.allowRecursive()) {
	        if (!node.property()) {
	            return;
	        }
	        v.accept(createIssue(hl.IssueCode.UNKNOWN_NODE, "Recursive definition: " + node.name(), node));
	        return;
	    }
	    if (node.definition && node.definition().isAssignableFrom(universes.Universe10.Operation.name)) {
	        var queryStringNode = node.element(universes.Universe10.Operation.properties.queryString.name);
	        var queryParamsNode = node.lowLevel && _.find(node.lowLevel().children(), function (child) { return child.key && child.key() === universes.Universe10.Operation.properties.queryParameters.name; });
	        if (queryStringNode && queryParamsNode) {
	            v.accept(createIssue(hl.IssueCode.UNKNOWN_NODE, universes.Universe10.Operation.properties.queryParameters.name + " already specified.", queryStringNode));
	            v.accept(createLLIssue(hl.IssueCode.UNKNOWN_NODE, universes.Universe10.Operation.properties.queryString.name + " already specified.", queryParamsNode, node));
	        }
	    }
	    try {
	        var isOverlay = node.definition && node.definition() && node.definition().key() === universes.Universe10.Overlay;
	        var children = isOverlay ? node.children() : node.directChildren();
	        children.filter(function (child) {
	            return !requiredOnly || (child.property && child.property() && child.property().isRequired());
	        }).forEach(function (x) {
	            if (x && x.errorMessage) {
	                v.accept(createIssue(hl.IssueCode.UNKNOWN_NODE, x.errorMessage, x.name() ? x : node));
	                return;
	            }
	            x.validate(v);
	        });
	    }
	    finally {
	        node.unmarkCh();
	    }
	}
	exports.validateBasic = validateBasic;
	function hasTemplateArgs(node) {
	    var vl = node.value();
	    if (typeof vl == "string") {
	        if (vl.indexOf("<<") != -1) {
	            return true;
	        }
	    }
	    var x = node.children();
	    for (var i = 0; i < x.length; i++) {
	        if (hasTemplateArgs(x[i])) {
	            return true;
	        }
	    }
	    return false;
	}
	var createLibraryIssue = function (attr, hlNode) {
	    var start = hlNode.lowLevel().start();
	    var usesNodes = [];
	    if (start < 0) {
	        var seq = hlNode.attr("key").value().split(".");
	        var nodes = [];
	        var parent = hlNode.parent();
	        for (var _i = 0, seq_1 = seq; _i < seq_1.length; _i++) {
	            var segment = seq_1[_i];
	            var n = _.find(parent.elementsOfKind("uses"), function (x) { return x.attr("key") && x.attr("key").value() == segment; });
	            nodes.push(n);
	            parent = n.lowLevel().unit().resolve(n.attr("value").value()).highLevel().asElement();
	        }
	        var issues = nodes.map(function (x) { return createIssue(hl.IssueCode.UNRESOLVED_REFERENCE, "Issues in the used library:" + x.attr("value").value(), x, true); });
	        issues = issues.reverse();
	        for (var i = 0; i < issues.length - 1; i++) {
	            issues[i].extras.push(issues[i + 1]);
	        }
	        return issues[0];
	    }
	    else {
	        usesNodes.push(hlNode);
	    }
	    return createIssue(hl.IssueCode.UNRESOLVED_REFERENCE, "Issues in the used library:" + attr.value(), hlNode, true);
	};
	function validate(node, v) {
	    if (!node.parent()) {
	        try {
	            validateIncludes(node, v);
	        }
	        finally {
	            cleanupIncludesFlag(node, v);
	        }
	    }
	    if (node.isAttr()) {
	        new CompositePropertyValidator().validate(node, v);
	    }
	    else if (node.isElement()) {
	        if (node.invalidSequence) {
	            var pName = node.property().nameId();
	            var msg = changeCase.sentenceCase(pluralize.singular(pName));
	            msg = "In RAML 1.0 " + msg + " is not allowed to have sequence as definition";
	            v.acceptUnique(createLLIssue(hl.IssueCode.UNKNOWN_NODE, msg, node.lowLevel().parent().parent(), node, false));
	        }
	        var highLevelNode = node.asElement();
	        if (universeHelpers.isExampleSpecType(highLevelNode.definition())) {
	            var hlChildren = highLevelNode.children();
	            if (hlChildren.length == 0) {
	                validateBasic(node, v, true);
	                return;
	            }
	            var content = hlChildren.filter(function (x) {
	                var propName = x.lowLevel().key();
	                if (!propName) {
	                    return true;
	                }
	                if (propName.charAt(0) == "(" && propName.charAt(propName.length - 1) == ")") {
	                    return false;
	                }
	                return highLevelNode.definition().property(propName) == null;
	            });
	            if (content.length > 0) {
	                validateBasic(node, v, true);
	                return;
	            }
	        }
	        if (highLevelNode.definition().isAnnotationType() || highLevelNode.property() && highLevelNode.property().nameId() == "annotations") {
	            new FixedFacetsValidator().validate(highLevelNode, v);
	            return;
	        }
	        if (highLevelNode.definition().isAssignableFrom(universes.Universe10.UsesDeclaration.name)) {
	            var vn = highLevelNode.attr(universes.Universe10.UsesDeclaration.properties.value.name);
	            if (vn && vn.value()) {
	                var rs = highLevelNode.lowLevel().unit().resolve(vn.value());
	                if (!rs) {
	                    v.accept(createIssue(hl.IssueCode.UNRESOLVED_REFERENCE, "Can not resolve library from path:" + vn.value(), highLevelNode, false));
	                }
	                else if (!resourceRegistry.isWaitingFor(vn.value())) {
	                    var issues = [];
	                    rs.highLevel().validate(hlimpl.createBasicValidationAcceptor(issues));
	                    if (issues.length > 0) {
	                        var brand = createLibraryIssue(vn, highLevelNode);
	                        issues.forEach(function (x) {
	                            x.unit = x.unit == null ? rs : x.unit;
	                            if (!x.path) {
	                                x.path = rs.absolutePath();
	                            }
	                        });
	                        for (var _i = 0, issues_1 = issues; _i < issues_1.length; _i++) {
	                            var issue = issues_1[_i];
	                            var _issue = issue;
	                            while (_issue.extras.length > 0) {
	                                _issue = _issue.extras[0];
	                            }
	                            _issue.extras.push(brand);
	                            v.accept(issue);
	                        }
	                    }
	                }
	            }
	        }
	        if (highLevelNode.definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name)) {
	            if (typeOfContainingTemplate(highLevelNode)) {
	                if (hasTemplateArgs(highLevelNode.lowLevel())) {
	                    return;
	                }
	            }
	            highLevelNode.attrs().forEach(function (a) {
	                var range = a.property().range().key();
	                if (range == universes.Universe08.RelativeUriString || range == universes.Universe10.RelativeUriString) {
	                    new UriValidator().validate(a, v);
	                    return;
	                }
	                if (range == universes.Universe08.FullUriTemplateString || range == universes.Universe10.FullUriTemplateString) {
	                    new UriValidator().validate(a, v);
	                    return;
	                }
	                if (a.property().getAdapter(services.RAMLPropertyService).isKey()) {
	                    var nameId = node.property() && node.property().nameId();
	                    if (nameId == universes.Universe08.Resource.properties.uriParameters.name
	                        || nameId == universes.Universe08.Resource.properties.baseUriParameters.name) {
	                        //new UrlParameterNameValidator().validate(a, v);
	                        return;
	                    }
	                    if (highLevelNode.property()) {
	                        if (highLevelNode.property().nameId() ==
	                            universes.Universe10.MethodBase.properties.body.name) {
	                            new MediaTypeValidator().validate(a, v);
	                            return;
	                        }
	                    }
	                }
	            });
	            if (highLevelNode.parent() && !highLevelNode.parent().parent()) {
	                if (rtypes.builtInTypes().get(highLevelNode.name())) {
	                    v.accept(createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, "redefining a built in type:" + highLevelNode.name(), highLevelNode));
	                }
	            }
	            new RecurrentOverlayValidator().validate(highLevelNode, v);
	            new RecurrentValidateChildrenKeys().validate(highLevelNode, v);
	            new NodeSpecificValidator().validate(highLevelNode, v);
	            new TypeDeclarationValidator().validate(highLevelNode, v);
	            return;
	        }
	        if (highLevelNode.definition().isAssignableFrom(universes.Universe10.LibraryBase.name)) {
	            var hasSchemas = false;
	            var hasTypes = false;
	            var vv;
	            highLevelNode.lowLevel().children().forEach(function (x) {
	                if (x.key() == "schemas") {
	                    hasSchemas = true;
	                    vv = x;
	                }
	                if (x.key() == "types") {
	                    hasTypes = true;
	                }
	            });
	            if (hasSchemas && hasTypes) {
	                v.accept(localLowLevelError(vv, highLevelNode, hl.IssueCode.ILLEGAL_PROPERTY_VALUE, false, "types and schemas are mutually exclusive", false));
	            }
	        }
	        var hasRequireds = highLevelNode.definition().requiredProperties() && highLevelNode.definition().requiredProperties().length > 0;
	        var isAllowAny = highLevelNode.definition().getAdapter(services.RAMLService).getAllowAny();
	        if (isAllowAny) {
	            if (hasRequireds) {
	                validateBasic(node, v, true);
	            }
	        }
	        else {
	            validateBasic(node, v);
	        }
	        new UriParametersValidator().validate(highLevelNode, v);
	        new CompositeNodeValidator().validate(highLevelNode, v);
	        new TemplateCyclesDetector().validate(highLevelNode, v);
	    }
	    else {
	        validateBasic(node, v);
	    }
	    new OptionalPropertiesValidator().validate(node, v);
	}
	exports.validate = validate;
	function cleanupIncludesFlag(node, v) {
	    var val = node.lowLevel().actual();
	    delete val._inc;
	    node.children().forEach(function (x) { return cleanupIncludesFlag(x, v); });
	}
	function validateIncludes(node, v) {
	    var llNode = node.lowLevel();
	    var val = llNode.actual();
	    if (val._inc) {
	        return;
	    }
	    if (node.isElement()) {
	        var vl = node.name();
	        if (typeof vl == "string") {
	            if (vl != null && vl.indexOf(" ") != -1) {
	                v.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "Keys should not have spaces '" + vl + "'", node, true));
	            }
	        }
	    }
	    val._inc = true;
	    if (llNode) {
	        llNode.includeErrors().forEach(function (x) {
	            var isWarn = false;
	            if (node.lowLevel().hasInnerIncludeError()) {
	                isWarn = true;
	            }
	            var em = createIssue(hl.IssueCode.UNABLE_TO_RESOLVE_INCLUDE_FILE, x, node, isWarn);
	            v.accept(em);
	        });
	        var includePath = llNode.includePath();
	        if (includePath != null && !path.isAbsolute(includePath) && !ll.isWebPath(includePath)) {
	            var unitPath = llNode.unit().absolutePath();
	            var exceeding = calculateExceeding(path.dirname(unitPath), includePath);
	            if (exceeding > 0) {
	                var em = createIssue(hl.IssueCode.UNABLE_TO_RESOLVE_INCLUDE_FILE, "Resolved include path exceeds file system root", node, true);
	                v.accept(em);
	            }
	        }
	    }
	    node.children().forEach(function (x) { return validateIncludes(x, v); });
	    if (node.children().length == 0 && llNode != null) {
	        llNode.children().forEach(function (x) { return validateIncludesLL(x, v, node); });
	    }
	}
	function validateIncludesLL(llNode, v, node) {
	    llNode.includeErrors().forEach(function (x) {
	        var isWarn = false;
	        if (llNode.hasInnerIncludeError()) {
	            isWarn = true;
	        }
	        var em = createLLIssue(hl.IssueCode.UNABLE_TO_RESOLVE_INCLUDE_FILE, x, llNode, node, isWarn);
	        v.accept(em);
	    });
	    var includePath = llNode.includePath();
	    if (includePath != null && !path.isAbsolute(includePath) && !ll.isWebPath(includePath)) {
	        var unitPath = llNode.unit().absolutePath();
	        var exceeding = calculateExceeding(path.dirname(unitPath), includePath);
	        if (exceeding > 0) {
	            var em = createLLIssue(hl.IssueCode.UNABLE_TO_RESOLVE_INCLUDE_FILE, "Resolved include path exceeds file system root", llNode, node, true);
	            v.accept(em);
	        }
	    }
	    llNode.children().forEach(function (x) { return validateIncludesLL(x, v, node); });
	}
	var actualSegments = function (rootPath) {
	    rootPath = rootPath.replace(/\\/g, "/").trim();
	    if (rootPath.length > 1 && rootPath.charAt(1) == ":" && /^win/.test(process.platform)) {
	        rootPath = rootPath.substring(2);
	    }
	    var segments = rootPath.split("/");
	    if (segments[0].length == 0) {
	        segments = segments.slice(1);
	    }
	    if (segments.length > 0 && segments[segments.length - 1].length == 0) {
	        segments = segments.slice(0, segments.length - 1);
	    }
	    return segments;
	};
	function calculateExceeding(rootPath, relativePath) {
	    var rootSegments = actualSegments(rootPath);
	    var relativeSegments = actualSegments(relativePath);
	    var count = rootSegments.length;
	    var result = 0;
	    for (var _i = 0, relativeSegments_1 = relativeSegments; _i < relativeSegments_1.length; _i++) {
	        var segment = relativeSegments_1[_i];
	        if (segment == "..") {
	            count--;
	            if (count < 0) {
	                result = Math.min(count, result);
	            }
	        }
	        else {
	            count++;
	        }
	    }
	    return -1 * result;
	}
	var validateRegexp = function (cleanedValue, v, node) {
	    try {
	        new RegExp(cleanedValue);
	    }
	    catch (Error) {
	        v.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "Illegal pattern " + cleanedValue, node));
	    }
	};
	var TraitVariablesValidator = (function () {
	    function TraitVariablesValidator() {
	    }
	    TraitVariablesValidator.prototype.validateName = function (node, acceptor) {
	        var name = node.name();
	        if (name) {
	            var start = node.lowLevel().keyStart();
	            this.check(name, start, node, acceptor);
	        }
	    };
	    TraitVariablesValidator.prototype.validateValue = function (node, acceptor) {
	        var value = node.value();
	        if (typeof (value) === 'string') {
	            var start = node.lowLevel().valueStart();
	            this.check(value, start, node, acceptor);
	        }
	    };
	    TraitVariablesValidator.prototype.hasTraitOrResourceTypeParent = function (node) {
	        var parent = node.parent();
	        while (parent != null) {
	            if (!parent.definition())
	                return false;
	            if (universeHelpers.isTraitType(parent.definition())
	                || universeHelpers.isResourceTypeType(parent.definition())) {
	                return true;
	            }
	            parent = parent.parent();
	        }
	        return false;
	    };
	    TraitVariablesValidator.prototype.check = function (str, start, node, acceptor) {
	        if (!this.hasTraitOrResourceTypeParent(node))
	            return [];
	        var errors = [];
	        var prev = 0;
	        for (var i = str.indexOf('<<'); i >= 0; i = str.indexOf('<<', prev)) {
	            var i0 = i;
	            i += '<<'.length;
	            prev = str.indexOf('>>', i);
	            var paramOccurence = str.substring(i, prev);
	            var ind = paramOccurence.lastIndexOf('|');
	            var paramName = ind >= 0 ? paramOccurence.substring(0, ind) : paramOccurence;
	            if (paramName.trim().length == 0) {
	                var msg = "Trait or resource type parameter name must contain non whitespace characters";
	                var issue = createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, msg, node, false);
	                issue.start = start + i;
	                issue.end = start + prev;
	                acceptor.accept(issue);
	            }
	            if (ind != -1) {
	                ind++;
	                var transformerName = paramOccurence.substring(ind).trim();
	                var functionNames = expander.getTransformNames();
	                if (!_.find(functionNames, function (functionName) {
	                    return transformerName === functionName || transformerName === ('!' + functionName);
	                })) {
	                    var msg = "Unknown function applied to parameter: " + transformerName;
	                    var issue = createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, msg, node, false);
	                    issue.start = start + ind;
	                    issue.end = start + prev;
	                    acceptor.accept(issue);
	                }
	            }
	            prev += '>>'.length;
	        }
	        return errors;
	    };
	    return TraitVariablesValidator;
	}());
	var MethodBodyValidator = (function () {
	    function MethodBodyValidator() {
	    }
	    MethodBodyValidator.prototype.validate = function (node, validationAcceptor) {
	        var methodNode = node.parent();
	        if (!methodNode) {
	            return;
	        }
	        if (!(methodNode.definition().isAssignableFrom(universes.Universe08.Method.name) || methodNode.definition().isAssignableFrom(universes.Universe10.Method.name))) {
	            return;
	        }
	        var hasBody = _.find(methodNode.lowLevel() && methodNode.lowLevel().children() || [], function (child) {
	            var keyValue = child.key();
	            return keyValue && (universes.Universe08.MethodBase.properties.body.name === keyValue || universes.Universe10.MethodBase.properties.body.name === keyValue);
	        });
	        if (hasBody && _.find(MethodBodyValidator.methodsWithoutRequestBody, function (methodDisabled) { return methodNode.name() === methodDisabled; })) {
	            validationAcceptor.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, 'Request body is disabled for "' + methodNode.name() + '" method.', methodNode));
	        }
	    };
	    MethodBodyValidator.methodsWithoutRequestBody = ['trace'];
	    return MethodBodyValidator;
	}());
	var CompositePropertyValidator = (function () {
	    function CompositePropertyValidator() {
	    }
	    CompositePropertyValidator.prototype.validate = function (node, v) {
	        var pr = checkPropertyQuard(node, v);
	        var vl = node.value();
	        if (!node.property().range().hasStructure()) {
	            if (vl instanceof hlimpl.StructuredValue && !node.property().isSelfNode()) {
	                //TODO THIS SHOULD BE MOVED TO TYPESYSTEM FOR STS AT SOME MOMENT
	                if (isTypeOrSchema(node.property())) {
	                    if (node.property().domain().key() == universes.Universe08.BodyLike) {
	                        var structValue = vl;
	                        var newNode = new hlimpl.ASTNodeImpl(node.lowLevel(), node.parent(), node.parent().definition().universe().type(universes.Universe08.BodyLike.name), node.property());
	                        newNode.validate(v);
	                        return;
	                    }
	                }
	                if (node.parent().definition().universe().version() == "RAML10"
	                    && typeOfContainingTemplate(node.parent()) != null) {
	                    return;
	                }
	                v.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "Scalar is expected here", node));
	            }
	            else {
	                var vk = node.lowLevel().valueKind();
	                if (node.lowLevel().valueKind() != yaml.Kind.INCLUDE_REF && !node.property().getAdapter(services.RAMLPropertyService).isKey()) {
	                    if ((!node.property().isMultiValue())) {
	                        var k = node.property().range().key();
	                        if (k == universes.Universe08.StringType || k == universes.Universe08.MarkdownString || k == universes.Universe08.MimeType) {
	                            if (vk == yaml.Kind.SEQ || vk == yaml.Kind.MAPPING || vk == yaml.Kind.MAP || ((node.property().isRequired() || node.property().nameId() == "mediaType") && (vk == null || vk === undefined))) {
	                                if (!node.property().domain().getAdapter(services.RAMLService).isInlinedTemplates()) {
	                                    v.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "property '" + node.name() + "' must be a string", node));
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            if (node.isAnnotatedScalar()) {
	                var fvl = new FixedFacetsValidator();
	                node.annotations().forEach(function (x) {
	                    var vl = x.value();
	                    var highLevel = vl.toHighLevel();
	                    if (!highLevel) {
	                        v.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "unknown annotation " + vl.valueName(), x));
	                    }
	                    else {
	                        fvl.validate(highLevel, v);
	                    }
	                });
	            }
	        }
	        var refName;
	        if (typeof vl == 'string') {
	            refName = vl;
	        }
	        else if (vl instanceof hlimpl.StructuredValue) {
	            refName = vl.valueName();
	        }
	        if (refName && refName.indexOf("<<") != -1) {
	            if (refName.indexOf(">>") > refName.indexOf("<<")) {
	                new TraitVariablesValidator().validateValue(node, v);
	                if (typeOfContainingTemplate(node.parent()) != null) {
	                    return;
	                }
	            }
	        }
	        new MethodBodyValidator().validate(node, v);
	        if ((node.property().range().key() == universes.Universe08.MimeType ||
	            node.property().range().key() == universes.Universe10.MimeType) ||
	            (node.property().nameId() == universes.Universe10.TypeDeclaration.properties.name.name
	                && node.parent().property().nameId() ==
	                    universes.Universe10.MethodBase.properties.body.name)) {
	            new MediaTypeValidator().validate(node, v);
	            return;
	        }
	        if (isExampleProp(node.property()) || isDefaultValueProp(node.property())) {
	            if (node.definition().universe().version() == "RAML08") {
	                var llv = node.lowLevel().value();
	                if (node.lowLevel().children().length > 0) {
	                    var valName = isExampleProp(node.property()) ? "example" : "default value";
	                    v.accept(createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, valName + " should be a string", node, false));
	                }
	            }
	            new ExampleAndDefaultValueValidator().validate(node, v);
	        }
	        if (isSecuredBy(node.property())) {
	            if (node.definition().universe().version() == "RAML08") {
	                var np = node.lowLevel().parent();
	                var ysc = yaml.Kind.SEQ;
	                var msg = "`securedBy` should be a list in RAML08";
	                if (node.lowLevel() instanceof proxy.LowLevelProxyNode) {
	                    if (np.valueKind() != ysc) {
	                        v.accept(createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, msg, node, false));
	                    }
	                }
	                else {
	                    if (np.kind() != ysc) {
	                        v.accept(createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, msg, node, false));
	                    }
	                }
	            }
	            new ExampleAndDefaultValueValidator().validate(node, v);
	        }
	        if (node.property().nameId() == universes.Universe10.TypeDeclaration.properties.name.name) {
	            //TODO MOVE TO DEF SYSTEM
	            var nameId = node.parent().property() && node.parent().property().nameId();
	            if (nameId == universes.Universe08.Resource.properties.uriParameters.name
	                || nameId == universes.Universe08.Resource.properties.baseUriParameters.name) {
	                //                    new UrlParameterNameValidator().validate(node, v);
	                return;
	            }
	        }
	        var range = node.property().range().key();
	        if (range == universes.Universe08.RelativeUriString || range == universes.Universe10.RelativeUriString) {
	            new UriValidator().validate(node, v);
	            return;
	        }
	        if (range == universes.Universe08.FullUriTemplateString || range == universes.Universe10.FullUriTemplateString) {
	            new UriValidator().validate(node, v);
	            return;
	        }
	        if ("pattern" == node.name() && universes.Universe10.StringType == node.definition().key()
	            && node.parent().definition().isAssignableFrom("StringTypeDeclaration")) {
	            validateRegexp(node.value(), v, node);
	        }
	        if ("name" == node.name() && universes.Universe10.StringType == node.definition().key()
	            && (typeof node.value() == "string")
	            && node.value().indexOf("[") == 0
	            && node.value().lastIndexOf("]") == node.value().length - 1) {
	            if (node.parent() instanceof hlimpl.ASTNodeImpl &&
	                universes.Universe10.ObjectTypeDeclaration.properties.properties.name == node.parent().property().nameId()) {
	                if (node.parent().parent() instanceof hlimpl.ASTNodeImpl &&
	                    universes.Universe10.ObjectTypeDeclaration == node.parent().parent().definition().key()) {
	                    var cleanedValue = node.value().substr(1, node.value().length - 2);
	                    validateRegexp(cleanedValue, v, node);
	                }
	            }
	        }
	        if (pr.isReference() || pr.isDescriminator()) {
	            new DescriminatorOrReferenceValidator().validate(node, v);
	        }
	        else {
	            new NormalValidator().validate(node, v);
	        }
	    };
	    return CompositePropertyValidator;
	}());
	function isValid(t, h, value, p, attr) {
	    if (t.hasArrayInHierarchy()) {
	        return isValidArray(t, h, value, p, attr);
	    }
	    else if (t.hasValueTypeInHierarchy()) {
	        return isValidValueType(t, h, value, p, attr);
	    }
	    return true;
	}
	exports.isValid = isValid;
	function isValidArray(t, h, v, p, attr) {
	    if (t.arrayInHierarchy().componentType()) {
	        return isValid(t.arrayInHierarchy().componentType(), h, v, p);
	    }
	    return true;
	}
	function isValidValueType(t, h, v, p, attr) {
	    //FIXME
	    try {
	        if (t.key() == universes.Universe10.AnnotationRef) {
	            var targets = search.referenceTargets(p, h);
	            var actualAnnotation = _.find(targets, function (x) { return hlimpl.qName(x, h) == v; });
	            if (actualAnnotation != null) {
	                var attrs = actualAnnotation.attributes("allowedTargets");
	                if (attrs) {
	                    var aVals = attrs.map(function (x) { return x.value(); });
	                    if (aVals.length > 0) {
	                        var found = false;
	                        //no we should actually check that we are applying annotation properly
	                        var tps = h.definition().allSuperTypes();
	                        tps = tps.concat([h.definition()]);
	                        var tpNames = tps.map(function (x) { return x.nameId(); });
	                        aVals.forEach(function (x) {
	                            //FIXME this is deeply wrong code
	                            if (x == "API") {
	                                x = "Api";
	                            }
	                            if (x == "NamedExample") {
	                                x = "ExampleSpec";
	                            }
	                            if (x == "SecurityScheme") {
	                                x = "AbstractSecurityScheme";
	                            }
	                            if (x == "SecuritySchemeSettings") {
	                                x = "SecuritySchemeSettings";
	                            }
	                            if (_.find(tpNames, function (y) { return y == x; })) {
	                                found = true;
	                            }
	                            else {
	                                if (x == "Parameter") {
	                                    if (h.computedValue("location")) {
	                                        found = true;
	                                    }
	                                }
	                                if (x == "Field") {
	                                    if (h.computedValue("field")) {
	                                        found = true;
	                                    }
	                                }
	                            }
	                        });
	                        if (!found) {
	                            return new Error("annotation " + v + " can not be placed at this location, allowed targets are:" + aVals);
	                        }
	                    }
	                }
	            }
	            return tm;
	        }
	        if (t.key() == universes.Universe08.SchemaString || t.key() == universes.Universe10.SchemaString) {
	            var tm = su.createSchema(v, contentProvider(h.lowLevel()));
	            if (tm instanceof Error) {
	                tm.canBeRef = true;
	            }
	            return tm;
	        }
	        if (t.key() == universes.Universe08.StatusCodeString || t.key() == universes.Universe10.StatusCodeString) {
	            var err = validateResponseString(v);
	            if (err != null) {
	                return err;
	            }
	        }
	        if (t.key() == universes.Universe08.BooleanType || t.isAssignableFrom(universes.Universe10.BooleanType.name)) {
	            if (!(v === 'true' || v === 'false' || v === true || v === false)) {
	                return new Error("'true' or 'false' is expected here");
	            }
	            if (attr) {
	                var stringValue = attr.lowLevel().value(true);
	                if (!(stringValue === 'true' || stringValue === 'false')) {
	                    return new Error("'true' or 'false' is expected here");
	                }
	            }
	        }
	        if (t.key() == universes.Universe08.NumberType || t.isAssignableFrom(universes.Universe10.NumberType.name)) {
	            var q = parseFloat(v);
	            if (isNaN(q)) {
	                return new Error("the value of " + p.nameId() + " must be a number");
	            }
	        }
	        if (t.key() == universes.Universe08.StringType || t.isAssignableFrom(universes.Universe10.StringType.name)) {
	            if (v === null) {
	                //checking if there is at least something in the node.
	                //We have many tests and APIs with the text like 'propertyName:' without a value. I do not know if such cases are
	                //actually valid, but not reporting this for now.
	                if (h && p) {
	                    var highLevelProperty = h.attr(p.nameId());
	                    if (highLevelProperty) {
	                        var lowLevelChildren = highLevelProperty.lowLevel().children();
	                        if (lowLevelChildren && lowLevelChildren.length > 0) {
	                            return new Error(p.nameId() + " must be a string");
	                        }
	                    }
	                }
	            }
	        }
	        return true;
	    }
	    catch (e) {
	        e.canBeRef = true; //FIXME
	        return e;
	    }
	}
	var NormalValidator = (function () {
	    function NormalValidator() {
	    }
	    NormalValidator.prototype.validate = function (node, cb) {
	        var vl = node.value();
	        var pr = node.property();
	        var range = pr.range();
	        var dnode = range.getAdapter(services.RAMLService).getDeclaringNode();
	        if (dnode && range.isUserDefined()) {
	            var rof = dnode.parsedType();
	            var dp = node.parent().lowLevel().dumpToObject();
	            var tempVal = dp[node.parent().name()];
	            var isVal = pr.canBeValue();
	            var val = (isVal || (tempVal === null || tempVal === undefined)) ? tempVal : tempVal[pr.nameId()];
	            var validateObject = rof.validate(val, true);
	            if (!validateObject.isOk()) {
	                validateObject.getErrors().forEach(function (e) { return cb.accept(createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, e.getMessage(), node, false)); });
	            }
	        }
	        var v = cb;
	        if (node.lowLevel().keyKind() != yaml.Kind.SEQ) {
	            var validation = isValid(pr.range(), node.parent(), vl, pr, node);
	        }
	        else {
	            validation = true;
	        }
	        if (validation instanceof Error) {
	            if (!validation.canBeRef) {
	                v.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, validation.message, node));
	                validation = null;
	                return;
	            }
	        }
	        if (!validation || validation instanceof Error) {
	            if (pr.nameId() != 'value') {
	                if (!checkReference(pr, node, vl, v)) {
	                    if (pr.nameId() == universes.Universe10.TypeDeclaration.properties.schema.name
	                        || universes.Universe10.TypeDeclaration.properties.type.name) {
	                        if (vl && vl.trim() && (pr.domain().key() == universes.Universe08.BodyLike
	                            || pr.domain().key() == universes.Universe10.TypeDeclaration)) {
	                            var testSchema = vl.trim().charAt(0); //FIXME
	                            if (testSchema != '{' && testSchema != '<') {
	                                return;
	                            }
	                        }
	                    }
	                    var decl = node.findReferencedValue();
	                    if (decl instanceof Error) {
	                        v.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, decl.message, node));
	                    }
	                    if (!decl) {
	                        if (vl) {
	                            if (pr.nameId() == universes.Universe10.TypeDeclaration.properties.schema.name) {
	                                var z = vl.trim();
	                                if (z.charAt(0) != '{' && z.charAt(0) != '<') {
	                                    if (vl.indexOf('|') != -1 || vl.indexOf('[]') != -1 || vl.indexOf("(") != -1) {
	                                        return;
	                                    }
	                                }
	                            }
	                        }
	                        if (validation instanceof Error && vl) {
	                            v.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, validation.message, node));
	                            validation = null;
	                            return;
	                        }
	                        if (node.property().isRequired() && node.value() == null) {
	                            v.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "Empty value is not allowed here", node));
	                        }
	                        else {
	                            var ck = node.lowLevel().valueKind();
	                            if (ck == yaml.Kind.MAP || ck == yaml.Kind.SEQ || ck == yaml.Kind.MAPPING) {
	                                v.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "Empty value is not allowed here", node));
	                            }
	                        }
	                    }
	                }
	            }
	            else {
	                var vl = node.value();
	                var message = "Invalid value schema:" + vl;
	                if (validation instanceof Error) {
	                    message = validation.message;
	                }
	                v.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, message, node, pr.range().key() == universes.Universe08.SchemaString));
	            }
	        }
	        var values = pr.enumOptions();
	        if (values) {
	            if (typeof vl !== 'string') {
	                return;
	            }
	            if (typeof values == 'string') {
	                if (values != vl) {
	                    if (vl && (vl.indexOf("x-") == 0) && pr.nameId() == universes.Universe08.AbstractSecurityScheme.properties.type.name) {
	                    }
	                    else {
	                        v.accept(createIssue(hl.IssueCode.UNRESOLVED_REFERENCE, "Invalid value:" + vl + " allowed values are:" + values, node));
	                    }
	                }
	            }
	            else if (values.length > 0) {
	                if (!_.find(values, function (x) { return x == vl; })) {
	                    if (vl && (vl.indexOf("x-") == 0) && pr.nameId() == universes.Universe08.AbstractSecurityScheme.properties.type.name) {
	                    }
	                    else {
	                        v.accept(createIssue(hl.IssueCode.UNRESOLVED_REFERENCE, "Invalid value:" + vl + " allowed values are:" + values.join(","), node));
	                    }
	                }
	            }
	        }
	    };
	    return NormalValidator;
	}());
	var UriValidator = (function () {
	    function UriValidator() {
	    }
	    UriValidator.prototype.validate = function (node, cb) {
	        try {
	            var values = new UrlParameterNameValidator().parseUrl(node.value());
	            if (values.some(function (x) { return x == "version"; }) && node.property().nameId() == "baseUri") {
	                var version = node.root().attr("version");
	                if (!version) {
	                    cb.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "missing version", node, false));
	                }
	            }
	            if (values.some(function (x) { return x.length == 0; })) {
	                cb.accept(createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, "URI parameter must have name specified", node, false));
	            }
	        }
	        catch (e) {
	            cb.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, e.message, node, false));
	        }
	    };
	    return UriValidator;
	}());
	var MediaTypeValidator = (function () {
	    function MediaTypeValidator() {
	    }
	    MediaTypeValidator.prototype.validate = function (node, cb) {
	        try {
	            var v = node.value();
	            if (!v) {
	                return;
	            }
	            if (v == "*/*") {
	                return;
	            }
	            if (v.indexOf("/*") == v.length - 2) {
	                v = v.substring(0, v.length - 2) + "/xxx";
	            }
	            if (node.parent() && node.parent().parent() && node.parent().parent().definition().isAssignableFrom(universes.Universe10.Trait.name)) {
	                if (v.indexOf("<<") >= 0) {
	                    return;
	                }
	            }
	            if (v == "body") {
	                if (node.parent().parent()) {
	                    var ppc = node.parent().parent().definition().key();
	                    if (ppc === universes.Universe08.Response || ppc === universes.Universe10.Response ||
	                        node.parent().parent().definition().isAssignableFrom(universes.Universe10.MethodBase.name)) {
	                        v = node.parent().computedValue("mediaType");
	                    }
	                }
	            }
	            var res = mediaTypeParser.parse(v);
	            //check if type name satisfies RFC6338
	            if (!res.type.match(/[\w\d][\w\d!#\$&\-\^_+\.]*/)) {
	                cb.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "Invalid media type '" + res.type + "'", node));
	            }
	        }
	        catch (e) {
	            cb.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "" + e.message, node));
	        }
	        if (node.value() && node.value() == ("multipart/form-data") || node.value() == ("application/x-www-form-urlencoded")) {
	            if (node.parent() && node.parent().parent() && node.parent().parent().property()) {
	                if (node.parent().parent().property().nameId() == universes.Universe10.MethodBase.properties.responses.name) {
	                    cb.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "Form related media types can not be used in responses", node, true));
	                }
	            }
	        }
	        return;
	    };
	    return MediaTypeValidator;
	}());
	//class SignatureValidator implements PropertyValidator{
	//    validate(node:hl.IAttribute,cb:hl.ValidationAcceptor){
	//        var vl=node.value();
	//        var q = vl?vl.trim():"";
	//        if (q.length > 0 ) {
	//            try {
	//                //ramlSignature.validate(vl, node, cb);
	//            }catch (e){
	//                cb.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA,"Error during signature parse:"+e.message,node))
	//            }
	//            return;
	//        }
	//        return;
	//    }
	//}
	var UrlParameterNameValidator = (function () {
	    function UrlParameterNameValidator() {
	    }
	    UrlParameterNameValidator.prototype.checkBaseUri = function (node, c, vl, v) {
	        var bu = c.root().attr("baseUri");
	        if (bu) {
	            var tnv = bu.value();
	            try {
	                var pNames = this.parseUrl(tnv);
	                if (!_.find(pNames, function (x) { return x == vl; })) {
	                    v.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "Unused url parameter", node));
	                }
	            }
	            catch (e) {
	            }
	        }
	        else {
	            v.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "Unused url parameter", node));
	        }
	    };
	    UrlParameterNameValidator.prototype.parseUrl = function (value) {
	        var result = [];
	        var temp = "";
	        var inPar = false;
	        var count = 0;
	        for (var a = 0; a < value.length; a++) {
	            var c = value[a];
	            if (c == '{') {
	                count++;
	                inPar = true;
	                continue;
	            }
	            if (c == '}') {
	                count--;
	                inPar = false;
	                result.push(temp);
	                temp = "";
	                continue;
	            }
	            if (inPar) {
	                temp += c;
	            }
	        }
	        if (count > 0) {
	            throw new Error("Invalid resource name: unmatched '{'");
	        }
	        if (count < 0) {
	            throw new Error("Invalid resource name: unmatched '}'");
	        }
	        return result;
	    };
	    UrlParameterNameValidator.prototype.validate = function (node, cb) {
	        var vl = node.value();
	        if (node.parent().property().nameId() == universes.Universe10.Api.properties.baseUri.name) {
	            var c = node.parent().parent();
	            this.checkBaseUri(node, c, vl, cb);
	            return;
	        }
	        var c = node.parent().parent();
	        var tn = c.name();
	        if (c.definition().key() === universes.Universe10.Api ||
	            c.definition().key() === universes.Universe08.Api) {
	            this.checkBaseUri(node, c, vl, cb);
	            return;
	        }
	        if (c.definition().key() == universes.Universe10.ResourceType ||
	            c.definition().key() == universes.Universe08.ResourceType) {
	            return;
	        }
	        try {
	            var pNames = this.parseUrl(tn);
	            var foundInLocalParameters = _.find(pNames, function (x) { return x == vl; });
	            if (!foundInLocalParameters) {
	                var baseUri = node.root().attr(universes.Universe10.Api.properties.baseUri.name);
	                if (baseUri && node.name() === universes.Universe08.Api.properties.baseUriParameters.name) {
	                    var baseUriValue = baseUri.value();
	                    if (baseUriValue) {
	                        pNames = this.parseUrl(baseUriValue);
	                        if (pNames && pNames.length > 0) {
	                            if (_.find(pNames, function (x) { return x == vl; }))
	                                return;
	                        }
	                    }
	                }
	                cb.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "Unused url parameter '" + vl + "'", node));
	            }
	        }
	        catch (e) {
	        }
	    };
	    return UrlParameterNameValidator;
	}());
	exports.UrlParameterNameValidator = UrlParameterNameValidator;
	//TODO this should be probably moved to a more general file/module
	exports.typeToName = {};
	exports.typeToName[universes.Universe08.Trait.name] = "trait";
	exports.typeToName[universes.Universe08.ResourceType.name] = "resource type";
	exports.typeToName[universes.Universe10.Trait.name] = "trait";
	exports.typeToName[universes.Universe10.ResourceType.name] = "resource type";
	exports.typeToName[universes.Universe10.AbstractSecurityScheme.name] = "security scheme";
	exports.typeToName[universes.Universe10.Method.name] = "method";
	exports.typeToName[universes.Universe08.Method.name] = "method";
	exports.typeToName[universes.Universe10.Resource.name] = "resource";
	exports.typeToName[universes.Universe08.Resource.name] = "resource";
	exports.typeToName[universes.Universe10.Api.name] = "api";
	exports.typeToName[universes.Universe08.Api.name] = "api";
	exports.typeToName[universes.Universe10.Response.name] = "response";
	exports.typeToName[universes.Universe08.Response.name] = "response";
	exports.typeToName[universes.Universe08.BodyLike.name] = "body";
	exports.parameterPropertyToName = {};
	exports.parameterPropertyToName[universes.Universe08.MethodBase.properties.headers.name] = "header";
	exports.parameterPropertyToName[universes.Universe08.MethodBase.properties.queryParameters.name] = "query parameter";
	exports.parameterPropertyToName[universes.Universe08.Api.properties.uriParameters.name] = "uri parameter";
	exports.parameterPropertyToName[universes.Universe08.Api.properties.baseUriParameters.name] = "base uri parameter";
	exports.parameterPropertyToName[universes.Universe08.BodyLike.properties.formParameters.name] = "form parameter";
	exports.parameterPropertyToName[universes.Universe10.MethodBase.properties.headers.name] = "header";
	exports.parameterPropertyToName[universes.Universe10.MethodBase.properties.queryParameters.name] = "query parameter";
	exports.parameterPropertyToName[universes.Universe10.ResourceBase.properties.uriParameters.name] = "uri parameter";
	exports.parameterPropertyToName[universes.Universe10.Api.properties.baseUriParameters.name] = "base uri parameter";
	exports.parameterPropertyToName[universes.Universe10.MethodBase.properties.body.name] = "body";
	function getHumanReadableNodeName(astNode) {
	    if (!astNode)
	        return null;
	    if (astNode.isElement()) {
	        var element = astNode;
	        var definition = element.definition();
	        if (definition && exports.typeToName.hasOwnProperty(definition.nameId())) {
	            return exports.typeToName[definition.nameId()];
	        }
	        if (definition.isAssignableFrom(universes.Universe10.TypeDeclaration.name) ||
	            definition.isAssignableFrom(universes.Universe08.Parameter.name)) {
	            if (element.property() && exports.parameterPropertyToName.hasOwnProperty(element.property().nameId())) {
	                return exports.parameterPropertyToName[element.property().nameId()];
	            }
	            if (element.property() && element.parent() &&
	                element.property().nameId() == universes.Universe10.LibraryBase.properties.types.name &&
	                element.parent().definition() && element.parent().definition().isAssignableFrom(universes.Universe10.LibraryBase.name)) {
	                return "type";
	            }
	            if (element.property() && element.parent() &&
	                element.property().nameId() == universes.Universe10.LibraryBase.properties.securitySchemes.name &&
	                element.parent().definition() && element.parent().definition().isAssignableFrom(universes.Universe10.LibraryBase.name)) {
	                return "security scheme";
	            }
	        }
	    }
	    return null;
	}
	exports.getHumanReadableNodeName = getHumanReadableNodeName;
	function isValidPropertyValue(pr, vl, c) {
	    var node = search.declRoot(c);
	    if (!node._cach) {
	        node._cach = {};
	    }
	    var id = pr.id();
	    if (pr.domain()) {
	        id += pr.domain().nameId();
	    }
	    if (id) {
	        var cached = node._cach[id];
	        if (cached) {
	            return cached[vl] != null;
	        }
	    }
	    var vls = search.enumValues(pr, c);
	    var mm = {};
	    vls.forEach(function (x) { return mm[x] = 1; });
	    if (pr.id()) {
	        node._cach[id] = mm;
	    }
	    return mm[vl] != null;
	}
	function checkReference(pr, astNode, vl, cb) {
	    checkTraitReference(pr, astNode, cb);
	    checkResourceTypeReference(pr, astNode, cb);
	    if (!vl) {
	        return;
	    }
	    if (vl == 'null') {
	        if (pr.isAllowNull()) {
	            return;
	        }
	    }
	    var adapter = pr.getAdapter(services.RAMLPropertyService);
	    var valid = isValidPropertyValue(pr, vl, astNode.parent());
	    if (!valid && astNode.lowLevel().unit().absolutePath() !== astNode.parent().lowLevel().unit().absolutePath()) {
	        valid = isValidPropertyValue(pr, vl, hlimpl.fromUnit(astNode.lowLevel().unit()));
	    }
	    if (!valid) {
	        if (typeof vl == 'string') {
	            if ((vl.indexOf("x-") == 0) && pr.nameId() == universes.Universe10.TypeDeclaration.properties.type.name) {
	                return true;
	            }
	        }
	        var expected = (adapter.isReference && adapter.isReference() && adapter.referencesTo && adapter.referencesTo() && adapter.referencesTo().nameId && adapter.referencesTo().nameId());
	        var referencedToName = exports.typeToName[expected] || nameForNonReference(astNode);
	        var message = referencedToName ? ("Unrecognized " + referencedToName + " '" + vl + "'.") : ("Unresolved reference: " + vl);
	        var spesializedMessage = specializeReferenceError(message, pr, astNode);
	        cb.accept(createIssue(hl.IssueCode.UNRESOLVED_REFERENCE, spesializedMessage, astNode, pr.range().key() === universes.Universe08.SchemaString));
	        return true;
	    }
	    if (isDuplicateSibling(astNode) && universeHelpers.isTraitRefType(astNode.definition())) {
	        var message = "Duplicate trait reference '" + vl + "'.";
	        var spesializedMessage = specializeReferenceError(message, pr, astNode);
	        cb.accept(createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, spesializedMessage, astNode));
	        return true;
	    }
	    return false;
	}
	function isDuplicateSibling(attr) {
	    var ramlVersion = attr.property().domain().universe().version();
	    var siblingName;
	    if (ramlVersion == "RAML10") {
	        siblingName = stringify(json.serialize(attr.lowLevel()));
	    }
	    else {
	        siblingName = attr.value() && attr.value().valueName && attr.value().valueName();
	    }
	    if (!siblingName) {
	        return false;
	    }
	    var parent = attr.parent && attr.parent();
	    if (!parent) {
	        return false;
	    }
	    var propertyName = attr.name && attr.name();
	    if (!propertyName) {
	        return false;
	    }
	    var siblings = parent.attributes && parent.attributes(propertyName);
	    if (!siblings) {
	        return false;
	    }
	    if (siblings.length === 0) {
	        return false;
	    }
	    var count = 0;
	    siblings.forEach(function (sibling) {
	        var name;
	        if (ramlVersion == "RAML10") {
	            siblingName = stringify(json.serialize(sibling.lowLevel()));
	        }
	        else {
	            name = sibling.value && sibling.value() && sibling.value().valueName && sibling.value().valueName();
	        }
	        if (name === siblingName) {
	            count++;
	        }
	    });
	    return count > 1;
	}
	function checkTraitReference(property, astNode, acceptor) {
	    //"is" property value must be an array
	    if (!universeHelpers.isIsProperty(property)) {
	        return;
	    }
	    var lowLevel = astNode.lowLevel();
	    if (lowLevel == null) {
	        return;
	    }
	    //trying to find "is" mapping, looking 2 nodes up max
	    var isMappingNode = null;
	    var lowLevelParent = lowLevel.parent();
	    var lowLevelParentParent = lowLevelParent != null ? lowLevelParent.parent() : null;
	    if (lowLevel.kind() == yaml.Kind.MAPPING && lowLevel.key() && lowLevel.key() == "is") {
	        isMappingNode = lowLevel;
	    }
	    else if (lowLevelParent != null &&
	        lowLevelParent.kind() == yaml.Kind.MAPPING && lowLevelParent.key() && lowLevelParent.key() == "is") {
	        isMappingNode = lowLevelParent;
	    }
	    else if (lowLevelParentParent != null &&
	        lowLevelParentParent.kind() == yaml.Kind.MAPPING && lowLevelParentParent.key() && lowLevelParentParent.key() == "is") {
	        isMappingNode = lowLevelParentParent;
	    }
	    if (isMappingNode == null) {
	        return;
	    }
	    //having a single value is bad
	    if (isMappingNode.value() != null && (!isMappingNode.children() || isMappingNode.children().length == 0)) {
	        acceptor.accept(createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, "property 'is' must be an array", astNode));
	    }
	    //only maps and scalars are allowed as direct children
	    var illegalChildFound = false;
	    isMappingNode.children().forEach(function (child) {
	        if (child.kind() != yaml.Kind.SCALAR && child.kind() != yaml.Kind.MAP) {
	            illegalChildFound = true;
	        }
	    });
	    if (illegalChildFound) {
	        acceptor.accept(createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, "property 'is' must be an array", astNode));
	    }
	}
	function checkResourceTypeReference(property, astNode, acceptor) {
	    if (!universeHelpers.isTypeProperty(property)) {
	        return;
	    }
	    if (!universeHelpers.isResourceTypeRefType(astNode.definition())) {
	        return;
	    }
	    var lowLevel = astNode.lowLevel();
	    if (astNode.value() == null && lowLevel && lowLevel.children() &&
	        lowLevel.children().length == 0) {
	        if (lowLevel.kind() == yaml.Kind.MAPPING && lowLevel.valueKind() != null) {
	            //no value, no children in the mapping, but some value, that means empty map or something like this.
	            acceptor.accept(createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, "resource type name must be provided", astNode));
	        }
	    }
	    else if (astNode.value() == null && lowLevel && lowLevel.children() &&
	        lowLevel.children().length > 1) {
	        //more than a single resource type in a list / map
	        acceptor.accept(createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, "a resource or resourceType can inherit from a single resourceType", astNode));
	    }
	}
	/**
	 * Sometimes we need a more specialized message for the bad references, which diviate from a general algorithm.
	 * Like listing possible values etc.
	 * This method is responsible for such cases.
	 * @param originalMessage
	 * @param pr
	 * @param astNode
	 * @returns {string}
	 */
	function specializeReferenceError(originalMessage, property, astNode) {
	    if (property.nameId() == "type" && property.domain().universe().version() == "RAML08") {
	        if (property.domain().isAssignableFrom(universes.Universe08.Parameter.name)) {
	            return "type can be either of: string, number, integer, file, date or boolean";
	        }
	    }
	    if (astNode.parent() != null && universeHelpers.isSecuritySchemaType(astNode.parent().definition())) {
	        return originalMessage +
	            " Allowed values are:OAuth 1.0,OAuth 2.0,Basic Authentication,DigestSecurityScheme Authentication,x-{other}";
	    }
	    return originalMessage;
	}
	function nameForNonReference(astNode) {
	    var propertyName = astNode && astNode.lowLevel() && astNode.lowLevel().key();
	    if (propertyName === universes.Universe10.AbstractSecurityScheme.properties.type.name) {
	        var domain = astNode.parent() && astNode.parent().definition() && astNode.parent().definition().nameId();
	        if (domain === universes.Universe10.AbstractSecurityScheme.name) {
	            return "security scheme type";
	        }
	    }
	    else if (propertyName === universes.Universe08.BodyLike.properties.schema.name) {
	        var domain = astNode.parent() && astNode.parent().definition() && astNode.parent().definition().nameId();
	        if (domain === universes.Universe08.BodyLike.name) {
	            return "schema";
	        }
	    }
	}
	var DescriminatorOrReferenceValidator = (function () {
	    function DescriminatorOrReferenceValidator() {
	    }
	    DescriminatorOrReferenceValidator.prototype.validate = function (node, cb) {
	        var vl = node.value();
	        var valueKey = vl;
	        var pr = node.property();
	        if (typeof vl == 'string') {
	            checkReference(pr, node, vl, cb);
	            if (pr.range() instanceof def.ReferenceType) {
	                var t = pr.range();
	                if (true) {
	                    var mockNode = jsyaml.createNode("" + vl, node.lowLevel().parent(), node.lowLevel().unit());
	                    mockNode._actualNode().startPosition = node.lowLevel().valueStart();
	                    mockNode._actualNode().endPosition = node.lowLevel().valueEnd();
	                    var stv = new hlimpl.StructuredValue(mockNode, node.parent(), node.property());
	                    var hn = stv.toHighLevel();
	                    if (hn) {
	                        hn.validate(cb);
	                    }
	                }
	            }
	        }
	        else if (vl != null) {
	            var st = vl;
	            if (st) {
	                valueKey = st.valueName();
	                var vn = st.valueName();
	                if (!checkReference(pr, node, vn, cb)) {
	                    var hnode = st.toHighLevel();
	                    if (hnode)
	                        hnode.validate(cb);
	                }
	            }
	            else {
	                valueKey = null;
	            }
	        }
	        else {
	            //there is no value, but still a reference: calling checkReference with null value
	            if (node.definition().isAssignableFrom(universes.Universe10.Reference.name)) {
	                checkReference(pr, node, null, cb);
	            }
	        }
	        if (valueKey) {
	            var validation = isValid(pr.range(), node.parent(), valueKey, pr);
	            if (validation instanceof Error) {
	                cb.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, validation.message, node));
	                validation = null;
	            }
	        }
	    };
	    return DescriminatorOrReferenceValidator;
	}());
	var allowOverride = { resources: 1, queryParameters: 1, headers: 1, body: 1, methods: 1, responses: 1 };
	var RAMLVersionAndFragmentValidator = (function () {
	    function RAMLVersionAndFragmentValidator() {
	    }
	    RAMLVersionAndFragmentValidator.prototype.validate = function (node, v) {
	        var u = node.universe();
	        var tv = u.getTypedVersion();
	        if (tv) {
	            if (tv !== "0.8" && tv !== "1.0") {
	                var i = createIssue(hl.IssueCode.NODE_HAS_VALUE, "Unknown version of RAML expected to see one of '#%RAML 0.8' or '#%RAML 1.0'", node);
	                v.accept(i);
	            }
	            var tl = u.getOriginalTopLevelText();
	            if (tl) {
	                if (tl != node.definition().nameId()) {
	                    if (node.definition().nameId() == "Api") {
	                        var i = createIssue(hl.IssueCode.NODE_HAS_VALUE, "Unknown top level type:" + tl, node);
	                        v.accept(i);
	                    }
	                }
	                else if ("Api" == u.getOriginalTopLevelText()) {
	                    var i = createIssue(hl.IssueCode.NODE_HAS_VALUE, "Redundant fragment name:" + tl, node);
	                    v.accept(i);
	                }
	            }
	        }
	    };
	    return RAMLVersionAndFragmentValidator;
	}());
	var RequiredPropertiesAndContextRequirementsValidator = (function () {
	    function RequiredPropertiesAndContextRequirementsValidator() {
	    }
	    RequiredPropertiesAndContextRequirementsValidator.prototype.validate = function (node, v) {
	        var _this = this;
	        (node.definition()).getAdapter(services.RAMLService).getContextRequirements().forEach(function (x) {
	            if (!node.checkContextValue(x.name, x.value, x.value)) {
	                var message = x.name + (" should be " + x.value + " to use type " + node.definition().nameId());
	                if (x.name == 'location' && x.value == "ParameterLocation.FORM") {
	                    message = "file type can be only used in web forms";
	                }
	                v.accept(createIssue(hl.IssueCode.MISSED_CONTEXT_REQUIREMENT, message, node));
	            }
	        });
	        var t;
	        var isInlinedTemplate = node.definition().getAdapter(services.RAMLService).isInlinedTemplates();
	        if (isInlinedTemplate) {
	            var paramsMap = {};
	            for (var _i = 0, _a = node.lowLevel().children(); _i < _a.length; _i++) {
	                var ch = _a[_i];
	                paramsMap[ch.key()] = ch.value(true);
	            }
	            var templateKind = node.definition().isAssignableFrom(universes.Universe10.Trait.name) ? "trait" : "resource type";
	            var unitsChain = expander.toUnits(node);
	            var vt = new expander.ValueTransformer(templateKind, node.definition().nameId(), unitsChain, paramsMap);
	            var parent = node.parent();
	            var def = parent ? parent.definition() : node.definition();
	            while (parent != null && !universeHelpers.isResourceType(def) && !universeHelpers.isMethodType(def)) {
	                parent = parent.parent();
	            }
	            t = new expander.DefaultTransformer(parent, vt, unitsChain);
	        }
	        node.definition().requiredProperties().forEach(function (x) {
	            if (isInlinedTemplate) {
	                var paths = x.getAdapter(services.RAMLPropertyService).meta("templatePaths");
	                if (paths) {
	                    var parent = node.parent();
	                    var hasSufficientChild = false;
	                    for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
	                        var path = paths_1[_i];
	                        path = path.map(function (x) { return t.transform(x).value; });
	                        if (_this.checkPathSufficiency(parent.lowLevel(), path, parent)) {
	                            hasSufficientChild = true;
	                            break;
	                        }
	                    }
	                    if (!hasSufficientChild) {
	                        return;
	                    }
	                }
	            }
	            var r = x.range();
	            if (r.hasArrayInHierarchy()) {
	                r = r.arrayInHierarchy().componentType();
	            }
	            if (r.hasValueTypeInHierarchy()) {
	                var nm = node.attr(x.nameId());
	                var gotValue = false;
	                if (nm != null) {
	                    if (nm.lowLevel().kind() == yaml.Kind.SCALAR
	                        || nm.lowLevel().valueKind() == yaml.Kind.SCALAR
	                        || nm.lowLevel().kind() == yaml.Kind.INCLUDE_REF
	                        || nm.lowLevel().valueKind() == yaml.Kind.INCLUDE_REF
	                        || (nm.lowLevel().valueKind() === null && !isInlinedTemplate)) {
	                        //if(nm.value()!=null){
	                        gotValue = true;
	                    }
	                    else if (nm.lowLevel().children().length != 0) {
	                        gotValue = true;
	                    }
	                }
	                if (!gotValue) {
	                    var msg = "Missing required property " + x.nameId();
	                    if (isInlinedTemplate) {
	                        msg = "value was not provided for parameter: " + x.nameId();
	                    }
	                    var i = createIssue(hl.IssueCode.MISSING_REQUIRED_PROPERTY, msg, node);
	                    v.accept(i);
	                }
	            }
	            else {
	                var el = node.elementsOfKind(x.nameId());
	                if (!el || el.length == 0) {
	                    var i = createIssue(hl.IssueCode.MISSING_REQUIRED_PROPERTY, "Missing required property " + x.nameId(), node);
	                    v.accept(i);
	                }
	            }
	        });
	    };
	    RequiredPropertiesAndContextRequirementsValidator.prototype.checkPathSufficiency = function (node, path, hlParent) {
	        if (hlParent == null || hlParent.definition() == null) {
	            return false;
	        }
	        var definition = hlParent.definition();
	        if (universeHelpers.isResourceTypeType(definition) || universeHelpers.isTraitType(definition)) {
	            return true;
	        }
	        if (path.length == 0) {
	            return false;
	        }
	        if (node == null) {
	            return false;
	        }
	        var segment = path[0];
	        if (segment == null) {
	            return false;
	        }
	        if (segment == "/") {
	            return this.checkPathSufficiency(node, path.slice(1), hlParent);
	        }
	        if (segment.length == 0) {
	            return true;
	        }
	        var children = node.children().filter(function (x) { return x.key() == segment; });
	        if (children.length == 0) {
	            path.indexOf("/") < 0;
	        }
	        var lowLevel = children[0];
	        if (lowLevel instanceof proxy.LowLevelCompositeNode) {
	            lowLevel = lowLevel.primaryNode();
	        }
	        if (lowLevel == null) {
	            return path.indexOf("/") < 0;
	        }
	        if (lowLevel.key() == "type") {
	            return true;
	        }
	        if (path.length == 1) {
	            // if(hlName==prop.nameId()&&node.definition().nameId()==prop.domain().nameId()){
	            //     return true;
	            // }
	            return lowLevel == null || lowLevel.value() == null;
	        }
	        else {
	            var path1 = path.slice(1);
	            return this.checkPathSufficiency(lowLevel, path1, hlParent);
	        }
	    };
	    return RequiredPropertiesAndContextRequirementsValidator;
	}());
	var ScalarQuoteValidator = (function () {
	    function ScalarQuoteValidator() {
	    }
	    ScalarQuoteValidator.prototype.validate = function (node, v) {
	        var r = node.lowLevel().unit();
	        node.lowLevel().visit(function (x) {
	            if (x.unit() != r) {
	                return false;
	            }
	            if (x.value() && x._node && x._node.value) {
	                if (x._node.value.doubleQuoted) {
	                    var ind = (x.value() + "").indexOf(":");
	                    var nl = (x.value() + "").indexOf("\n");
	                    if (ind != -1 && nl != -1 && (!x.includePath() || x.includePath().length == 0)) {
	                        var i = createIssue(hl.IssueCode.NODE_HAS_VALUE, "Suspicious double quoted multiline scalar, it is likely that you forgot closing \" " + x.value(), node, true);
	                        i.start = x._node.value.startPosition;
	                        i.end = x._node.value.endPosition;
	                        if (i.start == i.end) {
	                            i.end++;
	                        }
	                        v.accept(i);
	                    }
	                }
	            }
	            return true;
	        });
	    };
	    return ScalarQuoteValidator;
	}());
	var FixedFacetsValidator = (function () {
	    function FixedFacetsValidator() {
	    }
	    FixedFacetsValidator.prototype.validate = function (node, v) {
	        var nc = node.definition();
	        var dnode = nc.getAdapter(services.RAMLService).getDeclaringNode();
	        if (dnode) {
	            var rof = dnode.parsedType();
	            var dp = node.lowLevel().dumpToObject(true);
	            if (dp) {
	                dp = dp[Object.keys(dp)[0]];
	            }
	            var validateObject = rof.validate(dp, false, false);
	            if (!validateObject.isOk()) {
	                validateObject.getErrors().forEach(function (e) { return v.accept(createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, e.getMessage(), mapPath(node, e), false)); });
	            }
	        }
	    };
	    return FixedFacetsValidator;
	}());
	var TypeDeclarationValidator = (function () {
	    function TypeDeclarationValidator() {
	        this.annotables = {
	            "API": true,
	            "DocumentationItem": true,
	            "Resource": true,
	            "Method": true,
	            "Response": true,
	            "RequestBody": true,
	            "ResponseBody": true,
	            "TypeDeclaration": true,
	            "Example": true,
	            "ResourceType": true,
	            "Trait": true,
	            "SecurityScheme": true,
	            "SecuritySchemeSettings": true,
	            "AnnotationType": true,
	            "Library": true,
	            "Overlay": true,
	            "Extension": true
	        };
	    }
	    TypeDeclarationValidator.prototype.validate = function (node, v) {
	        var nc = node.definition();
	        var rof = node.parsedType();
	        var validateObject = rof.validateType(node.types().getAnnotationTypeRegistry());
	        if (!validateObject.isOk()) {
	            for (var _i = 0, _a = validateObject.getErrors(); _i < _a.length; _i++) {
	                var e = _a[_i];
	                var n = extractLowLevelNode(e);
	                var issue;
	                if (n) {
	                    issue = createLLIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, e.getMessage(), n, mapPath(node, e), e.isWarning(), true);
	                }
	                else {
	                    issue = createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, e.getMessage(), mapPath(node, e), e.isWarning());
	                }
	                v.accept(issue);
	            }
	            ;
	        }
	        var examplesLowLevel = node.lowLevel() && _.find(node.lowLevel().children(), function (x) { return x.key() == 'examples'; });
	        if (examplesLowLevel && examplesLowLevel.valueKind && examplesLowLevel.valueKind() === yaml.Kind.SEQ) {
	            issue = createLLIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, "map is expected here.", examplesLowLevel, node, false);
	            v.accept(issue);
	        }
	        if (node.property() && universeHelpers.isAnnotationTypesProperty(node.property())) {
	            var atAttrs = node.attributes(universes.Universe10.TypeDeclaration.properties.allowedTargets.name);
	            for (var _b = 0, atAttrs_1 = atAttrs; _b < atAttrs_1.length; _b++) {
	                var attr = atAttrs_1[_b];
	                this.checkAnnotationTarget(attr, v);
	            }
	        }
	    };
	    TypeDeclarationValidator.prototype.checkAnnotationTarget = function (attr, v) {
	        var val = attr.value();
	        if (val == null) {
	            return;
	        }
	        if (typeof (val) != "string") {
	            v.accept(createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, "annotation target must be set by a string", attr, false));
	        }
	        var str = val;
	        if (val.replace(/\w|\s/g, '').length > 0) {
	            v.accept(createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, "'allowedTargets' property value must be an array of type names or a single type name", attr, false));
	        }
	        else if (!this.annotables[str]) {
	            v.accept(createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, "unsupported annotation target: '" + str + "'", attr, false));
	        }
	    };
	    return TypeDeclarationValidator;
	}());
	function mapPath(node, e) {
	    var src = e.getValidationPath();
	    return findElementAtPath(node, src);
	}
	function extractLowLevelNode(e) {
	    var pn = e.getExtra(rtypes.SOURCE_EXTRA);
	    if (pn instanceof hlimpl.LowLevelWrapperForTypeSystem) {
	        return pn.node();
	    }
	    return null;
	}
	function findElementAtPath(n, p) {
	    if (!p) {
	        return n;
	    }
	    var chld = n.children();
	    for (var i = 0; i < chld.length; i++) {
	        if (chld[i].name() === p.name) {
	            return findElementAtPath(chld[i], p.child);
	        }
	    }
	    if (!n.lowLevel()) {
	        return n;
	    }
	    var lchld = n.lowLevel().children();
	    for (var i = 0; i < lchld.length; i++) {
	        if (lchld[i].key() === p.name) {
	            var nn = new hlimpl.BasicASTNode(lchld[i], n);
	            return findElementAtPath(nn, p.child);
	        }
	    }
	    if (!isNaN(p.name)) {
	        if (lchld[p.name]) {
	            var node = lchld[p.name];
	            var nn = new hlimpl.BasicASTNode(node, n);
	            return findElementAtPath(nn, p.child);
	        }
	    }
	    return n;
	}
	var CompositeNodeValidator = (function () {
	    function CompositeNodeValidator() {
	    }
	    CompositeNodeValidator.prototype.validate = function (node, acceptor) {
	        if (node.definition().isAnnotationType()) {
	            return;
	        }
	        if (node.lowLevel().keyKind() == yaml.Kind.SEQ) {
	            var isPattern = node.definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name);
	            if (!isPattern) {
	                acceptor.accept(createIssue(hl.IssueCode.UNKNOWN_NODE, "Node key can not be sequence", node));
	            }
	        }
	        if (node.definition().key() == universes.Universe08.GlobalSchema) {
	            if (node.lowLevel().valueKind() != yaml.Kind.SCALAR) {
	                var isString = false;
	                if (node.lowLevel().valueKind() == yaml.Kind.ANCHOR_REF || node.lowLevel().valueKind() == yaml.Kind.INCLUDE_REF) {
	                    var vl = node.lowLevel().value();
	                    if (typeof vl === "string") {
	                        isString = true;
	                    }
	                }
	                if (!isString) {
	                    acceptor.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "schema " + node.name() + " must be a string", node));
	                }
	            }
	        }
	        if (!node.parent()) {
	            new RAMLVersionAndFragmentValidator().validate(node, acceptor);
	            //Note: overloading validator now checks for oveloading and rejects it
	            if (node.definition().key() == universes.Universe08.Api || node.definition().key() == universes.Universe10.Api) {
	                new OverloadingValidator().validateApi(node.wrapperNode(), acceptor);
	            }
	            new ScalarQuoteValidator().validate(node, acceptor);
	            lintNode(node, acceptor);
	        }
	        new OverlayNodesValidator().validate(node, acceptor);
	        var nc = node.definition();
	        if (nc.key() == universes.Universe08.BodyLike) {
	            if (node.lowLevel().children().map(function (x) { return x.key(); }).some(function (x) { return x === "formParameters"; })) {
	                if (node.parent() && node.parent().definition().key() == universes.Universe08.Response) {
	                    var i = createIssue(hl.IssueCode.NODE_HAS_VALUE, "form parameters can not be used in response", node);
	                    acceptor.accept(i);
	                }
	                else if (node.lowLevel().children().map(function (x) { return x.key(); }).some(function (x) { return x === "schema" || x === "example"; })) {
	                    var i = createIssue(hl.IssueCode.NODE_HAS_VALUE, "formParameters cannot be used together with the example or schema properties", node);
	                    acceptor.accept(i);
	                }
	            }
	        }
	        if (nc.key() == universes.Universe10.OAuth2SecuritySchemeSettings) {
	            var requireUrl = false;
	            node.attributes("authorizationGrants").forEach(function (x) {
	                var vl = x.value();
	                if (vl === "authorization_code" || vl === "implicit") {
	                    requireUrl = true;
	                }
	                else if (vl !== "password" && vl !== 'client_credentials') {
	                    if (vl && typeof vl === "string" && vl.indexOf("://") == -1 && vl.indexOf(":") == -1) {
	                        var i = createIssue(hl.IssueCode.NODE_HAS_VALUE, "authorizationGrants should be one of authorization_code,implicit,password,client_credentials or to be an abolute URI", x);
	                        acceptor.accept(i);
	                    }
	                }
	            });
	            if (requireUrl) {
	                if (!node.attr("authorizationUri")) {
	                    var i = createIssue(hl.IssueCode.NODE_HAS_VALUE, "authorizationUri is required when `authorization_code` or `implicit` grant type are used ", node);
	                    acceptor.accept(i);
	                }
	            }
	        }
	        //validation of enum values;
	        if (node.definition().isAssignableFrom(universes.Universe08.Parameter.name)
	            || node.definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name)) {
	            var vls = node.attributes("enum").map(function (x) { return x.value(); });
	            if (vls.length != _.uniq(vls).length) {
	                var i = createIssue(hl.IssueCode.NODE_HAS_VALUE, "enum contains duplicated values", node);
	                acceptor.accept(i);
	            }
	            if (node.definition().isAssignableFrom(universes.Universe08.NumberTypeDeclaration.name) || node.definition().isAssignableFrom(universes.Universe10.NumberTypeDeclaration.name)) {
	                var isInteger = node.definition().isAssignableFrom(universes.Universe08.IntegerTypeDeclaration.name) || node.definition().isAssignableFrom(universes.Universe10.IntegerTypeDeclaration.name);
	                node.attributes("enum").forEach(function (attribute) {
	                    var value = isInteger ? parseInt(attribute.value()) : parseFloat(attribute.value());
	                    var isValid = isInteger ? !isNaN(value) && attribute.value().indexOf('.') === -1 : !isNaN(value);
	                    if (!isValid) {
	                        var issue = createIssue(hl.IssueCode.NODE_HAS_VALUE, (isInteger ? "Integer" : "Number") + " is expected", attribute);
	                        acceptor.accept(issue);
	                    }
	                });
	            }
	        }
	        if (universeHelpers.isResourceTypeType(node.definition())) {
	            if (node.value() == null && node.lowLevel().value(true) === "null") {
	                acceptor.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "Resource type can not be null", node));
	            }
	        }
	        checkPropertyQuard(node, acceptor);
	        var nodeValue = node.value();
	        if ((typeof nodeValue == 'string'
	            || typeof nodeValue == 'number'
	            || typeof nodeValue == 'boolean')
	            && !node.definition().getAdapter(services.RAMLService).allowValue()) {
	            if (node.parent()) {
	                if (nodeValue != '~') {
	                    var i = createIssue(hl.IssueCode.NODE_HAS_VALUE, "node " + node.name() + " can not be a scalar", node);
	                    acceptor.accept(i);
	                }
	            }
	        }
	        new RequiredPropertiesAndContextRequirementsValidator().validate(node, acceptor);
	        new ValidateChildrenKeys().validate(node, acceptor);
	        new NodeSpecificValidator().validate(node, acceptor);
	    };
	    return CompositeNodeValidator;
	}());
	var BaseUriParameterValidator = (function () {
	    function BaseUriParameterValidator() {
	    }
	    BaseUriParameterValidator.prototype.validate = function (node, acceptor) {
	        //we cant have "version" base uri parameter
	        var nameAttributeValue = node.attrValue(universes.Universe10.TypeDeclaration.properties.name.name);
	        if ("version" == nameAttributeValue) {
	            //I dont like the message, but its coming from JS 0.8 parser @Denis
	            acceptor.accept(createIssue(hl.IssueCode.ILLEGAL_PROPERTY, "version parameter not allowed here", node));
	        }
	    };
	    return BaseUriParameterValidator;
	}());
	var NodeSpecificValidatorRegistryEntry = (function () {
	    /**
	     *
	     * @param definition - array of definitions from universes
	     * @param propertyName - name of the property. May be null, then property is not tested.
	     * @param assignableFrom - whether instead of direct definition comparison, the tested node will be checked
	     * for assignability from the specified definitions
	     */
	    function NodeSpecificValidatorRegistryEntry(definitions, propertyName, validator, assignableFrom) {
	        if (assignableFrom === void 0) { assignableFrom = false; }
	        this.definitions = definitions;
	        this.propertyName = propertyName;
	        this.assignableFrom = assignableFrom;
	        this.validator = validator;
	    }
	    /**
	     * Checks whether this entry is applicable to the node. If so, invokes its validator.
	     * @param node
	     * @param cb
	     */
	    NodeSpecificValidatorRegistryEntry.prototype.validate = function (node, acceptor) {
	        var nodeDefinition = node.definition();
	        if (nodeDefinition == null)
	            return;
	        var definitionMatched = false;
	        if (!this.assignableFrom) {
	            definitionMatched =
	                this.definitions.some(function (currentDefinition) { return currentDefinition === nodeDefinition; });
	        }
	        else {
	            definitionMatched =
	                this.definitions.some(function (currentDefinition) { return nodeDefinition.isAssignableFrom(currentDefinition.name); });
	        }
	        if (!definitionMatched)
	            return;
	        if (this.propertyName != null) {
	            if (node.property() == null)
	                return;
	            if (node.property().nameId() != this.propertyName)
	                return;
	        }
	        //definition and property matched, invoking validator
	        this.validator.validate(node, acceptor);
	    };
	    return NodeSpecificValidatorRegistryEntry;
	}());
	/**
	 * A central switch for validations specific to a particular node.
	 * In future it would be nice to migrate all node-specific validation scattered around the code here.
	 */
	var NodeSpecificValidator = (function () {
	    function NodeSpecificValidator() {
	    }
	    NodeSpecificValidator.createRegistry = function () {
	        var result = [];
	        NodeSpecificValidator.registerValidator(result, [universes.Universe10.TypeDeclaration, universes.Universe08.Parameter], universes.Universe10.Api.properties.baseUriParameters.name, new BaseUriParameterValidator(), true);
	        return result;
	    };
	    NodeSpecificValidator.registerValidator = function (listToAddTo, definitions, propertyName, validator, assignableFrom) {
	        if (assignableFrom === void 0) { assignableFrom = false; }
	        var entry = new NodeSpecificValidatorRegistryEntry(definitions, propertyName, validator, assignableFrom);
	        listToAddTo.push(entry);
	    };
	    NodeSpecificValidator.prototype.validate = function (node, acceptor) {
	        NodeSpecificValidator.entries.forEach(function (entry) { return entry.validate(node, acceptor); });
	    };
	    NodeSpecificValidator.entries = NodeSpecificValidator.createRegistry();
	    return NodeSpecificValidator;
	}());
	var OverlayNodesValidator = (function () {
	    function OverlayNodesValidator() {
	    }
	    /**
	     * Checks that this node is in white list and
	     * makes itself and all of its children allowed to exist in overlay even
	     * if there is no master counterpart
	     * @param node
	     * @param root
	     * @returns {boolean}
	     */
	    OverlayNodesValidator.prototype.allowsAnyChildren = function (node, root) {
	        var property = node.property();
	        var definition = node.definition();
	        //accepting new annotation types
	        if ((universeHelpers.isAnnotationTypeType(definition) || universeHelpers.isTypeDeclarationTypeOrDescendant(definition))
	            && universeHelpers.isAnnotationTypesProperty(property))
	            return true;
	        //accepting new top-level type declarations
	        if (node.parent() == root && universeHelpers.isTypesProperty(property)
	            && universeHelpers.isTypeDeclarationTypeOrDescendant(definition))
	            return true;
	        //as we allow types, it is logical to also allow schemas as "schemas are only aliases for types"
	        if (universeHelpers.isSchemasProperty(property)
	            && universeHelpers.isTypeDeclarationTypeOrDescendant(definition))
	            return true;
	        //accepting documentation
	        if (node.parent() == root && universeHelpers.isDocumentationProperty(property)
	            && universeHelpers.isDocumentationType(definition))
	            return true;
	        //accepting annotations
	        if (universeHelpers.isAnnotationsProperty(property))
	            return true;
	        //uses allowed
	        if (universeHelpers.isUsesProperty(property))
	            return true;
	        //examples allowed
	        if (universeHelpers.isExamplesProperty(property))
	            return true;
	        return false;
	    };
	    /**
	     * Checks that this node is allowed to exist in overlay even if there is no master counterpart
	     * due to it or its parent being in the white list.
	     * @param node
	     * @param root
	     */
	    OverlayNodesValidator.prototype.nodeAllowedDueToParent = function (node, root) {
	        var currentNode = node;
	        while (currentNode != root && currentNode != null) {
	            if (this.allowsAnyChildren(currentNode, root)) {
	                return true;
	            }
	            currentNode = currentNode.parent();
	        }
	        return false;
	    };
	    OverlayNodesValidator.prototype.validate = function (node, v) {
	        var root = node.root();
	        var property = node.property();
	        var definition = node.definition();
	        //we are only validating overlays
	        if (!universeHelpers.isOverlayType(root.definition()))
	            return;
	        //for root only validate properties
	        if (node == root) {
	            this.validateProperties(node, v);
	            return;
	        }
	        //we have a whitelist of IHighLevelNodes allowed to be added in an overlay like new types, annotation types,
	        //annotation etc. The contents of such nodes is checked here.
	        if (this.nodeAllowedDueToParent(node, root))
	            return;
	        //checking for a node, this node overrides
	        var overrides = root.knownIds();
	        if (!overrides) {
	            //should never happen
	            return;
	        }
	        var override = overrides.hasOwnProperty(node.id());
	        if (override) {
	            //overrides are allowed, but we need to check properties, this override potentially brings in or changes:
	            this.validateProperties(node, v);
	            return;
	        }
	        //otherwise reporting an illegal node:
	        v.accept(createIssue(hl.IssueCode.ONLY_OVERRIDE_ALLOWED, "The '" + node.id() + "' node does not match any node of the master api.", node));
	    };
	    OverlayNodesValidator.prototype.validateProperties = function (node, acceptor) {
	        node.attrs().forEach(function (attribute) {
	            //ignoring key properties as they are not overriding anything
	            if (attribute.property().getAdapter(services.RAMLPropertyService).isKey()) {
	                return;
	            }
	            //ignoring nodes, which are not coming from this node, but from is master chain
	            if (attribute.parent() != node) {
	                return;
	            }
	            //yes, that also happens!
	            if (attribute.isElement()) {
	                return;
	            }
	            //title allowed
	            if (universeHelpers.isTitlePropertyName(attribute.name()))
	                return;
	            //description allowed
	            if (universeHelpers.isDescriptionPropertyName(attribute.name()))
	                return;
	            //displayName allowed
	            if (universeHelpers.isDisplayNamePropertyName(attribute.name()))
	                return;
	            //usage allowed
	            if (universeHelpers.isUsagePropertyName(attribute.name()))
	                return;
	            //example allowed
	            if (universeHelpers.isExampleProperty(attribute.property()))
	                return;
	            //masterRef allowed
	            if (universeHelpers.isMasterRefProperty(attribute.property()))
	                return;
	            //annotations allowed
	            if (universeHelpers.isAnnotationsProperty(attribute.property()))
	                return;
	            //uses allowed
	            if (universeHelpers.isUsesProperty(attribute.property()))
	                return;
	            //reporting the error
	            var message = "Property " + attribute.name() +
	                " is not allowed to be overriden or added in overlays";
	            acceptor.accept(createIssue(hl.IssueCode.ONLY_OVERRIDE_ALLOWED, message, attribute));
	        });
	    };
	    return OverlayNodesValidator;
	}());
	var RecurrentOverlayValidator = (function () {
	    function RecurrentOverlayValidator() {
	    }
	    RecurrentOverlayValidator.prototype.validate = function (node, v) {
	        var _this = this;
	        var z = new OverlayNodesValidator();
	        z.validate(node, v);
	        node.directChildren().forEach(function (x) { if (x.isElement()) {
	            _this.validate(x.asElement(), v);
	        } });
	    };
	    return RecurrentOverlayValidator;
	}());
	var RecurrentValidateChildrenKeys = (function () {
	    function RecurrentValidateChildrenKeys() {
	    }
	    RecurrentValidateChildrenKeys.prototype.val = function (node, v, p) {
	        var _this = this;
	        if (node.kind() == yaml.Kind.MAP || node.kind() == yaml.Kind.MAPPING) {
	            var ms = {};
	            node.children().forEach(function (x) {
	                var c = x.key();
	                if (c) {
	                    if (ms.hasOwnProperty(c)) {
	                        var issue = createIssue(hl.IssueCode.KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT, "keys should be unique", p, false);
	                        if (x.unit() == p.lowLevel().unit()) {
	                            issue.start = x.keyStart();
	                            issue.end = x.keyEnd();
	                        }
	                        v.accept(issue);
	                    }
	                    ms[c] = 1;
	                }
	            });
	        }
	        node.children().forEach(function (x) {
	            _this.val(x, v, p);
	        });
	    };
	    RecurrentValidateChildrenKeys.prototype.validate = function (node, v) {
	        this.val(node.lowLevel(), v, node);
	    };
	    return RecurrentValidateChildrenKeys;
	}());
	var ValidateChildrenKeys = (function () {
	    function ValidateChildrenKeys() {
	    }
	    ValidateChildrenKeys.prototype.validate = function (node, acceptor) {
	        //validation is being performed at high level instead of low-level
	        //to provide more meaningful and specific error messages
	        this.validateChildElements(node, acceptor);
	        var lowLevelChildren = node.lowLevel().children();
	        var keyToLowLevelChildren = _.groupBy(lowLevelChildren.filter(function (x) { return x.key() != null; }), function (x) { return x.key(); });
	        this.validateChildAttributes(node, keyToLowLevelChildren, acceptor);
	        this.validateUnrecognizedLowLevelChildren(node, keyToLowLevelChildren, acceptor);
	    };
	    ValidateChildrenKeys.prototype.validateChildElements = function (node, acceptor) {
	        //testing for child elements having equal keys
	        var keyToElements = {};
	        var childElements = node.directChildren().filter(function (x) { return x.isElement(); });
	        childElements.forEach(function (childNode) {
	            var childElement = childNode;
	            if (childElement["_computed"]) {
	                return;
	            }
	            if (!childElement.name()) {
	                return; //handling nodes with no key (documentation)
	            }
	            var elementKey = childElement.name() + childElement.property().nameId();
	            if (keyToElements.hasOwnProperty(elementKey)) {
	                if (!childElement.isNamePatch()) {
	                    keyToElements[elementKey].push(childElement);
	                }
	            }
	            else {
	                keyToElements[elementKey] = [childElement];
	            }
	        });
	        Object.keys(keyToElements).forEach(function (key) {
	            var childElements = keyToElements[key];
	            if (!childElements || childElements.length < 2)
	                return;
	            childElements.forEach(function (childElement) {
	                var message = "";
	                var humanReadableName = getHumanReadableNodeName(childElement);
	                if (humanReadableName) {
	                    var capitalized = humanReadableName.charAt(0).toUpperCase() + humanReadableName.slice(1);
	                    var message = capitalized + " '" + childElement.name() + "' already exists";
	                }
	                else {
	                    message = childElement.name() + " already exists in this context";
	                }
	                var issue = createIssue(hl.IssueCode.KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT, message, childElement);
	                acceptor.accept(issue);
	            });
	        });
	    };
	    ValidateChildrenKeys.prototype.validateChildAttributes = function (node, keyToLowLevelChildren, acceptor) {
	        var highLevelAttributes = this.getHighLevelAttributes(node);
	        var nameToHighLevelAttributes = _.groupBy(highLevelAttributes, function (x) { return x.name(); });
	        var allowsAnyAndHasRequireds = this.allowsAnyAndHasRequireds(node);
	        Object.keys(nameToHighLevelAttributes).forEach(function (attributeName) {
	            if (nameToHighLevelAttributes[attributeName].length < 2) {
	                return;
	            }
	            var isUnknown = nameToHighLevelAttributes[attributeName][0].isUnknown();
	            var isMultiValue = !isUnknown && nameToHighLevelAttributes[attributeName][0].property().isMultiValue();
	            if (isMultiValue && (node.definition().isAssignableFrom(universes.Universe08.SecuritySchemeSettings.name) ||
	                node.definition().isAssignableFrom(universes.Universe10.SecuritySchemeSettings.name))) {
	                isMultiValue = keyToLowLevelChildren[attributeName] && keyToLowLevelChildren[attributeName].length === 1;
	            }
	            if ((isUnknown && allowsAnyAndHasRequireds) || !isMultiValue ||
	                (isMultiValue && keyToLowLevelChildren[attributeName] != null && keyToLowLevelChildren[attributeName].length > 1)) {
	                //we blame even multivalue properties if they have duplicated low-level keys as YAML forbids this
	                nameToHighLevelAttributes[attributeName].forEach(function (attribute) {
	                    var message = "property already used: '" + (attribute.property() ? attribute.property().nameId() : attribute.name()) + "'";
	                    var humanReadableParent = getHumanReadableNodeName(attribute.parent());
	                    if (humanReadableParent) {
	                        var capitalizedParent = humanReadableParent.charAt(0).toUpperCase() + humanReadableParent.slice(1);
	                        message = capitalizedParent + " " + message;
	                    }
	                    var issue = createIssue(hl.IssueCode.PROPERTY_EXPECT_TO_HAVE_SINGLE_VALUE, message, attribute);
	                    acceptor.accept(issue);
	                });
	            }
	        });
	    };
	    ValidateChildrenKeys.prototype.validateUnrecognizedLowLevelChildren = function (node, keyToLowLevelChildren, acceptor) {
	        var highLevelChildren = node.directChildren();
	        var nameToHighLevelChildren = _.groupBy(highLevelChildren, function (x) { return x.name(); });
	        Object.keys(keyToLowLevelChildren).forEach(function (lowLevelChildKey) {
	            if (lowLevelChildKey) {
	                if (keyToLowLevelChildren[lowLevelChildKey].length > 1 && !nameToHighLevelChildren[lowLevelChildKey]) {
	                    if (node.definition().isAssignableFrom(universes.Universe10.ObjectTypeDeclaration.name)) {
	                        return;
	                    }
	                    var message = "property already used: '" + lowLevelChildKey + "'";
	                    var humanReadableNode = getHumanReadableNodeName(node);
	                    if (humanReadableNode) {
	                        var capitalizedParent = humanReadableNode.charAt(0).toUpperCase() + humanReadableNode.slice(1);
	                        message = capitalizedParent + " " + message;
	                    }
	                    keyToLowLevelChildren[lowLevelChildKey].forEach(function (lowLevelChild) {
	                        var i = createLLIssue(hl.IssueCode.PROPERTY_EXPECT_TO_HAVE_SINGLE_VALUE, message, lowLevelChild, node);
	                        i.start = lowLevelChild.keyStart();
	                        i.end = lowLevelChild.keyEnd();
	                        acceptor.accept(i);
	                    });
	                }
	            }
	        });
	    };
	    ValidateChildrenKeys.prototype.filterMultiValueAnnotations = function (node, keyToLowLevelChildren, acceptor) {
	        var highLevelAttributes = this.getHighLevelAttributes(node);
	        var computedAnnotationsMultiplValues = false;
	        Object.keys(keyToLowLevelChildren).forEach(function (lowLevelChildKey) {
	            if (lowLevelChildKey.charAt(0) !== '(' || keyToLowLevelChildren[lowLevelChildKey].length < 2) {
	                return;
	            }
	        });
	    };
	    ValidateChildrenKeys.prototype.getHighLevelAttributes = function (node) {
	        var allowsAnyAndHasRequireds = this.allowsAnyAndHasRequireds(node);
	        return node.directChildren().filter(function (x) { return x.isAttr() || allowsAnyAndHasRequireds; });
	    };
	    ValidateChildrenKeys.prototype.allowsAnyAndHasRequireds = function (node) {
	        var requireds = node.definition().requiredProperties();
	        var hasRequireds = requireds && requireds.length > 0;
	        var ramlService = node.definition().getAdapter(services.RAMLService);
	        var isAllowAny = ramlService && ramlService.getAllowAny();
	        var anyExceptRequireds = isAllowAny && hasRequireds;
	        return anyExceptRequireds;
	    };
	    return ValidateChildrenKeys;
	}());
	function contentProvider(lowLevel) {
	    var root = lowLevel && lowLevel.includeBaseUnit() && ((lowLevel.includePath && lowLevel.includePath()) ? lowLevel.includeBaseUnit().resolve(lowLevel.includePath()) : lowLevel.includeBaseUnit());
	    return new contentprovider.ContentProvider(root);
	}
	/**
	 * validates examples
	 */
	var ExampleAndDefaultValueValidator = (function () {
	    function ExampleAndDefaultValueValidator() {
	    }
	    ExampleAndDefaultValueValidator.prototype.validate = function (node, cb) {
	        //check if we expect to do strict validation
	        var strictValidation = this.isStrict(node);
	        if (!strictValidation) {
	            if (!settings.validateNotStrictExamples) {
	                return;
	            }
	        }
	        var pObj = this.parseObject(node, cb, strictValidation);
	        if (!pObj) {
	            return;
	        }
	        var schema = this.aquireSchema(node);
	        if (schema) {
	            schema.validate(pObj, cb, strictValidation);
	        }
	    };
	    ExampleAndDefaultValueValidator.prototype.isExampleNode = function (node) {
	        return this.isSingleExampleNode(node) || this.isExampleNodeInMultipleDecl(node);
	    };
	    ExampleAndDefaultValueValidator.prototype.isSingleExampleNode = function (node) {
	        return node.name() == universes.Universe10.TypeDeclaration.properties.example.name;
	    };
	    ExampleAndDefaultValueValidator.prototype.isExampleNodeInMultipleDecl = function (node) {
	        var parent = node.parent();
	        if (parent) {
	            return universeHelpers.isExampleSpecType(parent.definition());
	        }
	        return false;
	    };
	    ExampleAndDefaultValueValidator.prototype.findParentSchemaOrTypeAttribute = function (node) {
	        var attribute = node.parent().attr(universes.Universe10.TypeDeclaration.properties.schema.name);
	        if (attribute) {
	            return attribute;
	        }
	        attribute = node.parent().attr(universes.Universe10.TypeDeclaration.properties.type.name);
	        if (attribute) {
	            return attribute;
	        }
	        if (!node.parent()) {
	            return null;
	        }
	        attribute = node.parent().parent().attr(universes.Universe10.TypeDeclaration.properties.schema.name);
	        if (attribute) {
	            return attribute;
	        }
	        attribute = node.parent().parent().attr(universes.Universe10.TypeDeclaration.properties.type.name);
	        if (attribute) {
	            return attribute;
	        }
	        return null;
	    };
	    ExampleAndDefaultValueValidator.prototype.aquireSchema = function (node) {
	        var sp = node.parent().definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name);
	        if (this.isExampleNode(node)) {
	            var sampleRoot = node;
	            if (this.isExampleNodeInMultipleDecl(node)) {
	                sampleRoot = node.parent();
	            }
	            if (sampleRoot.parent()) {
	                if (sampleRoot.parent().definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name) && sampleRoot.parent().parent() === null) {
	                    sp = false;
	                }
	                else if (sampleRoot.parent().property().nameId() == universes.Universe10.LibraryBase.properties.types.name) {
	                    sp = false;
	                }
	                if (sampleRoot.parent().parent()) {
	                    var ppc = sampleRoot.parent().parent().definition().key();
	                    if (ppc == universes.Universe08.Method || ppc == universes.Universe10.Method) {
	                        if (sampleRoot.parent().property().nameId() == universes.Universe10.MethodBase.properties.queryParameters.name) {
	                        }
	                        else {
	                            sp = true;
	                        }
	                    }
	                    if (ppc == universes.Universe08.Response || ppc == universes.Universe10.Response) {
	                        sp = true;
	                    }
	                }
	            }
	        }
	        if (node.parent().definition().key() == universes.Universe08.BodyLike || sp) {
	            //FIXME MULTIPLE INHERITANCE
	            var sa = this.findParentSchemaOrTypeAttribute(node);
	            if (sa) {
	                var val = sa.value();
	                if (val instanceof hlimpl.StructuredValue) {
	                    return null;
	                }
	                var strVal = ("" + val).trim();
	                var so = null;
	                if (strVal.charAt(0) == "{") {
	                    try {
	                        so = su.getJSONSchema(strVal, contentProvider(sa.lowLevel()));
	                    }
	                    catch (e) {
	                        return null;
	                    }
	                }
	                if (strVal.charAt(0) == "<") {
	                    try {
	                        so = su.getXMLSchema(strVal);
	                    }
	                    catch (e) {
	                        return null;
	                    }
	                }
	                if (so) {
	                    return {
	                        validate: function (pObje, cb, strict) {
	                            try {
	                                if (pObje.__$validated) {
	                                    return;
	                                }
	                                if (so instanceof Error) {
	                                    cb.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, so.message, node, !strict));
	                                    return;
	                                }
	                                so.validateObject(pObje);
	                            }
	                            catch (e) {
	                                var illegalRequiredMessageStart = "Cannot assign to read only property '__$validated' of ";
	                                if (e.message && e.message.indexOf(illegalRequiredMessageStart) == 0) {
	                                    var propertyName = e.message.substr(illegalRequiredMessageStart.length, e.message.length - illegalRequiredMessageStart.length);
	                                    var patchedErrorMessage = "Invalid JSON schema. Potentially, required array containing value "
	                                        + propertyName + " has invalid location";
	                                    cb.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, patchedErrorMessage, sa, !strict));
	                                    return;
	                                }
	                                if (e.message == "Object.keys called on non-object") {
	                                    return;
	                                }
	                                cb.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "Example does not conform to schema:" + e.message, node, !strict));
	                                return;
	                            }
	                            //validate using classical schema;
	                        }
	                    };
	                }
	                else {
	                    if (strVal.length > 0) {
	                        var nodeParent = node.parent();
	                        var grandParent = nodeParent && nodeParent.parent();
	                        var owner = nodeParent && nodeParent.definition() && nodeParent.definition().isAssignableFrom(universes.Universe10.ObjectTypeDeclaration.name) && nodeParent;
	                        owner = owner || (grandParent && grandParent.definition() && grandParent.definition().isAssignableFrom(universes.Universe10.ObjectTypeDeclaration.name) && grandParent);
	                        if (owner) {
	                            return this.typeValidator(owner, node);
	                        }
	                    }
	                }
	            }
	        }
	        return this.getSchemaFromModel(node);
	    };
	    ExampleAndDefaultValueValidator.prototype.getSchemaFromModel = function (node) {
	        var p = node.parent();
	        // if (node.property().nameId()==universes.Universe10.ExampleSpec.properties.content.name){
	        //     p=p.parent();
	        // }
	        return this.typeValidator(p, node);
	    };
	    ExampleAndDefaultValueValidator.prototype.typeValidator = function (p, node) {
	        var newVar = {
	            validate: function (pObje, cb, strict) {
	                var pt = p.parsedType();
	                if (pt && !pt.isUnknown()) {
	                    if (typeof pObje === "number" && pt.isString()) {
	                        pObje = "" + pObje;
	                    }
	                    if (typeof pObje === "boolean" && pt.isString()) {
	                        pObje = "" + pObje;
	                    }
	                    if (pt.getExtra("repeat")) {
	                        pObje = [pObje];
	                    }
	                    var validateObject = pt.validate(pObje, false);
	                    if (!validateObject.isOk()) {
	                        validateObject.getErrors().forEach(function (e) { return cb.accept(createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, e.getMessage(), node, !strict)); });
	                    }
	                }
	            }
	        };
	        return newVar;
	    };
	    ;
	    ExampleAndDefaultValueValidator.prototype.toObject = function (h, v, cb) {
	        var res = v.lowLevel().dumpToObject(true);
	        this.testDublication(h, v.lowLevel(), cb);
	        if (res["example"]) {
	            return res["example"];
	        }
	        if (res["content"]) {
	            return res["content"];
	        }
	    };
	    ExampleAndDefaultValueValidator.prototype.testDublication = function (h, v, cb) {
	        var _this = this;
	        var map = {};
	        v.children().forEach(function (x) {
	            if (x.key()) {
	                if (map[x.key()]) {
	                    cb.accept(createIssue(hl.IssueCode.KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT, "Keys should be unique", new hlimpl.BasicASTNode(x, h.parent())));
	                }
	                map[x.key()] = x;
	            }
	            _this.testDublication(h, x, cb);
	        });
	    };
	    ExampleAndDefaultValueValidator.prototype.parseObject = function (node, cb, strictValidation) {
	        var pObj = null;
	        var vl = node.value();
	        var mediaType = getMediaType(node);
	        if (vl instanceof hlimpl.StructuredValue) {
	            //validate in context of type/schema
	            pObj = this.toObject(node, vl, cb);
	        }
	        else {
	            if (mediaType) {
	                if (isJson(mediaType)) {
	                    try {
	                        pObj = JSON.parse(vl);
	                    }
	                    catch (e) {
	                        cb.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "Can not parse JSON:" + e.message, node, !strictValidation));
	                        return;
	                    }
	                }
	                if (isXML(mediaType)) {
	                    try {
	                        pObj = xmlutil(vl);
	                    }
	                    catch (e) {
	                        cb.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "Can not parse XML:" + e.message, node, !strictValidation));
	                        return;
	                    }
	                }
	            }
	            else {
	                try {
	                    if (vl && vl.length > 0 && (vl.trim().charAt(0) == '[' || vl.trim().charAt(0) == '{' || vl.trim().charAt(0) == '<')) {
	                        pObj = JSON.parse(vl);
	                    }
	                    else {
	                        if (vl == "true") {
	                            return true;
	                        }
	                        else if (vl == "false") {
	                            return false;
	                        }
	                        else {
	                            var n = parseFloat(vl);
	                            if (!isNaN(n)) {
	                                return n;
	                            }
	                        }
	                        return vl;
	                    }
	                }
	                catch (e) {
	                    if (vl.trim().indexOf("<") == 0) {
	                        try {
	                            pObj = xmlutil(vl);
	                        }
	                        catch (e) {
	                            cb.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "Can not parse XML:" + e.message, node, !strictValidation));
	                            return;
	                        }
	                    }
	                    else {
	                        //cb.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "Can not parse JSON:" + e.message, node, !strictValidation));
	                        return vl;
	                    }
	                }
	            }
	        }
	        return pObj;
	    };
	    ExampleAndDefaultValueValidator.prototype.isStrict = function (node) {
	        if (universeHelpers.isDefaultValue(node.property())) {
	            return true;
	        }
	        if (universeHelpers.isExampleProperty(node.property())
	            && node.parent().definition().universe().version() == "RAML08") {
	            //for RAML 0.8 we do not validate examples strictly
	            return false;
	        }
	        var strictValidation = false;
	        var strict = node.parent().attr("strict");
	        if (strict) {
	            if (strict.value() == 'true') {
	                strictValidation = true;
	            }
	        }
	        return strictValidation;
	    };
	    return ExampleAndDefaultValueValidator;
	}());
	exports.ExampleAndDefaultValueValidator = ExampleAndDefaultValueValidator;
	var toReadableName = function (template, toLowerCase, pluralize_) {
	    var templateName = changeCase.sentence(template);
	    if (!toLowerCase) {
	        templateName = changeCase.ucFirst(templateName);
	    }
	    if (pluralize_) {
	        templateName = pluralize.plural(templateName);
	    }
	    return templateName;
	};
	var OptionalPropertiesValidator = (function () {
	    function OptionalPropertiesValidator() {
	    }
	    OptionalPropertiesValidator.prototype.validate = function (node, v) {
	        if (node.isAttr()) {
	            if (!node.optional()) {
	                return;
	            }
	            var attr = node;
	            var prop = attr.property();
	            if (prop.isMultiValue() || prop.range().isArray()) {
	                return;
	            }
	            if (!prop.isFromParentKey()) {
	                var template = typeOfContainingTemplate(attr.parent());
	                if (template) {
	                    if (prop.isValueProperty()) {
	                        var templateNamePlural = toReadableName(template, true, true);
	                        var message = "Optional scalar properties are not allowed in "
	                            + templateNamePlural + " and their descendants: " + attr.name() + "?";
	                        var issue = createIssue(hl.IssueCode.INVALID_PROPERTY, message, attr, false);
	                        v.accept(issue);
	                    }
	                }
	            }
	        }
	        else if (node.isElement()) {
	            var aNode = node;
	            var prop = aNode.property();
	            var allowsQuestion = aNode.allowsQuestion();
	            if (!allowsQuestion) {
	                var propName = prop ? toReadableName(prop.nameId(), true, true) : 'API root';
	                aNode.optionalProperties().forEach(function (x) {
	                    aNode.children().forEach(function (y) {
	                        var message = "Optional properties are not allowed in "
	                            + propName + ": " + y.lowLevel().key() + "?";
	                        var issue = createIssue(hl.IssueCode.INVALID_PROPERTY, message, node, false);
	                        v.accept(issue);
	                    });
	                });
	            }
	            var def = node.asElement().definition();
	            if (node.optional() && def.universe().version() == "RAML10") {
	                var prop = node.property();
	                var isParam = universeHelpers.isQueryParametersProperty(prop)
	                    || universeHelpers.isUriParametersProperty(prop)
	                    || universeHelpers.isHeadersProperty(prop);
	                if (!universeHelpers.isMethodType(def) && !(universeHelpers.isTypeDeclarationType(def) && isParam)) {
	                    var issue = createIssue(hl.IssueCode.MISSED_CONTEXT_REQUIREMENT, "Only method nodes can be optional", node, false);
	                    v.accept(issue);
	                }
	            }
	        }
	    };
	    return OptionalPropertiesValidator;
	}());
	var UriParametersValidator = (function () {
	    function UriParametersValidator() {
	    }
	    UriParametersValidator.prototype.validate = function (node, v) {
	        var def = node.definition();
	        var baseUriPropName = universes.Universe10.Api.properties.baseUri.name;
	        var baseUriParamsPropName = universes.Universe10.Api.properties.baseUriParameters.name;
	        var uriPropName = universes.Universe10.Resource.properties.relativeUri.name;
	        var uriParamsPropName = universes.Universe10.ResourceBase.properties.uriParameters.name;
	        if (universeHelpers.isApiSibling(def)) {
	            this.inspectParameters(node, v, baseUriPropName, baseUriParamsPropName);
	        }
	        else if (universeHelpers.isResourceType(def)) {
	            var rootNode = node.root();
	            this.inspectParameters(node, v, baseUriPropName, baseUriParamsPropName, rootNode);
	            this.inspectParameters(node, v, uriPropName, uriParamsPropName);
	        }
	        else if (universeHelpers.isResourceTypeType(def)) {
	            var rootNode = node.root();
	            this.inspectParameters(node, v, baseUriPropName, baseUriParamsPropName, rootNode);
	        }
	    };
	    UriParametersValidator.prototype.inspectParameters = function (node, v, uriPropName, paramsPropName, rootNode) {
	        rootNode = rootNode || node;
	        var uriValue = '';
	        var uriAttr = rootNode.attr(uriPropName);
	        if (uriAttr) {
	            uriValue = uriAttr.value();
	            if (!uriValue || typeof (uriValue) != "string") {
	                uriValue = '';
	            }
	        }
	        var paramElements = node.elementsOfKind(paramsPropName);
	        paramElements.forEach(function (x) {
	            var nameAttr = x.attr(universes.Universe10.TypeDeclaration.properties.name.name);
	            if (nameAttr) {
	                var name = nameAttr.value();
	                if (name != null) {
	                    if (uriValue.indexOf('{' + name + '}') < 0) {
	                        if (universeHelpers.isResourceTypeType(node.definition())) {
	                            if (name.indexOf('<<') >= 0) {
	                                return;
	                            }
	                        }
	                        var propNameReadable = pluralize.singular(changeCase.sentence(paramsPropName));
	                        var message = changeCase.ucFirst(propNameReadable) + " unused";
	                        var issue = createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, message, x, true);
	                        v.accept(issue);
	                    }
	                }
	            }
	        });
	    };
	    return UriParametersValidator;
	}());
	var TemplateCyclesDetector = (function () {
	    function TemplateCyclesDetector() {
	        this.nameProperty = universes.Universe10.ResourceType.properties.name.name;
	    }
	    TemplateCyclesDetector.prototype.validate = function (node, v) {
	        var definition = node.definition();
	        if (!(universeHelpers.isLibraryBaseSibling(definition) || universeHelpers.isApiType(definition))) {
	            return;
	        }
	        var resourceTypesProp = universes.Universe10.LibraryBase.properties.resourceTypes.name;
	        var typeProp = universes.Universe10.ResourceBase.properties.type.name;
	        var traitsProp = universes.Universe10.LibraryBase.properties.traits.name;
	        var isProp = universes.Universe10.MethodBase.properties.is.name;
	        var allResourceTypes = search.globalDeclarations(node)
	            .filter(function (x) { return universeHelpers.isResourceTypeType(x.definition()); });
	        var alltraits = search.globalDeclarations(node)
	            .filter(function (x) { return universeHelpers.isTraitType(x.definition()); });
	        this.checkCycles(allResourceTypes, typeProp, v);
	        this.checkCycles(alltraits, isProp, v);
	    };
	    TemplateCyclesDetector.prototype.checkCycles = function (templates, propName, v) {
	        var _this = this;
	        var templatesMap = {};
	        templates.forEach(function (x) {
	            var name = _this.templateName(x);
	            templatesMap[name] = x;
	        });
	        var templatesWithCycle = {};
	        templates.forEach(function (template) {
	            var name = _this.templateName(template);
	            if (templatesWithCycle[name]) {
	                //skip checking templates which are already known to have cycles in definition;
	                return;
	            }
	            _this.findCyclesInDefinition(template, propName, templatesMap).forEach(function (cycle) {
	                //mark templates which have cycles in definitions
	                cycle.forEach(function (x) { return templatesWithCycle[x] = true; });
	                cycle = cycle.reverse();
	                var message = toReadableName(template.definition().nameId())
	                    + " definition contains cycle: " + cycle.join(" -> ");
	                var issue = createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, message, template, false);
	                v.accept(issue);
	            });
	        });
	    };
	    TemplateCyclesDetector.prototype.templateName = function (node) {
	        var nameAttribute = node.attr(this.nameProperty);
	        if (!nameAttribute) {
	            return null;
	        }
	        return nameAttribute.value();
	    };
	    TemplateCyclesDetector.prototype.findCyclesInDefinition = function (node, propName, templatesMap, occuredTemplates) {
	        if (occuredTemplates === void 0) { occuredTemplates = {}; }
	        var name = this.templateName(node);
	        if (occuredTemplates[name]) {
	            return [[name]];
	        }
	        var nextOccuredTemplates = {};
	        Object.keys(occuredTemplates).forEach(function (x) { return nextOccuredTemplates[x] = occuredTemplates[x]; });
	        nextOccuredTemplates[name] = true;
	        var occuredCycles = [];
	        var templatesRefs = node.attributes(propName);
	        for (var i = 0; i < templatesRefs.length; i++) {
	            var ref = templatesRefs[i];
	            var val = ref.value();
	            if (val) {
	                var refName = typeof (val) == 'string' ? val : val.valueName();
	                var template = templatesMap[refName];
	                if (template != null) {
	                    var newCycles = this.findCyclesInDefinition(template, propName, templatesMap, nextOccuredTemplates);
	                    newCycles.forEach(function (x) { return occuredCycles.push(x); });
	                }
	            }
	        }
	        occuredCycles.forEach(function (x) { return x.push(name); });
	        return occuredCycles;
	    };
	    return TemplateCyclesDetector;
	}());
	function isJson(s) {
	    return s.indexOf("json") != -1;
	}
	exports.isJson = isJson;
	function isXML(s) {
	    return s.indexOf("xml") != -1;
	}
	exports.isXML = isXML;
	function getMediaType(node) {
	    var vl = getMediaType2(node);
	    if (vl == 'body') {
	        var rootMedia = node.root().attr("mediaType");
	        if (rootMedia) {
	            return rootMedia.value();
	        }
	        return null;
	    }
	    return vl;
	}
	exports.getMediaType = getMediaType;
	function getMediaType2(node) {
	    if (node.parent()) {
	        var pc = node.parent().definition();
	        if (pc.key() == universes.Universe08.BodyLike) {
	            return node.parent().name();
	        }
	        if (node.parent().parent()) {
	            var ppc = node.parent().parent().definition().key();
	            if (ppc == universes.Universe08.Response || ppc == universes.Universe10.Response) {
	                if (node.parent().property().nameId() == universes.Universe08.Response.properties.headers.name) {
	                    return null;
	                }
	                return node.parent().name();
	            }
	            if (ppc == universes.Universe08.Method || ppc == universes.Universe10.Method) {
	                if (node.parent().property().nameId() == universes.Universe10.MethodBase.properties.queryParameters.name
	                    || node.parent().property().nameId() == universes.Universe10.MethodBase.properties.headers.name) {
	                    return null;
	                }
	                return node.parent().name();
	            }
	        }
	    }
	    return null;
	}
	var localError = function (node, c, w, message, p, prop, positionsSource) {
	    var llNode = positionsSource ? positionsSource : node.lowLevel();
	    var contents = llNode.unit() && llNode.unit().contents();
	    var contentLength = contents && contents.length;
	    var st = llNode.start();
	    var et = llNode.end();
	    if (contentLength && contentLength < et) {
	        et = contentLength - 1;
	    }
	    if (llNode.key() && llNode.keyStart()) {
	        var ks = llNode.keyStart();
	        if (ks > 0) {
	            st = ks;
	        }
	        var ke = llNode.keyEnd();
	        if (ke > 0) {
	            et = ke;
	        }
	    }
	    if (et < st) {
	        et = st + 1;
	        //this happens for empty APIs, when we basically have nothing to parse
	        if (node.isElement()) {
	            var definition = node.definition();
	            if (universeHelpers.isApiType(definition)) {
	                st = contentLength == 0 ? 0 : contentLength - 1;
	                et = st;
	            }
	        }
	    }
	    if (prop && !prop.getAdapter(services.RAMLPropertyService).isMerged() && node.parent() == null) {
	        var nm = _.find(llNode.children(), function (x) { return x.key() == prop.nameId(); });
	        if (nm) {
	            var ks = nm.keyStart();
	            var ke = nm.keyEnd();
	            if (ks > 0 && ke > ks) {
	                st = ks;
	                et = ke;
	            }
	        }
	    }
	    return {
	        code: c,
	        isWarning: w,
	        message: message,
	        node: node,
	        start: st,
	        end: et,
	        path: p ? (llNode.unit() ? llNode.unit().path() : "") : null,
	        extras: [],
	        unit: node ? llNode.unit() : null
	    };
	};
	var localLowLevelError = function (node, highLevelAnchor, issueCode, isWarning, message, path) {
	    var contents = node.unit() && node.unit().contents();
	    var contentLength = contents && contents.length;
	    var st = node.start();
	    var et = node.end();
	    if (contentLength && contentLength >= et) {
	        et = contentLength - 1;
	    }
	    if (node.key() && node.keyStart()) {
	        var ks = node.keyStart();
	        if (ks > 0) {
	            st = ks;
	        }
	        var ke = node.keyEnd();
	        if (ke > 0) {
	            et = ke;
	        }
	    }
	    return {
	        code: issueCode,
	        isWarning: isWarning,
	        message: message,
	        node: highLevelAnchor,
	        start: st,
	        end: et,
	        path: path ? (node.unit() ? node.unit().path() : "") : null,
	        extras: [],
	        unit: node ? node.unit() : null
	    };
	};
	function toIssue(error, node) {
	    return createIssue(hl.IssueCode.ILLEGAL_PROPERTY_VALUE, error.getMessage(), mapPath(node, error), error.isWarning());
	}
	exports.toIssue = toIssue;
	function createIssue(c, message, node, w) {
	    if (w === void 0) { w = false; }
	    //console.log(node.name()+node.lowLevel().start()+":"+node.id());
	    var original = null;
	    var pr = null;
	    if (node.lowLevel() instanceof proxy.LowLevelProxyNode) {
	        var proxyNode = node.lowLevel();
	        while (!proxyNode.primaryNode()) {
	            if (!original) {
	                original = localError(node, c, w, message, true, pr);
	            }
	            node = node.parent();
	            proxyNode = node.lowLevel();
	        }
	    }
	    if (node) {
	        pr = node.property();
	        if (node.lowLevel().unit() != node.root().lowLevel().unit()) {
	            original = localError(node, c, w, message, true, pr);
	            var v = node.lowLevel().unit();
	            if (v) {
	            }
	            while (node.lowLevel().unit() != node.root().lowLevel().unit()) {
	                pr = node.property();
	                node = node.parent();
	            }
	        }
	    }
	    if (original) {
	        if (node.property() && node.property().nameId() == universes.Universe10.FragmentDeclaration.properties.uses.name && node.parent() != null) {
	            pr = node.property(); //FIXME there should be other cases
	            node = node.parent();
	        }
	    }
	    var error = localError(node, c, w, message, false, pr);
	    if (original) {
	        original.extras.push(error);
	        error = original;
	    }
	    //console.log(error.start+":"+error.end)
	    return error;
	}
	exports.createIssue = createIssue;
	function createLLIssue(issueCode, message, node, rootCalculationAnchor, isWarning, p) {
	    if (isWarning === void 0) { isWarning = false; }
	    if (p === void 0) { p = false; }
	    var original = null;
	    if (node) {
	        if (rootCalculationAnchor.lowLevel().unit() != rootCalculationAnchor.root().lowLevel().unit()) {
	            original = localLowLevelError(node, rootCalculationAnchor, issueCode, isWarning, message, true);
	            var v = rootCalculationAnchor.lowLevel().unit();
	            if (v) {
	                message = message + " " + v.path();
	            }
	            while (rootCalculationAnchor.lowLevel().unit() != rootCalculationAnchor.root().lowLevel().unit()) {
	                rootCalculationAnchor = rootCalculationAnchor.parent();
	            }
	        }
	    }
	    if (original) {
	        if (rootCalculationAnchor.property() && rootCalculationAnchor.property().nameId()
	            == universes.Universe10.FragmentDeclaration.properties.uses.name && rootCalculationAnchor.parent() != null) {
	            rootCalculationAnchor = rootCalculationAnchor.parent();
	        }
	    }
	    var error = localLowLevelError(node, rootCalculationAnchor, issueCode, isWarning, message, p);
	    if (original) {
	        original.extras.push(error);
	        error = original;
	    }
	    //console.log(error.start+":"+error.end)
	    return error;
	}
	exports.createLLIssue = createLLIssue;
	function validateResponseString(v) {
	    if (v.length != 3) {
	        return new Error("Status code should be 3 digits number.");
	    }
	    for (var i = 0; i < v.length; i++) {
	        var c = v[i];
	        if (!_.find(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'], function (x) { return x == c; })) {
	            return new Error("Status code should be 3 digits number.");
	        }
	    }
	    return null;
	}
	exports.validateResponseString = validateResponseString;
	//# sourceMappingURL=linter.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59)))

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/main.d.ts" />
	"use strict";
	var defs = __webpack_require__(36);
	var hl = __webpack_require__(10);
	var yaml = __webpack_require__(72);
	var _ = __webpack_require__(63);
	var def = defs;
	var hlimpl = __webpack_require__(16);
	var proxy = __webpack_require__(39);
	var search = __webpack_require__(23);
	var universes = __webpack_require__(22);
	var universeHelpers = __webpack_require__(14);
	var services = defs;
	var ramlTypes = defs.rt;
	var mediaTypeParser = __webpack_require__(61);
	var KeyMatcher = (function () {
	    function KeyMatcher(_props) {
	        this._props = _props;
	        this.parentValue = _.find(_props, function (x) { return x.isFromParentValue(); });
	        this.parentKey = _.find(_props, function (x) { return x.isFromParentKey(); });
	        this.canBeValue = _.find(_props, function (x) { return x.canBeValue(); });
	    }
	    KeyMatcher.prototype.add = function (p) {
	        this._props.push(p);
	    };
	    KeyMatcher.prototype.match = function (key) {
	        var _this = this;
	        var _res = null;
	        var lastPref = "";
	        this._props.forEach(function (p) {
	            if (p.getAdapter(services.RAMLPropertyService).isSystem()) {
	                return;
	            }
	            if (p != _this.parentValue && p != _this.parentKey && p.matchKey(key)) {
	                if (p.keyPrefix() != null) {
	                    if (p.keyPrefix().length >= lastPref.length) {
	                        lastPref = p.keyPrefix();
	                        _res = p;
	                    }
	                }
	                else {
	                    _res = p;
	                    lastPref = p.nameId();
	                }
	            }
	        });
	        return _res;
	    };
	    return KeyMatcher;
	}());
	function getAllOptions(c, deep) {
	    if (deep === void 0) { deep = 0; }
	    if (deep > 20) {
	        return [];
	    }
	    try {
	        var result = [];
	        var tp = c.leftType();
	        if (tp) {
	            result.push(tp);
	        }
	        var r = c.rightType();
	        if (r) {
	            if (r.hasUnionInHierarchy()) {
	                var options = getAllOptions(r.unionInHierarchy(), deep + 1);
	                result = result.concat(options);
	            }
	            else {
	                result.push(r);
	            }
	        }
	        return result;
	    }
	    finally {
	    }
	}
	var ad = 0;
	var BasicNodeBuilder = (function () {
	    function BasicNodeBuilder() {
	        this.shouldDescriminate = false;
	    }
	    BasicNodeBuilder.prototype.process = function (node, childrenToAdopt) {
	        var _this = this;
	        var nn = node.lowLevel();
	        var cv = node;
	        cv._mergedChildren = null;
	        var cha = nn._node ? nn._node : nn;
	        try {
	            if (cha['currentChildren']) {
	                return cha['currentChildren'];
	            }
	            if (!node.definition()) {
	                return;
	            }
	            if (node.parent() == null && (!this.shouldDescriminate)) {
	                this.shouldDescriminate = true;
	                try {
	                    var children = this.process(node, childrenToAdopt);
	                    var ts = node;
	                    ts._children = children;
	                    var t = doDescrimination(node);
	                    if (t) {
	                        ts.patchType(t);
	                    }
	                    var children = this.process(node, childrenToAdopt);
	                    ts._children = children;
	                }
	                finally {
	                    this.shouldDescriminate = false;
	                }
	            }
	            if (node.definition().hasUnionInHierarchy()) {
	                if (true &&
	                    (node.parent() && node.property().nameId() == universes.Universe10.LibraryBase.properties.annotations.name)) {
	                    var optins = getAllOptions(node.definition().unionInHierarchy());
	                    var actualResult = null;
	                    var bestResult = null;
	                    var bestType = null;
	                    var bestCount = 1000;
	                    var llnode = node;
	                    optins.forEach(function (x) {
	                        if (!actualResult) {
	                            //TODO ADD UNION + Descriminator
	                            if (!(x).hasUnionInHierarchy()) {
	                                var tp = llnode.patchType(x);
	                                if (ad == 0) {
	                                    ad++;
	                                    try {
	                                        var result = _this.process(node, childrenToAdopt);
	                                        var uc = 0;
	                                        for (var i = 0; i < result.length; i++) {
	                                            if (result[i].isUnknown()) {
	                                                uc++;
	                                            }
	                                        }
	                                        if (uc == 0) {
	                                            actualResult = result;
	                                        }
	                                        if (bestCount > uc) {
	                                            bestCount = uc;
	                                            bestResult = result;
	                                            bestType = x;
	                                        }
	                                    }
	                                    finally {
	                                        ad--;
	                                    }
	                                }
	                            }
	                        }
	                    });
	                    if (actualResult) {
	                        llnode.patchType(bestType);
	                        return actualResult;
	                    }
	                    if (bestResult) {
	                        llnode.patchType(bestType);
	                    }
	                }
	            }
	            var km = new KeyMatcher(node.definition().allProperties());
	            if (node.parent() == null || node.lowLevel().includePath()) {
	                var u = node.definition().universe();
	                if (u.version() == "RAML10") {
	                    if (!node.definition().property("uses")) {
	                        u.type("FragmentDeclaration").allProperties().forEach(function (x) { return km.add(x); });
	                    }
	                }
	            }
	            var aNode = node;
	            var allowsQuestion = aNode._allowQuestion || node.definition().getAdapter(services.RAMLService).getAllowQuestion();
	            var res = [];
	            //cha['currentChildren']=res;
	            if (km.parentKey) {
	                if (node.lowLevel().key()) {
	                    var keyAttr = new hlimpl.ASTPropImpl(node.lowLevel(), node, km.parentKey.range(), km.parentKey, true);
	                    res.push(keyAttr);
	                    var isDefaultMediaType = node.property()
	                        && universeHelpers.isBodyProperty(node.property())
	                        && node.lowLevel().key() == node.property().nameId();
	                    if (isDefaultMediaType) {
	                        var isInsideTraitOrResourceType = isInTtraitOrResourceType(aNode);
	                        if (!isInsideTraitOrResourceType && aNode._computedKey) {
	                            keyAttr.overrideValue(aNode._computedKey);
	                        }
	                    }
	                }
	                if (node.lowLevel().valueKind() === yaml.Kind.SEQ) {
	                    var error = new hlimpl.BasicASTNode(node.lowLevel(), aNode);
	                    error.errorMessage = "" + node.definition().nameId() + " definition should be a map";
	                    res.push(error);
	                    return res;
	                }
	            }
	            if (node.lowLevel().value(true) != null) {
	                if (km.parentValue) {
	                    res.push(new hlimpl.ASTPropImpl(node.lowLevel(), node, km.parentValue.range(), km.parentValue));
	                }
	                else if (km.canBeValue) {
	                    var s = node.lowLevel().value();
	                    if (s == null) {
	                        s = node.lowLevel().value(true);
	                    }
	                    if (typeof s == 'string' && s.trim().length > 0) {
	                        //if (km.canBeValue.nameId()==universes.Universe10.Resource.properties.signature.name){
	                        //      if (s.trim().charAt(0)=='('){
	                        //          //TODO BETTER DECITION current one prevents completion from working correctly
	                        //          //in few other cases
	                        //          res.push(new hlimpl.ASTPropImpl(node.lowLevel(), node, km.canBeValue.range(), km.canBeValue));
	                        //      }
	                        //}
	                        //else {
	                        res.push(new hlimpl.ASTPropImpl(node.lowLevel(), node, km.canBeValue.range(), km.canBeValue));
	                    }
	                }
	            }
	            else {
	            }
	            aNode._children = res;
	            if (!aNode.definition().getAdapter(services.RAMLService).isUserDefined()) {
	                if (aNode.definition().key() == universes.Universe08.Api || aNode.definition().key() == universes.Universe10.Api) {
	                    var uses = childrenToAdopt.filter(function (x) { return x.key() == "uses"; });
	                    res = this.processChildren(uses, aNode, res, allowsQuestion, km);
	                    var types = childrenToAdopt.filter(function (x) { return x.key() == "types"; });
	                    res = this.processChildren(types, aNode, res, allowsQuestion, km);
	                    var other = childrenToAdopt.filter(function (x) { return (x.key() != "types" && x.key() != "uses"); });
	                    res = this.processChildren(other, aNode, res, allowsQuestion, km);
	                }
	                else {
	                    res = this.processChildren(childrenToAdopt, aNode, res, allowsQuestion, km);
	                }
	            }
	            else {
	                res = this.processChildren(childrenToAdopt, aNode, res, allowsQuestion, km);
	            }
	            aNode._children = res;
	            return res;
	        }
	        finally {
	        }
	    };
	    BasicNodeBuilder.prototype.isTypeDeclarationShortcut = function (node, property) {
	        var isTypeDeclarationType = universeHelpers.isTypeProperty(property);
	        var isTypeDeclaration = node.definition() && universeHelpers.isTypeDeclarationTypeOrDescendant(node.definition());
	        if (isTypeDeclaration && isTypeDeclarationType && node.lowLevel() && node.lowLevel().valueKind() === yaml.Kind.SEQ) {
	            return true;
	        }
	        return false;
	    };
	    BasicNodeBuilder.prototype.processChildren = function (childrenToAdopt, aNode, res, allowsQuestion, km) {
	        var _this = this;
	        var typeDeclarationName = universes.Universe10.TypeDeclaration.name;
	        var typePropertyName = universes.Universe10.TypeDeclaration.properties.type.name;
	        if (aNode.definition() && aNode.definition().isAssignableFrom(typeDeclarationName) && aNode.lowLevel() && (km.canBeValue && km.canBeValue.nameId() === typePropertyName) && aNode.lowLevel()._node && aNode.lowLevel()._node.value && aNode.lowLevel()._node.value.kind === yaml.Kind.SEQ) {
	            childrenToAdopt.forEach(function (child) {
	                var property = new hlimpl.ASTPropImpl(child, aNode, km.canBeValue.range(), km.canBeValue);
	                res.push(property);
	            });
	            return res;
	        }
	        childrenToAdopt.forEach(function (x) {
	            if (km.canBeValue && _this.isTypeDeclarationShortcut(aNode, km.canBeValue)) {
	                res.push(new hlimpl.ASTPropImpl(x, aNode, km.canBeValue.range(), km.canBeValue));
	                return;
	            }
	            var key = x.key();
	            //if (x.optional()&&!allowsQuestion) {
	            //    return;
	            //}
	            var p = key != null ? km.match(key) : null;
	            if (p != null) {
	                var range = p.range();
	                if (p.isAnnotation() && key != "annotations") {
	                    var pi = new hlimpl.ASTPropImpl(x, aNode, range, p);
	                    res.push(pi);
	                    return;
	                }
	                var um = false;
	                var multyValue = p.isMultiValue();
	                if (range.isArray()) {
	                    multyValue = true;
	                    range = range.array().componentType();
	                    um = true;
	                }
	                else if (range.hasArrayInHierarchy()) {
	                    multyValue = true;
	                    um = true;
	                }
	                //TODO DESCRIMINATORS
	                if (range.hasValueTypeInHierarchy()) {
	                    var ch = x.children();
	                    var seq = (x.valueKind() == yaml.Kind.SEQ);
	                    if ((seq && ch.length > 0 || ch.length > 1) && multyValue) {
	                        if (ch.length > 1 && universeHelpers.isTypeDeclarationSibling(aNode.definition())
	                            && universeHelpers.isTypeProperty(p) && x.valueKind() != yaml.Kind.SEQ) {
	                            var pi = new hlimpl.ASTPropImpl(x, aNode, range, p);
	                            res.push(pi);
	                            aNode.setComputed(p.nameId(), pi);
	                        }
	                        else {
	                            var values = [];
	                            ch.forEach(function (y) {
	                                var pi = new hlimpl.ASTPropImpl(y, aNode, range, p);
	                                res.push(pi);
	                                values.push(y.value());
	                            });
	                            if (p.isInherited()) {
	                                aNode.setComputed(p.nameId(), values);
	                            }
	                        }
	                    }
	                    else {
	                        if (p.isInherited()) {
	                            aNode.setComputed(p.nameId(), x.value());
	                        }
	                        var attrNode = new hlimpl.ASTPropImpl(x, aNode, range, p);
	                        if ((seq || x.valueKind() == yaml.Kind.MAP)) {
	                            var rng = p.range().nameId();
	                            if (!p.getAdapter(services.RAMLPropertyService).isExampleProperty()) {
	                                if (rng == 'StringType') {
	                                    rng = "string";
	                                }
	                                if (rng == 'NumberType') {
	                                    rng = "number";
	                                }
	                                if (rng == 'BooleanType') {
	                                    rng = "boolean";
	                                }
	                                if (rng == "string" || rng == "number" || rng == "boolean") {
	                                    if (!x.isAnnotatedScalar()) {
	                                        attrNode.errorMessage = "property '" + p.groupName() + "' must be a " + rng;
	                                        if (x.children().length == 0 && p.groupName() == "enum") {
	                                            attrNode.errorMessage = "enum is empty";
	                                            if (x.valueKind() == yaml.Kind.MAP) {
	                                                attrNode.errorMessage = "the value of enum must be an array";
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                        res.push(attrNode);
	                    }
	                    //}
	                    return;
	                }
	                else {
	                    var rs = [];
	                    //now we need determine actual type
	                    aNode._children = res;
	                    if (x.value() != null && (typeof x.value() == 'string' || typeof x.value() == 'boolean' || typeof x.value() == 'number')) {
	                        if (("" + x.value()).trim().length > 0) {
	                            var c = p.range();
	                            if (!c.allProperties().some(function (x) {
	                                var srv = x;
	                                if (srv) {
	                                    return srv.canBeValue() && srv.isFromParentValue();
	                                }
	                                return false;
	                            })) {
	                                var bnode = new hlimpl.BasicASTNode(x, aNode);
	                                bnode.getLowLevelEnd = function () {
	                                    return -1;
	                                };
	                                bnode.getLowLevelStart = function () {
	                                    return -1;
	                                };
	                                bnode.knownProperty = p;
	                                res.push(bnode);
	                            }
	                        }
	                    }
	                    if (!p.isMerged()) {
	                        if (multyValue) {
	                            if (p.getAdapter(services.RAMLPropertyService).isEmbedMap()) {
	                                var chld = x.children();
	                                var newChld = [];
	                                var hasSequenceComposition = false;
	                                chld.forEach(function (n) {
	                                    if (n.kind() == yaml.Kind.INCLUDE_REF) {
	                                        if (aNode.universe().version() == "RAML08") {
	                                            n.children().forEach(function (y) {
	                                                var node = new hlimpl.ASTNodeImpl(y, aNode, range, p);
	                                                node._allowQuestion = allowsQuestion;
	                                                rs.push(node);
	                                                hasSequenceComposition = true;
	                                            });
	                                        }
	                                        else {
	                                            newChld.push(n);
	                                        }
	                                    }
	                                    else {
	                                        newChld.push(n);
	                                    }
	                                });
	                                chld = newChld;
	                                if (chld.length == 0) {
	                                    if (p.range().key() == universes.Universe08.ResourceType) {
	                                        if (!hasSequenceComposition) {
	                                            var error = new hlimpl.BasicASTNode(x, aNode);
	                                            error.errorMessage = "property: '" + p.nameId() + "' must be a map";
	                                            res.push(error);
	                                        }
	                                    }
	                                    if (x.valueKind() == yaml.Kind.SCALAR) {
	                                        if (p.range().key() == universes.Universe08.AbstractSecurityScheme) {
	                                            var error = new hlimpl.BasicASTNode(x.parent(), aNode);
	                                            error.errorMessage = "property: '" + p.nameId() + "' must be a map";
	                                            res.push(error);
	                                        }
	                                    }
	                                }
	                                var exit = false;
	                                chld.forEach(function (y) {
	                                    if (exit) {
	                                        return;
	                                    }
	                                    //TODO TRACK GROUP KEY
	                                    var cld = y.children();
	                                    if (!y.key() && cld.length == 1) {
	                                        if (aNode.universe().version() == "RAML10" && !aNode.parent()) {
	                                            var bnode = new hlimpl.BasicASTNode(x, aNode);
	                                            res.push(bnode);
	                                            bnode.needMap = true;
	                                            bnode.knownProperty = p;
	                                            exit = true;
	                                        }
	                                        else {
	                                            var node = new hlimpl.ASTNodeImpl(cld[0], aNode, range, p);
	                                            node._allowQuestion = allowsQuestion;
	                                            rs.push(node);
	                                        }
	                                    }
	                                    else {
	                                        if (aNode.universe().version() == "RAML10") {
	                                            var node = new hlimpl.ASTNodeImpl(y, aNode, range, p);
	                                            node._allowQuestion = allowsQuestion;
	                                            rs.push(node);
	                                        }
	                                        else {
	                                            var bnode = new hlimpl.BasicASTNode(y, aNode);
	                                            res.push(bnode);
	                                            if (y.key()) {
	                                                bnode.needSequence = true;
	                                            }
	                                        }
	                                    }
	                                });
	                            }
	                            else {
	                                var filter = {};
	                                var inherited = [];
	                                if (range instanceof defs.NodeClass) {
	                                    var nc = range;
	                                    if (nc.getAdapter(services.RAMLService).getCanInherit().length > 0) {
	                                        nc.getAdapter(services.RAMLService).getCanInherit().forEach(function (v) {
	                                            var originalValue = aNode.computedValue(v);
	                                            var actualValue = Array.isArray(originalValue) ? originalValue : [originalValue];
	                                            for (var pos = 0; pos < actualValue.length; pos++) {
	                                                var vl = actualValue[pos];
	                                                if (vl && p.nameId() == universes.Universe10.Response.properties.body.name) {
	                                                    var exists = _.find(x.children(), function (x) { return x.key() == vl; });
	                                                    var originalParent = x;
	                                                    while (originalParent.originalNode) {
	                                                        originalParent = originalParent.originalNode();
	                                                    }
	                                                    var mediaTypeSibling = _.find(originalParent.children(), function (sibling) {
	                                                        try {
	                                                            mediaTypeParser.parse(sibling.key());
	                                                            return true;
	                                                        }
	                                                        catch (exception) {
	                                                            return false;
	                                                        }
	                                                    });
	                                                    if (!mediaTypeSibling) {
	                                                        //we can create inherited node;
	                                                        var pc = aNode.parent().definition().key();
	                                                        var node = new hlimpl.ASTNodeImpl(x, aNode, range, p);
	                                                        node._computedKey = vl;
	                                                        if (pc == universes.Universe10.MethodBase || pc == universes.Universe08.MethodBase) {
	                                                            node.setComputed("form", "true"); //FIXME
	                                                        }
	                                                        var isInsideTraitOrResourceType = isInTtraitOrResourceType(aNode);
	                                                        var t = descriminate(p, aNode, node);
	                                                        if (t) {
	                                                            if (!isInsideTraitOrResourceType) {
	                                                                t.setName(vl);
	                                                            }
	                                                            node.patchType(t);
	                                                        }
	                                                        var ch = node.children();
	                                                        //this are false unknowns actual unknowns will be reported by parent node
	                                                        node._children = ch.filter(function (x) { return !x.isUnknown(); });
	                                                        node._allowQuestion = allowsQuestion;
	                                                        if (!exists) {
	                                                            inherited.push(node);
	                                                        }
	                                                        node.children().forEach(function (x) {
	                                                            if (x.property().getAdapter(services.RAMLPropertyService).isKey()) {
	                                                                var atr = x;
	                                                                atr._computed = true;
	                                                                return;
	                                                            }
	                                                            if (x.isElement()) {
	                                                                if (!x.property().getAdapter(services.RAMLPropertyService).isMerged()) {
	                                                                    filter[x.property().nameId()] = true;
	                                                                }
	                                                            }
	                                                            if (x.property().isAnnotation()) {
	                                                                var atr = x;
	                                                                var vl = atr.value();
	                                                                var strVal = "";
	                                                                if (vl instanceof hlimpl.StructuredValue) {
	                                                                    strVal = vl.valueName();
	                                                                }
	                                                                else {
	                                                                    strVal = "" + vl;
	                                                                }
	                                                                filter["(" + strVal + ")"] = true;
	                                                            }
	                                                            else {
	                                                                filter[x.name()] = true;
	                                                            }
	                                                        });
	                                                        var ap = node.definition().allProperties();
	                                                        ap.forEach(function (p) {
	                                                            if (p.getAdapter(services.RAMLPropertyService).isKey()) {
	                                                                return;
	                                                            }
	                                                            if (p.getAdapter(services.RAMLPropertyService).isSystem()) {
	                                                                return;
	                                                            }
	                                                            if (node.lowLevel().children().some(function (x) { return x.key() == p.nameId(); })) {
	                                                                filter[p.nameId()] = true;
	                                                            }
	                                                        });
	                                                        node._computed = true;
	                                                    }
	                                                }
	                                            }
	                                        });
	                                    }
	                                }
	                                var parsed = [];
	                                if (x.children().length == 0) {
	                                    if (x.valueKind() == yaml.Kind.SEQ) {
	                                        if (p.range().key() == universes.Universe08.Parameter) {
	                                            var error = new hlimpl.BasicASTNode(x, aNode);
	                                            error.errorMessage = "property: '" + p.nameId() + "' must be a map";
	                                            res.push(error);
	                                        }
	                                    }
	                                }
	                                if (p.nameId() === "documentation" && x.valueKind() !== yaml.Kind.SEQ) {
	                                    if (!aNode.definition().getAdapter(services.RAMLService).isUserDefined()) {
	                                        var error = new hlimpl.BasicASTNode(x, aNode);
	                                        error.errorMessage = "property: '" + p.nameId() + "' should be a sequence";
	                                        res.push(error);
	                                    }
	                                }
	                                else {
	                                    x.children().forEach(function (y) {
	                                        if (filter[y.key()]) {
	                                            return;
	                                        }
	                                        if (y.valueKind() == yaml.Kind.SEQ) {
	                                            var isRaml1 = aNode.definition().universe().version() == "RAML10";
	                                            y.children().forEach(function (z) {
	                                                var node = new hlimpl.ASTNodeImpl(z, aNode, range, p);
	                                                node._allowQuestion = allowsQuestion;
	                                                node.setNamePatch(y.key());
	                                                if (isRaml1) {
	                                                    node.invalidSequence = true;
	                                                }
	                                                parsed.push(node);
	                                            });
	                                            if (y.children().length == 0) {
	                                                var error = new hlimpl.BasicASTNode(y, aNode);
	                                                if (p.range().key() == universes.Universe08.Parameter) {
	                                                    error.errorMessage = "named parameter needs at least one type";
	                                                }
	                                                else {
	                                                    error.errorMessage = "node should have at least one member value";
	                                                }
	                                                res.push(error);
	                                            }
	                                        }
	                                        else {
	                                            var node = new hlimpl.ASTNodeImpl(y, aNode, range, p);
	                                            var dc = p.domain().key();
	                                            if (p.nameId() == "body" && (dc == universes.Universe08.MethodBase || dc == universes.Universe10.MethodBase)) {
	                                                node.setComputed("form", "true"); //FIXME
	                                            }
	                                            node._allowQuestion = allowsQuestion;
	                                            parsed.push(node);
	                                        }
	                                    });
	                                }
	                                if (parsed.length > 0) {
	                                    parsed.forEach(function (x) { return rs.push(x); });
	                                }
	                                else {
	                                    inherited.forEach(function (x) { return rs.push(x); });
	                                }
	                            }
	                        }
	                        else {
	                            //var y=x.children()[0];
	                            rs.push(new hlimpl.ASTNodeImpl(x, aNode, range, p));
	                        }
	                    }
	                    else {
	                        var node = new hlimpl.ASTNodeImpl(x, aNode, range, p);
	                        node._allowQuestion = allowsQuestion;
	                        rs.push(node);
	                    }
	                    aNode._children = aNode._children.concat(rs);
	                    res = res.concat(rs);
	                    rs.forEach(function (x) {
	                        var rt = descriminate(p, aNode, x);
	                        if (rt && rt != x.definition()) {
	                            x.patchType(rt);
	                        }
	                        x._associatedDef = null;
	                        p.childRestrictions().forEach(function (y) {
	                            x.setComputed(y.name, y.value);
	                        });
	                        var def = x.definition();
	                    });
	                }
	            }
	            else {
	                if (!(x instanceof proxy.LowLevelCompositeNode)
	                    || x.primaryNode() != null) {
	                    res.push(new hlimpl.BasicASTNode(x, aNode));
	                }
	            }
	        });
	        return res;
	    };
	    return BasicNodeBuilder;
	}());
	exports.BasicNodeBuilder = BasicNodeBuilder;
	function getBaseType(node, expression) {
	    if (!expression) {
	        return node.definition().universe().type(universes.Universe10.StringTypeDeclaration.name);
	    }
	    var pt = node.parsedType();
	    if (pt.isString()) {
	        return (node.definition().universe().type(universes.Universe10.StringTypeDeclaration.name));
	    }
	    else if (pt.isNumber()) {
	        if (pt.isInteger()) {
	            return (node.definition().universe().type(universes.Universe10.IntegerTypeDeclaration.name));
	        }
	        return (node.definition().universe().type(universes.Universe10.NumberTypeDeclaration.name));
	    }
	    else if (pt.isBoolean()) {
	        return (node.definition().universe().type(universes.Universe10.BooleanTypeDeclaration.name));
	    }
	    else if (pt.isObject()) {
	        return (node.definition().universe().type(universes.Universe10.ObjectTypeDeclaration.name));
	    }
	    else if (pt.isArray()) {
	        return (node.definition().universe().type(universes.Universe10.ArrayTypeDeclaration.name));
	    }
	    else if (pt.isFile()) {
	        return (node.definition().universe().type(universes.Universe10.FileTypeDeclaration.name));
	    }
	    else if (pt.isDateTime()) {
	        return (node.definition().universe().type(universes.Universe10.DateTimeTypeDeclaration.name));
	    }
	    else if (pt.isDateTimeOnly()) {
	        return (node.definition().universe().type(universes.Universe10.DateTimeOnlyTypeDeclaration.name));
	    }
	    else if (pt.isDateOnly()) {
	        return (node.definition().universe().type(universes.Universe10.DateOnlyTypeDeclaration.name));
	    }
	    else if (pt.isTimeOnly()) {
	        return (node.definition().universe().type(universes.Universe10.TimeOnlyTypeDeclaration.name));
	    }
	    if (pt.isUnion()) {
	        return (node.definition().universe().type(universes.Universe10.UnionTypeDeclaration.name));
	    }
	    return (node.definition().universe().type(universes.Universe10.TypeDeclaration.name));
	}
	function transform(u) {
	    return function (x) {
	        var m = u.type(x);
	        if (!m) {
	            var ut = new defs.UserDefinedClass("", u, null, "", "");
	        }
	        return m;
	    };
	}
	function findFacetInTypeNode(typeNode, facetName) {
	    var typeNodeElement = typeNode.asElement();
	    if (typeNodeElement == null)
	        return null;
	    var facets = typeNodeElement.elementsOfKind(universes.Universe10.TypeDeclaration.properties.facets.name);
	    if (facets == null || facets.length == 0)
	        return null;
	    return _.find(facets, function (facet) {
	        return facetName == facet.attrValue(universes.Universe10.TypeDeclaration.properties.name.name);
	    });
	}
	function findFacetDeclaration(facet) {
	    var owner = facet.owner();
	    if (owner == null)
	        return null;
	    var facetName = facet.facetName();
	    if (!facetName)
	        return null;
	    var ownerSource = owner.getExtra(ramlTypes.SOURCE_EXTRA);
	    if (ownerSource == null)
	        return null;
	    if (!def.isSourceProvider(ownerSource) && !hl.isParseResult(ownerSource)) {
	        return null;
	    }
	    return {
	        getSource: function () {
	            if (def.isSourceProvider(ownerSource)) {
	                var resolvedSource = ownerSource.getSource();
	                if (resolvedSource && hl.isParseResult(resolvedSource)) {
	                    return findFacetInTypeNode(resolvedSource, facetName);
	                }
	            }
	            else if (hl.isParseResult(ownerSource)) {
	                return findFacetInTypeNode(ownerSource, facetName);
	            }
	            return null;
	        }
	    };
	}
	function patchTypeWithFacets(originalType, nodeReferencingType, parentOfReferencingNode) {
	    if (originalType == null)
	        return null;
	    var patchedType = new defs.NodeClass(nodeReferencingType.name(), nodeReferencingType.definition().universe(), "", "");
	    var parsedRType = nodeReferencingType.parsedType();
	    parsedRType.allFacets().forEach(function (facet) {
	        if (facet.kind() == defs.tsInterfaces.MetaInformationKind.FacetDeclaration) {
	            var propertySource = findFacetDeclaration(facet);
	            var facetBasedProperty = null;
	            if (propertySource != null) {
	                facetBasedProperty = new defs.UserDefinedProp(facet.facetName(), null);
	                facetBasedProperty.setSourceProvider(propertySource);
	            }
	            else {
	                facetBasedProperty = new defs.Property(facet.facetName(), "");
	            }
	            facetBasedProperty.withRange(parentOfReferencingNode.definition().universe().type("StringType"));
	            facetBasedProperty.withDomain(patchedType);
	            facetBasedProperty.withGroupName(facet.facetName());
	            facetBasedProperty.withRequired(false);
	            facet.value();
	            ramlTypes.setPropertyConstructor(function (x) {
	                var v = new defs.Property(x, "");
	                v.unmerge();
	                return v;
	            });
	            facetBasedProperty.withRange(ramlTypes.toNominal(facet.value(), transform(nodeReferencingType.definition().universe())));
	        }
	    });
	    patchedType._superTypes.push(originalType);
	    return patchedType;
	    // return originalType;
	}
	function desc1(p, parent, x) {
	    var tp = x.attr("type");
	    var value = "";
	    if (tp) {
	        var baseType = getBaseType(x, tp.value());
	        var patchedType = patchTypeWithFacets(baseType, x, parent);
	        if (patchedType) {
	            if (patchedType.superTypes().length == 0) {
	                patchedType._superTypes.push(x.definition().universe().type(universes.Universe10.TypeDeclaration.name));
	            }
	        }
	        return patchedType;
	    }
	    else {
	        var propertiesName = universes.Universe10.ObjectTypeDeclaration.properties.properties.name;
	        if (p) {
	            if (p.nameId() == "body" || _.find(x.lowLevel().children(), function (x) { return x.key() === propertiesName; })) {
	                return x.definition().universe().type(universes.Universe10.ObjectTypeDeclaration.name);
	            }
	        }
	        else {
	            if (!parent && x.lowLevel() && _.find(x.lowLevel().children(), function (x) { return x.key() === propertiesName; })) {
	                return x.definition().universe().type(universes.Universe10.ObjectTypeDeclaration.name);
	            }
	        }
	        return x.definition().universe().type(universes.Universe10.StringTypeDeclaration.name);
	    }
	}
	function doDescrimination(node) {
	    try {
	        var nodeDefenitionName = node.definition().nameId();
	        var isApi = nodeDefenitionName === universes.Universe10.Api.name || nodeDefenitionName === universes.Universe08.Api.name;
	        if (!isApi && !node.property() && !node.parent() && node.definition().nameId() === hlimpl.getFragmentDefenitionName(node)) {
	            if (node.property() && node.property().nameId() === universes.Universe10.LibraryBase.properties.annotationTypes.name) {
	                return descriminate(null, null, node);
	            }
	            var result = null;
	            var subTypes = node.definition().allSubTypes();
	            subTypes.forEach(function (subType) {
	                if (!result && match(subType, node, null)) {
	                    result = subType;
	                }
	            });
	            return result;
	        }
	    }
	    catch (exception) {
	    }
	    return descriminate(node.property(), node.parent(), node);
	}
	exports.doDescrimination = doDescrimination;
	function descriminate(p, parent, x) {
	    var n = x.lowLevel();
	    if (p) {
	        if (p.nameId() == universes.Universe10.FragmentDeclaration.properties.uses.name &&
	            p.range().nameId() == universes.Universe10.Library.name) {
	        }
	    }
	    var range = p ? p.range().nameId() : x.definition().nameId();
	    if (n._node && n._node['descriminate']) {
	        return null;
	    }
	    if (n._node) {
	        n._node['descriminate'] = 1;
	    }
	    try {
	        if (range == universes.Universe10.TypeDeclaration.name) {
	            var res = desc1(p, parent, x);
	            if (p || (!p && !parent && x.lowLevel())) {
	                if (p && res != null && ((p.nameId() == universes.Universe10.MethodBase.properties.body.name
	                    || p.nameId() == universes.Universe10.Response.properties.headers.name) ||
	                    p.nameId() == universes.Universe10.MethodBase.properties.queryParameters.name)) {
	                    var ares = new defs.UserDefinedClass(x.lowLevel().key(), res.universe(), x, x.lowLevel().unit() ? x.lowLevel().unit().path() : "", "");
	                    ares._superTypes.push(res);
	                    return ares;
	                }
	                if (res != null && universeHelpers.isAnnotationTypeType(x.definition())) {
	                    var annotationType = descriminateAnnotationType(res);
	                    var ares = new defs.UserDefinedClass(x.lowLevel().key(), res.universe(), x, x.lowLevel().unit() ? x.lowLevel().unit().path() : "", "");
	                    ares._superTypes.push(annotationType);
	                    ares._superTypes.push(res);
	                    return ares;
	                }
	            }
	            if (res) {
	                return res;
	            }
	        }
	        //generic case;
	        var rt = null;
	        if (p && parent) {
	            var types = search.findAllSubTypes(p, parent);
	            if (types.length > 0) {
	                types.forEach(function (y) {
	                    if (!rt) {
	                        if (match(y, x, rt)) {
	                            rt = y;
	                        }
	                    }
	                });
	            }
	            return rt;
	        }
	    }
	    finally {
	        if (n._node) {
	            delete n._node['descriminate'];
	        }
	    }
	}
	;
	function descriminateAnnotationType(type) {
	    var arr = [type].concat(type.allSuperTypes());
	    var candidate;
	    for (var i = 0; i < arr.length; i++) {
	        var t = arr[i];
	        if (t.isUserDefined()) {
	            continue;
	        }
	        if (t.isUnion()) {
	            var ut = t;
	            var lt = ut.leftType();
	            var rt = ut.leftType();
	            var lat = descriminateAnnotationType(lt);
	            var rat = descriminateAnnotationType(lt);
	            if (lat.isAssignableFrom(rat.nameId()) && (candidate == null || lat.isAssignableFrom(candidate.nameId()))) {
	                candidate = lat;
	                continue;
	            }
	            if (rat.isAssignableFrom(lat.nameId()) && (candidate == null || rat.isAssignableFrom(candidate.nameId()))) {
	                candidate = rat;
	                continue;
	            }
	            candidate = type.universe().type(universes.Universe10.UnionTypeDeclaration.name);
	            break;
	        }
	        if (t.isArray()) {
	            candidate = type.universe().type(universes.Universe10.ArrayTypeDeclaration.name);
	            break;
	        }
	        var subTypes = t.subTypes();
	        for (var j = 0; j < subTypes.length; j++) {
	            var st = subTypes[j];
	            if (st.isAssignableFrom(universes.Universe10.TypeDeclaration.name)) {
	                if (candidate == null) {
	                    candidate = st;
	                }
	                else if (st.isAssignableFrom(candidate.nameId())) {
	                    candidate = st;
	                }
	            }
	        }
	    }
	    return candidate != null ? candidate : type.universe().type(universes.Universe10.TypeDeclaration.name);
	}
	var isInTtraitOrResourceType = function (aNode) {
	    var isInsideTraitOrResourceType = false;
	    var parent_ = aNode;
	    while (parent_) {
	        var pDef = parent_.definition();
	        if (universeHelpers.isTraitType(pDef)
	            || universeHelpers.isResourceTypeType(pDef)) {
	            isInsideTraitOrResourceType = true;
	            break;
	        }
	        parent_ = parent_.parent();
	    }
	    return isInsideTraitOrResourceType;
	};
	function match(t, r, alreadyFound) {
	    //this.vReqInitied=true;
	    if (r.isAttr() || r.isUnknown()) {
	        return false;
	    }
	    var el = r;
	    var hasSuperType = _.find(t.superTypes(), function (x) {
	        var dp = _.find(x.allProperties(), function (x) { return (x).isDescriminator(); });
	        if (dp) {
	            var a = el.attr(dp.nameId());
	            if (a) {
	                if (a.value() == t.nameId()) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    });
	    if (hasSuperType) {
	        return true;
	    }
	    if (t.valueRequirements().length == 0) {
	        return false;
	    }
	    var matches = true;
	    //descriminating constraint
	    t.valueRequirements().forEach(function (x) {
	        var a = el.attr(x.name);
	        if (a) {
	            if (a.value() == x.value) {
	            }
	            else {
	                if (t.getAdapter(services.RAMLService).getConsumesRefs()) {
	                    var vl = a.value();
	                    var allSubs = [];
	                    t.superTypes().forEach(function (x) { return x.allSubTypes().forEach(function (y) {
	                        allSubs.push(y);
	                    }); });
	                    var allSubNames = [];
	                    _.unique(allSubs).forEach(function (x) {
	                        allSubNames.push(x.nameId());
	                        x.valueRequirements().forEach(function (y) {
	                            allSubNames.push(y.value);
	                        });
	                        x.getAdapter(services.RAMLService).getAliases().forEach(function (y) { return allSubNames.push(y); });
	                    });
	                    if (_.find(allSubNames, function (x) { return x == vl; })) {
	                        matches = false;
	                    }
	                }
	                else {
	                    matches = false;
	                }
	            }
	        }
	        else {
	            var m = t.getAdapter(services.RAMLService).getDefining();
	            var ms = false;
	            m.forEach(function (x) {
	                el.lowLevel().children().forEach(function (y) {
	                    if (y.key() == x) {
	                        ms = true;
	                    }
	                });
	            });
	            if (ms) {
	                matches = true;
	                return;
	            }
	            if (!alreadyFound) {
	                var pr = t.property(x.name);
	                if (pr && pr.defaultValue() == x.value) {
	                }
	                else {
	                    matches = false;
	                }
	            }
	            else {
	                matches = false;
	            }
	        }
	    });
	    return matches;
	}
	//# sourceMappingURL=builder.js.map

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/// <reference path="../../../typings/main.d.ts" />
	var lowlevel = __webpack_require__(11);
	var path = __webpack_require__(15);
	var fs = __webpack_require__(38);
	var yaml = __webpack_require__(72);
	var _ = __webpack_require__(63);
	var textutil = __webpack_require__(42);
	var hli = __webpack_require__(16);
	var services = __webpack_require__(34);
	var rr = __webpack_require__(28);
	var util = __webpack_require__(32);
	var refResolvers = __webpack_require__(29);
	var schemes = __webpack_require__(53);
	var universes = __webpack_require__(22);
	var expander = __webpack_require__(24);
	var namespaceResolver = __webpack_require__(54);
	var Error = yaml.YAMLException;
	exports.Kind = {
	    SCALAR: yaml.Kind.SCALAR
	};
	var MarkupIndentingBuffer = (function () {
	    function MarkupIndentingBuffer(indent) {
	        this.text = '';
	        this.indent = indent;
	    }
	    MarkupIndentingBuffer.prototype.isLastNL = function () {
	        return this.text.length > 0 && this.text[this.text.length - 1] == '\n';
	    };
	    MarkupIndentingBuffer.prototype.addWithIndent = function (lev, s) {
	        if (this.isLastNL()) {
	            this.text += textutil.indent(lev);
	            this.text += this.indent;
	        }
	        this.text += s;
	    };
	    MarkupIndentingBuffer.prototype.addChar = function (ch) {
	        if (this.isLastNL()) {
	            this.text += this.indent;
	        }
	        this.text += ch;
	    };
	    MarkupIndentingBuffer.prototype.append = function (s) {
	        for (var i = 0; i < s.length; i++) {
	            this.addChar(s[i]);
	        }
	    };
	    return MarkupIndentingBuffer;
	}());
	exports.MarkupIndentingBuffer = MarkupIndentingBuffer;
	var CompilationUnit = (function () {
	    function CompilationUnit(_path, _content, _tl, _project, _apath) {
	        this._path = _path;
	        this._content = _content;
	        this._tl = _tl;
	        this._project = _project;
	        this._apath = _apath;
	        this._path = this._path != null ? this._path.replace(/\\/g, "/") : null;
	    }
	    CompilationUnit.prototype.highLevel = function () {
	        if (this._hl) {
	            return this._hl;
	        }
	        this._hl = hli.fromUnit(this);
	        return this._hl;
	    };
	    CompilationUnit.prototype.isStubUnit = function () {
	        return this.stu;
	    };
	    CompilationUnit.prototype.resolveAsync = function (p) {
	        var unit = this._project.resolveAsync(this._path, p);
	        return unit;
	    };
	    CompilationUnit.prototype.getIncludeNodes = function () {
	        var ast = this.ast();
	        var arr = [];
	        if (ast == null)
	            return [];
	        ast.gatherIncludes(arr);
	        ast.children().forEach(function (x) {
	            if (x.key() == "uses") {
	                x.children().forEach(function (y) {
	                    arr.push({
	                        includePath: function () { return y.value(); }
	                    });
	                });
	            }
	        });
	        return arr;
	    };
	    CompilationUnit.prototype.cloneToProject = function (p) {
	        var newUnit = new CompilationUnit(this._path, this._content, this._tl, p, this._apath);
	        return newUnit;
	    };
	    CompilationUnit.prototype.clone = function () {
	        var newUnit = new CompilationUnit(this._path, this._content, this._tl, this.project(), this._apath);
	        return newUnit;
	    };
	    CompilationUnit.prototype.stub = function () {
	        var newUnit = new CompilationUnit(this._path, this._content, this._tl, this.project(), this._apath);
	        newUnit.stu = true;
	        return newUnit;
	    };
	    CompilationUnit.prototype.isDirty = function () {
	        return false;
	    };
	    CompilationUnit.prototype.expandedHighLevel = function () {
	        if (this.expanded) {
	            return this.expanded;
	        }
	        var result = this.highLevel().asElement();
	        var nm = expander.expandTraitsAndResourceTypes(result.wrapperNode());
	        var hlnode = nm.highLevel();
	        hlnode._expanded = true;
	        this.expanded = hlnode;
	        return hlnode;
	    };
	    CompilationUnit.prototype.absolutePath = function () {
	        return this._apath;
	    };
	    CompilationUnit.prototype.isRAMLUnit = function () {
	        var en = path.extname(this._path);
	        return en == '.raml' || en == '.yaml' || en == '.yml';
	    };
	    CompilationUnit.prototype.contents = function () {
	        return this._content;
	    };
	    CompilationUnit.prototype.resolve = function (p) {
	        if (typeof p != "string") {
	            p = "" + p;
	        }
	        var unit = this._project.resolve(this._path, p);
	        return unit;
	    };
	    CompilationUnit.prototype.path = function () {
	        return this._path;
	    };
	    CompilationUnit.prototype.lexerErrors = function () {
	        if (this.errors == null) {
	            this.ast();
	        }
	        return this.errors;
	    };
	    CompilationUnit.prototype.ast = function () {
	        var _this = this;
	        if (this._node) {
	            return this._node;
	        }
	        try {
	            var result = yaml.load(this._content, {});
	            this.errors = result.errors;
	            this.errors.forEach(function (x) {
	                if (x.mark) {
	                    x.mark.filePath = _this.absolutePath();
	                }
	            });
	            this._node = new ASTNode(result, this, null, null, null);
	            this._node._errors = this.errors;
	            return this._node;
	        }
	        catch (e) {
	            this.errors = [];
	            this.errors.push(new Error(e.message));
	            //console.log(this._content)
	            //console.log(e)
	            this._node = null;
	            return this._node;
	        }
	    };
	    CompilationUnit.prototype.isTopLevel = function () {
	        return this._tl;
	    };
	    CompilationUnit.prototype.updateContent = function (n) {
	        this._content = n;
	        this.errors = null;
	        this._node = null; //todo incremental update
	        this._lineMapper = null;
	    };
	    CompilationUnit.prototype.updateContentSafe = function (n) {
	        this._content = n;
	        this._lineMapper = null;
	        this._hl = null;
	    };
	    CompilationUnit.prototype.project = function () {
	        return this._project;
	    };
	    CompilationUnit.prototype.lineMapper = function () {
	        if (this._lineMapper == null) {
	            this._lineMapper = new lowlevel.LineMapperImpl(this.contents(), this.absolutePath());
	        }
	        return this._lineMapper;
	    };
	    //ramlVersion():string{
	    //    return this._ramlVersion;
	    //}
	    /**
	     * Returns true if this unit is overlay or extension, false otherwise.
	     */
	    CompilationUnit.prototype.isOverlayOrExtension = function () {
	        var contents = this.contents();
	        var spec = "";
	        var ptype = null;
	        var num = 0;
	        var pt = 0;
	        for (var n = 0; n < contents.length; n++) {
	            var c = contents.charAt(n);
	            if (c == '\r' || c == '\n') {
	                if (spec) {
	                    ptype = contents.substring(pt, n).trim();
	                }
	                else {
	                    spec = contents.substring(0, n).trim();
	                }
	                break;
	            }
	            if (c == ' ') {
	                num++;
	                if (!spec && num == 2) {
	                    spec = contents.substring(0, n);
	                    pt = n;
	                }
	            }
	        }
	        return ptype == "Extension" || ptype == "Overlay";
	    };
	    /**
	     * Returns master reference if presents, null otherwise.
	     */
	    CompilationUnit.prototype.getMasterReferenceNode = function () {
	        return _.find(this.ast().children(), function (x) { return x.key() == universes.Universe10.Overlay.properties.extends.name; });
	    };
	    return CompilationUnit;
	}());
	exports.CompilationUnit = CompilationUnit;
	var XhrSync = __webpack_require__(60).XMLHttpRequest;
	var XhrAsync = __webpack_require__(60).XMLHttpRequest;
	var XMLHttpRequestWrapper = (function () {
	    function XMLHttpRequestWrapper() {
	    }
	    XMLHttpRequestWrapper.prototype.open = function (method, url, async) {
	        this.xhr = async ? new XhrAsync() : new XhrSync();
	        this.async = async;
	        this.xhr.open(method, url, async);
	    };
	    XMLHttpRequestWrapper.prototype.setRequestHeader = function (name, value) {
	        this.xhr.setRequestHeader(name, value);
	    };
	    XMLHttpRequestWrapper.prototype.getResponseHeader = function (name) {
	        return this.xhr.getResponseHeader(name);
	    };
	    XMLHttpRequestWrapper.prototype.getAllResponseHeaders = function () {
	        return this.xhr.getAllResponseHeaders();
	    };
	    XMLHttpRequestWrapper.prototype.send = function (content) {
	        var _this = this;
	        this.xhr.onload = function () { return _this.onResponse(false); };
	        this.xhr.onerror = function () { return _this.onResponse(true); };
	        this.xhr.send(content);
	    };
	    XMLHttpRequestWrapper.prototype.onResponse = function (isError) {
	        this.statusText = this.xhr.statusText;
	        this.responseText = this.xhr.responseText;
	        this.responseType = this.xhr.responseType;
	        this.status = this.xhr.status;
	        if (isError && this.onerror) {
	            this.onerror();
	            return;
	        }
	        if (this.onload) {
	            this.onload();
	        }
	    };
	    return XMLHttpRequestWrapper;
	}());
	exports.XMLHttpRequestWrapper = XMLHttpRequestWrapper;
	function buildXHR() {
	    return new XMLHttpRequestWrapper();
	}
	exports.buildXHR = buildXHR;
	var SimpleExecutor = (function () {
	    function SimpleExecutor() {
	    }
	    SimpleExecutor.prototype.execute = function (req, doAppendParams) {
	        if (doAppendParams === void 0) { doAppendParams = true; }
	        var xhr = buildXHR();
	        var url = req.url;
	        if (doAppendParams) {
	            url = this.appendParams(req, req.url);
	        }
	        xhr.open(req.method, url, false);
	        this.doRequest(req, xhr);
	        //rheaders=xhr.getAllResponseHeaders();
	        var status = xhr.status;
	        if (status > 300 && status < 400) {
	            var locHeader = xhr.getResponseHeader('location');
	            if (locHeader) {
	                req.url = locHeader;
	                return this.execute(req, false);
	            }
	        }
	        var response = {
	            status: status,
	            statusText: xhr.statusText,
	            headers: xhr.getAllResponseHeaders().split('\n').map(function (x) {
	                var ind = x.indexOf(':');
	                return {
	                    name: x.substring(0, ind).trim(),
	                    value: x.substring(ind + 1).trim()
	                };
	            }),
	            content: {
	                text: xhr.responseText,
	                mimeType: xhr.responseType
	            }
	        };
	        return response;
	    };
	    SimpleExecutor.prototype.appendParams = function (req, url) {
	        var gotQueryParams = (req.queryString && req.queryString.length > 0);
	        if (gotQueryParams) {
	            url = url + '?';
	            var arr = [];
	            if (gotQueryParams) {
	                arr = arr.concat(req.queryString.map(function (q) {
	                    return encodeURIComponent(q.name) + '=' + encodeURIComponent(q.value);
	                }));
	            }
	            url += arr.join('&');
	        }
	        return url;
	    };
	    SimpleExecutor.prototype.log = function (varName, value) {
	    };
	    SimpleExecutor.prototype.executeAsync = function (req, doAppendParams) {
	        if (doAppendParams === void 0) { doAppendParams = true; }
	        var xhr = buildXHR();
	        var url = req.url;
	        if (doAppendParams) {
	            url = this.appendParams(req, req.url);
	        }
	        var outer = this;
	        return new Promise(function (resolve, reject) {
	            xhr.open(req.method, url, true);
	            xhr.onload = function () {
	                var status = xhr.status;
	                var response = {
	                    status: status,
	                    statusText: xhr.statusText,
	                    headers: xhr.getAllResponseHeaders().split('\n').map(function (x) {
	                        var ind = x.indexOf(':');
	                        return {
	                            name: x.substring(0, ind).trim(),
	                            value: x.substring(ind + 1).trim()
	                        };
	                    }),
	                    content: {
	                        text: xhr.responseText,
	                        mimeType: xhr.responseType
	                    }
	                };
	                resolve(response);
	            };
	            xhr.onerror = function () {
	                reject(new Error("Network Error"));
	            };
	            outer.doRequest(req, xhr);
	        });
	    };
	    SimpleExecutor.prototype.doRequest = function (req, xhr) {
	        if (req.headers) {
	            req.headers.forEach(function (x) { return xhr.setRequestHeader(x.name, x.value); });
	        }
	        if (req.postData) {
	            if (req.postData.params) {
	                var body = req.postData.params.map(function (p) { return encodeURIComponent(p.name) + '=' + encodeURIComponent(p.value); }).join('&');
	                xhr.send(body);
	            }
	            else {
	                xhr.send(req.postData.text);
	            }
	        }
	        else {
	            xhr.send();
	        }
	    };
	    return SimpleExecutor;
	}());
	exports.SimpleExecutor = SimpleExecutor;
	var HTTPResolverImpl = (function () {
	    function HTTPResolverImpl() {
	        this.executor = new SimpleExecutor();
	    }
	    HTTPResolverImpl.prototype.getResource = function (url) {
	        if (typeof atom !== 'undefined' && atom != null) {
	            var cached = rr.get(url);
	            if (cached) {
	                return cached;
	            }
	            rr.addNotify(url);
	            try {
	                var resultWithCallback = {
	                    content: ""
	                };
	                this.getResourceAsync(url).then(function (x) {
	                    try {
	                        if (x.errorMessage) {
	                            rr.set(url, { content: null, errorMessage: null });
	                        }
	                        else {
	                            x.errorMessage = null;
	                            rr.set(url, x);
	                        }
	                    }
	                    finally {
	                        if (resultWithCallback.callback) {
	                            resultWithCallback.callback(rr.get(url));
	                        }
	                        rr.removeNotity(url);
	                    }
	                }, function (e) {
	                    rr.set(url, { content: null, errorMessage: null });
	                    if (resultWithCallback.callback) {
	                        resultWithCallback.callback(rr.get(url));
	                    }
	                    rr.removeNotity(url);
	                });
	                return resultWithCallback;
	            }
	            catch (e) {
	                console.log("Error");
	                console.log(e);
	            }
	        }
	        var response = this.executor.execute({
	            method: 'get',
	            url: url
	        });
	        if (!response) {
	            throw new Error("Unable to execute GET " + url);
	        }
	        var result = this.toResponse(response, url);
	        return result;
	    };
	    HTTPResolverImpl.prototype.getResourceAsync = function (url) {
	        var _this = this;
	        return this.executor.executeAsync({
	            method: 'get',
	            url: url
	        }).then(function (x) {
	            if (!x) {
	                return Promise.reject(new Error("Unable to execute GET " + url));
	            }
	            var result = _this.toResponse(x, url);
	            return result;
	        }, function (x) {
	            return Promise.reject(new Error("Unable to execute GET " + url));
	        });
	    };
	    HTTPResolverImpl.prototype.toResponse = function (response, url) {
	        var msg = null;
	        if (response.status >= 400) {
	            msg = "GET " + url + "\nreturned error: " + response.status;
	            if (response.statusText) {
	                msg += " " + response.statusText;
	            }
	        }
	        var content = null;
	        if (response.content && response.content.text) {
	            content = response.content.text;
	        }
	        var result = {
	            content: content,
	            errorMessage: msg
	        };
	        return result;
	    };
	    return HTTPResolverImpl;
	}());
	exports.HTTPResolverImpl = HTTPResolverImpl;
	var FSResolverImpl = (function () {
	    function FSResolverImpl() {
	    }
	    FSResolverImpl.prototype.content = function (path) {
	        if (typeof path != "string") {
	            path = "" + path;
	        }
	        if (!fs.existsSync(path)) {
	            return null;
	        }
	        try {
	            return fs.readFileSync(path).toString();
	        }
	        catch (e) {
	            return null;
	        }
	    };
	    FSResolverImpl.prototype.list = function (path) {
	        return fs.readdirSync(path);
	    };
	    FSResolverImpl.prototype.contentAsync = function (path) {
	        return new Promise(function (resolve, reject) {
	            fs.readFile(path, function (err, data) {
	                if (err != null) {
	                    return reject(err);
	                }
	                var content = data.toString();
	                resolve(content);
	            });
	        });
	    };
	    FSResolverImpl.prototype.listAsync = function (path) {
	        return new Promise(function (reject, resolve) {
	            fs.readdir(path, function (err, files) {
	                if (err != null) {
	                    return reject(err);
	                }
	                resolve(files);
	            });
	        });
	    };
	    return FSResolverImpl;
	}());
	exports.FSResolverImpl = FSResolverImpl;
	function copyNode(n) {
	    if (n == null) {
	        return null;
	    }
	    switch (n.kind) {
	        case yaml.Kind.SCALAR:
	            return {
	                errors: [],
	                startPosition: n.startPosition,
	                endPosition: n.endPosition,
	                value: n.value,
	                kind: yaml.Kind.SCALAR,
	                parent: n.parent
	            };
	        case yaml.Kind.MAPPING:
	            var map = n;
	            return {
	                errors: [],
	                key: copyNode(map.key),
	                value: copyNode(map.value),
	                startPosition: map.startPosition,
	                endPosition: map.endPosition,
	                kind: yaml.Kind.MAPPING,
	                parent: map.parent
	            };
	        case yaml.Kind.MAP:
	            var ymap = n;
	            return {
	                errors: [],
	                startPosition: n.startPosition,
	                endPosition: n.endPosition,
	                mappings: ymap.mappings.map(function (x) { return copyNode(x); }),
	                kind: yaml.Kind.MAP,
	                parent: ymap.parent
	            };
	    }
	    return n;
	}
	var innerShift = function (offset, yaNode, shift) {
	    if (!yaNode)
	        return;
	    if (yaNode.startPosition >= offset) {
	        yaNode.startPosition += shift;
	    }
	    if (yaNode.endPosition > offset) {
	        yaNode.endPosition += shift;
	    }
	    //this kind is a separate case
	    if (yaNode.kind == yaml.Kind.MAPPING) {
	        var m = yaNode;
	        innerShift(offset, m.key, shift);
	        innerShift(offset, m.value, shift);
	    }
	};
	function splitOnLines(text) {
	    var lines = text.match(/^.*((\r\n|\n|\r)|$)/gm);
	    return lines;
	}
	//TODO IMPROVE INDENTS
	function stripIndent(text, indent) {
	    var lines = splitOnLines(text);
	    var rs = [];
	    for (var i = 0; i < lines.length; i++) {
	        if (i == 0) {
	            rs.push(lines[0]);
	        }
	        else {
	            rs.push(lines[i].substring(indent.length));
	        }
	    }
	    return rs.join("");
	}
	var leadingIndent = function (node, text) {
	    var leading = "";
	    var pos = node.start() - 1;
	    //if(pos > 0 && text[pos] == ' ' && text[pos-1] == '-') {
	    //    // seq here
	    //    pos -= 2;
	    //}
	    while (pos > 0) {
	        var ch = text[pos];
	        //if (ch == '\r' || ch == '\n' || ch != ' ') break;
	        //console.log('char: [' + ch + ']');
	        if (ch != ' ' && ch != '-')
	            break;
	        leading = ' ' + leading;
	        pos--;
	    }
	    return leading;
	};
	function indent(line) {
	    var rs = "";
	    for (var i = 0; i < line.length; i++) {
	        var c = line[i];
	        if (c == '\r' || c == '\n') {
	            continue;
	        }
	        if (c == ' ' || c == '\t') {
	            rs += c;
	            continue;
	        }
	        break;
	    }
	    return rs;
	}
	function indentLines(s, indent) {
	    return s.split("\n").map(function (x) {
	        if (x.trim().length == 0) {
	            return x;
	        }
	        return indent + x;
	    }).join("\n");
	}
	function extraIndent(text, indent) {
	    var lines = splitOnLines(text);
	    var rs = [];
	    for (var i = 0; i < lines.length; i++) {
	        if (i == 0) {
	            rs.push(lines[0]);
	        }
	        else {
	            if (lines[i].trim().length > 0) {
	                rs.push(indent + lines[i]);
	            }
	            else {
	                rs.push("");
	            }
	        }
	    }
	    return rs.join("");
	}
	var Project = (function () {
	    /**
	     *
	     * @param rootPath - path to folder where your root api is located
	     * @param resolver
	     * @param _httpResolver
	     */
	    function Project(rootPath, resolver, _httpResolver) {
	        this.rootPath = rootPath;
	        this.resolver = resolver;
	        this._httpResolver = _httpResolver;
	        this.listeners = [];
	        this.tlisteners = [];
	        this.pathToUnit = {};
	        this.failedUnits = {};
	        this._fsEnabled = true;
	        this._namespaceResolver = new namespaceResolver.NamespaceResolver();
	        if (this.resolver == null) {
	            this.resolver = new FSResolverImpl();
	        }
	        else {
	            this._fsEnabled = false;
	        }
	        if (this._httpResolver == null) {
	            this._httpResolver = new HTTPResolverImpl();
	        }
	    }
	    Project.prototype.getRootPath = function () {
	        return this.rootPath;
	    };
	    Project.prototype.fsEnabled = function () {
	        return this._fsEnabled;
	    };
	    Project.prototype.cloneWithResolver = function (newResolver, httpResolver) {
	        if (httpResolver === void 0) { httpResolver = null; }
	        var newProject = new Project(this.rootPath, newResolver, httpResolver ? httpResolver : this._httpResolver);
	        for (var unitPath in this.pathToUnit) {
	            newProject.pathToUnit[unitPath] = this.pathToUnit[unitPath].cloneToProject(newProject);
	        }
	        return newProject;
	    };
	    Project.prototype.setCachedUnitContent = function (pth, cnt, tl) {
	        if (tl === void 0) { tl = true; }
	        var relPath = pth;
	        var apath = lowlevel.toAbsolutePath(this.rootPath, pth);
	        var unit = new CompilationUnit(relPath, cnt, tl, this, apath);
	        this.pathToUnit[apath] = unit;
	        return unit;
	    };
	    Project.prototype.resolveAsync = function (unitPath, pathInUnit) {
	        var _this = this;
	        if (!pathInUnit) {
	            return Promise.reject(new Error("Unit path is null"));
	        }
	        var includeReference = refResolvers.getIncludeReference(pathInUnit);
	        var oldPath = pathInUnit;
	        if (includeReference) {
	            pathInUnit = includeReference.getIncludePath();
	        }
	        var absPath = lowlevel.buildPath(pathInUnit, unitPath, this.rootPath);
	        if (includeReference) {
	            var result;
	            var refPath = lowlevel.toAbsolutePath(path.dirname(lowlevel.toAbsolutePath(this.rootPath, unitPath)), includeReference.encodedName());
	            // if (this.pathToUnit[refPath]) {
	            //     result = this.pathToUnit[refPath];
	            // } else {
	            //     this.pathToUnit[refPath] = new CompilationUnit(includeReference.encodedName(), refResolvers.resolveContents(oldPath), false, this, refPath);
	            //
	            //     result = this.pathToUnit[refPath];
	            // }
	            this.pathToUnit[absPath] ? Promise.resolve(result).then(function (unit) {
	                _this.pathToUnit[refPath] = new CompilationUnit(includeReference.encodedName(), refResolvers.resolveContents(oldPath, _this.pathToUnit[absPath].contents()), false, _this, refPath);
	                return _this.pathToUnit[refPath];
	            }) : this.unitAsync(absPath, true).then(function (unit) {
	                _this.pathToUnit[absPath] = unit;
	                _this.pathToUnit[refPath] = new CompilationUnit(includeReference.encodedName(), refResolvers.resolveContents(oldPath, _this.pathToUnit[absPath].contents()), false, _this, refPath);
	                return _this.pathToUnit[refPath];
	            });
	        }
	        return this.unitAsync(absPath, true);
	    };
	    Project.prototype.resolve = function (unitPath, pathInUnit) {
	        if (!pathInUnit) {
	            return null;
	        }
	        pathInUnit = pathInUnit.replace(/\\/g, "/");
	        var includeReference = refResolvers.getIncludeReference(pathInUnit);
	        var oldPath = pathInUnit;
	        if (includeReference) {
	            pathInUnit = includeReference.getIncludePath();
	        }
	        var absPath = lowlevel.buildPath(pathInUnit, unitPath, this.rootPath);
	        if (includeReference) {
	            if (!this.pathToUnit[absPath]) {
	                this.pathToUnit[absPath] = this.unit(absPath, true);
	            }
	            var wrappedUnit = this.pathToUnit[absPath];
	            var refPath = lowlevel.toAbsolutePath(path.dirname(lowlevel.toAbsolutePath(this.rootPath, unitPath)), includeReference.encodedName());
	            if (this.pathToUnit[refPath]) {
	                return this.pathToUnit[refPath];
	            }
	            this.pathToUnit[refPath] = new CompilationUnit(includeReference.encodedName(), refResolvers.resolveContents(oldPath, wrappedUnit && wrappedUnit.contents()), false, this, refPath);
	            return this.pathToUnit[refPath];
	        }
	        return this.unit(absPath, true);
	    };
	    Project.prototype.units = function () {
	        var _this = this;
	        if (!this.resolver.list) {
	            throw new Error("Provided FSResolver is unable to list files. Please, use ExtendedFSResolver.");
	        }
	        var names = this.resolver.list(this.rootPath).filter(function (x) { return path.extname(x) == '.raml'; });
	        return names.map(function (x) { return _this.unit(x); }).filter(function (y) { return y.isTopLevel(); });
	    };
	    Project.prototype.unitsAsync = function () {
	        var _this = this;
	        if (!this.resolver.listAsync) {
	            return Promise.reject(new Error("Provided FSResolver is unable to list files. Please, use ExtendedFSResolver."));
	        }
	        return this.resolver.listAsync(this.rootPath).then(function (x) {
	            var promises = x.filter(function (x) { return path.extname(x) == '.raml'; }).map(function (x) { return _this.unitAsync(x).then(function (x) {
	                return x.isTopLevel() ? x : null;
	            }, function (x) {
	                return null;
	            }); });
	            return Promise.all(promises).then(function (arr) {
	                return arr.filter(function (x) { return x != null; });
	            });
	        });
	    };
	    Project.prototype.lexerErrors = function () {
	        var results = [];
	        this.units().forEach(function (x) {
	            results = results.concat(x.lexerErrors());
	        });
	        return results;
	    };
	    Project.prototype.deleteUnit = function (p, absolute) {
	        if (absolute === void 0) { absolute = false; }
	        var apath = null;
	        if (lowlevel.isWebPath(p)) {
	            apath = p;
	        }
	        else {
	            apath = absolute ? p : lowlevel.toAbsolutePath(this.rootPath, p);
	        }
	        delete this.pathToUnit[apath];
	    };
	    Project.prototype.unit = function (p, absolute) {
	        if (absolute === void 0) { absolute = false; }
	        if (absolute || lowlevel.isWebPath(p)) {
	            if (this.failedUnits[p] != null) {
	                if (!this.failedUnits[p].inner) {
	                    return null; //throw(this.failedUnits[p]);
	                }
	            }
	        }
	        else {
	            var ap = lowlevel.toAbsolutePath(this.rootPath, p);
	            if (this.failedUnits[ap]) {
	                if (!this.failedUnits[p].inner) {
	                    return null; //throw(this.failedUnits[p]);
	                }
	            }
	        }
	        var cnt = null;
	        var apath = p;
	        var response;
	        if (lowlevel.isWebPath(p)) {
	            if (this.pathToUnit[apath]) {
	                return this.pathToUnit[apath];
	            }
	            if (this._httpResolver) {
	                response = this._httpResolver.getResource(p);
	                if (response && response.errorMessage) {
	                    throw new Error(response.errorMessage);
	                }
	                if (response) {
	                    cnt = response.content;
	                }
	                else {
	                    cnt = null;
	                }
	            }
	            else {
	                response = new HTTPResolverImpl().getResource(apath);
	                if (response) {
	                    cnt = response.content;
	                }
	                else {
	                    cnt = null;
	                }
	            }
	        }
	        else {
	            if (p.charAt(0) == '/' && !absolute) {
	                p = p.substr(1); //TODO REVIEW IT
	            }
	            var apath = lowlevel.toAbsolutePath(this.rootPath, p);
	            if (this.pathToUnit[apath]) {
	                return this.pathToUnit[apath];
	            }
	            if (lowlevel.isWebPath(apath)) {
	                if (this._httpResolver) {
	                    var resp = this._httpResolver.getResource(apath);
	                    if (resp && resp.errorMessage) {
	                        throw new Error(resp.errorMessage);
	                    }
	                    if (resp) {
	                        cnt = resp.content;
	                    }
	                    else {
	                        cnt = null;
	                    }
	                }
	                else {
	                    var resourceResponse = new HTTPResolverImpl().getResource(apath);
	                    if (resourceResponse) {
	                        cnt = resourceResponse.content;
	                    }
	                    else {
	                        cnt = null;
	                    }
	                }
	            }
	            else {
	                cnt = this.resolver.content(apath);
	            }
	        }
	        if (cnt == null) {
	            return null;
	        }
	        var tl = util.stringStartsWith(cnt, "#%RAML");
	        var relPath = (lowlevel.isWebPath(this.rootPath) == lowlevel.isWebPath(apath)) ? path.relative(this.rootPath, apath) : apath;
	        var unit = new CompilationUnit(relPath, cnt, tl, this, apath);
	        this.pathToUnit[apath] = unit;
	        if (response) {
	            response.callback = function (contentHolder) {
	                unit.updateContent(contentHolder && contentHolder.content);
	            };
	        }
	        return unit;
	    };
	    Project.prototype.unitAsync = function (p, absolute) {
	        var _this = this;
	        if (absolute === void 0) { absolute = false; }
	        var cnt = null;
	        var apath = p;
	        if (lowlevel.isWebPath(p)) {
	            if (this.pathToUnit[apath]) {
	                return Promise.resolve(this.pathToUnit[apath]);
	            }
	            if (this._httpResolver) {
	                var resp = this._httpResolver.getResourceAsync(apath);
	                cnt = resp.then(function (x) {
	                    if (x.errorMessage) {
	                        return Promise.reject(new Error(x.errorMessage));
	                    }
	                    return x.content;
	                });
	            }
	            else {
	                cnt = new HTTPResolverImpl().getResourceAsync(apath);
	            }
	        }
	        else {
	            if (p.charAt(0) == '/' && !absolute) {
	                p = p.substr(1); //TODO REVIEW IT
	            }
	            if (absolute) {
	                apath = p;
	            }
	            else {
	                apath = lowlevel.toAbsolutePath(this.rootPath, p);
	            }
	            if (this.pathToUnit[apath]) {
	                return Promise.resolve(this.pathToUnit[apath]);
	            }
	            if (lowlevel.isWebPath(apath)) {
	                if (this._httpResolver) {
	                    var resp = this._httpResolver.getResourceAsync(apath);
	                    cnt = resp.then(function (x) {
	                        if (x.errorMessage) {
	                            return Promise.reject(new Error(x.errorMessage));
	                        }
	                        return x.content;
	                    });
	                }
	                else {
	                    cnt = new HTTPResolverImpl().getResourceAsync(apath);
	                }
	            }
	            else {
	                cnt = this.resolver.contentAsync(apath);
	            }
	        }
	        if (cnt == null) {
	            return Promise.resolve(null);
	        }
	        var relPath = (lowlevel.isWebPath(this.rootPath) == lowlevel.isWebPath(apath)) ? path.relative(this.rootPath, apath) : apath;
	        return cnt.then(function (x) {
	            if (x == null) {
	                return Promise.reject(new Error("Can note resolve " + apath));
	            }
	            var tl = util.stringStartsWith(x, "#%RAML");
	            var unit = new CompilationUnit(relPath, x, tl, _this, apath);
	            _this.pathToUnit[apath] = unit;
	            return unit;
	        }, function (err) {
	            if (typeof (err) == "object" && err instanceof Error) {
	                return Promise.reject(err);
	            }
	            else {
	                return Promise.reject(new Error(err.toString()));
	            }
	        }).then(function (unit) {
	            if (unit.isRAMLUnit()) {
	                return unit;
	            }
	            return schemes.isScheme(unit.contents()) ? schemes.startDownloadingReferencesAsync(unit.contents(), unit) : unit;
	        });
	    };
	    Project.prototype.visualizeNewlines = function (s) {
	        var res = '';
	        for (var i = 0; i < s.length; i++) {
	            var ch = s[i];
	            if (ch == '\r')
	                ch = '\\r';
	            if (ch == '\n')
	                ch = '\\n';
	            res += ch;
	        }
	        return res;
	    };
	    Project.prototype.indent = function (node) {
	        //node.show('NODE');
	        var text = node.unit().contents();
	        //console.log('node text: ' + textutil.replaceNewlines(text.substring(node.start(), node.end())));
	        //console.log('node parent: ' + node.parent());
	        //console.log('node unit: ' + node.unit());
	        if (node == node.root()) {
	            //console.log('node is root');
	            return '';
	        }
	        var leading = leadingIndent(node, text);
	        //console.log('leading: [' + leading + '] ' + leading.length);
	        var dmp = splitOnLines(node.dump());
	        if (dmp.length > 1) {
	            if (dmp[1].trim().length > 0) {
	                //console.log('DMP0: [' + dmp[0] + ']');
	                //console.log('DMP1: [' + dmp[1] + ']');
	                var extra = indent(dmp[1]);
	                return leading + extra;
	            }
	        }
	        //console.log('LEADING: [' + this.visualizeNewlines(leading) + '] ');
	        return leading + '  ';
	    };
	    Project.prototype.startIndent = function (node) {
	        var text = node.unit().contents();
	        //console.log('Node text:\n' + this.visualizeNewlines(text.substring(node.start(), node.end())));
	        if (node == node.root())
	            return '';
	        var dmp = splitOnLines(node.dump());
	        if (dmp.length > 0) {
	            console.log('FIRST: ' + dmp[0]);
	            var extra = indent(dmp[0]);
	            return extra + '  ';
	        }
	        //console.log('LEADING: [' + this.visualizeNewlines(leading) + '] ');
	        return '';
	    };
	    Project.prototype.canWriteInOneLine = function (node) {
	        return false;
	    };
	    Project.prototype.isOneLine = function (node) {
	        return node.text().indexOf('\n') < 0;
	    };
	    Project.prototype.recalcPositionsUp = function (target) {
	        var np = target;
	        while (np) {
	            np.recalcEndPositionFromChilds();
	            np = np.parent();
	        }
	    };
	    Project.prototype.add2 = function (target, node, toSeq, ipoint, json) {
	        if (json === void 0) { json = false; }
	        var unit = target.unit();
	        var api = target.root();
	        //console.log('api: ' + api);
	        var point = null;
	        if (ipoint) {
	            if (ipoint instanceof ASTNode) {
	                //console.log('insertion: ast node');
	                point = ipoint;
	            }
	            if (ipoint instanceof InsertionPoint) {
	                //console.log('insertion: ip');
	                point = ipoint.point;
	            }
	        }
	        //console.log('target: ' + target.kindName() + '/' + target.valueKindName() + ' node: ' + node.kindName());
	        //if(point) point.show('POINT:');
	        if (target.isValueInclude()) {
	            //console.log('insert to include ref');
	            var childs = target.children();
	            if (childs.length == 0) {
	                throw new Error("not implemented: insert into empty include ref");
	            }
	            var parent = childs[0].parent();
	            //console.log('parent: ' + parent);
	            //parent.show('INCLUDE PARENT:');
	            this.add2(parent, node, toSeq, point, json);
	            return;
	        }
	        var range = new textutil.TextRange(unit.contents(), node.start(), node.end());
	        var targetRange = new textutil.TextRange(unit.contents(), target.start(), target.end());
	        var unitText = target.unit().contents();
	        if (target.valueKind() == yaml.Kind.SEQ) {
	            target = createSeq(target.valueAsSeq(), target, target.unit());
	        }
	        var json = this.isJson(target);
	        //console.log('target: ' + target.start() + '..' + target.end());
	        var originalIndent = json ? '' : this.indent(target.isSeq() ? target.parent() : target);
	        //console.log('indent: [' + originalIndent + '] ' + originalIndent.length + '; toseq: ' + toSeq + '; json: ' + json);
	        var xindent = originalIndent;
	        var indentLength = originalIndent.length;
	        var isTargetSeq = target.isSeq() || target.isMapping() && (target.isValueSeq() || target.isValueScalar() || !target.asMapping().value); //target.valueKind() == yaml.Kind.SEQ || target.isSeq();
	        //toSeq = false;
	        //console.log('target: ' + target.kindName() + '/' + yaml.Kind[target.valueKind()] + '; toseq: ' + toSeq);
	        //target.root().show("API:");
	        //target.show("TARGET:");
	        //console.log('oindent: ' + originalIndent.length);
	        toSeq = toSeq; // || isTargetSeq;
	        if (toSeq) {
	            if (json) {
	            }
	            else {
	                if (isTargetSeq) {
	                    xindent += "  ";
	                    indentLength += 2;
	                }
	            }
	        }
	        //console.log('xindent: ' + xindent.length);
	        var buf = new MarkupIndentingBuffer(xindent);
	        //target.show('TARGET:');
	        //node.show('NODE1');
	        node.markupNode(buf, node._actualNode(), 0, json);
	        var text = buf.text;
	        //node.show('NODE2', 0, text);
	        //console.log('TEXT TO ADD0: ' + textutil.replaceNewlines(text));
	        if (toSeq) {
	            //if(target.valueKind() == yaml.Kind.SEQ) {
	            var trimText = textutil.trimEnd(text);
	            var trimLen = text.length - trimText.length;
	            if (trimLen > 0) {
	                //console.log('trim len: ' + trimLen);
	                var textlen = text.length;
	                text = text.substring(0, textlen - trimLen);
	                node.shiftNodes(textlen - trimLen, -trimLen);
	            }
	        }
	        //target.show('TARGET2');
	        //node.show('NODE2', 0, text);
	        //console.log('TEXT TO ADD1: ' + textutil.replaceNewlines(text));
	        //console.log('TEXT TO ADD:\n' + this.visualizeNewlines(text));
	        //console.log('toseq: ' + toSeq);
	        if (toSeq && !json) {
	            if (node.highLevelNode()) {
	            }
	            //console.log('target: ' + target.kindName());
	            if (target.isMapping()) {
	            }
	            if (target.isSeq() || target.isMapping() && (target.isValueSeq() || target.isValueScalar() || !target.asMapping().value)) {
	                //console.log('--- make it seq');
	                text = originalIndent + '- ' + text;
	            }
	            else {
	                //console.log('--- keep it map');
	                text = originalIndent + text;
	            }
	        }
	        else {
	            text = originalIndent + text;
	        }
	        //console.log('TEXT TO ADD2: ' + textutil.replaceNewlines(text));
	        //target.show('TARGET3');
	        var pos = target.end();
	        //console.log('insert to target end: ' + pos+ ' ; point: ' + point);
	        if (point) {
	            //point.show("POINT");
	            if (point != target) {
	                pos = point.end();
	            }
	            else {
	                if (json && toSeq) {
	                }
	                else {
	                    pos = target.keyEnd() + 1;
	                    pos = new textutil.TextRange(unitText, pos, pos).extendAnyUntilNewLines().endpos();
	                }
	            }
	        }
	        else {
	            if (json && toSeq) {
	                var seq = target.asSeq();
	                if (seq) {
	                    if (seq.items.length > 0) {
	                        pos = seq.items[seq.items.length - 1].endPosition;
	                    }
	                    else {
	                        pos = seq.endPosition - 1;
	                    }
	                }
	            }
	            else {
	                if (ipoint && (ipoint instanceof InsertionPoint)) {
	                    //ipoint.show('insertion point provided');
	                    var ip = ipoint;
	                    if (ip.type == InsertionPointType.START) {
	                        pos = target.keyEnd() + 1;
	                        pos = new textutil.TextRange(unitText, pos, pos).extendAnyUntilNewLines().endpos();
	                    }
	                }
	            }
	        }
	        //console.log('insert poition: ' + pos);
	        var insertionRange = new textutil.TextRange(unitText, 0, pos);
	        pos = insertionRange.extendToNewlines().reduceSpaces().endpos();
	        if (json && target.isSeq()) {
	            var seq = target.asSeq();
	            if (seq.items.length > 0) {
	                text = ', ' + text;
	                indentLength += 2;
	            }
	        }
	        else if (pos > 0 && unitText[pos - 1] != '\n') {
	            text = "\n" + text;
	            indentLength++;
	        }
	        var suffixLen = 0;
	        if (toSeq && !json) {
	            text += '\n';
	            suffixLen++;
	        }
	        //console.log('FINAL TEXT TO ADD: [' + textutil.replaceNewlines(text) + '] at position ' + pos);
	        var newtext = unitText.substring(0, pos) + text + unitText.substring(pos, unitText.length);
	        var cu = unit;
	        cu.updateContentSafe(newtext);
	        this.executeReplace(new textutil.TextRange(unitText, pos, pos), text, cu);
	        //console.log('shift root from position: ' + pos);
	        target.root().shiftNodes(pos, indentLength + (node.end() - node.start()) + suffixLen);
	        //console.log('node len: ' + (node.end()-node.start()));
	        //console.log('text len: ' + text.length);
	        //(<ASTNode>target.root()).shiftNodes(pos, text.length+indentLength);
	        //target.show('TARGET2:');
	        //node.show('NODE TO ADD:');
	        if (point) {
	            var childs = target.children();
	            var index = -1;
	            for (var i = 0; i < childs.length; i++) {
	                var x = childs[i];
	                if (x.start() == point.start() && x.end() == point.end()) {
	                    index = i;
	                    break;
	                }
	            }
	            //console.log('index: ' + index);
	            if (index >= 0) {
	                target.addChild(node, index + 1);
	            }
	            else {
	                target.addChild(node);
	            }
	        }
	        else {
	            target.addChild(node);
	        }
	        node.shiftNodes(0, pos + indentLength);
	        //target.show('TARGET UPDATED:');
	        this.recalcPositionsUp(target);
	        //target.show('TARGET UPDATED POSITIONS:');
	        //api.show('ROOT UPDATED POSITIONS:');
	        node.setUnit(target.unit());
	        node.visit(function (n) {
	            var node = n;
	            node.setUnit(target.unit());
	            return true;
	        });
	    };
	    Project.prototype.isJsonMap = function (node) {
	        if (!node.isMap())
	            return false;
	        var text = node.text().trim();
	        return text.length >= 2 && text[0] == '{' && text[text.length - 1] == '}';
	    };
	    Project.prototype.isJsonSeq = function (node) {
	        if (!node.isSeq())
	            return false;
	        var text = node.text().trim();
	        return text.length >= 2 && text[0] == '[' && text[text.length - 1] == ']';
	    };
	    Project.prototype.isJson = function (node) {
	        return this.isJsonMap(node) || this.isJsonSeq(node);
	    };
	    Project.prototype.remove = function (unit, target, node) {
	        var parent = node.parent();
	        node._oldText = node.dump();
	        //node.showParents('PARENTS:');
	        //console.log('REMOVE NODE: ' + node.kindName() + ' from ' + target.kindName());
	        //console.log('INITIAL SELECTION: [' + textutil.replaceNewlines(range.text()) + ']');
	        //console.log('  text: \n' + unitText.substring(startpos,endpos));
	        if (this.isOneLine(node) && node.isMapping() && node.parent().isMap()) {
	            var mapnode = node.parent();
	            if (mapnode.asMap().mappings.length == 1 && mapnode.parent() != null) {
	                //console.log('REMOVE MAP INSTEAD!');
	                this.remove(unit, mapnode.parent(), mapnode);
	                return;
	            }
	        }
	        if (this.isOneLine(node) && node.isScalar() && node.parent().isSeq()) {
	            var seqnode = node.parent();
	            var seqn = seqnode.asSeq();
	            //console.log('SEQ: ' + seqn.items.length);
	            if (seqn.items.length == 1) {
	                //console.log('REMOVE SEQ INSTEAD!');
	                this.remove(unit, seqnode.parent(), seqnode);
	                return;
	            }
	        }
	        if (target.isMapping() && node.isSeq()) {
	            //console.log('remove seq from mapping');
	            var map = target.parent();
	            //console.log('REMOVE MAPPING INSTEAD!');
	            this.remove(unit, map, target);
	            return;
	        }
	        //target.show('TARGET:');
	        //node.show('NODE:');
	        var range = new textutil.TextRange(unit.contents(), node.start(), node.end());
	        var targetRange = new textutil.TextRange(unit.contents(), target.start(), target.end());
	        var parentRange = new textutil.TextRange(unit.contents(), parent.start(), parent.end());
	        var originalStartPos = range.startpos();
	        //console.log('REMOVE TEXT: ' +  this.visualizeNewlines(range.text()));
	        if (target.isSeq()) {
	            // extend range to start of line
	            //console.log('RANGE SEQ 0: ' + textutil.replaceNewlines(range.text()));
	            var seq = (node.isSeq() ? node : node.parentOfKind(yaml.Kind.SEQ));
	            //console.log('seq: ' + seq.text() + ' json: ' + this.isJson(seq));
	            if (seq && this.isJson(seq)) {
	                range = range.extendSpaces().extendCharIfAny(',').extendSpaces();
	            }
	            else {
	                range = range.extendToStartOfLine().extendAnyUntilNewLines().extendToNewlines(); //
	            }
	        }
	        if (target.isMap()) {
	            // extend range to end of line
	            //console.log('RANGE MAP 0: [' +  this.visualizeNewlines(range.text()) + ']');
	            range = range.trimEnd().extendAnyUntilNewLines().extendToNewlines();
	            //console.log('RANGE MAP 1: [' +  this.visualizeNewlines(range.text()) + ']');
	            range = range.extendToStartOfLine().extendUntilNewlinesBack();
	        }
	        if (target.kind() == yaml.Kind.MAPPING) {
	            //console.log('RANGE MAPPING 0: ' +  this.visualizeNewlines(range.text()));
	            //console.log('NODE TEXT: ' + node.text());
	            if (this.isJson(node) && this.isOneLine(node)) {
	            }
	            else {
	                // extend range to end of line
	                //console.log('RANGE MAP 0: ' +  this.visualizeNewlines(range.text()));
	                range = range.extendSpacesUntilNewLines();
	                range = range.extendToNewlines();
	                //console.log('RANGE MAP 2: ' +  this.visualizeNewlines(range.text()));
	                range = range.extendToStartOfLine().extendUntilNewlinesBack();
	            }
	        }
	        if (node.isSeq()) {
	            //console.log('cleanup seq');
	            range = range.reduceSpaces();
	        }
	        //console.log('NODE:\n-----------\n' + range.unitText() + '\n-------------');
	        //console.log('TARGET: ' + target.kindName());
	        //target.show('TARGET');
	        //console.log('FINAL REMOVE TEXT: [' +  this.visualizeNewlines(range.text()) + ']');
	        //console.log('NEW TEXT:\n-----------\n' + range.remove() + '\n-------------');
	        var cu = unit;
	        cu.updateContentSafe(range.remove());
	        this.executeReplace(range, "", cu);
	        //node.parent().show('Before remove');
	        node.parent().removeChild(node);
	        var shift = -range.len();
	        //console.log('shift: ' + shift);
	        target.root().shiftNodes(originalStartPos, shift);
	        this.recalcPositionsUp(target);
	        //this.executeTextChange(new lowlevel.TextChangeCommand(range.startpos(), range.len(), "", unit))
	        //target.show('TARGET AFTER REMOVE:');
	        //target.root().show('API AFTER REMOVE:');
	    };
	    Project.prototype.changeKey = function (unit, attr, newval) {
	        //console.log('set key: ' + newval);
	        var range = new textutil.TextRange(attr.unit().contents(), attr.keyStart(), attr.keyEnd());
	        if (attr.kind() == yaml.Kind.MAPPING) {
	            var sc = attr._actualNode().key;
	            sc.value = newval;
	            sc.endPosition = sc.startPosition + newval.length;
	        }
	        var cu = unit;
	        this.executeReplace(range, newval, cu);
	        //console.log('new text: ' + this.visualizeNewlines(newtext));
	        var shift = newval.length - range.len();
	        //console.log('shift: ' + shift);
	        attr.root().shiftNodes(range.startpos(), shift, attr);
	        this.recalcPositionsUp(attr);
	    };
	    Project.prototype.executeReplace = function (r, txt, unit) {
	        var command = new lowlevel.TextChangeCommand(r.startpos(), r.endpos() - r.startpos(), txt, unit);
	        unit.project();
	        try {
	            this.tlisteners.forEach(function (x) { return x(command); });
	        }
	        catch (e) {
	            return false;
	        }
	        var newtext = r.replace(txt);
	        unit.updateContentSafe(newtext);
	        return true;
	    };
	    Project.prototype.changeValue = function (unit, attr, newval) {
	        //console.log('set value: ' + newval);mark
	        //console.log('ATTR ' + yaml.Kind[attr.kind()] + '; VALUE: ' + val + ' => ' + newval);
	        //attr.root().show('NODE:');
	        //console.log('TEXT:\n' + attr.unit().contents());
	        var range = new textutil.TextRange(attr.unit().contents(), attr.start(), attr.end());
	        //console.log('Range0: ' + range.startpos() + '..' + range.endpos() + ': [' + this.visualizeNewlines(range.text()) + ']');
	        //console.log('ATTR: ' + attr.kindName());
	        //attr.root().show('BEFORE');
	        var newNodeText;
	        var prefix = 0;
	        var delta = 0;
	        var replacer = null;
	        var mapping = null;
	        //console.log('attr: ' + attr.kindName());
	        if (attr.kind() == yaml.Kind.SCALAR) {
	            if (typeof newval == 'string') {
	                attr.asScalar().value = newval;
	                //range = range.withStart(attr.valueStart()).withEnd(attr.valueEnd());
	                //console.log('Range1: ' + this.visualizeNewlines(range.text()));
	                //console.log('Range0: ' + range.startpos() + '..' + range.endpos());
	                newNodeText = newval;
	            }
	            else {
	                throw new Error("not implemented");
	            }
	        }
	        else if (attr.kind() == yaml.Kind.MAPPING) {
	            //attr.show('ATTR:');
	            mapping = attr.asMapping();
	            //console.log('mapping val: ' + attr.valueKindName());
	            if (attr.isValueInclude()) {
	                var inc = attr.valueAsInclude();
	                var includeString = inc.value;
	                var includePath = includeString;
	                //console.log("attr.setValue: path: " + includePath);
	                var resolved = attr.unit().resolve(includePath);
	                if (resolved == null) {
	                    console.log("attr.setValue: couldn't resolve: " + includePath);
	                    return; // "can not resolve "+includePath
	                }
	                //console.log("attr.setValue: resolved: " + includePath);
	                if (resolved.isRAMLUnit()) {
	                    //TODO DIFFERENT DATA TYPES, inner references
	                    return;
	                }
	                //TODO for now disabling an update from outline details to JSON schema when there is a reference
	                //to an inner element of the schema
	                if (!refResolvers.getIncludeReference(includeString)) {
	                    resolved.updateContent(newval);
	                }
	                return;
	            }
	            //console.log('Range0: ' + range.startpos() + '..' + range.endpos() + ': [' + this.visualizeNewlines(range.text()) + ']');
	            if (mapping.value)
	                range = range.withStart(attr.valueStart()).withEnd(attr.valueEnd());
	            else
	                range = range.withStart(attr.keyEnd() + 1).withEnd(attr.keyEnd() + 1);
	            //console.log('Range1: ' + range.startpos() + '..' + range.endpos());
	            range = range.reduceNewlinesEnd();
	            //console.log('Range2: ' + range.startpos() + '..' + range.endpos() + ': [' + this.visualizeNewlines(range.text()) + ']');
	            if (newval == null) {
	                newNodeText = '';
	                mapping.value = null;
	            }
	            else if (typeof newval == 'string' || newval == null) {
	                var newstr = newval;
	                var ind = this.indent(attr);
	                //console.log('indent: ' + ind.length);
	                if (newstr && textutil.isMultiLine(newstr)) {
	                    newstr = '' + textutil.makeMutiLine(newstr, ind.length / 2);
	                }
	                newNodeText = newstr;
	                //var valueNode = null;
	                if (!mapping.value) {
	                    console.log('no value');
	                    mapping.value = yaml.newScalar(newstr);
	                    mapping.value.startPosition = attr.keyEnd() + 1;
	                    mapping.value.endPosition = mapping.value.startPosition + newstr.length;
	                    mapping.endPosition = mapping.value.endPosition;
	                    if (unit.contents().length > attr.keyEnd() + 1) {
	                        var vlPos = attr.keyEnd() + 1;
	                        if (unit.contents()[vlPos - 1] == ':') {
	                            newNodeText = " " + newNodeText;
	                            mapping.value.startPosition++;
	                            mapping.value.endPosition++;
	                            mapping.endPosition++;
	                            delta++;
	                        }
	                    }
	                }
	                else if (mapping.value.kind == yaml.Kind.SEQ) {
	                    console.log('seq value');
	                    var v = mapping.value.items[0];
	                    //TODO !!! assign value
	                    throw "assign value!!!";
	                }
	                else if (mapping.value.kind == yaml.Kind.SCALAR) {
	                    //console.log('scalar value');
	                    var sc = mapping.value;
	                    var oldtext = sc.value || "";
	                    //console.log('oldval: ' + sc.value);
	                    //console.log('newstr: ' + newstr + ' ' + newstr.length);
	                    sc.value = newstr;
	                    //console.log('value1: ' + mapping.value.startPosition + '..' + mapping.value.endPosition);
	                    mapping.value.endPosition = mapping.value.startPosition + newstr.length;
	                    //console.log('value2: ' + mapping.value.startPosition + '..' + mapping.value.endPosition);
	                    mapping.endPosition = mapping.value.endPosition;
	                    //console.log('mvalue: ' + mapping.startPosition + '..' + mapping.endPosition);
	                    //console.log('newval: ' + sc.value);
	                    delta += newstr.length - oldtext.length;
	                }
	            }
	            else {
	                var n = newval;
	                if (n.isMapping()) {
	                    newval = createMap([n.asMapping()]);
	                    n = newval;
	                }
	                else if (n.isMap()) {
	                }
	                else {
	                    throw new Error("only MAP/MAPPING nodes allowed as values");
	                }
	                //n.show('NODE1');
	                var buf = new MarkupIndentingBuffer('');
	                n.markupNode(buf, n._actualNode(), 0, true);
	                //n.show('NODE2');
	                newNodeText = '' + buf.text + '';
	                //indent++;
	                //n.shiftNodes(0, 1);
	                //console.log('node text: [[[' + newNodeText + ']]]');
	                //n.show("NN1:", 0, newNodeText);
	                //range = mapping.value? range.withStart(attr.valueStart()).withEnd(attr.valueEnd()) : range.withStart(attr.keyEnd()+1).withEnd(attr.keyEnd()+1 + newNodeText);
	                n.shiftNodes(0, range.startpos() + delta);
	                //n.show("NN2:");
	                replacer = n;
	            }
	        }
	        else {
	            console.log('Unsupported change value case: ' + attr.kindName());
	        }
	        //console.log('RangeX: ' + range.startpos() + '..' + range.endpos() + ': [' + this.visualizeNewlines(range.text()) + ']');
	        //console.log('new node text: ' + newNodeText);
	        var cu = unit;
	        //console.log('Range1: ' + range.startpos() + '..' + range.endpos());
	        //console.log('replace: ' + range.len());
	        //console.log('Range: ' + range.startpos() + '..' + range.endpos());
	        //console.log('OldText: ' + this.visualizeNewlines(cu.contents()));
	        this.executeReplace(range, newNodeText, cu);
	        //var newtext = range.replace(newNodeText);
	        //console.log('NewText: ' + this.visualizeNewlines(newtext));
	        //cu.updateContentSafe(newtext);
	        var shift = newNodeText.length - range.len();
	        //var shift = delta;
	        //attr.root().show('BEFORE SHIFT');
	        //console.log('shift: ' + shift + '; from: ' + (range.endpos() + prefix) + '; delta: ' + delta + '; prefix: ' + prefix);
	        attr.root().shiftNodes(range.endpos() + prefix, shift, attr);
	        //(<ASTNode>attr.root()).shiftNodes(range.endpos()+indent, shift);
	        //attr.show('ATTR2:');
	        if (replacer) {
	            mapping.value = replacer._actualNode();
	        }
	        this.recalcPositionsUp(attr);
	    };
	    Project.prototype.initWithRoot = function (root, newroot) {
	        var shift = root.end();
	        newroot.markup(false);
	        newroot._actualNode().startPosition = shift;
	        newroot._actualNode().endPosition = shift;
	        newroot.setUnit(root.unit());
	    };
	    Project.prototype.execute = function (cmd) {
	        var _this = this;
	        //console.log('Commands: ' + cmd.commands.length);
	        cmd.commands.forEach(function (x) {
	            //console.log('EXECUTE: kind: ' + lowlevel.CommandKind[x.kind] + '; val: ' + x.value);
	            switch (x.kind) {
	                case lowlevel.CommandKind.CHANGE_VALUE:
	                    var attr = x.target;
	                    var curval = attr.value();
	                    if (!curval) {
	                        curval = "";
	                    }
	                    var newval = x.value;
	                    console.log('set value: ' + (typeof curval) + ' ==> ' + (typeof newval));
	                    if ((typeof (curval) == 'string' ||
	                        typeof (curval) == 'number' ||
	                        typeof (curval) == 'boolean') && typeof newval == 'string') {
	                        //console.log('set value: str => str');
	                        if (curval != newval) {
	                            _this.changeValue(attr.unit(), attr, newval);
	                        }
	                    }
	                    else if ((typeof (curval) == 'string' ||
	                        typeof (curval) == 'number' ||
	                        typeof (curval) == 'boolean')
	                        && typeof (newval) != 'string') {
	                        //console.log('set value: str => obj');
	                        // change structure
	                        //this.changeValue(attr.unit(), attr, null);
	                        _this.changeValue(attr.unit(), attr, newval);
	                    }
	                    else if (typeof curval != 'string' && typeof newval == 'string') {
	                        var newstr = x.value;
	                        if (curval.kind() == yaml.Kind.MAPPING) {
	                            if (textutil.isMultiLine(newstr)) {
	                                //console.log('multiline');
	                                attr.children().forEach(function (n) {
	                                    _this.remove(attr.unit(), attr, n);
	                                });
	                                _this.changeValue(attr.unit(), attr, newstr);
	                            }
	                            else {
	                                //console.log('singleline');
	                                _this.changeKey(attr.unit(), curval, newstr);
	                            }
	                        }
	                        else {
	                            throw new Error('unsupported case: attribute value conversion: ' + (typeof curval) + ' ==> ' + (typeof newval) + ' not supported');
	                        }
	                    }
	                    else if (typeof curval != 'string' && typeof newval != 'string') {
	                        var newvalnode = newval;
	                        //(<ASTNode>curval).show("OLD:");
	                        //newvalnode.show("NEW:");
	                        if (newvalnode.isMapping()) {
	                            newval = createMap([newvalnode.asMapping()]);
	                        }
	                        //console.log('obj obj: ' + (curval == newval));
	                        if (curval == newval)
	                            break;
	                        // change structure
	                        //console.log('set value: obj => obj');
	                        var node = newval;
	                        var map = node.asMap();
	                        //console.log('attr: ' + attr.kindName() + " " + attr.dump());
	                        attr.children().forEach(function (n) {
	                            _this.remove(attr.unit(), attr, n);
	                        });
	                        node.children().forEach(function (m) {
	                            //this.add2(attr, <ASTNode>m, false, null, true);
	                        });
	                        _this.changeValue(attr.unit(), attr, newval);
	                    }
	                    else {
	                        throw new Error("shouldn't be this case: attribute value conversion " + (typeof curval) + ' ==> ' + (typeof newval) + ' not supported');
	                    }
	                    return;
	                case lowlevel.CommandKind.CHANGE_KEY:
	                    var attr = x.target;
	                    _this.changeKey(attr.unit(), attr, x.value);
	                    return;
	                case lowlevel.CommandKind.ADD_CHILD:
	                    var attr = x.target;
	                    var newValueNode = x.value;
	                    _this.add2(attr, newValueNode, x.toSeq, x.insertionPoint);
	                    return;
	                case lowlevel.CommandKind.REMOVE_CHILD:
	                    var target = x.target;
	                    var node = x.value;
	                    _this.remove(target.unit(), target, node);
	                    return;
	                case lowlevel.CommandKind.INIT_RAML_FILE:
	                    var root = x.target;
	                    var newroot = x.value;
	                    _this.initWithRoot(root, newroot);
	                    return;
	                default:
	                    console.log('UNSUPPORTED COMMAND: ' + lowlevel.CommandKind[x.kind]);
	                    return;
	            }
	        });
	    };
	    Project.prototype.replaceYamlNode = function (target, newNodeContent, offset, shift, unit) {
	        //console.log('New content:\n' + newNodeContent);
	        //target.show('OLD TARGET');
	        var newYamlNode = yaml.load(newNodeContent, {});
	        //console.log('new yaml: ' + yaml.Kind[newYamlNode.kind]);
	        this.updatePositions(target.start(), newYamlNode);
	        //console.log('Shift: ' + shift);
	        //(<ASTNode>unit.ast()).shiftNodes(offset, shift);
	        target.root().shiftNodes(offset, shift);
	        var targetParent = target.parent();
	        var targetYamlNode = target._actualNode();
	        var parent = targetYamlNode.parent;
	        newYamlNode.parent = parent;
	        if (targetParent && targetParent.kind() == yaml.Kind.MAP) {
	            //console.log('MAP!!!');
	            var targetParentMapNode = targetParent._actualNode();
	            targetParentMapNode.mappings = targetParentMapNode.mappings.map(function (x) {
	                if (x != targetYamlNode) {
	                    return x;
	                }
	                return newYamlNode;
	            });
	        }
	        target.updateFrom(newYamlNode);
	        //target.show('MEW TARGET');
	        this.recalcPositionsUp(target);
	    };
	    Project.prototype.executeTextChange2 = function (textCommand) {
	        var cu = textCommand.unit;
	        var unitText = cu.contents();
	        var target = textCommand.target;
	        if (target) {
	            var cnt = unitText.substring(target.start(), target.end());
	            var original = unitText;
	            unitText = unitText.substr(0, textCommand.offset) + textCommand.text + unitText.substr(textCommand.offset + textCommand.replacementLength);
	            var newNodeContent = cnt.substr(0, textCommand.offset - target.start()) +
	                textCommand.text + cnt.substr(textCommand.offset - target.start() + textCommand.replacementLength);
	            cu.updateContentSafe(unitText);
	            if (textCommand.offset > target.start()) {
	                try {
	                    var shift = textCommand.text.length - textCommand.replacementLength;
	                    var offset = textCommand.offset;
	                    target.unit().project().replaceYamlNode(target, newNodeContent, offset, shift, textCommand.unit);
	                }
	                catch (e) {
	                    console.log('New node contents (causes error below): \n' + newNodeContent);
	                    console.log('Reparse error: ' + e.stack);
	                }
	            }
	        }
	        else {
	            unitText = unitText.substr(0, textCommand.offset) + textCommand.text + unitText.substr(textCommand.offset + textCommand.replacementLength);
	        }
	        cu.updateContent(unitText);
	        this.listeners.forEach(function (x) {
	            x(null);
	        });
	        this.tlisteners.forEach(function (x) {
	            x(textCommand);
	        });
	    };
	    Project.prototype.executeTextChange = function (textCommand) {
	        var l0 = new Date().getTime();
	        try {
	            var oc = textCommand.unit.contents();
	            //console.log('Offset: ' + textCommand.offset + '; end: ' + (textCommand.offset + textCommand.replacementLength) + '; len: ' + textCommand.replacementLength);
	            var target = textCommand.target;
	            if (target == null) {
	                target = this.findNode(textCommand.unit.ast(), textCommand.offset, textCommand.offset + textCommand.replacementLength);
	            }
	            var cu = textCommand.unit;
	            if (target) {
	                var cnt = oc.substring(target.start(), target.end());
	                //console.log('Content: ' + cnt);
	                var original = oc;
	                oc = oc.substr(0, textCommand.offset) + textCommand.text + oc.substr(textCommand.offset + textCommand.replacementLength);
	                var newNodeContent = cnt.substr(0, textCommand.offset - target.start()) +
	                    textCommand.text + cnt.substr(textCommand.offset - target.start() + textCommand.replacementLength);
	                cu.updateContentSafe(oc);
	                //console.log('UPDATED TEXT: ' + oc);
	                var hasNewLines = breaksTheLine(original, textCommand);
	                if (textCommand.offset > target.start()) {
	                    //we can just reparse new node content;
	                    //console.log(newNodeContent)
	                    try {
	                        var newYamlNode = yaml.load(newNodeContent, {});
	                        this.updatePositions(target.start(), newYamlNode);
	                        //console.log("Positions updated")
	                        //lets shift all after it
	                        var shift = textCommand.text.length - textCommand.replacementLength;
	                        //console.log('shift: ' + shift);
	                        //console.log('offset: ' + textCommand.offset);
	                        textCommand.unit.ast().shiftNodes(textCommand.offset, shift);
	                        //console.log('Unit AST: ' + textCommand.unit.ast())
	                        if (newYamlNode != null && newYamlNode.kind == yaml.Kind.MAP) {
	                            var actualResult = newYamlNode.mappings[0];
	                            var targetYamlNode = target._actualNode();
	                            var parent = targetYamlNode.parent;
	                            var cmd = new lowlevel.ASTDelta();
	                            var unit = textCommand.unit;
	                            cmd.commands = [
	                                new lowlevel.ASTChangeCommand(lowlevel.CommandKind.CHANGE_VALUE, new ASTNode(copyNode(targetYamlNode), unit, null, null, null), new ASTNode(actualResult, unit, null, null, null), 0)
	                            ];
	                            if (parent && parent.kind == yaml.Kind.MAP) {
	                                var map = parent;
	                                map.mappings = map.mappings.map(function (x) {
	                                    if (x != targetYamlNode) {
	                                        return x;
	                                    }
	                                    return actualResult;
	                                });
	                            }
	                            actualResult.parent = parent;
	                            //updating low level ast from yaml
	                            this.recalcPositionsUp(target);
	                            target.updateFrom(actualResult);
	                            //console.log("Incremental without listeners: "+(new Date().getTime()-l0));
	                            //console.log("Notify listeners1: " + this.listeners.length + ":" + this.tlisteners.length);
	                            this.listeners.forEach(function (x) {
	                                x(cmd);
	                            });
	                            this.tlisteners.forEach(function (x) {
	                                x(textCommand);
	                            });
	                            //console.log("Incremental update processed");
	                            return;
	                        }
	                    }
	                    catch (e) {
	                        console.log('New node contents (causes error below): \n' + newNodeContent);
	                        console.log('Reparse error: ' + e.stack);
	                    }
	                }
	            }
	            else {
	                oc = oc.substr(0, textCommand.offset) + textCommand.text + oc.substr(textCommand.offset + textCommand.replacementLength);
	            }
	            var t2 = new Date().getTime();
	            //console.log("Full without listeners:"+(t2-l0));
	            //!find node in scope
	            cu.updateContent(oc);
	            //console.log("Notify listeners2: " + this.listeners.length + ":" + this.tlisteners.length);
	            this.listeners.forEach(function (x) {
	                x(null);
	            });
	            this.tlisteners.forEach(function (x) {
	                x(textCommand);
	            });
	        }
	        finally {
	            var t2 = new Date().getTime();
	        }
	    };
	    Project.prototype.updatePositions = function (offset, n) {
	        var _this = this;
	        if (n == null) {
	            return;
	        }
	        if (n.startPosition == -1) {
	            n.startPosition = offset;
	        }
	        else {
	            n.startPosition = offset + n.startPosition;
	        }
	        n.endPosition = offset + n.endPosition;
	        //console.log('SET POS: ' + n.startPosition + ".." + n.endPosition);
	        switch (n.kind) {
	            case yaml.Kind.MAP:
	                var m = n;
	                m.mappings.forEach(function (x) { return _this.updatePositions(offset, x); });
	                break;
	            case yaml.Kind.MAPPING:
	                var ma = n;
	                this.updatePositions(offset, ma.key);
	                this.updatePositions(offset, ma.value);
	                break;
	            case yaml.Kind.SCALAR:
	                break;
	            case yaml.Kind.SEQ:
	                var s = n;
	                s.items.forEach(function (x) { return _this.updatePositions(offset, x); });
	                break;
	        }
	    };
	    Project.prototype.findNode = function (n, offset, end) {
	        var _this = this;
	        if (n == null) {
	            return null;
	        }
	        var node = n;
	        if (n.start() <= offset && n.end() >= end) {
	            var res = n;
	            node.directChildren().forEach(function (x) {
	                var m = _this.findNode(x, offset, end);
	                if (m) {
	                    res = m;
	                }
	            });
	            return res;
	        }
	        return null;
	    };
	    //shiftNodes(n:lowlevel.ILowLevelASTNode, offset:number, shift:number):lowlevel.ILowLevelASTNode{
	    //    var node:ASTNode=<ASTNode>n;
	    //    if (node==null){
	    //        return null;
	    //    }
	    //    node.directChildren().forEach(x=> {
	    //        var m = this.shiftNodes(x, offset, shift);
	    //    })
	    //    var yaNode=(<ASTNode>n)._actualNode();
	    //    if(yaNode) innerShift(offset, yaNode, shift);
	    //    return null;
	    //}
	    Project.prototype.addTextChangeListener = function (listener) {
	        this.tlisteners.push(listener);
	    };
	    Project.prototype.removeTextChangeListener = function (listener) {
	        this.tlisteners = this.tlisteners.filter(function (x) { return x != listener; });
	    };
	    Project.prototype.addListener = function (listener) {
	        this.listeners.push(listener);
	    };
	    Project.prototype.removeListener = function (listener) {
	        this.listeners = this.listeners.filter(function (x) { return x != listener; });
	    };
	    Project.prototype.namespaceResolver = function () {
	        return this._namespaceResolver;
	    };
	    return Project;
	}());
	exports.Project = Project;
	function breaksTheLine(oc, textCommand) {
	    var oldText = oc.substr(textCommand.offset, textCommand.replacementLength);
	    if (oldText.indexOf('\n') != -1) {
	        return true;
	    }
	    if (textCommand.text.indexOf('\n') != -1) {
	        return true;
	    }
	}
	function tryParseScalar(q) {
	    if (q == "null") {
	        q = null;
	    }
	    else if (q == "~") {
	        q = null;
	    }
	    else if (q == "true") {
	        q = true;
	    }
	    else if (q == "false") {
	        q = false;
	    }
	    else {
	        var vl = parseFloat(q);
	        if (!isNaN(vl)) {
	            if (("" + q).match("^[-+]?[0-9]*\\.?[0-9]+$")) {
	                q = vl;
	            }
	        }
	    }
	    return q;
	}
	var ASTNode = (function () {
	    function ASTNode(_node, _unit, _parent, _anchor, _include, cacheChildren, _includesContents) {
	        if (cacheChildren === void 0) { cacheChildren = false; }
	        if (_includesContents === void 0) { _includesContents = false; }
	        this._node = _node;
	        this._unit = _unit;
	        this._parent = _parent;
	        this._anchor = _anchor;
	        this._include = _include;
	        this.cacheChildren = cacheChildren;
	        this._includesContents = _includesContents;
	        this._errors = [];
	        if (_node == null) {
	            console.log("null");
	        }
	    }
	    ASTNode.prototype.actual = function () {
	        return this._node;
	    };
	    ASTNode.prototype.yamlNode = function () {
	        return this._node;
	    };
	    ASTNode.prototype.includesContents = function () {
	        return this._includesContents;
	    };
	    ASTNode.prototype.setIncludesContents = function (includesContents) {
	        this._includesContents = includesContents;
	    };
	    ASTNode.prototype.gatherIncludes = function (s, inc, anc, inOneMemberMap) {
	        var _this = this;
	        if (s === void 0) { s = []; }
	        if (inc === void 0) { inc = null; }
	        if (anc === void 0) { anc = null; }
	        if (inOneMemberMap === void 0) { inOneMemberMap = true; }
	        if (this._node == null) {
	            return; //TODO FIXME
	        }
	        var kind = this._node.kind;
	        if (kind == yaml.Kind.SCALAR) {
	            if (schemes.isScheme(this._node.value)) {
	                var references = schemes.getReferences(this._node.value, this.unit());
	                references.forEach(function (reference) {
	                    var includeNode = yaml.newScalar(reference);
	                    includeNode.kind = yaml.Kind.INCLUDE_REF;
	                    var includeAST = new ASTNode(includeNode, _this.unit(), null, null, null);
	                    s.push(includeAST);
	                });
	            }
	            return;
	        }
	        else if (kind == yaml.Kind.MAP) {
	            var map = this._node;
	            if (map.mappings.length == 1 && !inOneMemberMap) {
	                new ASTNode(map.mappings[0].value, this._unit, this, inc, anc, this.cacheChildren).gatherIncludes(s);
	            }
	            else {
	                map.mappings.
	                    map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include, _this.cacheChildren); }).
	                    forEach(function (x) { return x.gatherIncludes(s); });
	            }
	        }
	        else if (kind == yaml.Kind.MAPPING) {
	            var mapping = this._node;
	            if (mapping.value == null) {
	            }
	            else {
	                new ASTNode(mapping.value, this._unit, this, anc ? anc : this._anchor, inc ? inc : this._include, this.cacheChildren).gatherIncludes(s);
	            }
	        }
	        else if (kind == yaml.Kind.SEQ) {
	            var seq = this._node;
	            seq.items.filter(function (x) { return x != null; }).map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include, _this.cacheChildren); }).forEach(function (x) { return x.gatherIncludes(s); });
	        }
	        else if (kind == yaml.Kind.INCLUDE_REF) {
	            if (this._unit) {
	                s.push(this);
	            }
	        }
	    };
	    ASTNode.prototype.setHighLevelParseResult = function (highLevelParseResult) {
	        this._highLevelParseResult = highLevelParseResult;
	    };
	    ASTNode.prototype.highLevelParseResult = function () {
	        return this._highLevelParseResult;
	    };
	    ASTNode.prototype.setHighLevelNode = function (highLevel) {
	        this._highLevelNode = highLevel;
	    };
	    ASTNode.prototype.highLevelNode = function () {
	        return this._highLevelNode;
	    };
	    ASTNode.prototype.start = function () {
	        return this._node.startPosition;
	    };
	    ASTNode.prototype.errors = function () {
	        return this._errors;
	    };
	    ASTNode.prototype.addIncludeError = function (error) {
	        this._errors.push(error);
	        if (!this._node.includeErrors) {
	            this._node.includeErrors = [];
	        }
	        this._node.includeErrors.push(error);
	    };
	    ASTNode.prototype.parent = function () {
	        return this._parent;
	    };
	    ASTNode.prototype.recalcEndPositionFromChilds = function () {
	        var childs = this.children();
	        //if(this.children().length == 0) return;
	        var max = 0;
	        var first = this.children()[0];
	        var last = this.children()[this.children().length - 1];
	        //this.children().forEach(n=> {
	        //    var node: ASTNode = <ASTNode>n;
	        //    if(node._node.endPosition > max) max = node._node.endPosition;
	        //});
	        if (this.isMapping()) {
	            var mapping = this.asMapping();
	            //console.log('reposition: mapping');
	            if (mapping.value) {
	                if (mapping.value.kind == yaml.Kind.MAP) {
	                    var map = mapping.value;
	                    if (map.startPosition < 0 && first) {
	                        map.startPosition = first.start();
	                    }
	                    if (last)
	                        this._node.endPosition = last._node.endPosition;
	                    //console.log('embedded map: ' + map.startPosition + ".." + map.endPosition);
	                    this._node.endPosition = Math.max(this._node.endPosition, mapping.value.endPosition);
	                }
	                else if (mapping.value.kind == yaml.Kind.SEQ) {
	                    var seq = mapping.value;
	                    if (seq.startPosition < 0) {
	                        //console.log('*** missed start position');
	                        if (seq.items.length > 0) {
	                            var pos = seq.items[0].startPosition;
	                            var range = new textutil.TextRange(this.unit().contents(), pos, pos);
	                            range = range.extendSpacesBack().extendCharIfAnyBack('-');
	                            seq.startPosition = range.startpos();
	                        }
	                        else {
	                        }
	                    }
	                    //console.log('mapping1     : ' + mapping.startPosition + ".." + mapping.endPosition);
	                    //console.log('embedded seq1: ' + seq.startPosition + ".." + seq.endPosition);
	                    if (seq.items.length > 0) {
	                        var ilast = seq.items[seq.items.length - 1];
	                        this._node.endPosition = Math.max(this._node.endPosition, seq.endPosition, ilast.endPosition);
	                        seq.endPosition = Math.max(this._node.endPosition, seq.endPosition, ilast.endPosition);
	                    }
	                }
	                else if (mapping.value.kind == yaml.Kind.SCALAR) {
	                }
	                else {
	                    if (last)
	                        this._node.endPosition = last._node.endPosition;
	                }
	            }
	        }
	        else {
	            if (last)
	                this._node.endPosition = last._node.endPosition;
	        }
	        //this._node.endPosition = max;;
	    };
	    ASTNode.prototype.isValueLocal = function () {
	        if (this._node.kind == yaml.Kind.MAPPING) {
	            var knd = this._node.value.kind;
	            return knd != yaml.Kind.INCLUDE_REF && knd != yaml.Kind.ANCHOR_REF;
	        }
	        return true;
	    };
	    ASTNode.prototype.keyStart = function () {
	        if (this._node.kind == yaml.Kind.MAPPING) {
	            return this._node.key.startPosition;
	        }
	        return -1;
	    };
	    ASTNode.prototype.keyEnd = function () {
	        if (this._node.kind == yaml.Kind.MAPPING) {
	            return this._node.key.endPosition;
	        }
	        return -1;
	    };
	    ASTNode.prototype.valueStart = function () {
	        if (this._node.kind == yaml.Kind.MAPPING) {
	            var mapping = this.asMapping();
	            if (mapping.value)
	                return mapping.value.startPosition;
	            else
	                return mapping.endPosition;
	        }
	        return -1;
	    };
	    ASTNode.prototype.valueEnd = function () {
	        if (this._node.kind == yaml.Kind.MAPPING) {
	            var mapping = this.asMapping();
	            return mapping.value ? mapping.value.endPosition : mapping.endPosition;
	        }
	        return -1;
	    };
	    ASTNode.prototype.end = function () {
	        return this._node.endPosition;
	    };
	    ASTNode.prototype.dump = function () {
	        if (this._oldText) {
	            return this._oldText;
	        }
	        if (this._unit && this._node.startPosition > 0 && this._node.endPosition > 0) {
	            var originalText = this._unit.contents().substring(this._node.startPosition, this._node.endPosition);
	            originalText = stripIndent(originalText, leadingIndent(this, this._unit.contents()));
	            //console.log("L:");
	            //console.log(originalText);
	            return originalText;
	        }
	        return yaml.dump(this.dumpToObject(), {});
	    };
	    ASTNode.prototype.dumpToObject = function (full) {
	        if (full === void 0) { full = false; }
	        return this.dumpNode(this._node, full);
	    };
	    ASTNode.prototype.dumpNode = function (n, full) {
	        var _this = this;
	        if (full === void 0) { full = false; }
	        if (!n) {
	            return null;
	        }
	        if (n.kind == yaml.Kind.INCLUDE_REF) {
	            if (this._unit) {
	                var s = n;
	                var includePath = s.value;
	                var resolved = null;
	                try {
	                    resolved = this._unit.resolve(includePath);
	                }
	                catch (Error) {
	                }
	                if (resolved == null) {
	                    return null;
	                }
	                else if (resolved.isRAMLUnit() && this.canInclude(resolved)) {
	                    var ast = resolved.ast();
	                    if (ast) {
	                        return ast.dumpToObject(full);
	                    }
	                }
	            }
	            return null;
	        }
	        if (n.kind == yaml.Kind.SEQ) {
	            var seq = n;
	            var arr = [];
	            seq.items.forEach(function (x) { return arr.push(_this.dumpNode(x, full)); });
	            return arr;
	        }
	        if (n.kind == yaml.Kind.ANCHOR_REF) {
	            var aref = n;
	            return this.dumpNode(aref.value, full);
	        }
	        if (n.kind == yaml.Kind.MAPPING) {
	            var c = n;
	            var v = {};
	            var val = c.value;
	            var mm = this.dumpNode(val, full);
	            v["" + this.dumpNode(c.key, full)] = mm;
	            return v;
	        }
	        if (n.kind == yaml.Kind.SCALAR) {
	            var s = n;
	            var q = s.value;
	            if (s.plainScalar) {
	                q = tryParseScalar(q);
	            }
	            return q;
	        }
	        if (n.kind == yaml.Kind.MAP) {
	            var map = n;
	            var res = {};
	            if (map.mappings) {
	                map.mappings.forEach(function (x) {
	                    var ms = _this.dumpNode(x.value, full);
	                    if (ms == null) {
	                        ms = full ? "!$$$novalue" : ms;
	                    }
	                    //if (ms!=null||full) {
	                    res[_this.dumpNode(x.key, full) + ""] = ms;
	                    //}
	                });
	            }
	            return res;
	        }
	    };
	    ASTNode.prototype.keyKind = function () {
	        if (this._node.key) {
	            return this._node.key.kind;
	        }
	        return null;
	    };
	    ASTNode.prototype._actualNode = function () {
	        return this._node;
	    };
	    ASTNode.prototype.execute = function (cmd) {
	        if (this.unit()) {
	            this.unit().project().execute(cmd);
	        }
	        else {
	            cmd.commands.forEach(function (x) {
	                switch (x.kind) {
	                    case lowlevel.CommandKind.CHANGE_VALUE:
	                        var attr = x.target;
	                        var newValue = x.value;
	                        var va = attr._actualNode();
	                        var as = attr.start();
	                        if (va.kind == yaml.Kind.MAPPING) {
	                            va.value = yaml.newScalar("" + newValue);
	                        }
	                        //this.executeTextChange(new lowlevel.TextChangeCommand(as,attr.value().length,<string>newValue,attr.unit()))
	                        return;
	                    case lowlevel.CommandKind.CHANGE_KEY:
	                        var attr = x.target;
	                        var newValue = x.value;
	                        var va = attr._actualNode();
	                        if (va.kind == yaml.Kind.MAPPING) {
	                            var sc = va.key;
	                            sc.value = newValue;
	                        }
	                        return;
	                }
	            });
	        }
	    };
	    ASTNode.prototype.updateFrom = function (n) {
	        this._node = n;
	    };
	    ASTNode.prototype.isAnnotatedScalar = function () {
	        if (this.kind() == yaml.Kind.MAPPING && this.unit()) {
	            if (this.valueKind() == yaml.Kind.MAP && this._node.value.mappings) {
	                var isScalar = this._node.value.mappings.length > 0;
	                this._node.value.mappings.forEach(function (x) {
	                    if (x.key.value === "value") {
	                        return;
	                    }
	                    if (x.key.value) {
	                        if (x.key.value.charAt(0) == '(' && x.key.value.charAt(x.key.value.length - 1) == ')') {
	                            return;
	                        }
	                    }
	                    isScalar = false;
	                });
	                return isScalar;
	            }
	        }
	        return false;
	    };
	    ASTNode.prototype.value = function (toString) {
	        if (!this._node) {
	            return "";
	        }
	        if (this._node.kind == yaml.Kind.SCALAR) {
	            if (this._node['value'] === "~" && this._node['valueObject'] === null) {
	                return toString ? "null" : null;
	            }
	            //TODO WHAT IS IT IS INCLUDE ACTUALLY
	            if (!toString && ("" + this._node['valueObject'] === this._node['value'])) {
	                return this._node['valueObject'];
	            }
	            var q = this._node['value'];
	            if (!toString) {
	                if (this._node.plainScalar) {
	                    q = tryParseScalar(q);
	                }
	            }
	            return q;
	        }
	        if (this._node.kind == yaml.Kind.ANCHOR_REF) {
	            var ref = this._node;
	            return new ASTNode(ref.value, this._unit, this, null, null).value(toString);
	        }
	        if (this._node.kind == yaml.Kind.MAPPING) {
	            var map = this._node;
	            if (map.value == null) {
	                return null;
	            }
	            if (this.isAnnotatedScalar()) {
	                var child = new ASTNode(map.value, this._unit, this, null, null);
	                var ch = child.children();
	                for (var i = 0; i < ch.length; i++) {
	                    if (ch[i].key() === "value") {
	                        return ch[i].value();
	                    }
	                }
	            }
	            return new ASTNode(map.value, this._unit, this, null, null).value(toString);
	        }
	        if (this._node.kind == yaml.Kind.INCLUDE_REF) {
	            //here we should resolve include
	            var includeString = this._node['value'];
	            var includePath = includeString;
	            var resolved = null;
	            try {
	                resolved = this._unit.resolve(includePath);
	            }
	            catch (Error) {
	                //not sure why we're returning this as a value, but that's what we do with failed units due to unknown cause below,
	                //so doing the same @Denis
	                return "can not resolve " + includePath + " due to: " + Error.message;
	            }
	            if (resolved == null) {
	                return "can not resolve " + includePath;
	            }
	            if (resolved.isRAMLUnit()) {
	                var ast = resolved.ast();
	                if (!ast) {
	                    return "can not resolve " + includePath + " due to: file is empty";
	                }
	                return ast.value();
	            }
	            var text = resolved.contents();
	            if (textutil.isMultiLineValue(text)) {
	                text = textutil.fromMutiLine(text);
	            }
	            return text;
	        }
	        if (this._node.kind == yaml.Kind.MAP) {
	            var amap = this._node;
	            if (amap.mappings.length == 1) {
	                //handle map with one member case differently
	                return new ASTNode(amap.mappings[0], this._unit, this, null, null);
	            }
	        }
	        if (this._node.kind == yaml.Kind.SEQ) {
	            var aseq = this._node;
	            if (aseq.items.length == 1 && true) {
	                //handle seq with one member case differently
	                return new ASTNode(aseq.items[0], this._unit, this, null, null).value(toString);
	            }
	        }
	        //this are only kinds which has values
	        return null;
	    };
	    ASTNode.prototype.printDetails = function (indent) {
	        var result = "";
	        if (!indent)
	            indent = "";
	        var typeName = this.kindName();
	        if (this.kind() == yaml.Kind.SCALAR) {
	            result += indent + "[" + typeName + "]" + " " + this.value() + "\n";
	        }
	        else if (this.kind() == yaml.Kind.MAPPING &&
	            this._node.value &&
	            this._node.value.kind == yaml.Kind.SCALAR) {
	            result += indent + "[" + typeName + "]" + " " + this.key()
	                + " = " + this.value() + "\n";
	        }
	        else if (this.kind() == yaml.Kind.MAPPING) {
	            result += indent + "[" + typeName + "]" + " " + this.key()
	                + " = :\n";
	            this.children().forEach(function (child) {
	                result += child.printDetails(indent + "\t");
	            });
	        }
	        else {
	            result += indent + "[" + typeName + "]" + " :\n";
	            this.children().forEach(function (child) {
	                result += child.printDetails(indent + "\t");
	            });
	        }
	        return result;
	    };
	    ASTNode.prototype.visit = function (v) {
	        this.children().forEach(function (x) {
	            if (v(x)) {
	                x.visit(v);
	            }
	        });
	    };
	    ASTNode.prototype.rawKey = function () {
	        if (!this._node) {
	            return "";
	        }
	        if (this._node.kind == yaml.Kind.MAPPING) {
	            var map = this._node;
	            if (map.key.kind == yaml.Kind.SEQ) {
	                var items = map.key;
	                var mn = "[";
	                items.items.forEach(function (x) { return mn += x.value; });
	                return mn + "]";
	            }
	            return map.key.value;
	        }
	        if (this._node.kind == yaml.Kind.INCLUDE_REF) {
	            var m = this.children();
	            if (m.length == 1) {
	                return m[0].key();
	            }
	        }
	        //other kinds do not have keys
	        return null;
	    };
	    ASTNode.prototype.key = function (raw) {
	        if (raw === void 0) { raw = false; }
	        var key = this.rawKey();
	        if (raw) {
	            return key;
	        }
	        if (key != null && util.stringEndsWith(key, '?')) {
	            key = key.substring(0, key.length - 1);
	        }
	        return key;
	    };
	    ASTNode.prototype.optional = function () {
	        var key = this.rawKey();
	        return key != null && util.stringEndsWith(key, '?');
	    };
	    ASTNode.prototype.addChild = function (n, pos) {
	        if (pos === void 0) { pos = -1; }
	        //this.show('ADD TARGET:');
	        var node = n;
	        //console.log('add-child: ' + this.kindName() + ' .add ' + node.kindName());
	        node._parent = this;
	        this._oldText = null;
	        if (this.isMap()) {
	            //console.log('pos: ' + pos);
	            var map = this.asMap();
	            if (map.mappings == null || map.mappings == undefined) {
	                map.mappings = [];
	            }
	            if (pos >= 0) {
	                map.mappings.splice(pos, 0, node.asMapping());
	            }
	            else {
	                map.mappings.push(node.asMapping());
	            }
	        }
	        else if (this.isMapping()) {
	            var mapping = this.asMapping();
	            var val = mapping.value;
	            //console.log('mapping value: ' + val);
	            if (!mapping.value && node.isMap()) {
	                mapping.value = node._actualNode();
	                return;
	            }
	            if (mapping.value && mapping.value.kind == yaml.Kind.SCALAR) {
	                // cleanup old value
	                mapping.value = null;
	                val = null;
	            }
	            if (!val) {
	                if (node.isScalar() || node.highLevelNode() && node.highLevelNode().property().getAdapter(services.RAMLPropertyParserService).isEmbedMap()) {
	                    val = yaml.newSeq();
	                }
	                else {
	                    val = yaml.newMap();
	                }
	                mapping.value = val;
	            }
	            if (val.kind == yaml.Kind.MAP) {
	                var map = val;
	                if (map.mappings == null || map.mappings == undefined) {
	                    map.mappings = [];
	                }
	                if (node.isScalar()) {
	                }
	                if (pos >= 0) {
	                    map.mappings.splice(pos, 0, node.asMapping());
	                }
	                else {
	                    map.mappings.push(node.asMapping());
	                }
	            }
	            else if (val.kind == yaml.Kind.SEQ) {
	                var seq = val;
	                if (pos >= 0) {
	                    seq.items.splice(pos, 0, node._actualNode());
	                }
	                else {
	                    seq.items.push(node._actualNode());
	                }
	            }
	            else {
	                throw new Error("Insert into mapping with " + yaml.Kind[mapping.value.kind] + " value not supported");
	            }
	        }
	        else if (this.isSeq()) {
	            var seq = this.asSeq();
	            if (pos >= 0) {
	                seq.items.splice(pos, 0, node._actualNode());
	            }
	            else {
	                seq.items.push(node._actualNode());
	            }
	        }
	        else {
	            throw new Error("Insert into " + this.kindName() + " not supported");
	        }
	    };
	    ASTNode.prototype.removeChild = function (n) {
	        this._oldText = null;
	        var node = n;
	        var ynode;
	        var index;
	        //console.log('*** REMOVE FROM: ' + this.kindName());
	        if (this.kind() == yaml.Kind.SEQ) {
	            //console.log('remove from seq');
	            var seq = this.asSeq();
	            //val = <yaml.YamlMap>((<yaml.YAMLMapping>this._node).value);
	            ynode = node._node;
	            index = seq.items.indexOf(ynode);
	            if (index > -1)
	                seq.items.splice(index, 1);
	        }
	        else if (this.kind() == yaml.Kind.MAP) {
	            //val = <yaml.YamlMap>((<yaml.YAMLMapping>this._node).value);
	            var map = this.asMap();
	            //console.log('remove from map: ' + map.mappings.length);
	            ynode = node.asMapping();
	            index = map.mappings.indexOf(ynode);
	            //console.log('  index: ' + index);
	            if (index > -1)
	                map.mappings.splice(index, 1);
	        }
	        else if (this.kind() == yaml.Kind.MAPPING) {
	            //console.log('*** REMOVE FROM MAPPING');
	            //val = <yaml.YamlMap>((<yaml.YAMLMapping>this._node).value);
	            //console.log('remove from mapping with map as value');
	            var mapping = this.asMapping();
	            //this.show("REMOVE TARGET: ***");
	            //node.show("REMOVE NODE: ***");
	            if (node._actualNode() == mapping.value) {
	                // remove right from mapping
	                //console.log('*** remove map from mapping!');
	                mapping.value = null;
	            }
	            else {
	                var map = (mapping.value);
	                ynode = node.asMapping();
	                if (map && map.mappings) {
	                    index = map.mappings.indexOf(ynode);
	                    if (index > -1)
	                        map.mappings.splice(index, 1);
	                }
	            }
	        }
	        else {
	            throw new Error("Delete from " + yaml.Kind[this.kind()] + " unsupported");
	        }
	    };
	    ASTNode.prototype.hasInnerIncludeError = function () {
	        return this.innerIncludeErrors;
	    };
	    ASTNode.prototype.includeErrors = function () {
	        if (this._node.kind == yaml.Kind.MAPPING) {
	            var mapping = this._node;
	            if (mapping.value == null) {
	                return [];
	            }
	            var node = new ASTNode(mapping.value, this._unit, this, this._anchor, this._include);
	            var res = node.includeErrors();
	            this.innerIncludeErrors = node.hasInnerIncludeError();
	            // if (res == null || res.length == 0) {
	            //     <any>this._node
	            // }
	            return res;
	        }
	        var rs = [];
	        if (this._node.kind == yaml.Kind.INCLUDE_REF) {
	            var mapping = this._node;
	            if (mapping.value == null) {
	                return [];
	            }
	            var includePath = this.includePath();
	            var resolved = null;
	            try {
	                resolved = this._unit.resolve(includePath);
	            }
	            catch (Error) {
	                this.innerIncludeErrors = Error.inner;
	                var s = "Can not resolve " + includePath + " due to: " + Error.message;
	                //known cause of failure
	                rs.push(s);
	                return rs;
	            }
	            var innerIncludeErrors = this._node.includeErrors;
	            if (innerIncludeErrors && innerIncludeErrors.length > 0) {
	                this.innerIncludeErrors = true;
	                rs = innerIncludeErrors.map(function (innerError) {
	                    if (typeof (innerError) == "object" && innerError instanceof Error) {
	                        return innerError.message;
	                    }
	                    else {
	                        return innerError.toString();
	                    }
	                });
	                return rs;
	            }
	            if (resolved == null) {
	                //unknown cause of failure
	                rs.push("Can not resolve " + includePath);
	                return rs;
	            }
	            if (resolved.isRAMLUnit()) {
	                var ast = resolved.ast();
	                if (ast) {
	                    return [];
	                }
	                else {
	                    rs.push("" + includePath + " can not be parsed");
	                }
	            }
	            else {
	            }
	        }
	        return rs;
	    };
	    /**
	     * Joins current mappings with mappings from "<<" anchor, if there is one.
	     * @param mappings
	     * @param inc
	     * @param anc
	     * @returns {any}
	     */
	    ASTNode.prototype.joinMappingsWithFullIncludeAnchor = function (mappings, inc, anc) {
	        var _this = this;
	        var fullAnchorMapping = _.find(mappings, function (mapping) {
	            return mapping.key && mapping.value &&
	                mapping.key.kind == yaml.Kind.SCALAR &&
	                mapping.key.value == "<<" &&
	                mapping.value.kind == yaml.Kind.ANCHOR_REF;
	        });
	        if (!fullAnchorMapping) {
	            return mappings.map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include, _this.cacheChildren); });
	        }
	        var filteredMappings = _.filter(mappings, function (mapping) {
	            return !(mapping.key.kind == yaml.Kind.SCALAR &&
	                mapping.key.value == "<<" &&
	                mapping.value.kind == yaml.Kind.ANCHOR_REF);
	        });
	        var childrenFromAnchor = new ASTNode(fullAnchorMapping.value, this._unit, this, inc, anc, this.cacheChildren).children(null, null, true);
	        var filteredChildren = filteredMappings.map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include, _this.cacheChildren); });
	        return filteredChildren.concat(childrenFromAnchor);
	    };
	    ASTNode.prototype.children = function (inc, anc, inOneMemberMap) {
	        var _this = this;
	        if (inc === void 0) { inc = null; }
	        if (anc === void 0) { anc = null; }
	        if (inOneMemberMap === void 0) { inOneMemberMap = true; }
	        if (this._node == null) {
	            return []; //TODO FIXME
	        }
	        if (this.cacheChildren && this._children) {
	            return this._children;
	        }
	        var result;
	        var kind = this._node.kind;
	        if (kind == yaml.Kind.SCALAR) {
	            result = [];
	        }
	        else if (kind == yaml.Kind.MAP) {
	            var map = this._node;
	            if (map.mappings.length == 1 && !inOneMemberMap) {
	                //handle map with one member case differently
	                // q:
	                //  []
	                //   - a
	                //   - b
	                // ->
	                // q:
	                //  a
	                //  b
	                result = new ASTNode(map.mappings[0].value, this._unit, this, inc, anc, this.cacheChildren).children(null, null, true);
	            }
	            else {
	                //result = map.mappings.map(x=>new ASTNode(x, this._unit, this, anc ? anc : this._anchor, inc ? inc : this._include,this.cacheChildren));
	                result = this.joinMappingsWithFullIncludeAnchor(map.mappings, inc, anc);
	            }
	        }
	        else if (kind == yaml.Kind.MAPPING) {
	            var mapping = this._node;
	            if (mapping.value == null) {
	                result = [];
	            }
	            else {
	                var proxy = new ASTNode(mapping.value, this._unit, this, anc ? anc : this._anchor, inc ? inc : this._include, this.cacheChildren);
	                result = proxy.children();
	                if (proxy.includesContents()) {
	                    this.setIncludesContents(true);
	                }
	            }
	        }
	        else if (kind == yaml.Kind.SEQ) {
	            var seq = this._node;
	            result = seq.items.filter(function (x) { return x != null; }).map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include, _this.cacheChildren); });
	        }
	        else if (kind == yaml.Kind.INCLUDE_REF) {
	            if (this._unit) {
	                var includePath = this.includePath();
	                var resolved = null;
	                try {
	                    resolved = this._unit.resolve(includePath);
	                }
	                catch (Error) {
	                }
	                if (resolved == null) {
	                    result = [];
	                }
	                else if (resolved.isRAMLUnit() && this.canInclude(resolved)) {
	                    var ast = resolved.ast();
	                    if (ast) {
	                        if (this.cacheChildren) {
	                            ast = toChildCachingNode(ast);
	                        } //else {
	                        //    ast = <ASTNode>toIncludingNode(ast);
	                        //}
	                        result = resolved.ast().children(this, null);
	                        this.setIncludesContents(true);
	                    }
	                }
	            }
	            if (!result) {
	                result = [];
	            }
	        }
	        else if (kind == yaml.Kind.ANCHOR_REF) {
	            var ref = this._node;
	            result = new ASTNode(ref.value, this._unit, this, null, null, this.cacheChildren).children();
	        }
	        else {
	            throw new Error("Should never happen; kind : " + yaml.Kind[this._node.kind]);
	        }
	        if (this.cacheChildren) {
	            this._children = result;
	        }
	        return result;
	    };
	    ASTNode.prototype.canInclude = function (unit) {
	        var includedFrom = this.includedFrom();
	        while (includedFrom != null) {
	            if (includedFrom.unit().absolutePath() == unit.absolutePath()) {
	                return false;
	            }
	            includedFrom = includedFrom.includedFrom();
	        }
	        return true;
	    };
	    ASTNode.prototype.directChildren = function (inc, anc, inOneMemberMap) {
	        var _this = this;
	        if (inc === void 0) { inc = null; }
	        if (anc === void 0) { anc = null; }
	        if (inOneMemberMap === void 0) { inOneMemberMap = true; }
	        if (this._node) {
	            switch (this._node.kind) {
	                case yaml.Kind.SCALAR:
	                    return [];
	                case yaml.Kind.MAP:
	                    {
	                        var map = this._node;
	                        if (map.mappings.length == 1 && !inOneMemberMap) {
	                            //handle map with one member case differently
	                            return new ASTNode(map.mappings[0].value, this._unit, this, inc, anc).directChildren(null, null, true);
	                        }
	                        return map.mappings.map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include); });
	                    }
	                case yaml.Kind.MAPPING:
	                    {
	                        var mapping = this._node;
	                        if (mapping.value == null) {
	                            return [];
	                        }
	                        return new ASTNode(mapping.value, this._unit, this, anc ? anc : this._anchor, inc ? inc : this._include).directChildren();
	                    }
	                case yaml.Kind.SEQ:
	                    {
	                        var seq = this._node;
	                        return seq.items.filter(function (x) { return x != null; }).map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include); });
	                    }
	                case yaml.Kind.INCLUDE_REF:
	                    {
	                        return [];
	                    }
	                case yaml.Kind.ANCHOR_REF:
	                    {
	                        return [];
	                    }
	            }
	            throw new Error("Should never happen; kind : " + yaml.Kind[this._node.kind]);
	        }
	        return [];
	    };
	    ASTNode.prototype.anchorId = function () {
	        return this._node.anchorId;
	    };
	    ASTNode.prototype.unit = function () {
	        return this._unit;
	        //if(this._unit) return this._unit;
	        //if(!this.parent()) return null;
	        //return this.parent().unit();
	    };
	    ASTNode.prototype.includeBaseUnit = function () {
	        return this._unit;
	    };
	    ASTNode.prototype.setUnit = function (unit) {
	        this._unit = unit;
	    };
	    ASTNode.prototype.includePath = function () {
	        var includeString = this.getIncludeString();
	        if (!includeString) {
	            return null;
	        }
	        return includeString;
	    };
	    ASTNode.prototype.includeReference = function () {
	        var includeString = this.getIncludeString();
	        if (!includeString) {
	            return null;
	        }
	        return refResolvers.getIncludeReference(includeString);
	    };
	    ASTNode.prototype.getIncludeString = function () {
	        if (this._node.kind == yaml.Kind.INCLUDE_REF) {
	            var includePath = this._node['value'];
	            return includePath;
	        }
	        else if (this._node.kind == yaml.Kind.MAPPING) {
	            var mapping = this._node;
	            if (mapping.value == null)
	                return null;
	            return new ASTNode(mapping.value, this._unit, this, null, null).getIncludeString();
	        }
	        return null;
	    };
	    ASTNode.prototype.anchoredFrom = function () {
	        return this._anchor;
	    };
	    ASTNode.prototype.includedFrom = function () {
	        return this._include;
	    };
	    ASTNode.prototype.kind = function () {
	        return this._actualNode().kind;
	    };
	    ASTNode.prototype.valueKind = function () {
	        if (this._node.kind != yaml.Kind.MAPPING) {
	            return null;
	        }
	        var map = this._node;
	        if (!map.value) {
	            return null;
	        }
	        return map.value.kind;
	    };
	    ASTNode.prototype.anchorValueKind = function () {
	        if (this.valueKind() == yaml.Kind.ANCHOR_REF) {
	            var ref = this._node.value;
	            return ref.value.kind;
	        }
	        return null;
	    };
	    ASTNode.prototype.valueKindName = function () {
	        var kind = this.valueKind();
	        return kind != undefined ? yaml.Kind[kind] : null;
	    };
	    ASTNode.prototype.kindName = function () {
	        return yaml.Kind[this.kind()];
	    };
	    ASTNode.prototype.indent = function (lev, str) {
	        if (str === void 0) { str = ''; }
	        var leading = '';
	        //leading += '[' + lev + ']';
	        for (var i = 0; i < lev; i++)
	            leading += '  ';
	        return leading + str;
	    };
	    ASTNode.prototype.replaceNewlines = function (s, rep) {
	        if (rep === void 0) { rep = null; }
	        var res = '';
	        for (var i = 0; i < s.length; i++) {
	            var ch = s[i];
	            if (ch == '\r')
	                ch = rep == null ? '\\r' : rep;
	            if (ch == '\n')
	                ch = rep == null ? '\\n' : rep;
	            res += ch;
	        }
	        return res;
	    };
	    ASTNode.prototype.shortText = function (unittext, maxlen) {
	        if (maxlen === void 0) { maxlen = 50; }
	        var elen = this.end() - this.start();
	        var len = elen;
	        //var len = Math.min(elen,50);
	        var unit = this.unit();
	        if (!unittext && unit) {
	            unittext = unit.contents();
	        }
	        var text;
	        if (!unittext) {
	            text = '[no-unit]';
	        }
	        else {
	            var s = unittext;
	            text = s ? s.substring(this.start(), this.end()) : '[no-text]';
	        }
	        text = "[" + this.start() + ".." + this.end() + "] " + elen + " // " + text + ' //';
	        if (len < elen)
	            text += '...';
	        text = this.replaceNewlines(text);
	        return text;
	    };
	    ASTNode.prototype.nodeShortText = function (node, unittext, maxlen) {
	        if (maxlen === void 0) { maxlen = 50; }
	        var elen = node.endPosition - node.startPosition;
	        var len = elen;
	        //var len = Math.min(elen,50);
	        var unit = this.unit();
	        if (!unittext && unit) {
	            unittext = unit.contents();
	        }
	        var text;
	        if (!unittext) {
	            text = '[no-unit]';
	        }
	        else {
	            var s = unittext;
	            text = s ? s.substring(node.startPosition, node.endPosition) : '[no-text]';
	        }
	        text = "[" + node.startPosition + ".." + node.endPosition + "] " + elen + " // " + text + ' //';
	        if (len < elen)
	            text += '...';
	        text = this.replaceNewlines(text);
	        return text;
	    };
	    ASTNode.prototype.show = function (message, lev, text) {
	        if (message === void 0) { message = null; }
	        if (lev === void 0) { lev = 0; }
	        if (text === void 0) { text = null; }
	        if (message && lev == 0) {
	            console.log(message);
	        }
	        var children = this.children();
	        var desc = this.kindName();
	        var val = this._actualNode().value;
	        if (this.kind() == yaml.Kind.MAPPING) {
	            desc += '[' + this._actualNode().key.value + ']';
	        }
	        if (val) {
	            desc += "/" + yaml.Kind[val.kind];
	        }
	        else
	            desc += "";
	        if (children.length == 0) {
	            //desc += "/" + this.value();
	            console.log(this.indent(lev) + desc + " // " + this.shortText(text));
	            if (this.isMapping() && this.asMapping().value) {
	                console.log(this.indent(lev + 1) + '// ' + this.valueKindName() + ': ' + this.nodeShortText(this.asMapping().value, text));
	            }
	        }
	        else {
	            console.log(this.indent(lev) + desc + " { // " + this.shortText(text));
	            if (this.isMapping() && this.asMapping().value) {
	                console.log(this.indent(lev + 1) + '// ' + this.valueKindName() + ': ' + this.nodeShortText(this.asMapping().value, text));
	            }
	            children.forEach(function (node) {
	                var n = node;
	                n.show(null, lev + 1, text);
	            });
	            console.log(this.indent(lev) + '}');
	        }
	    };
	    ASTNode.prototype.showParents = function (message, lev) {
	        if (lev === void 0) { lev = 0; }
	        if (message && lev == 0) {
	            console.log(message);
	        }
	        var depth = 0;
	        if (this.parent()) {
	            var n = this.parent();
	            depth = n.showParents(null, lev + 1);
	        }
	        var desc = this.kindName();
	        var val = this._actualNode().value;
	        if (val)
	            desc += "/" + yaml.Kind[val.kind];
	        else
	            desc += "/null";
	        console.log(this.indent(depth) + desc + " // " + this.shortText(null));
	        return depth + 1;
	    };
	    ASTNode.prototype.inlined = function (kind) {
	        return kind == yaml.Kind.SCALAR || kind == yaml.Kind.INCLUDE_REF;
	    };
	    ASTNode.prototype.markupNode = function (xbuf, node, lev, json) {
	        if (json === void 0) { json = false; }
	        var start = xbuf.text.length;
	        //console.log('node: ' + node);
	        switch (node.kind) {
	            case yaml.Kind.MAP:
	                if (json)
	                    xbuf.append('{');
	                var mappings = node.mappings;
	                //console.log('map: ' + mappings.length);
	                for (var i = 0; i < mappings.length; i++) {
	                    if (json && i > 0)
	                        xbuf.append(', ');
	                    this.markupNode(xbuf, mappings[i], lev, json);
	                }
	                if (json)
	                    xbuf.append('}');
	                break;
	            case yaml.Kind.SEQ:
	                var items = node.items;
	                //console.log('seq: ' + items.length);
	                for (var i = 0; i < items.length; i++) {
	                    xbuf.append(this.indent(lev, '- '));
	                    //this.markupNode(xindent, pos+xbuf.text.length-(lev+1)*2, items[i], lev+1, xbuf);
	                    this.markupNode(xbuf, items[i], lev + 1, json);
	                }
	                break;
	            case yaml.Kind.MAPPING:
	                var mapping = node;
	                var val = mapping.value;
	                //console.log('mapping: ' + mapping.key.value + ' ' + val.kind);
	                if (json) {
	                    if (!val) {
	                        xbuf.append('\n');
	                        break;
	                    }
	                    xbuf.append(mapping.key.value);
	                    xbuf.append(': ');
	                    if (val.kind == yaml.Kind.SCALAR) {
	                        var sc = val;
	                        xbuf.append(sc.value);
	                    }
	                    else if (val.kind == yaml.Kind.MAP) {
	                        //var mp = <yaml.YamlMap>val;
	                        this.markupNode(xbuf, mapping.value, lev + 1, json);
	                    }
	                    else {
	                        throw new Error("markup not implemented: " + yaml.Kind[val.kind]);
	                    }
	                    break;
	                }
	                xbuf.addWithIndent(lev, mapping.key.value + ':');
	                if (!val) {
	                    xbuf.append('\n');
	                    break;
	                }
	                if (val.kind == yaml.Kind.SCALAR) {
	                    var sc = val;
	                }
	                //xbuf.append(this.indent(lev, mapping.key.value + ':'));
	                if (mapping.value) {
	                    xbuf.append(this.inlined(mapping.value.kind) ? ' ' : '\n');
	                    this.markupNode(xbuf, mapping.value, lev + 1, json);
	                }
	                else {
	                    xbuf.append('\n');
	                }
	                //console.log('xbuf: ' + xbuf);
	                break;
	            case yaml.Kind.SCALAR:
	                var sc = node;
	                if (textutil.isMultiLine(sc.value)) {
	                    xbuf.append('|\n');
	                    var lines = splitOnLines(sc.value);
	                    for (var i = 0; i < lines.length; i++) {
	                        xbuf.append(this.indent(lev, lines[i]));
	                    }
	                    xbuf.append('\n');
	                }
	                else {
	                    xbuf.append(sc.value + '\n');
	                }
	                //console.log('SCALAR: ' + textutil.replaceNewlines(sc.value));
	                break;
	            case yaml.Kind.INCLUDE_REF:
	                var ref = node;
	                xbuf.append('!include ' + ref.value + '\n');
	                break;
	            default:
	                throw new Error('Unknown node kind: ' + yaml.Kind[node.kind]);
	        }
	        while (start < xbuf.text.length && xbuf.text[start] == ' ')
	            start++;
	        node.startPosition = start;
	        node.endPosition = xbuf.text.length;
	    };
	    ASTNode.prototype.markup = function (json) {
	        if (json === void 0) { json = false; }
	        var buf = new MarkupIndentingBuffer('');
	        this.markupNode(buf, this._actualNode(), 0, json);
	        return buf.text;
	    };
	    ASTNode.prototype.root = function () {
	        var node = this;
	        while (node.parent()) {
	            var p = node.parent();
	            //if(p.isValueInclude()) break; // stop on include
	            node = p;
	        }
	        return node;
	    };
	    ASTNode.prototype.parentOfKind = function (kind) {
	        var p = this.parent();
	        while (p) {
	            if (p.kind() == kind)
	                return p;
	            p = p.parent();
	        }
	        return null;
	    };
	    ASTNode.prototype.find = function (name) {
	        var found = null;
	        //console.log('Looking for: ' + name);
	        this.directChildren().forEach(function (y) {
	            if (y.key() && y.key() == name) {
	                if (!found)
	                    found = y;
	            }
	        });
	        return found;
	    };
	    ASTNode.prototype.shiftNodes = function (offset, shift, exclude) {
	        this.directChildren().forEach(function (x) {
	            if (exclude && exclude.start() == x.start() && exclude.end() == x.end()) {
	            }
	            else {
	                var m = x.shiftNodes(offset, shift, exclude);
	            }
	        });
	        if (exclude && exclude.start() == this.start() && exclude.end() == this.end()) {
	        }
	        else {
	            var yaNode = this._actualNode();
	            if (yaNode)
	                innerShift(offset, yaNode, shift);
	        }
	        return null;
	    };
	    ASTNode.prototype.isMap = function () {
	        return this.kind() == yaml.Kind.MAP;
	    };
	    ASTNode.prototype.isMapping = function () {
	        return this.kind() == yaml.Kind.MAPPING;
	    };
	    ASTNode.prototype.isSeq = function () {
	        return this.kind() == yaml.Kind.SEQ;
	    };
	    ASTNode.prototype.isScalar = function () {
	        return this.kind() == yaml.Kind.SCALAR;
	    };
	    ASTNode.prototype.asMap = function () {
	        if (!this.isMap())
	            throw new Error("map expected instead of " + this.kindName());
	        return (this._actualNode());
	    };
	    ASTNode.prototype.asMapping = function () {
	        if (!this.isMapping())
	            throw new Error("maping expected instead of " + this.kindName());
	        return (this._actualNode());
	    };
	    ASTNode.prototype.asSeq = function () {
	        if (!this.isSeq())
	            throw new Error("seq expected instead of " + this.kindName());
	        return (this._actualNode());
	    };
	    ASTNode.prototype.asScalar = function () {
	        if (!this.isScalar())
	            throw new Error("scalar expected instead of " + this.kindName());
	        return (this._actualNode());
	    };
	    ASTNode.prototype.isValueSeq = function () {
	        return this.valueKind() == yaml.Kind.SEQ;
	    };
	    ASTNode.prototype.isValueMap = function () {
	        return this.valueKind() == yaml.Kind.MAP;
	    };
	    ASTNode.prototype.isValueInclude = function () {
	        return this.valueKind() == yaml.Kind.INCLUDE_REF;
	    };
	    ASTNode.prototype.isValueScalar = function () {
	        return this.valueKind() == yaml.Kind.SCALAR;
	    };
	    ASTNode.prototype.valueAsSeq = function () {
	        if (!this.isMapping())
	            throw new Error("mapping expected instead of " + this.kindName());
	        if (this.valueKind() != yaml.Kind.SEQ)
	            throw new Error("mappng/seq expected instead of mapping/" + this.kindName());
	        return (this.asMapping().value);
	    };
	    ASTNode.prototype.valueAsMap = function () {
	        if (!this.isMapping())
	            throw new Error("mapping expected instead of " + this.kindName());
	        if (this.valueKind() != yaml.Kind.MAP)
	            throw new Error("mappng/map expected instead of mapping/" + this.kindName());
	        return (this.asMapping().value);
	    };
	    ASTNode.prototype.valueAsScalar = function () {
	        if (!this.isMapping())
	            throw new Error("mapping expected instead of " + this.kindName());
	        if (this.valueKind() != yaml.Kind.SCALAR)
	            throw new Error("mappng/scalar expected instead of mapping/" + this.kindName());
	        return (this.asMapping().value);
	    };
	    ASTNode.prototype.valueAsInclude = function () {
	        if (!this.isMapping())
	            throw new Error("mapping expected instead of " + this.kindName());
	        if (this.valueKind() != yaml.Kind.INCLUDE_REF)
	            throw new Error("mappng/include expected instead of mapping/" + this.kindName());
	        return (this.asMapping().value);
	    };
	    ASTNode.prototype.text = function (unitText) {
	        if (unitText === void 0) { unitText = null; }
	        if (!unitText) {
	            if (!this.unit())
	                return '[no-text]';
	            unitText = this.unit().contents();
	        }
	        return unitText.substring(this.start(), this.end());
	    };
	    ASTNode.prototype.copy = function () {
	        var yn = copyNode(this._actualNode());
	        return new ASTNode(yn, this._unit, this._parent, this._anchor, this._include, this._includesContents);
	    };
	    ASTNode.prototype.nodeDefinition = function () {
	        return getDefinitionForLowLevelNode(this);
	    };
	    return ASTNode;
	}());
	exports.ASTNode = ASTNode;
	(function (InsertionPointType) {
	    InsertionPointType[InsertionPointType["NONE"] = 0] = "NONE";
	    InsertionPointType[InsertionPointType["START"] = 1] = "START";
	    InsertionPointType[InsertionPointType["END"] = 2] = "END";
	    InsertionPointType[InsertionPointType["POINT"] = 3] = "POINT";
	})(exports.InsertionPointType || (exports.InsertionPointType = {}));
	var InsertionPointType = exports.InsertionPointType;
	var InsertionPoint = (function () {
	    function InsertionPoint(type, point) {
	        if (point === void 0) { point = null; }
	        this.type = type;
	        this.point = point;
	    }
	    InsertionPoint.after = function (point) {
	        return new InsertionPoint(InsertionPointType.POINT, point);
	    };
	    InsertionPoint.atStart = function () {
	        return new InsertionPoint(InsertionPointType.START);
	    };
	    InsertionPoint.atEnd = function () {
	        return new InsertionPoint(InsertionPointType.END);
	    };
	    InsertionPoint.node = function () {
	        return new InsertionPoint(InsertionPointType.NONE);
	    };
	    InsertionPoint.prototype.show = function (msg) {
	        if (msg) {
	            console.log(msg);
	            console.log('  insertion point type: ' + InsertionPointType[this.type]);
	        }
	        else {
	            console.log('insertion point type: ' + InsertionPointType[this.type]);
	        }
	        if (this.type == InsertionPointType.POINT && this.point) {
	            this.point.show();
	        }
	    };
	    return InsertionPoint;
	}());
	exports.InsertionPoint = InsertionPoint;
	function createNode(key, parent, unit) {
	    //console.log('create node: ' + key);
	    var node = yaml.newMapping(yaml.newScalar(key), yaml.newMap());
	    return new ASTNode(node, unit, parent, null, null);
	}
	exports.createNode = createNode;
	function createMap(mappings) {
	    //console.log('create node: ' + key);
	    var node = yaml.newMap(mappings);
	    return new ASTNode(node, null, null, null, null);
	}
	exports.createMap = createMap;
	function createScalar(value) {
	    var node = yaml.newScalar(value);
	    return new ASTNode(node, null, null, null, null);
	}
	exports.createScalar = createScalar;
	function createSeq(sn, parent, unit) {
	    return new ASTNode(sn, unit, parent, null, null);
	}
	exports.createSeq = createSeq;
	/*
	export function createMappingWithMap(key:string, map: yaml.YAMLNode){
	    //console.log('create node: ' + key);
	    var node:yaml.YAMLNode=yaml.newMapping(yaml.newScalar(key),map);
	    return new ASTNode(node,null,null,null,null);
	}

	export function createMap(){
	    //console.log('create node: ' + key);
	    var node:yaml.YAMLNode=yaml.newMap();
	    return new ASTNode(node,null,null,null,null);
	}
	*/
	function createSeqNode(key) {
	    var node = yaml.newMapping(yaml.newScalar(key), yaml.newItems());
	    return new ASTNode(node, null, null, null, null);
	}
	exports.createSeqNode = createSeqNode;
	function createMapNode(key) {
	    var node = yaml.newMapping(yaml.newScalar(key), yaml.newMap());
	    return new ASTNode(node, null, null, null, null);
	}
	exports.createMapNode = createMapNode;
	function createMapping(key, v) {
	    //console.log('create mapping: ' + key);
	    var node = yaml.newMapping(yaml.newScalar(key), yaml.newScalar(v));
	    return new ASTNode(node, null, null, null, null);
	}
	exports.createMapping = createMapping;
	function toChildCachingNode(node) {
	    if (!(node instanceof ASTNode)) {
	        return null;
	    }
	    var astNode = node;
	    var result = new ASTNode(astNode.yamlNode(), astNode.unit(), null, null, null, true);
	    result._errors = astNode._errors;
	    return result;
	}
	exports.toChildCachingNode = toChildCachingNode;
	function toIncludingNode(node) {
	    if (!(node instanceof ASTNode)) {
	        return null;
	    }
	    var astNode = node;
	    var result = new ASTNode(astNode.yamlNode(), astNode.unit(), null, null, null, false);
	    result._errors = astNode._errors;
	    return result;
	}
	exports.toIncludingNode = toIncludingNode;
	function getDefinitionForLowLevelNode(node) {
	    var hl = node.highLevelNode();
	    if (hl) {
	        return hl.definition();
	    }
	    var parent = node.parent();
	    if (!parent) {
	        return null;
	    }
	    var key = node.key();
	    if (!key) {
	        return null;
	    }
	    var parentDef = parent.nodeDefinition();
	    if (!parentDef) {
	        return null;
	    }
	    if (!parentDef.property) {
	        return null;
	    }
	    var prop = parentDef.property(key);
	    if (!prop) {
	        return null;
	    }
	    return prop.range();
	}
	exports.getDefinitionForLowLevelNode = getDefinitionForLowLevelNode;
	function fetchMasterReference(unit, map, errors, lMap) {
	    if (!unit.isOverlayOrExtension())
	        return;
	    var masterReferenceNode = unit.getMasterReferenceNode();
	    if (!masterReferenceNode)
	        return;
	    var masterReferenceText = masterReferenceNode.value();
	    if (!masterReferenceText)
	        return;
	    var unitPath = path.dirname(unit.absolutePath());
	    var absIncludePath = lowlevel.toAbsolutePath(unitPath, masterReferenceText);
	    if (map[absIncludePath]) {
	        return;
	    }
	    if (errors[absIncludePath]) {
	        masterReferenceNode.errors().push(new Error(errors[masterReferenceText]));
	        return;
	    }
	    var arr = lMap[absIncludePath];
	    if (!arr) {
	        arr = [];
	        lMap[absIncludePath] = arr;
	    }
	    arr.push(masterReferenceNode);
	}
	function fetchIncludesAndMasterAsync(project, apiPath) {
	    var map = {};
	    var errors = {};
	    var nodes = [];
	    var units = [];
	    var processUnits = function (ind) {
	        var refs = [];
	        var lMap = {};
	        while (ind < units.length) {
	            var unit = units[ind];
	            var unitPath = unit.absolutePath();
	            fetchMasterReference(unit, map, errors, lMap);
	            var includeNodes = unit.getIncludeNodes();
	            includeNodes.forEach(function (x) {
	                var ip = x.includePath();
	                var includeReference = refResolvers.getIncludeReference(ip);
	                if (includeReference) {
	                    refs.push(project.resolveAsync(unit.absolutePath(), ip));
	                    return;
	                }
	                if (!ip)
	                    return;
	                var absIncludePath = lowlevel.buildPath(ip, unitPath, project.getRootPath());
	                if (map[absIncludePath]) {
	                    return;
	                }
	                if (errors[absIncludePath]) {
	                    if (x.errors) {
	                        x.errors().push(new Error(errors[ip]));
	                        return;
	                    }
	                }
	                var arr = lMap[absIncludePath];
	                if (!arr) {
	                    arr = [];
	                    lMap[absIncludePath] = arr;
	                }
	                arr.push(x);
	            });
	            ind++;
	        }
	        var unitPaths = Object.keys(lMap);
	        if (refs.length == 0 && unitPaths.length == 0) {
	            return Promise.resolve();
	        }
	        var promises = refs;
	        unitPaths.forEach(function (unitPath) {
	            promises.push(project.unitAsync(unitPath, true).then(function (x) {
	                if (!map[x.absolutePath()]) {
	                    map[x.absolutePath()] = true;
	                    units.push(x);
	                }
	            }, function (x) {
	                var innerError = project.pathToUnit[unitPath];
	                lMap[unitPath].forEach(function (node) {
	                    if (!innerError) {
	                        if (node.errors) {
	                            node.errors().push(new Error(x));
	                        }
	                    }
	                    else {
	                    }
	                });
	                errors[unitPath] = x;
	                project.failedUnits[unitPath] = x;
	                if (innerError) {
	                    x.inner = true;
	                }
	            }));
	        });
	        return Promise.all(promises).then(function (x) {
	            return processUnits(ind);
	        });
	    };
	    return project.unitAsync(apiPath).then(function (x) {
	        units.push(x);
	        map[x.absolutePath()] = true;
	        return processUnits(0);
	    }).then(function (x) {
	        return units.length > 0 ? units[0] : null;
	    });
	}
	exports.fetchIncludesAndMasterAsync = fetchIncludesAndMasterAsync;
	//# sourceMappingURL=jsyaml2lowLevel.js.map

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/main.d.ts" />
	"use strict";
	var HttpResponse = __webpack_require__(64);
	__webpack_require__(65);
	__webpack_require__(74);
	var lru = __webpack_require__(73);
	var globalCache = lru(50);
	function hasAsyncRequests() {
	    return Object.keys(notifies).length > 0;
	}
	exports.hasAsyncRequests = hasAsyncRequests;
	function addLoadCallback(listener) {
	    nlisteners.push(listener);
	}
	exports.addLoadCallback = addLoadCallback;
	var nlisteners = [];
	var notifies = {};
	function addNotify(url) {
	    notifies[url] = true;
	}
	exports.addNotify = addNotify;
	function removeNotity(url) {
	    delete notifies[url];
	    nlisteners.forEach(function (x) { return x(url); });
	}
	exports.removeNotity = removeNotity;
	function isWaitingFor(url) {
	    return notifies[url] ? true : false;
	}
	exports.isWaitingFor = isWaitingFor;
	function set(url, content) {
	    globalCache.set(url, content);
	}
	exports.set = set;
	function get(url) {
	    return globalCache.get(url);
	}
	exports.get = get;
	//# sourceMappingURL=resourceRegistry.js.map

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/main.d.ts" />
	"use strict";
	var _ = __webpack_require__(63);
	var DOMParser = __webpack_require__(75).DOMParser;
	var base64 = __webpack_require__(66);
	/**
	 * Gets pure include path portion from the complete include.
	 * Does not include the reference part.
	 * @param includeString
	 */
	function getIncludePath(includeString) {
	    if (!includeString) {
	        return includeString;
	    }
	    var index = includeString.indexOf("#");
	    if (index == -1)
	        return includeString;
	    return includeString.substring(0, index);
	}
	exports.getIncludePath = getIncludePath;
	/**
	 * Gets reference portion of the include string and returns it as
	 * an array of segments. Returns null of no reference is contained in the include.
	 * @param includeString
	 */
	function getIncludeReference(includeString) {
	    if (!includeString) {
	        return null;
	    }
	    if (typeof includeString != "string") {
	        includeString = "" + includeString;
	    }
	    var index = includeString.indexOf("#");
	    if (index == -1)
	        return null;
	    var referenceString = index == includeString.length - 1 ? "" : includeString.substring(index + 1, includeString.length);
	    var segments = referenceString.split("/");
	    if (segments.length == 0)
	        return null;
	    if (segments[0].trim() == "") {
	        segments.splice(0, 1);
	    }
	    return new IncludeReferenceImpl(referenceString, getIncludePath(includeString), segments);
	}
	exports.getIncludeReference = getIncludeReference;
	/**
	 * Factory method returning all include reference resolvers, registered in the system.
	 */
	function getIncludeReferenceResolvers() {
	    return [new JSONResolver(), new XMLResolver()];
	}
	exports.getIncludeReferenceResolvers = getIncludeReferenceResolvers;
	/**
	 * Checks all resolvers, finds the suitable one, resolves the reference and returns the result
	 * of resolving. Returns null if no suitable resolver is found or resolver itself fails to resolve.
	 * @param includeString - complete include string
	 * @param content - include contents
	 */
	function resolveContents(includeString, content) {
	    if (!includeString) {
	        return content;
	    }
	    var reference = getIncludeReference(includeString);
	    if (!reference) {
	        return content;
	    }
	    var includePath = getIncludePath(includeString);
	    return resolve(includePath, reference, content).content;
	}
	exports.resolveContents = resolveContents;
	/**
	 * Checks all resolvers, finds the suitable one, resolves the reference and returns the result
	 * of resolving. Returns null if no suitable resolver is found or resolver itself fails to resolve.
	 * @param includePath
	 * @param includeReference
	 * @param content
	 */
	function resolve(includePath, includeReference, content) {
	    var resolver = _.find(getIncludeReferenceResolvers(), function (currentResolver) { return currentResolver.isApplicable(includePath, content); });
	    if (!resolver)
	        return {
	            content: content,
	            validation: []
	        };
	    return resolver.resolveReference(content, includeReference);
	}
	exports.resolve = resolve;
	function completeReference(includePath, includeReference, content) {
	    if (!content) {
	        return [];
	    }
	    var resolver = _.find(getIncludeReferenceResolvers(), function (currentResolver) { return currentResolver.isApplicable(includePath, content); });
	    if (!resolver)
	        return [];
	    return resolver.completeReference(content, includeReference);
	}
	exports.completeReference = completeReference;
	var IncludeReferenceImpl = (function () {
	    function IncludeReferenceImpl(originalString, includePath, segments) {
	        this.includePath = includePath;
	        this.segments = segments;
	        this.originalString = originalString;
	    }
	    IncludeReferenceImpl.prototype.getIncludePath = function () {
	        return this.includePath;
	    };
	    IncludeReferenceImpl.prototype.getFragments = function () {
	        return this.segments;
	    };
	    IncludeReferenceImpl.prototype.asString = function () {
	        return this.originalString;
	    };
	    IncludeReferenceImpl.prototype.encodedName = function (withExtention) {
	        if (withExtention === void 0) { withExtention = true; }
	        return base64(this.includePath + '/' + this.asString()) + (withExtention ? this.includePath.substring(this.includePath.lastIndexOf('.')) : '');
	    };
	    return IncludeReferenceImpl;
	}());
	var JSONResolver = (function () {
	    function JSONResolver() {
	    }
	    JSONResolver.prototype.isApplicable = function (includePath, content) {
	        return includePath && (endsWith(includePath.trim(), '.js') || endsWith(includePath.trim(), '.json'));
	    };
	    JSONResolver.prototype.resolveReference = function (content, reference) {
	        try {
	            var resultJson = {};
	            resultJson['$ref'] = reference.getIncludePath() + '#' + reference.asString();
	            return {
	                content: JSON.stringify(resultJson, null, 2),
	                validation: []
	            };
	        }
	        catch (Error) {
	            console.log(Error);
	        }
	        return {
	            content: content,
	            validation: []
	        };
	    };
	    JSONResolver.prototype.completeReference = function (content, reference) {
	        try {
	            var jsonRoot = JSON.parse(content);
	            var fragments = reference.getFragments();
	            if (!fragments || fragments.length == 0) {
	                return this.getChildren(jsonRoot);
	            }
	            var currentJSON = jsonRoot;
	            var emptyPrefixCompletion = reference.asString().lastIndexOf("/") == reference.asString().length - 1;
	            var limit = emptyPrefixCompletion ? fragments.length : fragments.length - 1;
	            for (var i = 0; i < fragments.length - 1; i++) {
	                var fragment = fragments[i];
	                currentJSON = this.findChild(currentJSON, fragment);
	                if (!currentJSON) {
	                    return [];
	                }
	            }
	            if (emptyPrefixCompletion) {
	                return this.getChildren(currentJSON);
	            }
	            else {
	                var lastPrefix = fragments[fragments.length - 1];
	                var result = [];
	                this.getChildren(currentJSON).forEach(function (child) {
	                    if (child.indexOf(lastPrefix) == 0) {
	                        result.push(child);
	                    }
	                });
	                return result;
	            }
	        }
	        catch (Error) {
	            console.log(Error);
	        }
	        return [];
	    };
	    JSONResolver.prototype.findChild = function (jsonObject, fragment) {
	        var decoded = fragment.replace('~1', '/');
	        decoded = fragment.replace('~0', '~');
	        return jsonObject[decoded];
	    };
	    JSONResolver.prototype.getChildren = function (jsonObject) {
	        return Object.keys(jsonObject);
	    };
	    return JSONResolver;
	}());
	var XMLResolver = (function () {
	    function XMLResolver() {
	    }
	    XMLResolver.prototype.isApplicable = function (includePath, content) {
	        return includePath && (endsWith(includePath.trim(), '.xml') || endsWith(includePath.trim(), '.xsd'));
	    };
	    XMLResolver.prototype.resolveReference = function (content, reference) {
	        try {
	            var doc = new DOMParser().parseFromString(content);
	            var requestedName = reference.asString();
	            var uniqueName = reference.encodedName(false);
	            var schema = elementChildrenByName(doc, 'xs:schema')[0];
	            var elements = elementChildrenByName(schema, 'xs:element');
	            var types = elementChildrenByName(schema, 'xs:complexType');
	            var canBeElement = _.find(elements, function (element) { return element.getAttribute('name') === requestedName; });
	            var canBeType = canBeElement ? _.find(types, function (type) { return type.getAttribute('name') === canBeElement.getAttribute('type'); }) : _.find(types, function (type) { return type.getAttribute('name') === requestedName; });
	            var element = doc.createElement('xs:element');
	            element.setAttribute('name', uniqueName);
	            if (canBeType) {
	                element.setAttribute('type', canBeType.getAttribute('name'));
	            }
	            if (canBeElement) {
	                element.setAttribute('originalname', canBeElement.getAttribute('name'));
	            }
	            element.setAttribute('requestedname', requestedName);
	            element.setAttribute('extraelement', 'true');
	            schema.appendChild(element);
	            return {
	                content: doc.toString(),
	                validation: []
	            };
	        }
	        catch (throwable) {
	            console.log(throwable);
	        }
	        return {
	            content: content,
	            validation: []
	        };
	    };
	    XMLResolver.prototype.completeReference = function (content, reference) {
	        try {
	            var doc = new DOMParser().parseFromString(content);
	            var result = [];
	            var schema = elementChildrenByName(doc, 'xs:schema')[0];
	            var elements = elementChildrenByName(schema, 'xs:element');
	            var types = elementChildrenByName(schema, 'xs:complexType');
	            elements.forEach(function (element) { return result.push(element.getAttribute('name')); });
	            types.forEach(function (type) { return result.push(type.getAttribute('name')); });
	            var emptyPrefixCompletion = reference.asString().trim().length === 0;
	            if (emptyPrefixCompletion) {
	                return result;
	            }
	            else {
	                return result.filter(function (value) { return value.indexOf(reference.asString()) === 0; });
	            }
	        }
	        catch (exception) {
	            return [];
	        }
	    };
	    return XMLResolver;
	}());
	function endsWith(input, ends) {
	    if (!input) {
	        return false;
	    }
	    if (!ends) {
	        return false;
	    }
	    return input.lastIndexOf(ends) === (input.length - ends.length);
	}
	function elementChildrenByName(parent, tagName) {
	    var elements = parent.getElementsByTagName(tagName);
	    var result = [];
	    for (var i = 0; i < elements.length; i++) {
	        var child = elements[i];
	        if (child.parentNode === parent) {
	            result.push(child);
	        }
	    }
	    return result;
	}
	//# sourceMappingURL=includeRefResolvers.js.map

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	(function (root) {

	  // Store setTimeout reference so promise-polyfill will be unaffected by
	  // other code modifying setTimeout (like sinon.useFakeTimers())
	  var setTimeoutFunc = setTimeout;

	  function noop() {
	  }

	  // Use polyfill for setImmediate for performance gains
	  var asap = (typeof setImmediate === 'function' && setImmediate) ||
	    function (fn) {
	      setTimeoutFunc(fn, 1);
	    };

	  var onUnhandledRejection = function onUnhandledRejection(err) {
	    if (typeof console !== 'undefined' && console) {
	      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
	    }
	  };

	  // Polyfill for Function.prototype.bind
	  function bind(fn, thisArg) {
	    return function () {
	      fn.apply(thisArg, arguments);
	    };
	  }

	  function Promise(fn) {
	    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
	    if (typeof fn !== 'function') throw new TypeError('not a function');
	    this._state = 0;
	    this._handled = false;
	    this._value = undefined;
	    this._deferreds = [];

	    doResolve(fn, this);
	  }

	  function handle(self, deferred) {
	    while (self._state === 3) {
	      self = self._value;
	    }
	    if (self._state === 0) {
	      self._deferreds.push(deferred);
	      return;
	    }
	    self._handled = true;
	    asap(function () {
	      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
	      if (cb === null) {
	        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
	        return;
	      }
	      var ret;
	      try {
	        ret = cb(self._value);
	      } catch (e) {
	        reject(deferred.promise, e);
	        return;
	      }
	      resolve(deferred.promise, ret);
	    });
	  }

	  function resolve(self, newValue) {
	    try {
	      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
	      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
	        var then = newValue.then;
	        if (newValue instanceof Promise) {
	          self._state = 3;
	          self._value = newValue;
	          finale(self);
	          return;
	        } else if (typeof then === 'function') {
	          doResolve(bind(then, newValue), self);
	          return;
	        }
	      }
	      self._state = 1;
	      self._value = newValue;
	      finale(self);
	    } catch (e) {
	      reject(self, e);
	    }
	  }

	  function reject(self, newValue) {
	    self._state = 2;
	    self._value = newValue;
	    finale(self);
	  }

	  function finale(self) {
	    if (self._state === 2 && self._deferreds.length === 0) {
	      asap(function() {
	        if (!self._handled) {
	          onUnhandledRejection(self._value);
	        }
	      }, 1);
	    }
	    
	    for (var i = 0, len = self._deferreds.length; i < len; i++) {
	      handle(self, self._deferreds[i]);
	    }
	    self._deferreds = null;
	  }

	  function Handler(onFulfilled, onRejected, promise) {
	    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	    this.promise = promise;
	  }

	  /**
	   * Take a potentially misbehaving resolver function and make sure
	   * onFulfilled and onRejected are only called once.
	   *
	   * Makes no guarantees about asynchrony.
	   */
	  function doResolve(fn, self) {
	    var done = false;
	    try {
	      fn(function (value) {
	        if (done) return;
	        done = true;
	        resolve(self, value);
	      }, function (reason) {
	        if (done) return;
	        done = true;
	        reject(self, reason);
	      });
	    } catch (ex) {
	      if (done) return;
	      done = true;
	      reject(self, ex);
	    }
	  }

	  Promise.prototype['catch'] = function (onRejected) {
	    return this.then(null, onRejected);
	  };

	  Promise.prototype.then = function (onFulfilled, onRejected) {
	    var prom = new Promise(noop);
	    handle(this, new Handler(onFulfilled, onRejected, prom));
	    return prom;
	  };

	  Promise.all = function (arr) {
	    var args = Array.prototype.slice.call(arr);

	    return new Promise(function (resolve, reject) {
	      if (args.length === 0) return resolve([]);
	      var remaining = args.length;

	      function res(i, val) {
	        try {
	          if (val && (typeof val === 'object' || typeof val === 'function')) {
	            var then = val.then;
	            if (typeof then === 'function') {
	              then.call(val, function (val) {
	                res(i, val);
	              }, reject);
	              return;
	            }
	          }
	          args[i] = val;
	          if (--remaining === 0) {
	            resolve(args);
	          }
	        } catch (ex) {
	          reject(ex);
	        }
	      }

	      for (var i = 0; i < args.length; i++) {
	        res(i, args[i]);
	      }
	    });
	  };

	  Promise.resolve = function (value) {
	    if (value && typeof value === 'object' && value.constructor === Promise) {
	      return value;
	    }

	    return new Promise(function (resolve) {
	      resolve(value);
	    });
	  };

	  Promise.reject = function (value) {
	    return new Promise(function (resolve, reject) {
	      reject(value);
	    });
	  };

	  Promise.race = function (values) {
	    return new Promise(function (resolve, reject) {
	      for (var i = 0, len = values.length; i < len; i++) {
	        values[i].then(resolve, reject);
	      }
	    });
	  };

	  /**
	   * Set the immediate function to execute callbacks
	   * @param fn {function} Function to execute
	   * @private
	   */
	  Promise._setImmediateFn = function _setImmediateFn(fn) {
	    asap = fn;
	  };
	  
	  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
	    onUnhandledRejection = fn;
	  };

	  if (typeof module !== 'undefined' && module.exports) {
	    module.exports = Promise;
	  } else if (!root.Promise) {
	    root.Promise = Promise;
	  }

	})(this);


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var path = __webpack_require__(15);
	var ll = __webpack_require__(11);
	var resourceRegistry = __webpack_require__(28);
	var ContentProvider = (function () {
	    function ContentProvider(unit) {
	        this.unit = unit;
	    }
	    ContentProvider.prototype.contextPath = function () {
	        if (!this.unit) {
	            return "";
	        }
	        var rootPath = this.unit.absolutePath();
	        return rootPath || "";
	    };
	    ContentProvider.prototype.normalizePath = function (url) {
	        if (!url) {
	            return url;
	        }
	        var result;
	        if (!isWebPath(url)) {
	            result = path.normalize(url).replace(/\\/g, "/");
	        }
	        else {
	            var prefix = url.toLowerCase().indexOf('https') === 0 ? 'https://' : 'http://';
	            result = prefix + path.normalize(url.substring(prefix.length)).replace(/\\/g, "/");
	        }
	        return result;
	    };
	    ContentProvider.prototype.content = function (reference) {
	        var normalized = this.normalizePath(reference);
	        //Absolute local paths are understand as relative to rootRAML
	        //by 'unit.resolve()'. In order to make it understand the input properly,
	        //all absolute local paths must be switched to relative form
	        var unitPath = this.toRelativeIfNeeded(normalized);
	        var unit = this.unit.resolve(unitPath);
	        if (!unit) {
	            return "";
	        }
	        return unit.contents() || "";
	    };
	    ContentProvider.prototype.contentAsync = function (reference) {
	        var normaized = this.normalizePath(reference);
	        //Absolute local paths are understand as relative to rootRAML
	        //by 'unit.resolveAsync()'. In order to make it understand the input properly,
	        //all absolute local paths must be switched to relative form
	        var unitPath = this.toRelativeIfNeeded(normaized);
	        var unitPromise = this.unit.resolveAsync(unitPath);
	        if (!unitPromise) {
	            return Promise.resolve("");
	        }
	        var result = unitPromise.then(function (unit) {
	            return (unit && unit.contents()) || "";
	        });
	        return result;
	    };
	    ContentProvider.prototype.toRelativeIfNeeded = function (normaized) {
	        var unitPath = normaized;
	        if (path.isAbsolute(normaized) && !isWebPath(normaized)) {
	            unitPath = path.relative(path.dirname(this.unit.absolutePath()), normaized);
	        }
	        return unitPath;
	    };
	    ContentProvider.prototype.hasAsyncRequests = function () {
	        return resourceRegistry.hasAsyncRequests();
	    };
	    ContentProvider.prototype.resolvePath = function (context, relativePath) {
	        //Using standard way of resolving references occured in RAML specs
	        return ll.buildPath(relativePath, context, this.unit.project().getRootPath());
	    };
	    ContentProvider.prototype.isAbsolutePath = function (uri) {
	        if (!uri) {
	            return false;
	        }
	        if (isWebPath(uri)) {
	            return true;
	        }
	        return path.isAbsolute(uri);
	    };
	    ContentProvider.prototype.promiseResolve = function (arg) {
	        return Promise.resolve(arg);
	    };
	    return ContentProvider;
	}());
	exports.ContentProvider = ContentProvider;
	function isWebPath(str) {
	    return ll.isWebPath(str);
	}
	//# sourceMappingURL=contentprovider.js.map

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/main.d.ts" />
	"use strict";
	var _ = __webpack_require__(63);
	var Opt = __webpack_require__(21);
	exports.defined = function (x) { return (x !== null) && (x !== undefined); };
	/**
	 * Arrays of Objects are common in RAML08.
	 * @param x
	 * @returns {{}}
	 */
	function flattenArrayOfObjects(x) {
	    var res = {};
	    x.forEach(function (v) { return Object.keys(v).forEach(function (k) { return res[k] = v[k]; }); });
	    return res;
	}
	exports.flattenArrayOfObjects = flattenArrayOfObjects;
	function find(xs, f) {
	    return new Opt(_.find(xs || [], f));
	}
	exports.find = find;
	exports.isInstance = function (v, C) { return (v instanceof C) ? [v] : []; };
	exports.ifInstanceOf = function (v, C, f) { return (v instanceof C) ? f(v) : null; };
	function toTuples(map) {
	    return Object.keys(map).map(function (k) { return [k, map[k]]; });
	}
	exports.toTuples = toTuples;
	function fromTuples(tuples) {
	    var obj = {};
	    tuples.forEach(function (x) { return obj[x[0]] = x[1]; });
	    return obj;
	}
	exports.fromTuples = fromTuples;
	exports.collectInstancesOf = function (xs, C) { return tap([], function (res) { return xs.forEach(function (v) { return exports.ifInstanceOf(v, C, function (x) { return res.push(x); }); }); }); };
	exports.collectInstancesOfInMap = function (map, C) {
	    return Object.keys(map).map(function (k) { return [k, map[k]]; }).filter(function (x) { return x[1] instanceof C; }).map(function (x) { return x; });
	};
	exports.asArray = function (v) { return exports.defined(v) ? ((v instanceof Array) ? v : [v]) : []; };
	exports.shallowCopy = function (obj) { return tap({}, function (copy) { return Object.keys(obj).forEach(function (k) { return copy[k] = obj[k]; }); }); };
	exports.flatMap = function (xs, f) { return exports.flatten(xs.map(f)); };
	exports.flatten = function (xss) { return Array.prototype.concat.apply([], xss); };
	exports.takeWhile = function (xs, f) { return tap([], function (res) {
	    for (var i = 0; i < xs.length; i++) {
	        if (!f(xs[i]))
	            break;
	        res.push(xs[i]);
	    }
	}); };
	function tap(v, f) {
	    f(v);
	    return v;
	}
	exports.tap = tap;
	function kv(obj, iter) {
	    if (typeof obj === 'object')
	        Object.keys(obj).forEach(function (k) { return iter(k, obj[k]); });
	}
	exports.kv = kv;
	function indexed(objects, key, delKey) {
	    if (delKey === void 0) { delKey = false; }
	    var obj = {};
	    objects.forEach(function (original) {
	        var copy = exports.shallowCopy(original);
	        if (delKey)
	            delete copy[key];
	        obj[original[key]] = copy;
	    });
	    return obj;
	}
	exports.indexed = indexed;
	function stringEndsWith(str, search) {
	    var dif = str.length - search.length;
	    return dif >= 0 && str.lastIndexOf(search) === dif;
	}
	exports.stringEndsWith = stringEndsWith;
	function stringStartsWith(str, search, ind) {
	    if (ind === void 0) { ind = 0; }
	    return str.length - search.length >= ind && str.substring(ind, ind + search.length) === search;
	}
	exports.stringStartsWith = stringStartsWith;
	function lazypropkeyfilter(k) {
	    return k[k.length - 1] == "_"; // ends with underscore
	}
	exports.lazypropkeyfilter = lazypropkeyfilter;
	function lazyprop(obj, key, func) {
	    var result, ready = false;
	    obj[key] = function () {
	        if (!ready) {
	            ready = true;
	            result = func.apply(obj);
	        }
	        return result;
	    };
	}
	function lazyprops(obj, keyfilter) {
	    if (keyfilter === void 0) { keyfilter = lazypropkeyfilter; }
	    for (var k in obj) {
	        if (keyfilter(k)) {
	            exports.ifInstanceOf(obj[k], Function, function (vf) { return (vf.length === 0) ? lazyprop(obj, k, vf) : null; });
	        }
	    }
	}
	exports.lazyprops = lazyprops;
	function iff(v, f) {
	    if (v !== undefined)
	        f(v);
	}
	exports.iff = iff;
	function isRAMLUrl(str) {
	    if (typeof str !== 'string' || str == '')
	        return false;
	    return stringEndsWith(str, ".raml");
	}
	exports.isRAMLUrl = isRAMLUrl;
	function getAllRequiredExternalModulesFromCode(code) {
	    var match;
	    var mods = [];
	    // both quoting styles
	    var r1 = new RegExp("require\\('([^']+)'\\)", "gi");
	    while (match = r1.exec(code)) {
	        mods.push(match[1]);
	    }
	    var r2 = new RegExp('require\\("([^"]+)"\\)', "gi");
	    while (match = r2.exec(code)) {
	        mods.push(match[1]);
	    }
	    mods = _.unique(mods).filter(function (x) { return x != ""; });
	    mods.sort();
	    return mods;
	}
	exports.getAllRequiredExternalModulesFromCode = getAllRequiredExternalModulesFromCode;
	exports.serial = (function () { var i = 0; return function () { return i++; }; })();
	function isEssential(arg) {
	    return typeof arg !== 'undefined' && arg != null;
	}
	exports.isEssential = isEssential;
	function firstToUpper(q) {
	    if (q.length == 0) {
	        return q;
	    }
	    return q.charAt(0).toUpperCase() + q.substr(1);
	}
	exports.firstToUpper = firstToUpper;
	function updateObject(source, target, addNewFields) {
	    if (addNewFields === void 0) { addNewFields = false; }
	    var keySet = Object.keys(target);
	    if (addNewFields) {
	        var map = {};
	        keySet.forEach(function (x) { return map[x] = true; });
	        Object.keys(source).forEach(function (x) { return map[x] = true; });
	        keySet = Object.keys(map);
	    }
	    keySet.forEach(function (x) {
	        var value = source[x];
	        if (value instanceof Object) {
	            if (!target[x]) {
	                target[x] = {};
	            }
	            updateObject(value, target[x], true);
	        }
	        else if (value != undefined) {
	            target[x] = source[x];
	        }
	    });
	}
	exports.updateObject = updateObject;
	;
	/**
	 * In 'str' replace all occurences of 'map' keys to their values.
	 */
	function replaceMap(str, map) {
	    Object.keys(map).forEach(function (x) { return str = replace(str, x, map[x]); });
	    return str;
	}
	exports.replaceMap = replaceMap;
	/**
	 * Replace all occurences of 'x' in 'str' to 'r' without thinking if 'x' can be passed without
	 * escaping as argument to RegExp constructor
	 */
	function replace(str, x, r) {
	    var result = '';
	    var prev = 0;
	    for (var i = str.indexOf(x); i < str.length && i >= 0; i = str.indexOf(x, prev)) {
	        result += str.substring(prev, i);
	        result += r;
	        prev = i + x.length;
	    }
	    result += str.substring(prev, str.length);
	    return result;
	}
	exports.replace = replace;
	//# sourceMappingURL=index.js.map

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var RamlWrapper = __webpack_require__(12);
	var RamlWrapperImpl = __webpack_require__(20);
	var factory = __webpack_require__(43);
	var core = __webpack_require__(46);
	var ramlPathMatch = __webpack_require__(55);
	var hl = __webpack_require__(10);
	var hlimpl = __webpack_require__(16);
	var linter = __webpack_require__(25);
	var stubs = __webpack_require__(17);
	var defs = __webpack_require__(36);
	var universeDef = __webpack_require__(22);
	var universes = __webpack_require__(22);
	var Opt = __webpack_require__(21);
	var util = __webpack_require__(32);
	var expander = __webpack_require__(24);
	var proxy = __webpack_require__(39);
	var referencePatcher = __webpack_require__(49);
	var lowLevelProxy = __webpack_require__(39);
	var search = __webpack_require__(23);
	var ll = __webpack_require__(27);
	var json = __webpack_require__(50);
	var path = __webpack_require__(15);
	var universeHelpers = __webpack_require__(14);
	var sourceFinder = __webpack_require__(45);
	function resolveType(p) {
	    return p.highLevel().localType();
	}
	exports.resolveType = resolveType;
	//__$helperMethod__ Runtime representation of type represented by this AST node
	function runtimeType(p) {
	    return p.highLevel().localType();
	}
	exports.runtimeType = runtimeType;
	function load(pth) {
	    var m = new ll.Project(path.dirname(pth));
	    var unit = m.unit(path.basename(pth));
	    if (unit) {
	        if (unit.isRAMLUnit()) {
	            return hlimpl.fromUnit(unit).wrapperNode();
	        }
	    }
	    return null;
	}
	exports.load = load;
	//__$helperMethod__ Path relative to API root
	function completeRelativeUri(res) {
	    var uri = '';
	    var parent = res;
	    do {
	        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
	        uri = res.relativeUri().value() + uri;
	        parent = res.parent();
	    } while (parent.definition().key().name == universes.Universe10.Resource.name);
	    return uri;
	}
	exports.completeRelativeUri = completeRelativeUri;
	/**
	 * __$helperMethod__
	 * Equivalent API with traits and resource types expanded
	 * @expLib whether to apply library expansion or not
	 * __$meta__={"name":"expand"}
	 */
	function expandSpec(api, expLib) {
	    if (expLib === void 0) { expLib = false; }
	    if (expLib) {
	        return expandLibraries(api);
	    }
	    else {
	        return expandTraitsAndResourceTypes(api);
	    }
	}
	exports.expandSpec = expandSpec;
	/**
	 * Equivalent API with traits and resource types expanded
	 * __$meta__={"name":"expand"}
	 */
	function expandTraitsAndResourceTypes(api) {
	    var lowLevelNode = api.highLevel().lowLevel();
	    if (lowLevelNode instanceof lowLevelProxy.LowLevelProxyNode) {
	        return api;
	    }
	    return expander.expandTraitsAndResourceTypes(api);
	}
	exports.expandTraitsAndResourceTypes = expandTraitsAndResourceTypes;
	/**
	 * Expand traits, resource types and libraries for the API
	 * __$meta__={"name":"expandLibraries"}
	 */
	function expandLibraries(api) {
	    return expander.expandLibraries(api);
	}
	exports.expandLibraries = expandLibraries;
	//__$helperMethod__ baseUri of owning Api concatenated with completeRelativeUri
	function absoluteUri(res) {
	    var uri = '';
	    var parent = res;
	    do {
	        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
	        uri = res.relativeUri().value() + uri;
	        parent = res.parent();
	    } while (parent.definition().key().name == universes.Universe10.Resource.name);
	    uri = uri.replace(/\/\//g, '/');
	    var buri = parent.baseUri();
	    var base = buri ? buri.value() : "";
	    base = base ? base : '';
	    if (util.stringEndsWith(base, '/')) {
	        uri = uri.substring(1);
	    }
	    uri = base + uri;
	    return uri;
	}
	exports.absoluteUri = absoluteUri;
	//__$helperMethod__ validate an instance against type
	function validateInstance(res, value) {
	    return res.runtimeType().validate(value).map(function (x) { return x.getMessage(); });
	    //throw new Error("Fix me");
	}
	exports.validateInstance = validateInstance;
	//__$helperMethod__ validate an instance against type
	function validateInstanceWithDetailedStatuses(res, value) {
	    return res.runtimeType().validate(value);
	}
	exports.validateInstanceWithDetailedStatuses = validateInstanceWithDetailedStatuses;
	/**
	 * __$helperMethod__
	 * Retrieve all traits including those defined in libraries
	 * __$meta__{"name":"traits","override":true}
	 */
	function traitsPrimary(a) {
	    return allTraits(a);
	}
	exports.traitsPrimary = traitsPrimary;
	/**
	 * __$helperMethod__ Retrieve all traits including those defined in libraries
	 * __$meta__{"deprecated":true}
	 */
	function allTraits(a) {
	    if (a.highLevel().lowLevel().actual().libExpanded) {
	        return a.traits_original();
	    }
	    return findTemplates(a, function (d) { return universeHelpers.isTraitType(d); });
	}
	exports.allTraits = allTraits;
	/**
	 * __$helperMethod__
	 * Retrieve all resource types including those defined in libraries
	 * __$meta__{"name":"resourceTypes","override":true}
	 */
	function resourceTypesPrimary(a) {
	    return allResourceTypes(a);
	}
	exports.resourceTypesPrimary = resourceTypesPrimary;
	/**
	 * __$helperMethod__ Retrieve all resource types including those defined in libraries
	 * __$meta__{"deprecated":true}
	 */
	function allResourceTypes(a) {
	    if (a.highLevel().lowLevel().actual().libExpanded) {
	        return a.resourceTypes_original();
	    }
	    return findTemplates(a, function (d) { return universeHelpers.isResourceTypeType(d); });
	}
	exports.allResourceTypes = allResourceTypes;
	function findTemplates(a, filter) {
	    var arr = search.globalDeclarations(a.highLevel()).filter(function (x) { return filter(x.definition()); });
	    var ll = a.highLevel().lowLevel();
	    var nodePath = ll.includePath();
	    if (!nodePath) {
	        nodePath = ll.unit().path();
	    }
	    var isProxy = a.highLevel().lowLevel() instanceof proxy.LowLevelProxyNode;
	    var exp = isProxy ? new expander.TraitsAndResourceTypesExpander() : null;
	    var topLevelArr = arr.map(function (x) {
	        var topLevelNode;
	        var p = x.lowLevel().unit().path();
	        if (isProxy) {
	            if (!(x.lowLevel() instanceof proxy.LowLevelProxyNode)) {
	                x = exp.createHighLevelNode(x, false);
	            }
	            new referencePatcher.ReferencePatcher().process(x, a.highLevel(), true, true);
	        }
	        if (p != nodePath) {
	            topLevelNode = factory.buildWrapperNode(x, false);
	            topLevelNode.meta().setCalculated();
	        }
	        else {
	            topLevelNode = x.wrapperNode();
	        }
	        return topLevelNode;
	    });
	    return topLevelArr;
	}
	;
	function relativeUriSegments(res) {
	    var result = [];
	    var parent = res;
	    do {
	        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
	        result.push(res.relativeUri().value());
	        parent = res.parent();
	    } while (parent.definition().key().name == universes.Universe10.Resource.name);
	    return result.reverse();
	}
	exports.relativeUriSegments = relativeUriSegments;
	//__$helperMethod__ For methods of Resources returns parent resource. For methods of ResourceTypes returns null.
	function parentResource(method) {
	    if (method.parent() instanceof RamlWrapperImpl.ResourceImpl) {
	        return method.parent();
	    }
	    return null;
	}
	exports.parentResource = parentResource;
	/**
	 * __$helperMethod__
	 * Parent resource for non top level resources
	 * __$meta__={"name":"parentResource"}
	 */
	function parent(resource) {
	    var parent = resource.parent();
	    if (parent.definition().key().name == universes.Universe10.Resource.name) {
	        return parent;
	    }
	    return null;
	}
	exports.parent = parent;
	//__$helperMethod__ Get child resource by its relative path
	function childResource(container, relPath) {
	    if (container == null) {
	        return null;
	    }
	    var resources = container.resources();
	    if (!resources) {
	        return null;
	    }
	    resources = resources.filter(function (x) { return x.relativeUri().value() == relPath; });
	    if (resources.length == 0) {
	        return null;
	    }
	    return resources[0];
	}
	exports.childResource = childResource;
	function getResource(container, path) {
	    if (!container) {
	        return null;
	    }
	    var res = null;
	    for (var i = 0; i < path.length; i++) {
	        res = childResource(container, path[i]);
	        if (!res) {
	            return null;
	        }
	        container = res;
	    }
	    return res;
	}
	exports.getResource = getResource;
	//__$helperMethod__ Get child method by its name
	function childMethod(resource, method) {
	    if (!resource) {
	        return null;
	    }
	    return resource.methods().filter(function (x) { return x.method() == method; });
	}
	exports.childMethod = childMethod;
	function getMethod(container, path, method) {
	    var resource = getResource(container, path);
	    if (!resource) {
	        return null;
	    }
	    return childMethod(resource, method);
	}
	exports.getMethod = getMethod;
	function isApi(obj) {
	    return universeHelpers.isApiSibling(obj.definition());
	}
	;
	//__$helperMethod__ Api owning the resource as a sibling
	function ownerApi(method) {
	    var obj = method;
	    while (!isApi(obj)) {
	        obj = obj.parent();
	    }
	    return obj;
	}
	exports.ownerApi = ownerApi;
	/**
	 * __$helperMethod__
	 * For methods of Resources: `{parent Resource relative path} {methodName}`.
	 * For methods of ResourceTypes: `{parent ResourceType name} {methodName}`.
	 * For other methods throws Exception.
	 */
	function methodId(method) {
	    var parent = method.parent();
	    if (parent instanceof RamlWrapperImpl.ResourceImpl) {
	        return completeRelativeUri(parent) + ' ' + method.method().toLowerCase();
	    }
	    else if (parent instanceof RamlWrapperImpl.ResourceTypeImpl) {
	        return parent.name() + ' ' + method.method().toLowerCase();
	    }
	    throw new Error("Method is supposed to be owned by Resource or ResourceType.\nHere the method is owned by " + method.definition().key().name);
	}
	exports.methodId = methodId;
	//__$helperMethod__ true for codes < 400 and false otherwise
	function isOkRange(response) {
	    var str = response.code().value();
	    var err = linter.validateResponseString(str);
	    if (err != null) {
	        return false;
	    }
	    try {
	        if (parseInt(str.charAt(0)) < 4) {
	            return true;
	        }
	    }
	    catch (e) { }
	    return false;
	}
	exports.isOkRange = isOkRange;
	//__$helperMethod__  Retrieve all resources of the Api
	function allResources(api) {
	    var resources = [];
	    var visitor = function (res) {
	        resources.push(res);
	        res.resources().forEach(function (x) { return visitor(x); });
	    };
	    api.resources().forEach(function (x) { return visitor(x); });
	    return resources;
	}
	exports.allResources = allResources;
	function matchUri(apiRootRelativeUri, resource) {
	    var allParameters = {};
	    while (resource != null) {
	        uriParameters(resource).forEach(function (x) { return allParameters[x.name()] = new ParamWrapper(x); });
	        resource = parent(resource);
	    }
	    var result = ramlPathMatch.ramlPathMatch(completeRelativeUri(resource), allParameters, {})(apiRootRelativeUri);
	    if (result) {
	        return new Opt(Object.keys(result.params)
	            .map(function (x) { return new ParamValue(x, result['params'][x]); }));
	    }
	    return Opt.empty();
	}
	exports.matchUri = matchUri;
	var schemaContentChars = ['{', '<'];
	// export function schema(body:RamlWrapper.TypeDeclaration, api:RamlWrapper.Api):Opt<SchemaDef>{
	//
	//     var schemaNode = body.schema();
	//     if(!schemaNode){
	//         return Opt.empty<SchemaDef>();
	//     }
	//     var schemaString = schemaNode;
	//     var isContent:boolean = false;
	//     schemaContentChars.forEach(x=>{try{ isContent = isContent||schemaString.indexOf(x)>=0}catch(e){}});
	//     var schDef:SchemaDef;
	//     if(isContent) {
	//         schDef = new SchemaDef(schemaString);
	//     }
	//     else{
	//         var globalSchemes = api.schemas().filter(x=>x.name()==schemaString);
	//         if(globalSchemes.length>0){
	//             schDef = new SchemaDef(globalSchemes[0].type(),globalSchemes[0].name());
	//         }
	//         else{
	//             return Opt.empty<SchemaDef>();
	//         }
	//     }
	//     return new Opt<SchemaDef>(schDef);
	// }
	/**
	 * __$helperMethod__
	 * Retrieve an ordered list of all uri parameters including those which are not described in the `uriParameters` node.
	 * Consider a fragment of RAML specification:
	 * ```yaml
	 * /resource/{objectId}/{propertyId}:
	 *   uriParameters:
	 *     objectId:
	 * ```
	 * Here `propertyId` uri parameter is not described in the `uriParameters` node,
	 * but it is among Resource.uriParameters().
	 * __$meta__={"name":"uriParameters","override": true}
	 */
	function uriParametersPrimary(resource) {
	    return uriParameters(resource);
	}
	exports.uriParametersPrimary = uriParametersPrimary;
	/**
	 * __$helperMethod__
	 * Retrieve an ordered list of all uri parameters including those which are not described in the `uriParameters` node.
	 * Consider a fragment of RAML specification:
	 * ```yaml
	 * /resource/{objectId}/{propertyId}:
	 *   uriParameters:
	 *     objectId:
	 * ```
	 * Here `propertyId` uri parameter is not described in the `uriParameters` node,
	 * but it is among Resource.allUriParameters().
	 * __$meta__={"name":"allUriParameters","deprecated":true}
	 */
	function uriParameters(resource) {
	    var params = resource.uriParameters_original();
	    if (!(resource instanceof RamlWrapperImpl.ResourceImpl)) {
	        return params;
	    }
	    var uri = resource.relativeUri().value();
	    var propName = universes.Universe10.ResourceBase.properties.uriParameters.name;
	    return extractParams(params, uri, resource, propName);
	}
	exports.uriParameters = uriParameters;
	/**
	 * __$helperMethod__
	 * Retrieve an ordered list of all base uri parameters regardless of whether they are described in `baseUriParameters` or not
	 * Consider a fragment of RAML specification:
	 * ```yaml
	 * version: v1
	 * baseUri: https://{organization}.example.com/{version}/{service}
	 * baseUriParameters:
	 *   service:
	 * ```
	 * Here `version` and `organization` are base uri parameters which are not described in the `baseUriParameters` node,
	 * but they are among `Api.baseUriParameters()`.
	 * __$meta__={"name":"baseUriParameters","override":true}
	 */
	function baseUriParametersPrimary(api) {
	    return baseUriParameters(api);
	}
	exports.baseUriParametersPrimary = baseUriParametersPrimary;
	/**
	 * __$helperMethod__
	 * Retrieve an ordered list of all base uri parameters regardless of whether they are described in `baseUriParameters` or not
	 * Consider a fragment of RAML specification:
	 * ```yaml
	 * version: v1
	 * baseUri: https://{organization}.example.com/{version}/{service}
	 * baseUriParameters:
	 *   service:
	 * ```
	 * Here `version` and `organization` are base uri parameters which are not described in the `baseUriParameters` node,
	 * but they are among `Api.allBaseUriParameters()`.
	 * __$meta__={"name":"allBaseUriParameters","deprecated":true}
	 */
	function baseUriParameters(api) {
	    var uri = api.baseUri() ? api.baseUri().value() : '';
	    var params = api.baseUriParameters_original();
	    var propName = universes.Universe10.Api.properties.baseUriParameters.name;
	    return extractParams(params, uri, api, propName);
	}
	exports.baseUriParameters = baseUriParameters;
	/**
	 * __$helperMethod__
	 * Retrieve an ordered list of all absolute uri parameters. Returns a union of `Api.baseUriParameters()`
	 * for `Api` owning the `Resource` and `Resource.uriParameters()`.
	 */
	function absoluteUriParameters(res) {
	    var params = [];
	    var parent = res;
	    do {
	        res = parent;
	        params = uriParameters(res).concat(params);
	        parent = res.parent();
	    } while (parent.definition().key().name == universes.Universe10.Resource.name);
	    var api = parent;
	    var baseUriParams = api.baseUriParameters();
	    params = baseUriParameters(api).concat(params);
	    return params;
	}
	exports.absoluteUriParameters = absoluteUriParameters;
	/**
	 * _//_$helperMethod__
	 * Protocols used by the API. Returns the `protocols` property value if it is specified.
	 * Otherwise, returns protocol, specified in the base URI.
	 * __$meta__={"name":"protocols","override":true}
	 */
	function protocolsPrimary(api) {
	    return allProtocols(api);
	}
	exports.protocolsPrimary = protocolsPrimary;
	/**
	 * __$helperMethod__
	 * Protocols used by the API. Returns the `protocols` property value if it is specified.
	 * Otherwise, returns protocol, specified in the base URI.
	 * __$meta__{"deprecated":true}
	 */
	function allProtocols(api) {
	    return api.protocols().map(function (x) { return x.toUpperCase(); });
	    //var attributeDefaults = (<RamlWrapper.ApiImpl>api).attributeDefaults();
	    //var result = (<RamlWrapper.ApiImpl>api).protocols_original();
	    //if(result.length!=0||!attributeDefaults){
	    //    return result;
	    //}
	    //var baseUriAttr = api.baseUri();
	    //if(baseUriAttr) {
	    //    var baseUri = baseUriAttr.value();
	    //    if (baseUri) {
	    //        var ind = baseUri.indexOf('://');
	    //        if (ind >= 0) {
	    //            result = [baseUri.substring(0, ind)];
	    //        }
	    //        if(result.length==0){
	    //            result = [ 'HTTP' ];
	    //        }
	    //    }
	    //}
	    //return result;
	}
	exports.allProtocols = allProtocols;
	/**
	 * _//_$helperMethod__
	 * Returns security schemes, resource or method is secured with. If no security schemes are set at resource or method level,
	 * returns schemes defined with `securedBy` at API level.
	 * __$meta__={"name":"securedBy","override":true}
	 */
	function securedByPrimary(resourceOrMethod) {
	    return allSecuredBy(resourceOrMethod);
	}
	exports.securedByPrimary = securedByPrimary;
	/**
	 * __$helperMethod__
	 * Returns security schemes, resource or method is secured with. If no security schemes are set at resource or method level,
	 * returns schemes defined with `securedBy` at API level.
	 * __$meta__{"deprecated":true}
	 */
	function allSecuredBy(resourceOrMethod) {
	    //var currentSecuredBy = (<RamlWrapper.ResourceBaseImpl|RamlWrapper.MethodImpl>resourceOrMethod).securedBy_original();
	    //if (currentSecuredBy && currentSecuredBy.length > 0) {
	    //    return currentSecuredBy;
	    //}
	    //
	    ////instanceof, but have to avoid direct usage of instanceof in JS.
	    //var key = resourceOrMethod.highLevel().definition().key();
	    //if (key == universes.Universe10.Method) {
	    //    var method = (<RamlWrapper.Method>resourceOrMethod);
	    //    var resource = <RamlWrapper.ResourceImpl>method.parentResource();
	    //    if (resource && resource.securedBy_original() && resource.securedBy_original().length > 0) {
	    //        return resource.securedBy_original();
	    //    }
	    //    return method.ownerApi().securedBy();
	    //}
	    //if (key == universes.Universe10.Resource) {
	    //    return (<RamlWrapper.Resource>resourceOrMethod).ownerApi().securedBy();
	    //}
	    return resourceOrMethod.securedBy(); //return currentSecuredBy;
	}
	exports.allSecuredBy = allSecuredBy;
	/**
	 * __$helperMethod__
	 * __$meta__={"primary":true}
	 */
	function securitySchemeName(schemeReference) {
	    var highLevel = schemeReference.highLevel();
	    if (!highLevel)
	        return "";
	    var attributeValue = highLevel.value();
	    if (!attributeValue)
	        return "";
	    return attributeValue.toString();
	}
	exports.securitySchemeName = securitySchemeName;
	/**
	 * __$helperMethod__
	 * __$meta__={"primary":true}
	 */
	function securityScheme(schemeReference) {
	    var highLevel = schemeReference.highLevel();
	    if (!highLevel)
	        return null;
	    var declaration = search.findDeclarationByNode(highLevel, search.LocationKind.VALUE_COMPLETION);
	    if (!declaration)
	        return null;
	    if (!declaration.getKind || declaration.getKind() != hl.NodeKind.NODE) {
	        return null;
	    }
	    var result = declaration.wrapperNode();
	    if (!(result instanceof RamlWrapperImpl.AbstractSecuritySchemeImpl)) {
	        //I do not see how to avoid instanceof here
	        return null;
	    }
	    return result;
	}
	exports.securityScheme = securityScheme;
	/**
	 * __$helperMethod__
	 * __$meta__={"primary":true}
	 */
	function RAMLVersion(api) {
	    return api.highLevel().definition().universe().version();
	}
	exports.RAMLVersion = RAMLVersion;
	/**
	 * __$helperMethod__
	 * __$meta__={"primary":true}
	 */
	function structuredValue(reference) {
	    var llNode = reference.value().lowLevel();
	    var type = null;
	    var hlNode = llNode.highLevelParseResult();
	    if (hlNode) {
	        var types = null;
	        var isAnnotations = false;
	        if (hlNode.isAttr()) {
	            isAnnotations = universeHelpers.isAnnotationsProperty(hlNode.property());
	            types = hlNode.parent().types();
	        }
	        else if (hlNode.isElement()) {
	            types = hlNode.asElement().types();
	        }
	        if (types) {
	            var refName = reference.name();
	            var fromLib = refName.indexOf(".") >= 0;
	            if (fromLib) {
	                var reg = isAnnotations ? types.getAnnotationTypeRegistry() : types.getTypeRegistry();
	                type = reg.get(refName);
	            }
	            else {
	                type = isAnnotations ? types.getAnnotationType(refName) : types.getType(refName);
	            }
	        }
	    }
	    return new core.TypeInstanceImpl(llNode, type);
	}
	exports.structuredValue = structuredValue;
	/**
	 * __$helperMethod__
	 * __$meta__={"name":"name","primary":true}
	 */
	function referenceName(reference) {
	    var val = reference.highLevel().value();
	    return (typeof val == 'string') || val == null ? val : val.valueName();
	}
	exports.referenceName = referenceName;
	/**
	 * __$helperMethod__
	 * __$meta__={"name":"trait","primary":true}
	 */
	function referencedTrait(ref) {
	    return referencedObject(ref);
	}
	exports.referencedTrait = referencedTrait;
	/**
	 * __$helperMethod__
	 * __$meta__={"name":"annotation","primary":true}
	 */
	function referencedAnnotation(ref) {
	    return referencedObject(ref);
	}
	exports.referencedAnnotation = referencedAnnotation;
	/**
	 * __$helperMethod__
	 * __$meta__={"name":"resourceType","primary":true}
	 */
	function referencedResourceType(ref) {
	    return referencedObject(ref);
	}
	exports.referencedResourceType = referencedResourceType;
	function referencedObject(ref) {
	    var attr = ref.highLevel();
	    var parent = attr.parent();
	    var vn = ref.name();
	    var cands = search.referenceTargets(attr.property(), parent).filter(function (x) { return hlimpl.qName(x, parent) == vn; });
	    if (cands.length == 0) {
	        return null;
	    }
	    return cands[0].wrapperNode();
	}
	function examplesFromNominal(runtimeDefinition, hlParent, isSingle, patchHL) {
	    if (patchHL === void 0) { patchHL = true; }
	    var llParent = hlParent.lowLevel();
	    var property = hlParent.definition().property(isSingle ? "example" : "examples");
	    var universe = defs.getUniverse("RAML10");
	    var definition = universe.type(universeDef.Universe10.ExampleSpec.name);
	    var expandables = runtimeDefinition.examples().filter(function (x) { return !x.isEmpty() && x.isSingle() == isSingle; });
	    return expandables.map(function (x) {
	        var obj = x.asJSON();
	        var key = x.isSingle() ? "example" : null;
	        var jsonNode = new json.AstNode(llParent.unit(), obj, llParent, null, key);
	        var hlNode = patchHL ? new hlimpl.ASTNodeImpl(jsonNode, hlParent, definition, property) : hlParent;
	        var wrapperAnnotations = [];
	        var annotations = x.annotations();
	        if (annotations) {
	            var aProp = universe.type("Annotable").property("annotations");
	            for (var _i = 0, _a = Object.keys(annotations); _i < _a.length; _i++) {
	                var aName = _a[_i];
	                var aObj = annotations[aName];
	                var aJson = new json.AstNode(llParent.unit(), aObj, jsonNode, null, "(" + aName + ")");
	                var aHlNode = new hlimpl.ASTPropImpl(aJson, hlNode, aProp.range(), aProp);
	                var wAnnotation = new RamlWrapperImpl.AnnotationRefImpl(aHlNode);
	                wrapperAnnotations.push(wAnnotation);
	            }
	        }
	        return new ExampleSpecImpl(hlNode, x, wrapperAnnotations);
	    });
	}
	exports.examplesFromNominal = examplesFromNominal;
	;
	function getExpandableExamples(node, isSingle) {
	    if (isSingle === void 0) { isSingle = false; }
	    var runtimeDefinition = node.runtimeDefinition();
	    if (!runtimeDefinition) {
	        return [];
	    }
	    var hlParent = node.highLevel();
	    return examplesFromNominal(runtimeDefinition, hlParent, isSingle);
	}
	;
	/**
	 * __$helperMethod__
	 * __$meta__={"name":"example","primary":true}
	 */
	function getTypeExample(td) {
	    var examples = getExpandableExamples(td, true);
	    if (examples.length > 0) {
	        return examples[0];
	    }
	    return null;
	}
	exports.getTypeExample = getTypeExample;
	/**
	 * __$helperMethod__
	 * __$meta__={"name":"examples","primary":true}
	 */
	function getTypeExamples(td) {
	    return getExpandableExamples(td);
	}
	exports.getTypeExamples = getTypeExamples;
	/**
	 * __$helperMethod__
	 * __$meta__={"name":"fixedFacets","primary":true}
	 */
	function typeFixedFacets(td) {
	    var rDef = td.runtimeDefinition();
	    var obj = rDef.getFixedFacets();
	    var keys = Object.keys(obj);
	    if (td.kind() != universeDef.Universe10.UnionTypeDeclaration.name) {
	        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
	            var key = keys_1[_i];
	            if (rDef.facet(key) == null) {
	                delete obj[key];
	            }
	        }
	    }
	    if (Object.keys(obj).length == 0) {
	        return null;
	    }
	    var node = new json.AstNode(null, obj);
	    return new core.TypeInstanceImpl(node);
	}
	exports.typeFixedFacets = typeFixedFacets;
	/**
	 * __$helperMethod__ A base type which the current type extends, or more generally a type expression.
	 * __$meta__={"name":"type","override":true}
	 */
	function typeValue(typeDeclaration) {
	    var attrs = typeDeclaration.highLevel().attributes(defs.universesInfo.Universe10.TypeDeclaration.properties.type.name);
	    var structuredAttrs = attrs.filter(function (x) { return x.value() instanceof hlimpl.StructuredValue; });
	    if (structuredAttrs.length == 0) {
	        return typeDeclaration.type_original().map(function (x) {
	            if (x === null || x === "NULL" || x === "Null") {
	                return "string";
	            }
	            return x;
	        });
	    }
	    var nullify = false;
	    var values = attrs.map(function (x) {
	        var val = x.value();
	        if (val == null) {
	            return null;
	        }
	        if (typeof (val) == "string") {
	            return val;
	        }
	        else if (val instanceof hlimpl.StructuredValue) {
	            nullify = true;
	        }
	        return val.toString();
	    });
	    if (nullify) {
	        return null;
	    }
	    return values;
	}
	exports.typeValue = typeValue;
	/**
	 * __$helperMethod__ A base type which the current type extends, or more generally a type expression.
	 * __$meta__={"name":"schema","override":true}
	 */
	function schemaValue(typeDeclaration) {
	    var nullify = false;
	    var attrs = typeDeclaration.highLevel().attributes(defs.universesInfo.Universe10.TypeDeclaration.properties.schema.name);
	    if (nullify) {
	        return null;
	    }
	    var structuredAttrs = attrs.filter(function (x) { return x.value() instanceof hlimpl.StructuredValue; });
	    if (structuredAttrs.length == 0) {
	        return typeDeclaration.schema_original();
	    }
	    var values = attrs.map(function (x) {
	        var val = x.value();
	        if (typeof (val) == "string") {
	            return val;
	        }
	        else if (val instanceof hlimpl.StructuredValue) {
	            nullify = true;
	        }
	        return val.toString();
	    });
	    if (nullify) {
	        return null;
	    }
	    return values;
	}
	exports.schemaValue = schemaValue;
	/**
	 * __$helperMethod__ Inlined supertype definition.
	 * __$meta__={"name":"structuredType","primary":true}
	 */
	function typeStructuredValue(typeDeclaration) {
	    var attrs = typeDeclaration.highLevel().attributes(defs.universesInfo.Universe10.TypeDeclaration.properties.type.name);
	    attrs = attrs.concat(typeDeclaration.highLevel().attributes(defs.universesInfo.Universe10.TypeDeclaration.properties.schema.name));
	    var values = attrs.map(function (x) { return x.value(); });
	    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
	        var val = values_1[_i];
	        if (val instanceof hlimpl.StructuredValue) {
	            var typeInstance = new core.TypeInstanceImpl(val.lowLevel());
	            return typeInstance;
	        }
	    }
	    return null;
	}
	exports.typeStructuredValue = typeStructuredValue;
	/**
	 * __$helperMethod__
	 * Returns the root node of the AST, uses statement refers.
	 * __$meta__={"name":"ast"}
	 */
	function referencedNode(usesDecl) {
	    var ref = usesDecl.value();
	    var unit = usesDecl.highLevel().lowLevel().unit().resolve(ref);
	    var hlNode = unit.highLevel();
	    var hlElement = hlNode.asElement();
	    if (hlElement) {
	        //we know, only libraries can be referenced from uses
	        var wrapperNode = hlElement.wrapperNode();
	        if (RamlWrapper.isLibrary(wrapperNode)) {
	            wrapperNode.setAttributeDefaults(usesDecl.attributeDefaults());
	            return wrapperNode;
	        }
	        else {
	            return null;
	        }
	    }
	    return null;
	}
	exports.referencedNode = referencedNode;
	/**
	 * __$helperMethod__
	 * Anonymous type declaration defined by "items" keyword.
	 * If no "items" is defined explicitly, this one is null.
	 * __$meta__={"name":"items"}
	 */
	function getItems(arrayTypeDecl) {
	    return arrayTypeDecl.items_original();
	}
	exports.getItems = getItems;
	function findComponentTypeDeclBySearch(arrayTypeDecl) {
	    var typeHighLevel = arrayTypeDecl.highLevel();
	    if (!typeHighLevel)
	        return null;
	    var attrType = typeHighLevel.attr(universes.Universe10.TypeDeclaration.properties.type.name);
	    if (attrType == null)
	        return null;
	    var attrTypeLowLevel = attrType.lowLevel();
	    if (attrTypeLowLevel == null)
	        return null;
	    var attrTypeValue = attrType.value();
	    if (!attrTypeValue || typeof (attrTypeValue) != "string")
	        return null;
	    var offset = attrTypeLowLevel.end() - attrTypeValue.length + 1;
	    var unit = attrType.lowLevel().unit();
	    if (!unit)
	        return null;
	    var declaration = search.findDeclaration(unit, offset);
	    if (!declaration)
	        return null;
	    if (!declaration.getKind || declaration.getKind() != hl.NodeKind.NODE) {
	        return null;
	    }
	    if (!universeHelpers.isTypeDeclarationSibling(declaration.definition()))
	        return null;
	    return declaration.wrapperNode();
	}
	function findComponentTypeDeclByRuntimeType(arrayTypeDecl) {
	    var runtimeType = arrayTypeDecl.runtimeType();
	    if (!runtimeType)
	        return null;
	    if (!runtimeType.isArray() || !runtimeType.componentType)
	        return null;
	    var runtimeArrayType = runtimeType;
	    var componentType = runtimeArrayType.componentType();
	    if (!componentType)
	        return null;
	    var componentTypeHLSourceProvider = sourceFinder.getNominalTypeSource(componentType);
	    if (!componentTypeHLSourceProvider)
	        return null;
	    var componentTypeSource = componentTypeHLSourceProvider.getSource();
	    if (!componentTypeSource)
	        return null;
	    if (!componentTypeSource.isElement())
	        return null;
	    if (!universeHelpers.isTypeDeclarationSibling(componentTypeSource.definition()))
	        return null;
	    var basicNodeSource = componentTypeSource.wrapperNode();
	    return basicNodeSource;
	}
	/**
	 * __$helperMethod__
	 * Returns anonymous type defined by "items" keyword, or a component type if declaration can be found.
	 * Does not resolve type expressions. Only returns component type declaration if it is actually defined
	 * somewhere in AST.
	 */
	function findComponentTypeDeclaration(arrayTypeDecl) {
	    var original = arrayTypeDecl.items_original();
	    if (original) {
	        return original;
	    }
	    var foundByRuntimeType = findComponentTypeDeclByRuntimeType(arrayTypeDecl);
	    if (foundByRuntimeType)
	        return foundByRuntimeType;
	    return findComponentTypeDeclBySearch(arrayTypeDecl);
	}
	exports.findComponentTypeDeclaration = findComponentTypeDeclaration;
	function extractParams(params, uri, owner, propName) {
	    if (typeof (uri) != 'string') {
	        return [];
	    }
	    var ownerHl = owner.highLevel();
	    var definition = ownerHl.definition();
	    var prop = definition.property(propName);
	    if (!uri) {
	        return [];
	    }
	    var describedParams = {};
	    params.forEach(function (x) {
	        var arr = describedParams[x.name()];
	        if (!arr) {
	            arr = [];
	            describedParams[x.name()] = arr;
	        }
	        arr.push(x);
	    });
	    var allParams = [];
	    var prev = 0;
	    var mentionedParams = {};
	    for (var i = uri.indexOf('{'); i >= 0; i = uri.indexOf('{', prev)) {
	        prev = uri.indexOf('}', ++i);
	        if (prev < 0) {
	            break;
	        }
	        var paramName = uri.substring(i, prev);
	        mentionedParams[paramName] = true;
	        if (describedParams[paramName]) {
	            describedParams[paramName].forEach(function (x) { return allParams.push(x); });
	        }
	        else {
	            var universe = definition.universe();
	            var nc = universe.type(universeDef.Universe10.StringTypeDeclaration.name);
	            var node = stubs.createStubNode(nc, null, paramName, ownerHl.lowLevel().unit());
	            var uriParameter = factory.buildWrapperNode(node);
	            var hlNode = uriParameter.highLevel();
	            hlNode.setParent(ownerHl);
	            uriParameter.meta().setCalculated();
	            uriParameter.setName(paramName);
	            hlNode.patchProp(prop);
	            allParams.push(uriParameter);
	        }
	    }
	    Object.keys(describedParams).filter(function (x) { return !mentionedParams[x]; })
	        .forEach(function (x) { return describedParams[x].forEach(function (y) { return allParams.push(y); }); });
	    return allParams;
	}
	;
	/**
	 * __$helperMethod__
	 * __$meta__={"name":"parametrizedProperties","primary":true}
	 */
	function getTemplateParametrizedProperties(node) {
	    if (node.kind() == universeDef.Universe10.Method.name || universeHelpers.isTypeDeclarationSibling(node.definition())) {
	        var isInsideTemplate = false;
	        var parent = node.highLevel().parent();
	        while (parent != null) {
	            var pDef = parent.definition();
	            if (universeHelpers.isResourceTypeType(pDef) || universeHelpers.isTraitType(pDef)) {
	                isInsideTemplate = true;
	                break;
	            }
	            parent = parent.parent();
	        }
	        if (!isInsideTemplate) {
	            return null;
	        }
	    }
	    var highLevelNode = node.highLevel();
	    if (highLevelNode == null) {
	        return null;
	    }
	    var lowLevelNode = highLevelNode.lowLevel();
	    if (lowLevelNode == null) {
	        return null;
	    }
	    var children = lowLevelNode.children().filter(function (x) {
	        var key = x.key();
	        if (!key) {
	            return false;
	        }
	        if (key.charAt(0) == "(" && key.charAt(key.length - 1) == ")") {
	            return false;
	        }
	        return key.indexOf("<<") >= 0;
	    });
	    if (children.length == 0) {
	        return null;
	    }
	    var result = new core.TypeInstanceImpl(children);
	    return result;
	}
	exports.getTemplateParametrizedProperties = getTemplateParametrizedProperties;
	var SchemaDef = (function () {
	    function SchemaDef(_content, _name) {
	        this._content = _content;
	        this._name = _name;
	    }
	    SchemaDef.prototype.name = function () { return this._name; };
	    SchemaDef.prototype.content = function () { return this._content; };
	    return SchemaDef;
	}());
	exports.SchemaDef = SchemaDef;
	var ParamValue = (function () {
	    function ParamValue(key, value) {
	        this.key = key;
	        this.value = value;
	    }
	    return ParamValue;
	}());
	exports.ParamValue = ParamValue;
	var ParamWrapper = (function () {
	    function ParamWrapper(_param) {
	        this._param = _param;
	        this.description = _param.description() ? _param.description().value() : this.description;
	        this.displayName = _param.displayName();
	        //        this.enum = _param.enum();
	        this.type = _param.type().length > 0 ? _param.type()[0] : "string";
	        this.example = _param.example();
	        this.required = _param.required();
	        this.default = _param.default();
	    }
	    return ParamWrapper;
	}());
	var ExampleSpecImpl = (function (_super) {
	    __extends(ExampleSpecImpl, _super);
	    function ExampleSpecImpl(hlNode, expandable, _annotations) {
	        _super.call(this, hlNode);
	        this.expandable = expandable;
	        this._annotations = _annotations;
	    }
	    ExampleSpecImpl.prototype.value = function () {
	        return this.expandable.asString();
	    };
	    ExampleSpecImpl.prototype.structuredValue = function () {
	        var obj;
	        if (this.expandable.isJSONString() || this.expandable.isYAML()) {
	            obj = this.expandable.asJSON();
	        }
	        else {
	            obj = this.expandable.original();
	        }
	        var llParent = this._node.lowLevel();
	        var key = this.expandable.isSingle() ? "example" : null;
	        var jsonNode = new json.AstNode(llParent.unit(), obj, llParent, null, key);
	        return new core.TypeInstanceImpl(jsonNode);
	    };
	    ExampleSpecImpl.prototype.strict = function () {
	        return this.expandable.strict();
	    };
	    ExampleSpecImpl.prototype.description = function () {
	        var descriptionValue = this.expandable.description();
	        if (descriptionValue == null && descriptionValue !== null) {
	            return null;
	        }
	        var attr = stubs.createAttr(this._node.definition().property(universeDef.Universe10.ExampleSpec.properties.description.name), descriptionValue);
	        var result = new RamlWrapperImpl.MarkdownStringImpl(attr);
	        return result;
	    };
	    ExampleSpecImpl.prototype.name = function () {
	        return this.expandable.name();
	    };
	    ExampleSpecImpl.prototype.displayName = function () {
	        return this.expandable.displayName();
	    };
	    ExampleSpecImpl.prototype.annotations = function () {
	        return this._annotations;
	    };
	    ExampleSpecImpl.prototype.scalarsAnnotations = function () { return {}; };
	    ExampleSpecImpl.prototype.uses = function () {
	        return _super.prototype.elements.call(this, 'uses');
	    };
	    return ExampleSpecImpl;
	}(core.BasicNodeImpl));
	exports.ExampleSpecImpl = ExampleSpecImpl;
	//# sourceMappingURL=wrapperHelper.js.map

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var serv = __webpack_require__(36);
	module.exports = serv;
	//# sourceMappingURL=ramlServices.js.map

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ramlDS = __webpack_require__(36);
	module.exports = ramlDS.getUniverse;
	//# sourceMappingURL=universeProvider.js.map

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	exports.rt = __webpack_require__(80);
	var typeSystem = exports.rt.nominalTypes;
	function getSchemaUtils() {
	    return exports.rt.getSchemaUtils();
	}
	exports.getSchemaUtils = getSchemaUtils;
	function registerAdapters(a) {
	    if (a["isUnion"]) {
	        a.addAdapter(new RAMLService(a));
	    }
	    else if (a["range"]) {
	        a.addAdapter(new RAMLPropertyService(a));
	    }
	}
	exports.TOP_LEVEL_EXTRA = exports.rt.TOP_LEVEL_EXTRA;
	exports.DEFINED_IN_TYPES_EXTRA = exports.rt.DEFINED_IN_TYPES_EXTRA;
	exports.USER_DEFINED_EXTRA = exports.rt.USER_DEFINED_EXTRA;
	exports.SOURCE_EXTRA = exports.rt.SOURCE_EXTRA;
	exports.tsInterfaces = exports.rt.tsInterfaces;
	// export function instanceOfHasExtra(instance : any) : instance is rt.IHasExtra {
	//     return rt.instanceOfHasExtra(instance);
	// }
	exports.injector = {
	    inject: function (a) {
	        registerAdapters(a);
	    }
	};
	typeSystem.registerInjector(exports.injector);
	var AbstractType = (function (_super) {
	    __extends(AbstractType, _super);
	    function AbstractType() {
	        _super.apply(this, arguments);
	    }
	    return AbstractType;
	}(typeSystem.AbstractType));
	exports.AbstractType = AbstractType;
	var ValueType = (function (_super) {
	    __extends(ValueType, _super);
	    function ValueType() {
	        _super.apply(this, arguments);
	    }
	    return ValueType;
	}(typeSystem.ValueType));
	exports.ValueType = ValueType;
	var SourceProvider = (function () {
	    function SourceProvider() {
	    }
	    SourceProvider.prototype.getSource = function () {
	        return null;
	    };
	    return SourceProvider;
	}());
	exports.SourceProvider = SourceProvider;
	function isSourceProvider(object) {
	    return object.getSource && typeof (object.getSource) == "function";
	}
	exports.isSourceProvider = isSourceProvider;
	var EnumType = (function (_super) {
	    __extends(EnumType, _super);
	    function EnumType() {
	        _super.apply(this, arguments);
	        this.values = [];
	    }
	    return EnumType;
	}(ValueType));
	exports.EnumType = EnumType;
	var ReferenceType = (function (_super) {
	    __extends(ReferenceType, _super);
	    function ReferenceType(name, path, referenceTo, _universe) {
	        _super.call(this, name, _universe, path);
	        this.referenceTo = referenceTo;
	    }
	    ReferenceType.prototype.getReferencedType = function () {
	        return this.universe().type(this.referenceTo);
	    };
	    ReferenceType.prototype.hasStructure = function () {
	        return true;
	    };
	    return ReferenceType;
	}(ValueType));
	exports.ReferenceType = ReferenceType;
	var NodeClass = (function (_super) {
	    __extends(NodeClass, _super);
	    function NodeClass(_name, universe, path, _description) {
	        if (_description === void 0) { _description = ""; }
	        _super.call(this, _name, universe, path);
	    }
	    NodeClass.prototype.allProperties = function (v) {
	        if (v === void 0) { v = {}; }
	        return _super.prototype.allProperties.call(this, v);
	    };
	    return NodeClass;
	}(typeSystem.StructuredType));
	exports.NodeClass = NodeClass;
	var UserDefinedClass = (function (_super) {
	    __extends(UserDefinedClass, _super);
	    function UserDefinedClass(name, universe, hl, path, description) {
	        _super.call(this, name, universe, path, description);
	        this.getAdapter(RAMLService).setDeclaringNode(hl);
	    }
	    UserDefinedClass.prototype.key = function () {
	        return null;
	    };
	    UserDefinedClass.prototype.isUserDefined = function () {
	        return true;
	    };
	    UserDefinedClass.prototype.typeId = function () {
	        var rs = this.nameId();
	        var node = this.getAdapter(RAMLService).getDeclaringNode();
	        if (node) {
	            rs = rs + node.lowLevel().start();
	            var unit = node.lowLevel().unit();
	            if (unit) {
	                rs = rs + unit.absolutePath();
	            }
	        }
	        return rs;
	    };
	    UserDefinedClass.prototype.hasValueTypeInHierarchy = function () {
	        if (this._value) {
	            return true;
	        }
	        if (this.isAssignableFrom("ObjectTypeDeclaration")) {
	            return false;
	        }
	        return false;
	    };
	    /**
	     * Returns whether this type contain genuine user defined type in its hierarchy.
	     * Genuine user defined type is a type user intentionally defined and filled with
	     * properties or facets, or having user-defined name as opposed to a synthetic user-defined type.
	     */
	    UserDefinedClass.prototype.isGenuineUserDefinedType = function () {
	        return this.genuineUserDefinedType() != null;
	    };
	    /**
	     * Returns nearest genuine user-define type in the hierarchy.
	     * Genuine user defined type is a type user intentionally defined and filled with
	     * properties or facets, or having user-defined name as opposed to a synthetic user-defined type.
	     */
	    UserDefinedClass.prototype.genuineUserDefinedType = function () {
	        var declaringNode = this.getAdapter(RAMLService).getDeclaringNode();
	        if (!declaringNode) {
	            return null;
	        }
	        return this;
	    };
	    return UserDefinedClass;
	}(NodeClass));
	exports.UserDefinedClass = UserDefinedClass;
	var AnnotationType = (function (_super) {
	    __extends(AnnotationType, _super);
	    function AnnotationType() {
	        _super.apply(this, arguments);
	    }
	    AnnotationType.prototype.allProperties = function (ps) {
	        if (ps === void 0) { ps = {}; }
	        var rs = this.superTypes()[0].allProperties();
	        if (rs.length == 0) {
	            var node = this.getAdapter(RAMLService).getDeclaringNode();
	            var up = new UserDefinedProp("value", node);
	            up.withDomain(this);
	            up.withCanBeValue();
	            up.withRequired(false);
	            var tp = this.superTypes()[0];
	            rs = [];
	            up.withRange(up.node().asElement().definition().universe().type("string"));
	            rs.push(up);
	        }
	        return rs;
	    };
	    AnnotationType.prototype.isAnnotationType = function () {
	        return true;
	    };
	    return AnnotationType;
	}(UserDefinedClass));
	exports.AnnotationType = AnnotationType;
	var Universe = (function (_super) {
	    __extends(Universe, _super);
	    function Universe(dec, name, _parent, v) {
	        if (name === void 0) { name = ""; }
	        if (_parent === void 0) { _parent = null; }
	        if (v === void 0) { v = "RAML08"; }
	        _super.call(this, name);
	        this._parent = _parent;
	        this._classes = [];
	        this._uversion = "RAML08";
	        this.aMap = {};
	        this.matchedObjects = dec;
	        this._uversion = v;
	    }
	    Universe.prototype.matched = function () {
	        if (this.matchedObjects) {
	            return this.matchedObjects;
	        }
	        if (this._parent) {
	            return this._parent.matched();
	        }
	    };
	    Universe.prototype.setTopLevel = function (t) {
	        this._topLevel = t;
	    };
	    Universe.prototype.getTopLevel = function () {
	        return this._topLevel;
	    };
	    Universe.prototype.setOriginalTopLevelText = function (t) {
	        this._originalTopLevelText = t;
	    };
	    Universe.prototype.getOriginalTopLevelText = function () {
	        return this._originalTopLevelText;
	    };
	    Universe.prototype.setTypedVersion = function (tv) {
	        this._typedVersion = tv;
	    };
	    Universe.prototype.getTypedVersion = function () {
	        return this._typedVersion;
	    };
	    Universe.prototype.version = function () {
	        return this._uversion;
	    };
	    Universe.prototype.setUniverseVersion = function (version) {
	        this._uversion = version;
	    };
	    Universe.prototype.types = function () {
	        var result = [].concat(this._classes);
	        if (this._parent != null) {
	            result = result.concat(this._parent.types());
	        }
	        return result;
	    };
	    Universe.prototype.type = function (name) {
	        if (this.aMap[name]) {
	            return this.aMap[name];
	        }
	        var tp;
	        for (var i = 0; i < this._classes.length; i++) {
	            if (this._classes[i].nameId() == name) {
	                tp = this._classes[i];
	                break;
	            }
	        }
	        if (tp == null) {
	            if (this._parent) {
	                var tp = this._parent.type(name);
	                if (tp instanceof AbstractType) {
	                    var at = tp;
	                    at._universe = this; //FIXME
	                }
	            }
	        }
	        return tp;
	    };
	    Universe.prototype.register = function (t) {
	        this._classes.push(t);
	        if (t instanceof NodeClass) {
	            this._classes.forEach(function (x) {
	                if (x instanceof NodeClass) {
	                    var nc = x;
	                    if (nc.getAdapter(RAMLService).getExtendedType() == t) {
	                        t.getAdapter(RAMLService).getRuntimeExtenders().push(x);
	                    }
	                }
	            });
	        }
	        return this;
	    };
	    Universe.prototype.registerAlias = function (a, t) {
	        this.aMap[a] = t;
	    };
	    Universe.prototype.unregister = function (t) {
	        this._classes = this._classes.filter(function (x) { return x != t; });
	        var st = t.superTypes();
	        st.forEach(function (x) {
	            var a = x;
	            a._superTypes = a._superTypes.filter(function (x) { return x != t; });
	        });
	        st = t.subTypes();
	        st.forEach(function (x) {
	            var a = x;
	            a._subTypes = a._subTypes.filter(function (x) { return x != t; });
	        });
	        return this;
	    };
	    Universe.prototype.registerSuperClass = function (t0, t1) {
	        var a0 = t0;
	        var a1 = t1;
	        a0._superTypes.push(t1);
	        a1._subTypes.push(t0);
	    };
	    return Universe;
	}(typeSystem.Described));
	exports.Universe = Universe;
	function prop(name, desc, domain, range, custom) {
	    var prop = new Property(name, desc);
	    return prop.withDomain(domain, custom).withRange(range);
	}
	exports.prop = prop;
	var ChildValueConstraint = (function () {
	    function ChildValueConstraint(name, value) {
	        this.name = name;
	        this.value = value;
	    }
	    return ChildValueConstraint;
	}());
	exports.ChildValueConstraint = ChildValueConstraint;
	var Property = (function (_super) {
	    __extends(Property, _super);
	    function Property() {
	        _super.apply(this, arguments);
	        this._isFromParentValue = false;
	        this._isFromParentKey = false;
	        this._key = false;
	        this._declaresFields = false;
	        this._describes = null;
	        this._canBeDuplicator = false;
	        this._allowsNull = false;
	        this._canBeValue = false;
	        this._isInherited = false;
	        this._selfNode = false;
	        this._noDirectParse = false;
	        this._contextReq = [];
	        this.determinesChildValues = [];
	    }
	    Property.prototype.isPrimitive = function () {
	        return this.range().isValueType() && !(this.range() instanceof ReferenceType);
	    };
	    Property.prototype.withNoDirectParse = function () {
	        this._noDirectParse = true;
	    };
	    Property.prototype.isNoDirectParse = function () {
	        return this._noDirectParse;
	    };
	    Property.prototype.withSelfNode = function () {
	        this._selfNode = true;
	    };
	    Property.prototype.isSelfNode = function () {
	        return this._selfNode;
	    };
	    Property.prototype.matchKey = function (k) {
	        if (this._groupName != null) {
	            if (this.isAnnotation()) {
	                if (k.charAt(0) == '(' && k.charAt(k.length - 1) == ')') {
	                    return true;
	                }
	                return false;
	            }
	            return this._groupName == k;
	        }
	        else {
	            return _super.prototype.matchKey.call(this, k);
	        }
	    };
	    Property.prototype.valueDocProvider = function () {
	        return this._vprovider;
	    };
	    Property.prototype.setValueDocProvider = function (v) {
	        this._vprovider = v;
	        return this;
	    };
	    Property.prototype.suggester = function () {
	        return this._suggester;
	    };
	    Property.prototype.setValueSuggester = function (s) {
	        this._suggester = s;
	    };
	    Property.prototype.enumOptions = function () {
	        if (this._enumOptions && typeof this._enumOptions == 'string') {
	            return [this._enumOptions + ""];
	        }
	        return this._enumOptions;
	    };
	    Property.prototype.getOftenKeys = function () {
	        return this._oftenKeys;
	    };
	    Property.prototype.withOftenKeys = function (keys) {
	        this._oftenKeys = keys;
	        return this;
	    };
	    Property.prototype.withCanBeValue = function () {
	        this._canBeValue = true;
	        return this;
	    };
	    Property.prototype.withInherited = function (w) {
	        this._isInherited = w;
	    };
	    Property.prototype.isInherited = function () {
	        return this._isInherited;
	    };
	    Property.prototype.isAllowNull = function () {
	        return this._allowsNull;
	    };
	    Property.prototype.withAllowNull = function () {
	        this._allowsNull = true;
	    };
	    Property.prototype.getCanBeDuplicator = function () {
	        return this._canBeDuplicator;
	    };
	    Property.prototype.canBeValue = function () {
	        return this._canBeValue;
	    };
	    Property.prototype.setCanBeDuplicator = function () {
	        this._canBeDuplicator = true;
	        return true;
	    };
	    Property.prototype.inheritedContextValue = function () {
	        return this._inheritsValueFromContext;
	    };
	    Property.prototype.withInheritedContextValue = function (v) {
	        this._inheritsValueFromContext = v;
	        return this;
	    };
	    Property.prototype.withContextRequirement = function (name, value) {
	        this._contextReq.push({ name: name, value: value });
	    };
	    Property.prototype.getContextRequirements = function () {
	        return this._contextReq;
	    };
	    Property.prototype.withDescribes = function (a) {
	        this._describes = a;
	        return this;
	    };
	    Property.prototype.describesAnnotation = function () {
	        return this._describes != null;
	    };
	    Property.prototype.describedAnnotation = function () {
	        return this._describes;
	    };
	    Property.prototype.isReference = function () {
	        return this.range() instanceof ReferenceType;
	    };
	    Property.prototype.referencesTo = function () {
	        return this.range().getReferencedType();
	    };
	    Property.prototype.newInstanceName = function () {
	        if (this._newInstanceName) {
	            return this._newInstanceName;
	        }
	        return this.range().nameId();
	    };
	    Property.prototype.withThisPropertyDeclaresFields = function (b) {
	        if (b === void 0) { b = true; }
	        this._declaresFields = b;
	        return this;
	    };
	    Property.prototype.isThisPropertyDeclaresTypeFields = function () {
	        return this._declaresFields;
	    };
	    Property.prototype.withNewInstanceName = function (name) {
	        this._newInstanceName = name;
	        return this;
	    };
	    Property.prototype.addChildValueConstraint = function (c) {
	        this.determinesChildValues.push(c);
	    };
	    Property.prototype.getChildValueConstraints = function () {
	        return this.determinesChildValues;
	    };
	    Property.prototype.childRestrictions = function () {
	        return this.determinesChildValues;
	    };
	    Property.prototype.id = function () {
	        if (this._id) {
	            return this._id;
	        }
	        if (!this._groupName) {
	            return null;
	        }
	        if (this.domain().getAdapter(RAMLService).getDeclaringNode()) {
	            return null;
	        }
	        this._id = this._groupName + this.domain().nameId();
	        return this._id;
	    };
	    Property.prototype.isAnnotation = function () {
	        return this._groupName == "annotations" &&
	            this.domain() && !this.domain().isUserDefined();
	    };
	    Property.prototype.withFromParentValue = function (v) {
	        if (v === void 0) { v = true; }
	        this._isFromParentValue = v;
	        return this;
	    };
	    Property.prototype.withFromParentKey = function (v) {
	        if (v === void 0) { v = true; }
	        this._isFromParentKey = v;
	        return this;
	    };
	    Property.prototype.isFromParentKey = function () {
	        return this._isFromParentKey;
	    };
	    Property.prototype.isFromParentValue = function () {
	        return this._isFromParentValue;
	    };
	    Property.prototype.withGroupName = function (gname) {
	        this._groupName = gname;
	        return this;
	    };
	    Property.prototype.unmerge = function () {
	        this._groupName = this.nameId();
	        return this;
	    };
	    Property.prototype.merge = function () {
	        this._groupName = null;
	        return this;
	    };
	    Property.prototype.withKey = function (isKey) {
	        this._key = isKey;
	        return this;
	    };
	    /**
	     * TODO THIS STUFF SHOULD BE MORE ABSTRACT (LATER...)
	     * @param keyShouldStartFrom
	     * @returns {Property}
	     */
	    Property.prototype.isKey = function () {
	        return this._key;
	    };
	    Property.prototype.isMerged = function () {
	        return this._groupName == null;
	    };
	    Property.prototype.groupName = function () {
	        return this._groupName;
	    };
	    Property.prototype.key = function () {
	        //TODO implement that
	        return null;
	    };
	    return Property;
	}(typeSystem.Property));
	exports.Property = Property;
	var UserDefinedProp = (function (_super) {
	    __extends(UserDefinedProp, _super);
	    function UserDefinedProp(name, source) {
	        _super.call(this, name);
	        this._node = source;
	    }
	    UserDefinedProp.prototype.withDisplayName = function (name) {
	        this._displayName = name;
	    };
	    UserDefinedProp.prototype.getDisplayName = function () {
	        return this._displayName;
	    };
	    UserDefinedProp.prototype.node = function () {
	        if (!this._node && this.sourceProvider != null) {
	            this._node = this.sourceProvider.getSource();
	        }
	        return this._node;
	    };
	    UserDefinedProp.prototype.setSourceProvider = function (sourceProvider) {
	        this.sourceProvider = sourceProvider;
	    };
	    return UserDefinedProp;
	}(Property));
	exports.UserDefinedProp = UserDefinedProp;
	var RAMLPropertyDocumentationService = (function () {
	    function RAMLPropertyDocumentationService() {
	    }
	    RAMLPropertyDocumentationService.prototype.setDocTableName = function (val) {
	        this._documentationTableName = val;
	    };
	    RAMLPropertyDocumentationService.prototype.docTableName = function () {
	        return this._documentationTableName;
	    };
	    RAMLPropertyDocumentationService.prototype.setHidden = function (val) {
	        this._isHidden = val;
	    };
	    RAMLPropertyDocumentationService.prototype.isHidden = function () {
	        return this._isHidden;
	    };
	    RAMLPropertyDocumentationService.prototype.setMarkdownDescription = function (val) {
	        this._markdownDescription = val;
	    };
	    RAMLPropertyDocumentationService.prototype.markdownDescription = function () {
	        return this._markdownDescription;
	    };
	    RAMLPropertyDocumentationService.prototype.setValueDescription = function (val) {
	        this._valueDescription = val;
	    };
	    RAMLPropertyDocumentationService.prototype.valueDescription = function () {
	        return this._valueDescription;
	    };
	    return RAMLPropertyDocumentationService;
	}());
	exports.RAMLPropertyDocumentationService = RAMLPropertyDocumentationService;
	var RAMLPropertyParserService = (function (_super) {
	    __extends(RAMLPropertyParserService, _super);
	    function RAMLPropertyParserService() {
	        _super.apply(this, arguments);
	    }
	    RAMLPropertyParserService.prototype.isSystem = function () {
	        return this._isSystemProperty;
	    };
	    RAMLPropertyParserService.prototype.withSystem = function (s) {
	        this._isSystemProperty = s;
	        return this;
	    };
	    RAMLPropertyParserService.prototype.isEmbedMap = function () {
	        return this._isEmbededMap;
	    };
	    RAMLPropertyParserService.prototype.withEmbedMap = function () {
	        this._isEmbededMap = true;
	        return this;
	    };
	    return RAMLPropertyParserService;
	}(RAMLPropertyDocumentationService));
	exports.RAMLPropertyParserService = RAMLPropertyParserService;
	var RAMLPropertyService = (function (_super) {
	    __extends(RAMLPropertyService, _super);
	    function RAMLPropertyService(_property) {
	        _super.call(this);
	        this._property = _property;
	        this._meta = {};
	        if (!_property) {
	            throw new Error();
	        }
	        _super.call(this);
	    }
	    RAMLPropertyService.prototype.valueDocProvider = function () {
	        return this._property.valueDocProvider();
	    };
	    RAMLPropertyService.prototype.withPropertyGrammarType = function (pt) {
	        this._propertyGrammarType = pt;
	    };
	    RAMLPropertyService.prototype.getPropertyGrammarType = function () {
	        return this._propertyGrammarType;
	    };
	    RAMLPropertyService.prototype.id = function () {
	        return this._property.nameId();
	    };
	    RAMLPropertyService.prototype.range = function () {
	        return this._property.range();
	    };
	    RAMLPropertyService.prototype.domain = function () {
	        return this._property.domain();
	    };
	    RAMLPropertyService.prototype.isAllowNull = function () {
	        return this._property.isAllowNull();
	    };
	    RAMLPropertyService.prototype.referencesTo = function () {
	        return this._property.referencesTo();
	    };
	    RAMLPropertyService.prototype.isReference = function () {
	        return this._property.isReference();
	    };
	    RAMLPropertyService.prototype.nameId = function () {
	        return this._property.nameId();
	    };
	    RAMLPropertyService.prototype.priority = function () {
	        if (this.isKey())
	            return 128;
	        else if (this.isReference())
	            return 64;
	        else if (this.isTypeExpr())
	            return 32;
	        else if (this.nameId() == 'example')
	            return 0;
	        else
	            return -1024;
	    };
	    RAMLPropertyService.prototype.isKey = function () {
	        if (this._property instanceof Property) {
	            return this._property.isKey();
	        }
	        return false;
	    };
	    RAMLPropertyService.prototype.isMerged = function () {
	        if (this._property instanceof Property) {
	            return this._property.isMerged();
	        }
	        return false;
	    };
	    RAMLPropertyService.prototype.isTypeExpr = function () {
	        return this.texpr;
	    };
	    RAMLPropertyService.prototype.isExampleProperty = function () {
	        return this.example;
	    };
	    RAMLPropertyService.prototype.setExample = function (e) {
	        this.example = e;
	    };
	    RAMLPropertyService.prototype.setTypeExpression = function (e) {
	        this.texpr = e;
	    };
	    RAMLPropertyService.prototype.isDescriminating = function () {
	        return this._property.isDescriminator();
	    };
	    RAMLPropertyService.prototype.putMeta = function (key, value) {
	        this._meta[key] = value;
	    };
	    RAMLPropertyService.prototype.meta = function (key) {
	        return this._meta[key];
	    };
	    return RAMLPropertyService;
	}(RAMLPropertyParserService));
	exports.RAMLPropertyService = RAMLPropertyService;
	var RAMLService = (function () {
	    function RAMLService(d) {
	        //!!!
	        this._allowsOptionalProperties = false;
	        this._possibleInterfaces = [];
	        //!!!
	        this._canInherit = [];
	        this._declaredBy = [];
	        //!!!
	        this._aliases = [];
	        //!!!???
	        this._defining = [];
	        this._runtimeExtenders = [];
	        //!!!???
	        this._declaresType = null;
	        //!!!
	        this._isTemplate = false;
	        //!!!
	        this._contextRequirements = [];
	        this._type = d;
	    }
	    RAMLService.prototype.withAllowQuestion = function () {
	        this._allowsOptionalProperties = true;
	    };
	    RAMLService.prototype.getAllowQuestion = function () {
	        return this._allowsOptionalProperties;
	    };
	    RAMLService.prototype.withCanInherit = function (clazz) {
	        this._canInherit.push(clazz);
	    };
	    RAMLService.prototype.getReferenceIs = function () {
	        return this._referenceIs;
	    };
	    RAMLService.prototype.withReferenceIs = function (fname) {
	        this._referenceIs = fname;
	    };
	    RAMLService.prototype.descriminatorValue = function () {
	        if (this.valueRequirements().length == 0) {
	            return this.nameId();
	        }
	        return this.valueRequirements()[0].value;
	    };
	    RAMLService.prototype.getCanInherit = function () {
	        return this._canInherit;
	    };
	    RAMLService.prototype.withAllowAny = function () {
	        this._allowsAnyChildren = true;
	    };
	    RAMLService.prototype.getAllowAny = function () {
	        return this._allowsAnyChildren || this._type.isExternal();
	    };
	    RAMLService.prototype.globallyDeclaredBy = function () {
	        return this._declaredBy;
	    };
	    RAMLService.prototype.setGloballyDeclaredBy = function (c) {
	        this._declaredBy.push(c);
	    };
	    RAMLService.prototype.setDeclaringNode = function (n) {
	        this._node = n;
	    };
	    RAMLService.prototype.nameId = function () {
	        return this._type.nameId();
	    };
	    RAMLService.prototype.universe = function () {
	        return this._type.universe();
	    };
	    RAMLService.prototype.isAssignableFrom = function (name) {
	        return this._type.isAssignableFrom(name);
	    };
	    RAMLService.prototype.setConsumesRefs = function (b) {
	        this._consumesRef = b;
	    };
	    RAMLService.prototype.definingPropertyIsEnough = function (v) {
	        this._defining.push(v);
	    };
	    RAMLService.prototype.getDefining = function () {
	        return this._defining;
	    };
	    RAMLService.prototype.getConsumesRefs = function () {
	        return this._consumesRef;
	    };
	    RAMLService.prototype.addAlias = function (al) {
	        this._aliases.push(al);
	    };
	    RAMLService.prototype.getAliases = function () {
	        return this._aliases;
	    };
	    RAMLService.prototype.valueRequirements = function () {
	        return this._type.valueRequirements();
	    };
	    RAMLService.prototype.isAnnotation = function () {
	        if (this._annotationChecked) {
	            return this._isAnnotation;
	        }
	        this._annotationChecked = true;
	        this._isAnnotation = (this._type.allSuperTypes().some(function (x) { return x.key() && x.key().name == "AnnotationRef"; }));
	        return this._isAnnotation;
	    };
	    RAMLService.prototype.allowValue = function () {
	        if (this._allowsValueSet) {
	            return this._allowsValue;
	        }
	        if (this._type.allProperties().some(function (x) { return x.isFromParentValue() || x.canBeValue(); })) {
	            this._allowsValue = true;
	            this._allowsValueSet = true;
	            return true;
	        }
	        this._allowsValueSet = true;
	        return false;
	    };
	    RAMLService.prototype.key = function () {
	        return this._type.key();
	    };
	    RAMLService.prototype.getRepresentationOf = function () {
	        return this._representationOf;
	    };
	    RAMLService.prototype.getPath = function () {
	        return "";
	    };
	    RAMLService.prototype.isDeclaration = function () {
	        if (this._isTemplate) {
	            return true;
	        }
	        if (this._convertsToGlobal) {
	            return true;
	        }
	        if (this._declaresType) {
	            return true;
	        }
	        if (this.key() && this.key().name === "Library") {
	            return true;
	        }
	        return false;
	    };
	    RAMLService.prototype.isGlobalDeclaration = function () {
	        if (this._actuallyExports) {
	            return true;
	        }
	        if (this._isTemplate) {
	            return true;
	        }
	        if (this._declaresType) {
	            return true;
	        }
	        return false;
	    };
	    RAMLService.prototype.isTypeSystemMember = function () {
	        return this._declaresType != null;
	    };
	    RAMLService.prototype.getExtendedType = function () {
	        return this.universe().type(this._declaresType);
	    };
	    RAMLService.prototype.setInlinedTemplates = function (b) {
	        this._isTemplate = b;
	        return this;
	    };
	    RAMLService.prototype.getRuntimeExtenders = function () {
	        return this._runtimeExtenders;
	    };
	    RAMLService.prototype.isInlinedTemplates = function () {
	        return this._isTemplate;
	    };
	    RAMLService.prototype.setExtendedTypeName = function (name) {
	        this._declaresType = name;
	        var tp = this.universe().type(name);
	        if (tp instanceof NodeClass) {
	            var nc = tp;
	            nc.getAdapter(RAMLService)._runtimeExtenders.push(this._type);
	        }
	    };
	    RAMLService.prototype.getKeyProp = function () {
	        var c = this._type.allProperties();
	        for (var i = 0; i < c.length; i++) {
	            if (c[i].getAdapter(RAMLPropertyService).isKey()) {
	                return c[i];
	            }
	        }
	        return null;
	    };
	    RAMLService.prototype.withActuallyExports = function (pname) {
	        this._actuallyExports = pname;
	    };
	    RAMLService.prototype.withConvertsToGlobal = function (pname) {
	        this._convertsToGlobal = pname;
	    };
	    RAMLService.prototype.getConvertsToGlobal = function () {
	        return this._convertsToGlobal;
	    };
	    RAMLService.prototype.getActuallyExports = function () {
	        return this._actuallyExports;
	    };
	    RAMLService.prototype.isUserDefined = function () {
	        if (this._type instanceof NodeClass) {
	            return this._type.isUserDefined();
	        }
	        if (this._type instanceof AbstractType) {
	            return this._type.isUserDefined();
	        }
	        return false;
	    };
	    RAMLService.prototype.withContextRequirement = function (name, value) {
	        this._contextRequirements.push({ name: name, value: value });
	    };
	    RAMLService.prototype.getContextRequirements = function () {
	        return this._contextRequirements;
	    };
	    RAMLService.prototype.findMembersDeterminer = function () {
	        var c = this._type.allProperties();
	        for (var i = 0; i < c.length; i++) {
	            if (c[i].isThisPropertyDeclaresTypeFields()) {
	                return c[i];
	            }
	        }
	        return null;
	    };
	    RAMLService.prototype.getDeclaringNode = function () {
	        if (this._node)
	            return this._node;
	        else if (this._type) {
	            //if this service have no source registered,
	            //checking if the type has source contributed via extras
	            var sourceNode = this._type.getExtra(exports.SOURCE_EXTRA);
	            if (!sourceNode)
	                return null;
	            if (sourceNode instanceof SourceProvider ||
	                (sourceNode.getSource && typeof (sourceNode.getSource) == "function")) {
	                return sourceNode.getSource();
	            }
	            else {
	                return sourceNode;
	            }
	        }
	        return null;
	    };
	    RAMLService.prototype.registerSupertypes = function (classNames) {
	        var _this = this;
	        var universe = this._type.universe();
	        classNames.forEach(function (x) {
	            var supertype = universe.type(x);
	            if (!supertype) {
	                return;
	            }
	            _this._type.addSuperType(supertype);
	        });
	    };
	    RAMLService.prototype.registerPossibleInterfaces = function (classNames) {
	        var universe = this._type.universe();
	        for (var _i = 0, classNames_1 = classNames; _i < classNames_1.length; _i++) {
	            var x = classNames_1[_i];
	            var supertype = universe.type(x);
	            if (!supertype) {
	                return;
	            }
	            this._possibleInterfaces.push(supertype);
	        }
	    };
	    RAMLService.prototype.possibleInterfaces = function () {
	        return this._possibleInterfaces;
	    };
	    return RAMLService;
	}());
	exports.RAMLService = RAMLService;
	var universes = {};
	var ramlDS = __webpack_require__(56);
	var jsonDefinitions = ramlDS.universeDumps;
	var ts2def = __webpack_require__(57);
	var unDesc = __webpack_require__(58);
	exports.universesInfo = unDesc;
	exports.getUniverse = (function () {
	    var x = function (key) {
	        if (universes[key]) {
	            return universes[key];
	        }
	        var src = jsonDefinitions[key];
	        var universe = ts2def.toDefSystem(src, (key == "RAML08") ? unDesc["Universe08"] : unDesc["Universe10"]);
	        if (universe) {
	            universe.setUniverseVersion(key);
	            universes[key] = universe;
	        }
	        return universe;
	    };
	    x.availableUniverses = function () { return Object.keys(jsonDefinitions); };
	    return x;
	})();
	//# sourceMappingURL=definitionSystem.js.map

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var punycode = __webpack_require__(82);

	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;

	exports.Url = Url;

	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}

	// Reference: RFC 3986, RFC 1808, RFC 2396

	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,

	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(81);

	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;

	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}

	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }

	  var rest = url;

	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();

	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }

	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }

	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {

	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c

	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.

	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }

	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }

	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }

	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;

	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);

	    // pull out port.
	    this.parseHost();

	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';

	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';

	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }

	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }

	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }

	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;

	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }

	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {

	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }


	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }

	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }

	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};

	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}

	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }

	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';

	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }

	  if (this.query &&
	      isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }

	  var search = this.search || (query && ('?' + query)) || '';

	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }

	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;

	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');

	  return protocol + host + pathname + search + hash;
	};

	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}

	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};

	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}

	Url.prototype.resolveObject = function(relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }

	  var result = new Url();
	  Object.keys(this).forEach(function(k) {
	    result[k] = this[k];
	  }, this);

	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;

	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }

	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });

	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }

	    result.href = result.format();
	    return result;
	  }

	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }

	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }

	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];

	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }

	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }

	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }

	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');

	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }

	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }

	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }

	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');

	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }

	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }

	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }

	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};

	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};

	function isString(arg) {
	  return typeof arg === "string";
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return  arg == null;
	}


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_38__;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var yaml = __webpack_require__(72);
	var json = __webpack_require__(50);
	var stringify = __webpack_require__(62);
	var impl = __webpack_require__(27);
	var util = __webpack_require__(32);
	var universes = __webpack_require__(22);
	var def = __webpack_require__(36);
	var universeHelpers = __webpack_require__(14);
	var _ = __webpack_require__(63);
	var LowLevelProxyNode = (function () {
	    function LowLevelProxyNode(_parent, _transformer, ramlVersion) {
	        this._parent = _parent;
	        this._transformer = _transformer;
	        this.ramlVersion = ramlVersion;
	    }
	    LowLevelProxyNode.prototype.hasInnerIncludeError = function () {
	        return this._originalNode.hasInnerIncludeError();
	    };
	    LowLevelProxyNode.prototype.keyKind = function () {
	        return this._originalNode.keyKind();
	    };
	    LowLevelProxyNode.prototype.primaryNode = function () {
	        return null;
	    };
	    LowLevelProxyNode.prototype.isAnnotatedScalar = function () {
	        return this._originalNode.isAnnotatedScalar();
	    };
	    LowLevelProxyNode.prototype.actual = function () {
	        if (this._originalNode) {
	            return this._originalNode.actual();
	        }
	        return this;
	    };
	    LowLevelProxyNode.prototype.transformer = function () { return this._transformer; };
	    LowLevelProxyNode.prototype.originalNode = function () {
	        return this._originalNode;
	    };
	    LowLevelProxyNode.prototype.start = function () { return this._originalNode.start(); };
	    LowLevelProxyNode.prototype.end = function () { return this._originalNode.end(); };
	    LowLevelProxyNode.prototype.value = function (toString) {
	        throw new Error('The method must be overridden');
	    };
	    LowLevelProxyNode.prototype.includeErrors = function () { return this._originalNode.includeErrors(); };
	    LowLevelProxyNode.prototype.includePath = function () { return this._originalNode.includePath(); };
	    LowLevelProxyNode.prototype.includeReference = function () { return this._originalNode.includeReference(); };
	    LowLevelProxyNode.prototype.setKeyOverride = function (_key) {
	        this._keyOverride = _key;
	    };
	    LowLevelProxyNode.prototype.setValueOverride = function (value) {
	        this._valueOverride = value;
	    };
	    LowLevelProxyNode.prototype.key = function (raw) {
	        if (raw === void 0) { raw = false; }
	        if (this._keyOverride) {
	            return this._keyOverride;
	        }
	        return this._originalNode.key(raw);
	    };
	    LowLevelProxyNode.prototype.optional = function () {
	        return this.originalNode().optional();
	    };
	    LowLevelProxyNode.prototype.children = function () {
	        throw new Error('The method must be overridden');
	    };
	    LowLevelProxyNode.prototype.parent = function () { return this._parent; };
	    LowLevelProxyNode.prototype.unit = function () { return this._originalNode.unit(); };
	    LowLevelProxyNode.prototype.includeBaseUnit = function () { return this._originalNode.unit(); };
	    LowLevelProxyNode.prototype.anchorId = function () { return this._originalNode.anchorId(); };
	    LowLevelProxyNode.prototype.errors = function () { return this._originalNode.errors(); };
	    LowLevelProxyNode.prototype.anchoredFrom = function () { return this._originalNode.anchoredFrom(); };
	    LowLevelProxyNode.prototype.includedFrom = function () { return this._originalNode.includedFrom(); };
	    LowLevelProxyNode.prototype.visit = function (v) {
	        if (v(this)) {
	            this.children().forEach(function (x) { return x.visit(v); });
	        }
	    };
	    //TODO
	    LowLevelProxyNode.prototype.addChild = function (n) { };
	    //TODO
	    LowLevelProxyNode.prototype.execute = function (cmd) { };
	    //TODO
	    LowLevelProxyNode.prototype.dump = function () { return null; };
	    LowLevelProxyNode.prototype.dumpToObject = function () {
	        var serialized = json.serialize2(this, false);
	        //var serialized = json.serialize(this);
	        if (this.kind() == yaml.Kind.MAPPING) {
	            var obj = {};
	            obj[this.key(true)] = serialized;
	            return obj;
	        }
	        return serialized;
	    };
	    LowLevelProxyNode.prototype.keyStart = function () { return this._originalNode.keyStart(); };
	    LowLevelProxyNode.prototype.keyEnd = function () { return this._originalNode.keyEnd(); };
	    LowLevelProxyNode.prototype.valueStart = function () { return this._originalNode.valueStart(); };
	    LowLevelProxyNode.prototype.valueEnd = function () { return this._originalNode.valueEnd(); };
	    LowLevelProxyNode.prototype.isValueLocal = function () { return this._originalNode.isValueLocal(); };
	    LowLevelProxyNode.prototype.kind = function () { return this._originalNode.kind(); };
	    LowLevelProxyNode.prototype.valueKind = function () { return this._originalNode.valueKind(); };
	    LowLevelProxyNode.prototype.anchorValueKind = function () { return this._originalNode.anchorValueKind(); };
	    LowLevelProxyNode.prototype.show = function (msg) { this._originalNode.show(msg); };
	    LowLevelProxyNode.prototype.setHighLevelParseResult = function (highLevelParseResult) {
	        this._highLevelParseResult = highLevelParseResult;
	    };
	    LowLevelProxyNode.prototype.highLevelParseResult = function () {
	        return this._highLevelParseResult;
	    };
	    LowLevelProxyNode.prototype.setHighLevelNode = function (highLevel) {
	        this._highLevelNode = highLevel;
	    };
	    LowLevelProxyNode.prototype.highLevelNode = function () {
	        if (this._highLevelNode) {
	            return this._highLevelNode;
	        }
	        return this._originalNode.highLevelNode();
	    };
	    LowLevelProxyNode.prototype.text = function (unitText) {
	        throw new Error("not implemented");
	    };
	    LowLevelProxyNode.prototype.copy = function () {
	        throw new Error("not implemented");
	    };
	    LowLevelProxyNode.prototype.markup = function (json) {
	        throw new Error("not implemented");
	    };
	    LowLevelProxyNode.prototype.nodeDefinition = function () {
	        return impl.getDefinitionForLowLevelNode(this);
	    };
	    LowLevelProxyNode.prototype.includesContents = function () {
	        return this._originalNode.includesContents();
	    };
	    return LowLevelProxyNode;
	}());
	exports.LowLevelProxyNode = LowLevelProxyNode;
	var LowLevelCompositeNode = (function (_super) {
	    __extends(LowLevelCompositeNode, _super);
	    function LowLevelCompositeNode(node, parent, transformer, ramlVersion, isPrimary) {
	        if (isPrimary === void 0) { isPrimary = true; }
	        _super.call(this, parent, transformer, ramlVersion);
	        this.isPrimary = isPrimary;
	        //Colliding nodes of the initioal AST
	        this._adoptedNodes = [];
	        this._preserveAnnotations = false;
	        var originalParent = this.parent() ? this.parent().originalNode() : null;
	        if (node instanceof LowLevelValueTransformingNode) {
	            this._originalNode = node;
	        }
	        else {
	            this._originalNode = new LowLevelValueTransformingNode(node, originalParent, transformer, this.ramlVersion);
	        }
	        this._adoptedNodes.push(this._originalNode);
	    }
	    LowLevelCompositeNode.prototype.adoptedNodes = function () {
	        return this._adoptedNodes;
	    };
	    LowLevelCompositeNode.prototype.primaryNode = function () {
	        return this.isPrimary ? this._originalNode : null;
	    };
	    LowLevelCompositeNode.prototype.parent = function () { return this._parent; };
	    LowLevelCompositeNode.prototype.adopt = function (node, transformer) {
	        if (!transformer) {
	            transformer = this._transformer;
	        }
	        var originalParent = this.parent() ? this.parent().originalNode() : null;
	        var tNode = new LowLevelValueTransformingNode(node, originalParent, transformer, this.ramlVersion);
	        this._adoptedNodes.push(tNode);
	        if (this._children) {
	            this._children.forEach(function (x) { return x._parent = null; });
	        }
	        this._children = null;
	        if (this.highLevelNode()) {
	            this.highLevelNode().resetChildren();
	        }
	    };
	    LowLevelCompositeNode.prototype.value = function (toString) {
	        if (this._valueOverride) {
	            return this._valueOverride;
	        }
	        var val;
	        var valuableNodes = this._adoptedNodes.filter(function (x) { return x.value() != null; });
	        if (valuableNodes.length > 0) {
	            val = valuableNodes[0].value(toString);
	        }
	        else {
	            val = this._originalNode.value(toString);
	        }
	        if (val instanceof LowLevelValueTransformingNode) {
	            this._valueOverride = val;
	        }
	        return val;
	    };
	    LowLevelCompositeNode.prototype.children = function () {
	        var _this = this;
	        if (this._children) {
	            return this._children;
	        }
	        var result = [];
	        var canBeMap = false;
	        var canBeSeq = false;
	        for (var _i = 0, _a = this._adoptedNodes; _i < _a.length; _i++) {
	            var x = _a[_i];
	            var adoptedNodeChildren = x.children();
	            if (adoptedNodeChildren && adoptedNodeChildren.length > 0) {
	                canBeSeq = true;
	                if (adoptedNodeChildren[0].key()) {
	                    if (this.originalNode().valueKind() != yaml.Kind.SEQ) {
	                        canBeMap = true;
	                    }
	                }
	            }
	        }
	        if (canBeMap) {
	            result = this.collectChildrenWithKeys();
	        }
	        else if (canBeSeq) {
	            result = this.collectChildrenWithKeys();
	            var map = {};
	            this._adoptedNodes.forEach(function (x) { return x.children().filter(function (y) { return !y.key(); }).forEach(function (y) {
	                var isPrimary = x == _this.primaryNode();
	                var key = _this.buildKey(y);
	                if (!isPrimary && map[key]) {
	                    //filtering away values with repeating keys
	                    //primary node is not subjected to filtration
	                    return;
	                }
	                map[key] = true;
	                var transformer = x.transformer() ? x.transformer() : _this.transformer();
	                var ch = (y instanceof LowLevelValueTransformingNode)
	                    ? y.originalNode() : y;
	                result.push(new LowLevelCompositeNode(ch, _this, transformer, _this.ramlVersion, isPrimary));
	            }); });
	        }
	        else {
	            result = [];
	        }
	        this._children = result;
	        return result;
	    };
	    LowLevelCompositeNode.prototype.buildKey = function (y) {
	        var obj = json.serialize(y);
	        var def = this.nodeDefinition();
	        if (def && (def.key() == universes.Universe08.TraitRef || def.key() == universes.Universe08.ResourceTypeRef
	            || def.key() == universes.Universe10.TraitRef || def.key() == universes.Universe10.ResourceTypeRef)) {
	            if (obj && typeof obj == 'object') {
	                var keys = Object.keys(obj);
	                if (keys.length > 0) {
	                    obj = keys[0];
	                }
	            }
	        }
	        if (obj == null)
	            return "";
	        return stringify(obj);
	    };
	    LowLevelCompositeNode.prototype.collectChildrenWithKeys = function () {
	        var _this = this;
	        var result = [];
	        var m = {};
	        for (var _i = 0, _a = this._adoptedNodes; _i < _a.length; _i++) {
	            var x = _a[_i];
	            var isPrimary = x == this.primaryNode();
	            for (var _b = 0, _c = x.children(); _b < _c.length; _b++) {
	                var y = _c[_b];
	                var key = y.originalNode().key();
	                if (key && x.transformer()) {
	                    var isAnnotation = key != null
	                        && (this._preserveAnnotations || this.isResource())
	                        && util.stringStartsWith(key, "(")
	                        && util.stringEndsWith(key, ")");
	                    if (!isAnnotation) {
	                        key = x.transformer().transform(key).value;
	                    }
	                }
	                if (this.skipKey(key, isPrimary)) {
	                    continue;
	                }
	                if (!key) {
	                    continue;
	                }
	                var arr = m[key];
	                if (!arr) {
	                    arr = [];
	                    m[key] = arr;
	                }
	                arr.push({ node: y.originalNode(), transformer: x.transformer(), isPrimary: isPrimary });
	            }
	        }
	        var ramlVersion = this.unit().highLevel().root().definition().universe().version();
	        var isResource = this.key() && this.key()[0] == "/";
	        var methodType = def.getUniverse("RAML10").type(universes.Universe10.Method.name);
	        var options = methodType.property(universes.Universe10.Method.properties.method.name).enumOptions();
	        Object.keys(m).forEach(function (key) {
	            var arr = m[key];
	            var allOptional = true;
	            var hasPrimaryChildren = false;
	            var isMethod = options.indexOf(key) >= 0;
	            arr.forEach(function (x) {
	                var isOpt = x.node.optional() &&
	                    (ramlVersion != "RAML10" ||
	                        (isResource && isMethod));
	                allOptional = allOptional && isOpt;
	                hasPrimaryChildren = hasPrimaryChildren || x.isPrimary;
	            });
	            if (hasPrimaryChildren) {
	                var primaryChildren = [];
	                arr.filter(function (x) { return x.isPrimary; }).forEach(function (x) {
	                    var tr = x.transformer ? x.transformer : _this.transformer();
	                    primaryChildren.push(new LowLevelCompositeNode(x.node, _this, tr, _this.ramlVersion, true));
	                });
	                var primaryChild = primaryChildren[0];
	                arr.filter(function (x) { return !x.isPrimary; }).forEach(function (x) {
	                    primaryChild.adopt(x.node, x.transformer);
	                });
	                primaryChildren.forEach(function (x) { return result.push(x); });
	            }
	            else if (!allOptional) {
	                var tr = arr[0].transformer ? arr[0].transformer : _this.transformer();
	                var primaryChild = new LowLevelCompositeNode(arr[0].node, _this, tr, _this.ramlVersion, false);
	                for (var i = 1; i < arr.length; i++) {
	                    primaryChild.adopt(arr[i].node, arr[i].transformer);
	                }
	                result.push(primaryChild);
	            }
	        });
	        return result;
	    };
	    LowLevelCompositeNode.prototype.isResource = function () {
	        return this.highLevelNode() && universeHelpers.isResourceType(this.highLevelNode().definition());
	    };
	    LowLevelCompositeNode.prototype.skipKey = function (key, isPrimary) {
	        if (isPrimary) {
	            return false;
	        }
	        if (this.ramlVersion != 'RAML08') {
	            return false;
	        }
	        var methodDef = universes.Universe08.Method;
	        var resourceDef = universes.Universe08.Resource;
	        //if(key==hasNormalParametersDef.properties.displayName.name
	        //    &&this.highLevelNode().definition().key().name==methodDef.name){
	        //    return true;
	        //}
	        //if(key==resourceDef.properties.displayName.name
	        //    &&this.highLevelNode().definition().key().name==resourceDef.name){
	        //    return true;
	        //}
	        return false;
	    };
	    LowLevelCompositeNode.prototype.valueKind = function () {
	        if (this._originalNode.kind() != yaml.Kind.MAPPING) {
	            return null;
	        }
	        for (var i = 0; i < this._adoptedNodes.length; i++) {
	            var node = this._adoptedNodes[i];
	            var yamlNode = node.originalNode().actual();
	            if (yamlNode && yamlNode.value != null) {
	                return node.valueKind();
	            }
	        }
	        return null;
	    };
	    LowLevelCompositeNode.prototype.includePath = function () {
	        for (var i = 0; i < this._adoptedNodes.length; i++) {
	            var node = this._adoptedNodes[i];
	            var includePath = node.includePath();
	            if (includePath != null) {
	                return includePath;
	            }
	        }
	        return null;
	    };
	    LowLevelCompositeNode.prototype.includeBaseUnit = function () {
	        for (var i = 0; i < this._adoptedNodes.length; i++) {
	            var node = this._adoptedNodes[i];
	            var includePath = node.includePath();
	            if (includePath != null) {
	                return node.unit();
	            }
	        }
	        return _super.prototype.includeBaseUnit.call(this);
	    };
	    LowLevelCompositeNode.prototype.includeReference = function () {
	        for (var i = 0; i < this._adoptedNodes.length; i++) {
	            var node = this._adoptedNodes[i];
	            if (node.value() != null) {
	                return node.includeReference();
	            }
	        }
	        return null;
	    };
	    LowLevelCompositeNode.prototype.optional = function () {
	        return _.all(this._adoptedNodes, function (x) { return x.optional(); });
	    };
	    LowLevelCompositeNode.prototype.replaceChild = function (oldNode, newNode, isPrimary, transformer) {
	        if (isPrimary === void 0) { isPrimary = false; }
	        if (transformer === void 0) { transformer = null; }
	        if (!this._children) {
	            this._children = [];
	        }
	        var newCNode = new LowLevelCompositeNode(newNode, this, null, this.ramlVersion);
	        if (oldNode == null) {
	            this._children.push(newCNode);
	            return newCNode;
	        }
	        var ind = this._children.indexOf(oldNode);
	        if (ind >= 0) {
	            this._children[ind] = newCNode;
	        }
	        else {
	            this._children.push(newCNode);
	        }
	        return newCNode;
	    };
	    LowLevelCompositeNode.prototype.removeChild = function (oldNode) {
	        if (!this._children || oldNode == null) {
	            return;
	        }
	        var ind = this._children.indexOf(oldNode);
	        if (ind >= 0) {
	            for (var i = ind; i < this._children.length - 1; i++) {
	                this._children[i] = this._children[i + 1];
	            }
	            this._children.pop();
	        }
	    };
	    LowLevelCompositeNode.prototype.setChildren = function (nodes) {
	        var _this = this;
	        if (nodes == null) {
	            this._children = null;
	            return;
	        }
	        this._children = nodes.map(function (x) {
	            if (x instanceof LowLevelCompositeNode) {
	                return x;
	            }
	            return new LowLevelCompositeNode(x, _this, null, _this.ramlVersion);
	        });
	    };
	    LowLevelCompositeNode.prototype.preserveAnnotations = function () {
	        if (!this._preserveAnnotations) {
	            if (this.isInsideResource === undefined) {
	                this.isInsideResource = false;
	                if (!this.isResource()) {
	                    var parent = this._parent;
	                    while (parent) {
	                        if (parent.isResource()) {
	                            this.isInsideResource = true;
	                            break;
	                        }
	                        parent = parent.parent();
	                    }
	                }
	            }
	            if (this.isInsideResource) {
	                this._preserveAnnotations = true;
	                this._children = null;
	            }
	        }
	    };
	    LowLevelCompositeNode.prototype.filterChildren = function () {
	        this.children();
	        var map = {};
	        var filtered = [];
	        this._children.forEach(function (x) {
	            if (x.key() != null) {
	                filtered.push(x);
	                return;
	            }
	            var key = JSON.stringify(json.serialize(x));
	            if (map[key]) {
	                return;
	            }
	            map[key] = true;
	            filtered.push(x);
	        });
	        this._children = filtered;
	    };
	    return LowLevelCompositeNode;
	}(LowLevelProxyNode));
	exports.LowLevelCompositeNode = LowLevelCompositeNode;
	var LowLevelValueTransformingNode = (function (_super) {
	    __extends(LowLevelValueTransformingNode, _super);
	    function LowLevelValueTransformingNode(node, parent, transformer, ramlVersion) {
	        _super.call(this, parent, transformer, ramlVersion);
	        this._originalNode = node;
	    }
	    LowLevelValueTransformingNode.prototype.value = function (toString) {
	        var val = this.originalNode().value(toString);
	        var t = this.transformer();
	        if (t) {
	            var transformationResult = t.transform(val, toString);
	            val = transformationResult.value;
	        }
	        if (val && typeof val === "object") {
	            return new LowLevelValueTransformingNode(val, this._parent, this._transformer, this.ramlVersion);
	        }
	        return val;
	    };
	    LowLevelValueTransformingNode.prototype.children = function () {
	        var _this = this;
	        var childNodes = null;
	        var originalNode = this.originalNode();
	        if (this._transformer != null) {
	            var substitution = this._transformer.children(originalNode);
	            if (substitution != null) {
	                childNodes = substitution;
	            }
	        }
	        if (childNodes == null) {
	            childNodes = originalNode.children();
	        }
	        return childNodes.map(function (x) { return new LowLevelValueTransformingNode(x, _this, _this._transformer, _this.ramlVersion); });
	    };
	    LowLevelValueTransformingNode.prototype.valueKind = function () {
	        var kind = this._transformer && this._transformer.valueKind(this.originalNode());
	        if (kind != null) {
	            return kind;
	        }
	        return _super.prototype.valueKind.call(this);
	    };
	    LowLevelValueTransformingNode.prototype.parent = function () { return this._parent; };
	    LowLevelValueTransformingNode.prototype.key = function (raw) {
	        if (raw === void 0) { raw = false; }
	        var key = _super.prototype.key.call(this, raw);
	        if (this.transformer() != null) {
	            return this.transformer().transform(key).value;
	        }
	        return key;
	    };
	    return LowLevelValueTransformingNode;
	}(LowLevelProxyNode));
	exports.LowLevelValueTransformingNode = LowLevelValueTransformingNode;
	//# sourceMappingURL=LowLevelASTProxy.js.map

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/main.d.ts" />
	"use strict";
	var jsyaml = __webpack_require__(27);
	var defs = __webpack_require__(36);
	var ll = __webpack_require__(11);
	var _ = __webpack_require__(63);
	var yaml = __webpack_require__(72);
	var hlimpl = __webpack_require__(16);
	var universes = __webpack_require__(22);
	var universeHelpers = __webpack_require__(14);
	var services = defs;
	function findLastAttributeIndex(n) {
	    var last = -1;
	    var children = n.lowLevel().children();
	    for (var i = 0; i < children.length; i++) {
	        var node = children[i];
	        if (!node.isMapping())
	            continue;
	        var name = node.asMapping().key.value;
	        var property = n.definition().property(name);
	        if (!property)
	            continue;
	        if (property.isFromParentValue() || property.range().hasValueTypeInHierarchy()) {
	            last = i;
	        }
	    }
	    //console.log('last attr index1: ' + last);
	    return last;
	}
	function findInsertionPointLowLevel(node, llnode, property, attr) {
	    //console.log('LL find insertion: node is attr: ' + attr);
	    var insertionPoint = null;
	    var embed = property && property.getAdapter(services.RAMLPropertyService).isEmbedMap();
	    if (embed && _.find(node.lowLevel().children(), function (x) { return x.key() == property.nameId(); })) {
	        embed = false;
	    }
	    if (attr || embed) {
	        var last = findLastAttribute(node);
	        if (!last) {
	            //insertionPoint = new jsyaml.InsertionPoint(jsyaml.InsertionPointType.START);
	            insertionPoint = jsyaml.InsertionPoint.atStart();
	        }
	        else {
	            insertionPoint = last;
	        }
	    }
	    return insertionPoint;
	}
	function findInsertionPoint(where, node) {
	    //console.log('find insertion point for node (HL): ' + node.property().name() + '; attr: ' + node.isAttr());
	    //console.log('node1: ' + node.lowLevel().text());
	    //always insert attributes at start
	    if (!where.isStub()) {
	        where.clearChildrenCache();
	    }
	    var ch = where.children();
	    var embed = node.property() && node.property().getAdapter(services.RAMLPropertyService).isEmbedMap();
	    if (embed && _.find(where.lowLevel().children(), function (x) { return x.key() == node.property().nameId(); })) {
	        embed = false;
	    }
	    var uh = universeHelpers;
	    if ((node.isAttr() || embed) && !(universeHelpers.isMethodType(where.definition()) && node.property && universeHelpers.isIsProperty(node.property()))) {
	        var toRet = null;
	        for (var i = 0; i < ch.length; i++) {
	            if (!ch[i].isAttr()) {
	                break;
	            }
	            else {
	                toRet = ch[i].lowLevel();
	            }
	        }
	        if (toRet == null) {
	            toRet = where.lowLevel();
	        }
	        return toRet;
	    }
	    else {
	        var pname = node.property().nameId();
	        var cls = where.definition();
	        var props = cls.allProperties();
	        //console.log('class: ' + cls.name());
	        //props.forEach(x=> console.log('  prop: ' + x.name()));
	        var pindex = cls.propertyIndex(pname);
	        if (pindex < 0) {
	            return null;
	        }
	        var llchilds = where.lowLevel().children();
	        //console.log('lookup: ' + pname + ' index: ' + pindex + ' childs: ' + llchilds.length);
	        for (var i = 0; i < llchilds.length; i++) {
	            var llch = llchilds[i];
	            //console.log('  child: ' + llch.kindName());
	            if (!llch.isMapping())
	                continue;
	            var cpnme = llch.asMapping().key.value;
	            var pi = cls.propertyIndex(cpnme);
	            //console.log('  property: ' + cpnme + ' index: ' + pi + ' at pos: ' + i);
	            if (pi > pindex) {
	                //console.log('  property: ' + cpnme + ' - found');
	                var lastok = i - 1;
	                //console.log('lastok: ' + lastok);
	                if (lastok < 0) {
	                    //TODO insert at the very beginning
	                    //console.log('insert to very beginning');
	                    return null;
	                }
	                else {
	                    console.log('insert to node: ' + lastok);
	                    return llchilds[lastok];
	                }
	            }
	            else {
	            }
	        }
	        return null;
	    }
	    //console.log('HL insertion: ' + toRet);
	    //return toRet;
	}
	function removeNodeFrom(source, node) {
	    if (source.isStub()) {
	        if (node instanceof hlimpl.ASTNodeImpl) {
	            var cm = node;
	            if (cm.isInEdit) {
	                return;
	            }
	        }
	        if (!source._children) {
	            return;
	        }
	        source._children = source._children.filter(function (x) { return x != node; });
	        return;
	    }
	    var command = new ll.CompositeCommand();
	    if (node instanceof hlimpl.ASTNodeImpl) {
	        var aNode = node;
	        if (!aNode.property().getAdapter(services.RAMLPropertyService).isMerged()) {
	            if (source.elementsOfKind(aNode.property().nameId()).length == 1) {
	                command.commands.push(ll.removeNode(source.lowLevel(), aNode.lowLevel().parent().parent()));
	            }
	            else {
	                command.commands.push(ll.removeNode(source.lowLevel(), aNode.lowLevel()));
	            }
	        }
	        else {
	            command.commands.push(ll.removeNode(source.lowLevel(), aNode.lowLevel()));
	        }
	    }
	    else {
	        command.commands.push(ll.removeNode(source.lowLevel(), node.lowLevel()));
	    }
	    source.lowLevel().execute(command);
	}
	exports.removeNodeFrom = removeNodeFrom;
	function initEmptyRAMLFile(node) {
	    var llroot = node.lowLevel().root();
	    var command = new ll.CompositeCommand();
	    var newroot = jsyaml.createMap([]);
	    command.commands.push(ll.initRamlFile(node.lowLevel(), newroot));
	    node.lowLevel().execute(command);
	    var root = node.root();
	    //console.log('root: ' + root);
	    root._node = newroot;
	    root.clearChildrenCache();
	}
	exports.initEmptyRAMLFile = initEmptyRAMLFile;
	function setValue(node, value) {
	    if (value == node.value())
	        return;
	    var c = new ll.CompositeCommand();
	    if (typeof value === 'string') {
	        var val = value;
	        //FIXME actually isFromParentKey should be enough in future does not changing it now for safety reasons
	        if (node.property().isFromParentKey() || node.property().isAnnotation()) {
	            if (node.property().isAnnotation()) {
	                val = '(' + val + ')';
	            }
	            c.commands.push(ll.setKey(node.lowLevel(), val));
	        }
	        else {
	            if ((!val || val.length == 0) && !node.isEmbedded()) {
	                c.commands.push(ll.removeNode(node.lowLevel().parent(), node.lowLevel()));
	                node.parent().clearChildrenCache();
	            }
	            else {
	                if (!val)
	                    val = '';
	                c.commands.push(ll.setAttr(node.lowLevel(), val));
	            }
	        }
	    }
	    else {
	        if (node.property().isFromParentKey()) {
	            throw new Error("couldn't set structured value to a key: " + node.property().nameId());
	        }
	        var sval = value;
	        c.commands.push(ll.setAttrStructured(node.lowLevel(), sval));
	    }
	    node.lowLevel().execute(c);
	}
	exports.setValue = setValue;
	function addStringValue(attr, value) {
	    var sc = jsyaml.createScalar(value);
	    var target = attr.lowLevel();
	    //console.log('add to target: ' + target.kindName());
	    if (target.isScalar()) {
	        target = target.parent();
	    }
	    else if (target.isMapping()) {
	    }
	    var command = new ll.CompositeCommand();
	    command.commands.push(ll.insertNode(target, sc, null, true));
	    attr.lowLevel().execute(command);
	    attr.parent().clearChildrenCache();
	}
	exports.addStringValue = addStringValue;
	function addStructuredValue(attr, sv) {
	    //var sc = jsyaml.createScalar(value);
	    var target = attr.lowLevel();
	    //console.log('add to target: ' + target.kindName());
	    if (target.isScalar()) {
	        target = target.parent();
	    }
	    else if (target.isMapping()) {
	        var ln = attr.lowLevel();
	    }
	    var command = new ll.CompositeCommand();
	    command.commands.push(ll.insertNode(target, sv.lowLevel(), null, true));
	    attr.lowLevel().execute(command);
	    attr.parent().clearChildrenCache();
	}
	exports.addStructuredValue = addStructuredValue;
	function removeAttr(attr) {
	    var llparent = attr.lowLevel().parent();
	    if (!attr.property().isMultiValue() && attr.isEmbedded()) {
	        // it's embedded value, need to clean scalar instead
	        //console.log('embedded!');
	        attr.setValue('');
	    }
	    else {
	        var command = new ll.CompositeCommand();
	        command.commands.push(ll.removeNode(llparent, attr.lowLevel()));
	        attr.lowLevel().execute(command);
	        attr.parent().clearChildrenCache();
	    }
	}
	exports.removeAttr = removeAttr;
	function setValues(attr, values) {
	    if (!attr.property().isMultiValue())
	        throw new Error("setValue(string[]) only apply to multi-values properties");
	    var node = attr.parent();
	    if (node && isTypeShortcut(node)) {
	        var command = new ll.CompositeCommand();
	        command.commands.push(ll.setAttr(node.lowLevel(), values[0]));
	        node.lowLevel().execute(command);
	        return;
	    }
	    if (attr.isEmpty()) {
	    }
	    else {
	        var llnode = node.lowLevel();
	        var attrs = node.attributes(attr.name());
	        attrs.forEach(function (attr) { return attr.remove(); });
	    }
	    if (values.length == 1 && attr.property().isDescriminator()) {
	        node.attrOrCreate(attr.name()).setValue(values[0]);
	    }
	    else {
	        values.forEach(function (val) {
	            return node.attrOrCreate(attr.name()).addValue(val);
	        });
	    }
	}
	exports.setValues = setValues;
	function setKey(node, value) {
	    if (value == node.name())
	        return;
	    var c = new ll.CompositeCommand();
	    c.commands.push(ll.setKey(node.lowLevel(), value));
	    node.lowLevel().execute(c);
	}
	exports.setKey = setKey;
	function isTypeShortcut(node) {
	    if (node.definition() && node.definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name)) {
	        if (node.lowLevel() && node.lowLevel().valueKind() === yaml.Kind.SCALAR) {
	            return true;
	        }
	    }
	    return false;
	}
	function createAttr(node, n, v) {
	    var mapping = jsyaml.createMapping(n, v);
	    var map;
	    if (node.definition() && node.definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name)) {
	        if (node.lowLevel() && (node.lowLevel().valueKind() === yaml.Kind.SCALAR || !node.lowLevel()._node.value)) {
	            var typePropertyName = n;
	            var typeMapping = jsyaml.createMapping(typePropertyName, node.lowLevel().value());
	            var command = new ll.CompositeCommand();
	            command.commands.push(ll.setAttr(node.lowLevel(), ""));
	            node.lowLevel().execute(command);
	            command = new ll.CompositeCommand();
	            var insertionPoint = findInsertionPointLowLevel(node, typeMapping, node.definition().property(typePropertyName), true);
	            command.commands.push(ll.insertNode(node.lowLevel(), typeMapping, insertionPoint));
	            node.lowLevel().execute(command);
	            node.resetChildren();
	            var attribute = node.attr(typePropertyName) && node.attr(typePropertyName).lowLevel();
	            if (attribute) {
	                command = new ll.CompositeCommand();
	                command.commands.push(ll.setAttr(attribute, v));
	                attribute.execute(command);
	                node.clearChildrenCache();
	                return;
	            }
	        }
	    }
	    //console.log('create attribute: ' + n);
	    if (node.isStub()) {
	        //console.log('create-attr: stub case');
	        var insertionIndex = findLastAttributeIndex(node);
	        //console.log('stub insertion index: ' + insertionIndex);
	        node.lowLevel().addChild(mapping, insertionIndex + 1);
	    }
	    else {
	        //console.log('root: ' + llroot.kindName());
	        if (node.isEmptyRamlFile()) {
	            node.initRamlFile();
	        }
	        //console.log('create-attr: real node case');
	        //node._node.addChild(mapping);
	        //node.clearChildrenCache();
	        var command = new ll.CompositeCommand();
	        var insertionPoint = findInsertionPointLowLevel(node, mapping, node.definition().property(n), true);
	        //command.commands.push(ll.insertNode(node.lowLevel(), mapping, null));
	        //var toseq = node.property().isMultiValue();
	        command.commands.push(ll.insertNode(node.lowLevel(), mapping, insertionPoint));
	        node.lowLevel().execute(command);
	    }
	    node.clearChildrenCache();
	}
	exports.createAttr = createAttr;
	function findLastAttribute(node) {
	    var childs = node.lowLevel().children();
	    var index = findLastAttributeIndex(node);
	    //console.log('last attr index2: ' + index);
	    return (index < 0) ? null : childs[index];
	}
	function addToNode(target, node) {
	    if (!target.isStub() && target.isEmptyRamlFile()) {
	        target.initRamlFile();
	    }
	    var llnode = node.lowLevel();
	    if (!target._children) {
	        target._children = [];
	    }
	    if (!node.property()) {
	        //now we should find correct property;
	        var an = node;
	        var allProps = target.definition().allProperties();
	        var cp = null;
	        allProps.forEach(function (x) {
	            var r = x.range();
	            if (r == an.definition()) {
	                cp = x;
	            }
	            var isOk = _.find(an.definition().allSuperTypes(), function (x) { return x == r; });
	            if (isOk) {
	                cp = x;
	            }
	        });
	        if (!cp) {
	            throw new Error("Unable to find correct child");
	        }
	        else {
	            an.patchProp(cp);
	        }
	    }
	    var insertionPoint = findInsertionPoint(target, node);
	    //console.log('high level op: ' + target.property() + '.add ' + node.property().name());
	    if (insertionPoint) {
	    }
	    //var newLowLevel:ll.ILowLevelASTNode=null;
	    var command = new ll.CompositeCommand();
	    //now we need to understand to which low level node it should go
	    //command.commands.push(ll.insertNode(target.lowLevel(), node.lowLevel()))
	    var insertionTarget = null;
	    if (node.property().getAdapter(services.RAMLPropertyService).isMerged() || node.property().range().hasValueTypeInHierarchy()) {
	        //console.log('CASE 1');
	        //newLowLevel = node.lowLevel();
	        command.commands.push(ll.insertNode(target.lowLevel(), node.lowLevel(), insertionPoint));
	        insertionTarget = target.lowLevel();
	    }
	    else {
	        //console.log('CASE 2');
	        var name = node.property().nameId();
	        var target2 = target.lowLevel();
	        //target.show('TARGET:');
	        //llnode.show('NODE:');
	        var found = target.lowLevel().find(name);
	        insertionTarget = found;
	        if (!found) {
	            //console.log('node not found');
	            var nn = null;
	            //var nn: jsyaml.ASTNode = jsyaml.createSeqNode(name);
	            //var mapping = <yaml.YAMLMapping>nn._actualNode();
	            //var seq: yaml.YAMLSequence = <yaml.YAMLSequence>mapping.value;
	            //if(!seq.items) seq.items = [];
	            //seq.items.push((<jsyaml.ASTNode>node.lowLevel())._actualNode());
	            if (node.property().getAdapter(services.RAMLPropertyService).isEmbedMap()) {
	                var v10 = target.definition().universe().version() == 'RAML10';
	                if (llnode.isValueMap() && v10)
	                    nn = jsyaml.createMapNode(name);
	                else
	                    nn = jsyaml.createSeqNode(name);
	                //console.log('NN: ' + yaml.Kind[nn._actualNode().kind]);
	                nn.addChild(node.lowLevel());
	            }
	            else {
	                nn = jsyaml.createNode(name);
	                nn.addChild(node.lowLevel());
	            }
	            //nn.show('WRAPPED NODE:');
	            //target.show('INSERT WRAPPED NODE TO:');
	            command.commands.push(ll.insertNode(target2, nn, insertionPoint));
	            insertionTarget = target2;
	        }
	        else {
	            var isEmptyTypes = found.value() === null && found.key && found.key() === universes.Universe10.Api.properties.types.name;
	            var needSeq = !isEmptyTypes && node.property().getAdapter(services.RAMLPropertyService).isEmbedMap();
	            command.commands.push(ll.insertNode(found, node.lowLevel(), insertionPoint, needSeq));
	        }
	    }
	    if (target.isStub()) {
	        var insertionIndex = findLastAttributeIndex(target);
	        if (insertionIndex < 0) {
	            target._children.push(node);
	        }
	        else {
	            //TODO behavior should be smarter we are ignoring insertion points now
	            target._children.splice(insertionIndex, 0, node);
	        }
	        command.commands.forEach(function (x) { return insertionTarget.addChild(x.value); });
	        return;
	    }
	    target.lowLevel().execute(command);
	    target._children.push(node);
	    //now we need to add new child to our children;
	    node.setParent(target);
	}
	exports.addToNode = addToNode;
	//# sourceMappingURL=mutators.js.map

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/main.d.ts" />
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var defs = __webpack_require__(36);
	var ramlTypes = defs.rt;
	var _ = __webpack_require__(63);
	var universes = __webpack_require__(22);
	var hlimpl = __webpack_require__(16);
	var services = defs;
	var linter = __webpack_require__(25);
	var universeHelpers = __webpack_require__(14);
	ramlTypes.setPropertyConstructor(function (x) {
	    var v = new defs.Property(x);
	    v.unmerge();
	    return v;
	});
	function templateFields(node, d) {
	    var u = node.root().definition().universe();
	    var key = node.lowLevel().key();
	    if (key) {
	        handleValue(key, d, null, true, u);
	    }
	    node.children().forEach(function (x) { return templateFields(x, d); });
	    if (node instanceof hlimpl.ASTPropImpl) {
	        var prop = node;
	        //TODO RECURSIVE PARAMETERS
	        var v = prop.value();
	        if (typeof v == 'string') {
	            var strV = v;
	            handleValue(strV, d, prop, false, u);
	        }
	        else {
	            node.lowLevel().visit(function (x) {
	                if (x.value()) {
	                    var strV = x.value() + "";
	                    handleValue(strV, d, prop, true, u);
	                }
	                return true;
	            });
	        }
	    }
	    else if (node instanceof hlimpl.BasicASTNode) {
	        var v = node.lowLevel().value();
	        if (typeof v == 'string') {
	            var strV = v;
	            handleValue(strV, d, null, false, u);
	        }
	        else {
	            node.lowLevel().visit(function (x) {
	                if (x.value()) {
	                    var strV = x.value() + "";
	                    handleValue(strV, d, null, true, u);
	                }
	                return true;
	            });
	        }
	    }
	}
	var extractUsedParamNames = function (strV) {
	    var parameterUsages = [];
	    var ps = 0;
	    while (true) {
	        var pos = strV.indexOf("<<", ps);
	        if (pos == -1) {
	            break;
	        }
	        var end = strV.indexOf(">>", pos);
	        var isFull = pos == 0 && end == strV.length - 2;
	        var parameterUsage = strV.substring(pos + 2, end);
	        ps = pos + 2;
	        var directiveIndex = parameterUsage.indexOf("|");
	        if (directiveIndex != -1) {
	            parameterUsage = parameterUsage.substring(0, directiveIndex);
	        }
	        parameterUsage = parameterUsage.trim();
	        parameterUsages.push(parameterUsage);
	    }
	    return { parameterUsages: parameterUsages, isFull: isFull };
	};
	var handleValue = function (strV, d, prop, allwaysString, u) {
	    var __ret = extractUsedParamNames(strV);
	    var parameterUsages = __ret.parameterUsages;
	    var isFull = __ret.isFull;
	    var r = (prop) ? prop.property().range() : null;
	    if (prop) {
	        if (prop.property().nameId() == universes.Universe10.TypeDeclaration.properties.type.name ||
	            prop.property().nameId() == universes.Universe10.TypeDeclaration.properties.schema.name) {
	            if (prop.property().domain().key() == universes.Universe10.TypeDeclaration) {
	                r = u.type(universes.Universe10.SchemaString.name);
	            }
	        }
	    }
	    if (!isFull || allwaysString) {
	        r = u.type(universes.Universe10.StringType.name);
	    }
	    else if (r == null && u.version() == "RAML10") {
	        r = u.type(universes.Universe10.AnyType.name);
	    }
	    for (var _i = 0, parameterUsages_1 = parameterUsages; _i < parameterUsages_1.length; _i++) {
	        var parameterUsage = parameterUsages_1[_i];
	        if (linter.RESERVED_TEMPLATE_PARAMETERS[parameterUsage] != null) {
	            //Handling reserved parameter names;
	            continue;
	        }
	        var q = d[parameterUsage];
	        //FIX ME NOT WHOLE TEMPLATES
	        if (q) {
	            q.push({
	                tp: r,
	                attr: prop
	            });
	        }
	        else {
	            d[parameterUsage] = [{
	                    tp: r,
	                    attr: prop
	                }];
	        }
	    }
	};
	function fillParamPaths(node, paramPaths, path) {
	    if (path === void 0) { path = []; }
	    if (node.optional()) {
	        path = path.concat("/");
	    }
	    var v = node.value();
	    if (typeof v == 'string') {
	        var strV = v;
	        var __ret = extractUsedParamNames(strV);
	        var parameterUsages = __ret.parameterUsages;
	        for (var _i = 0, parameterUsages_2 = parameterUsages; _i < parameterUsages_2.length; _i++) {
	            var pu = parameterUsages_2[_i];
	            var paths = paramPaths[pu];
	            if (paths == null) {
	                paths = [];
	                paramPaths[pu] = paths;
	            }
	            paths.push(path);
	        }
	    }
	    else {
	        for (var _a = 0, _b = node.children(); _a < _b.length; _a++) {
	            var ch = _b[_a];
	            fillParamPaths(ch, paramPaths, path.concat(ch.key()));
	        }
	    }
	}
	function fillTemplateType(result, node) {
	    var usages = {};
	    var paramPaths = {};
	    templateFields(node, usages);
	    fillParamPaths(node.lowLevel(), paramPaths);
	    for (var _i = 0, _a = Object.keys(paramPaths); _i < _a.length; _i++) {
	        var pu = _a[_i];
	        paramPaths[pu] = _.unique(paramPaths[pu]);
	    }
	    result.getAdapter(services.RAMLService).setInlinedTemplates(true);
	    Object.keys(usages).forEach(function (x) {
	        var propSource = null;
	        if (usages[x].length > 0) {
	            propSource = usages[x][0].attr;
	        }
	        var prop = new defs.UserDefinedProp(x, propSource);
	        //prop._node=node;
	        prop.withDomain(result);
	        var paths = paramPaths[x];
	        prop.getAdapter(services.RAMLPropertyService).putMeta("templatePaths", paths);
	        var defaultType;
	        if (node.definition().universe().version() == "RAML10") {
	            var hasString = usages[x].filter(function (y) { return universeHelpers.isStringTypeType(y.tp); }).length > 0;
	            defaultType = hasString ? universes.Universe10.StringType.name : universes.Universe10.AnyType.name;
	        }
	        else {
	            defaultType = universes.Universe08.StringType.name;
	        }
	        var tp = _.unique(usages[x].map(function (x) { return x.tp; })).filter(function (x) { return x && x.nameId() != defaultType; });
	        prop.withRange(tp.length == 1 ? tp[0] : node.definition().universe().type(defaultType));
	        prop.withRequired(true);
	        if (tp.length == 1 && node.definition().universe().version() == 'RAML10') {
	            if (tp[0].key() == universes.Universe10.SchemaString) {
	                prop.getAdapter(services.RAMLPropertyService).setTypeExpression(true);
	            }
	        }
	        prop.unmerge();
	    });
	    var keyProp = new defs.UserDefinedProp("____key", node);
	    //prop._node=node;
	    keyProp.withDomain(result);
	    keyProp.withKey(true);
	    keyProp.withFromParentKey(true);
	    keyProp.withRange(node.definition().universe().type(universes.Universe08.StringType.name));
	    return result;
	}
	function fillReferenceType(result, def) {
	    if (def.universe().version() == "RAML08") {
	        result.getAdapter(services.RAMLService).withAllowAny();
	    }
	    var p = def.property(def.getAdapter(services.RAMLService).getReferenceIs());
	    if (p) {
	        p.range().properties().forEach(function (x) {
	            var prop = new defs.Property(x.nameId());
	            prop.unmerge();
	            prop.withDomain(result);
	            prop.withRange(x.range());
	            prop.withMultiValue(x.isMultiValue());
	        });
	    }
	    return result;
	}
	var AnnotationType = (function (_super) {
	    __extends(AnnotationType, _super);
	    function AnnotationType() {
	        _super.apply(this, arguments);
	    }
	    AnnotationType.prototype.allProperties = function (ps) {
	        if (ps === void 0) { ps = {}; }
	        var rs = this.superTypes()[0].allProperties();
	        if (rs.length == 1 && rs[0].nameId() == "annotations") {
	            var propertyNode = this.getAdapter(defs.RAMLService).getDeclaringNode();
	            var property = new defs.UserDefinedProp("value", propertyNode);
	            property.withDomain(this);
	            property.withCanBeValue();
	            property.withRequired(false);
	            var tp = this.superTypes()[0];
	            rs = [];
	            property.withRange(property.node().asElement().definition().universe().type("string"));
	            rs.push(property);
	        }
	        return rs;
	    };
	    AnnotationType.prototype.isAnnotationType = function () {
	        return true;
	    };
	    return AnnotationType;
	}(defs.UserDefinedClass));
	function typeFromNode(node) {
	    if (!node) {
	        return null;
	    }
	    if (node.associatedType()) {
	        return node.associatedType();
	    }
	    var u = node.lowLevel().unit();
	    var upath = u ? u.path() : "";
	    ramlTypes.setPropertyConstructor(function (x) {
	        var propertySource = null;
	        var rs = node.elementsOfKind("properties").filter(function (y) { return y.name() == x; });
	        if (rs) {
	            propertySource = rs[0];
	        }
	        var v = new defs.UserDefinedProp(x, propertySource);
	        v.unmerge();
	        return v;
	    });
	    try {
	        var def = node.definition();
	        if (node.property() && node.property().nameId() == universes.Universe10.LibraryBase.properties.annotationTypes.name) {
	            //var st=node.definition().getAdapter(services.RAMLService).toRuntime();
	            var result = new AnnotationType(node.name(), node.definition().universe(), node, upath, "");
	            var st = getSimpleType(node);
	            result._superTypes.push(st);
	            if (node.elementsOfKind(universes.Universe10.ObjectTypeDeclaration.properties.properties.name).length == 0) {
	                result.getAdapter(services.RAMLService).withAllowAny();
	            }
	            var extType = def.getAdapter(services.RAMLService).getExtendedType();
	            if (extType) {
	                result._superTypes.push(extType);
	            }
	            return result;
	        }
	        else {
	            var result = new defs.UserDefinedClass(node.name(), node.definition().universe(), node, upath, "");
	        }
	        node.setAssociatedType(result);
	        //result.setDeclaringNode(node);
	        if (def.getAdapter(services.RAMLService).isInlinedTemplates()) {
	            return fillTemplateType(result, node);
	        }
	        else if (def.getAdapter(services.RAMLService).getReferenceIs()) {
	            return fillReferenceType(result, def);
	        }
	        var rs = getSimpleType(node);
	        rs.getAdapter(services.RAMLService).setDeclaringNode(node);
	        node.setAssociatedType(rs);
	    }
	    finally {
	        ramlTypes.setPropertyConstructor(null);
	    }
	    return rs;
	}
	exports.typeFromNode = typeFromNode;
	function getSimpleType(node) {
	    return ramlTypes.toNominal(node.parsedType(), function (x) {
	        var m = node.definition().universe().type(x);
	        if (!m) {
	            var ut = new defs.UserDefinedClass("", node.definition().universe(), node, "", "");
	        }
	        return m;
	    });
	}
	function transform(u) {
	    return function (x) {
	        var m = u.type(x);
	        if (!m) {
	            var ut = new defs.UserDefinedClass("", u, null, "", "");
	        }
	        return m;
	    };
	}
	function convertType(root, t) {
	    var node = _.find(root.elementsOfKind("types"), function (x) { return x.name() == t.name(); });
	    if (node) {
	        ramlTypes.setPropertyConstructor(function (x) {
	            var rs = node.elementsOfKind("properties").filter(function (y) { return y.name() == x; });
	            var propertySource = null;
	            if (rs && rs.length > 0) {
	                propertySource = rs[0];
	            }
	            else {
	                var rs = node.elementsOfKind("facets").filter(function (y) { return y.name() == x; });
	                if (rs && rs.length > 0) {
	                    propertySource = rs[0];
	                }
	            }
	            var v = new defs.UserDefinedProp(x, propertySource);
	            v.unmerge();
	            return v;
	        });
	    }
	    var u = transform(root.definition().universe());
	    return ramlTypes.toNominal(t, u);
	}
	exports.convertType = convertType;
	//# sourceMappingURL=typeBuilder.js.map

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/main.d.ts" />
	"use strict";
	function isMultiLine(s) {
	    return s && s.indexOf('\n') >= 0;
	}
	exports.isMultiLine = isMultiLine;
	function isMultiLineValue(s) {
	    return isMultiLine(s) && s.length > 2 && s[0] == '|' && (s[1] == '\n' || s[1] == '\r' || s[2] == '\n');
	}
	exports.isMultiLineValue = isMultiLineValue;
	function makeMutiLine(s, lev) {
	    var xbuf = '';
	    if (isMultiLine(s)) {
	        xbuf += '|\n';
	        var lines = splitOnLines(s);
	        for (var i = 0; i < lines.length; i++) {
	            xbuf += indent(lev, lines[i]);
	        }
	    }
	    else {
	        xbuf += s;
	    }
	    return xbuf;
	}
	exports.makeMutiLine = makeMutiLine;
	function fromMutiLine(s) {
	    if (!isMultiLineValue(s))
	        return s;
	    var res = null;
	    var lines = splitOnLines(s);
	    for (var i = 1; i < lines.length; i++) {
	        var line = lines[i];
	        var str = line.substring(2);
	        if (!res)
	            res = str;
	        else
	            res += str;
	    }
	    return res;
	}
	exports.fromMutiLine = fromMutiLine;
	function trimStart(s) {
	    if (!s)
	        return s;
	    var pos = 0;
	    while (pos < s.length) {
	        var ch = s[pos];
	        if (ch != '\r' && ch != '\n' && ch != ' ' && ch != '\t')
	            break;
	        pos++;
	    }
	    return s.substring(pos, s.length);
	}
	exports.trimStart = trimStart;
	function indent(lev, str) {
	    if (str === void 0) { str = ''; }
	    var leading = '';
	    //leading += '[' + lev + ']';
	    for (var i = 0; i < lev; i++)
	        leading += '  ';
	    return leading + str;
	}
	exports.indent = indent;
	function print(lev, str) {
	    if (str === void 0) { str = ''; }
	    console.log(indent(lev, str));
	}
	exports.print = print;
	function replaceNewlines(s, rep) {
	    if (rep === void 0) { rep = null; }
	    var res = '';
	    for (var i = 0; i < s.length; i++) {
	        var ch = s[i];
	        if (ch == '\r')
	            ch = rep == null ? '\\r' : rep;
	        if (ch == '\n')
	            ch = rep == null ? '\\n' : rep;
	        res += ch;
	    }
	    return res;
	}
	exports.replaceNewlines = replaceNewlines;
	function trimEnd(s) {
	    var pos = s.length;
	    while (pos > 0) {
	        var ch = s[pos - 1];
	        if (ch != ' ' && ch != '\t' && ch != '\r' && ch != '\n')
	            break;
	        pos--;
	    }
	    return s.substring(0, pos);
	}
	exports.trimEnd = trimEnd;
	function trim(s) {
	    return trimStart(trimEnd(s));
	}
	exports.trim = trim;
	function splitOnLines(text) {
	    var lines = text.match(/^.*((\r\n|\n|\r)|$)/gm);
	    return lines;
	}
	exports.splitOnLines = splitOnLines;
	function startsWith(s, suffix) {
	    if (!s || !suffix || s.length < suffix.length)
	        return false;
	    for (var i = 0; i < suffix.length; i++) {
	        if (s[i] != suffix[i])
	            return false;
	    }
	    return true;
	}
	exports.startsWith = startsWith;
	function endsWith(s, suffix) {
	    if (!s || !suffix || s.length < suffix.length)
	        return false;
	    for (var i = 0; i < suffix.length; i++) {
	        if (s[s.length - 1 - i] != suffix[suffix.length - 1 - i])
	            return false;
	    }
	    return true;
	}
	exports.endsWith = endsWith;
	function capitalize(s) {
	    return s.charAt(0).toUpperCase() + s.slice(1);
	}
	exports.capitalize = capitalize;
	var TextRange = (function () {
	    function TextRange(contents, start, end) {
	        this.contents = contents;
	        this.start = start;
	        this.end = end;
	    }
	    TextRange.prototype.text = function () {
	        return this.contents.substring(this.start, this.end);
	    };
	    TextRange.prototype.startpos = function () { return this.start; };
	    TextRange.prototype.endpos = function () { return this.end; };
	    TextRange.prototype.len = function () { return this.end - this.start; };
	    TextRange.prototype.unitText = function () { return this.contents; };
	    TextRange.prototype.withStart = function (start) {
	        return new TextRange(this.contents, start, this.end);
	    };
	    TextRange.prototype.withEnd = function (end) {
	        return new TextRange(this.contents, this.start, end);
	    };
	    TextRange.prototype.sub = function (start, end) {
	        return this.contents.substring(start, end);
	    };
	    TextRange.prototype.trimStart = function () {
	        var pos = this.start;
	        while (pos < this.contents.length - 1) {
	            var ch = this.contents[pos];
	            if (ch != ' ' && ch != '\t')
	                break;
	            pos++;
	        }
	        return new TextRange(this.contents, pos, this.end);
	    };
	    TextRange.prototype.trimEnd = function () {
	        var pos = this.end;
	        while (pos > 0) {
	            var ch = this.contents[pos - 1];
	            if (ch != ' ' && ch != '\t')
	                break;
	            pos--;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.extendToStartOfLine = function () {
	        var pos = this.start;
	        while (pos > 0) {
	            var prevchar = this.contents[pos - 1];
	            if (prevchar == '\r' || prevchar == '\n')
	                break;
	            pos--;
	        }
	        return new TextRange(this.contents, pos, this.end);
	    };
	    TextRange.prototype.extendAnyUntilNewLines = function () {
	        var pos = this.end;
	        if (pos > 0) {
	            var last = this.contents[pos - 1];
	            if (last == '\n')
	                return this;
	        }
	        while (pos < this.contents.length - 1) {
	            var nextchar = this.contents[pos];
	            if (nextchar == '\r' || nextchar == '\n')
	                break;
	            pos++;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.extendSpacesUntilNewLines = function () {
	        var pos = this.end;
	        if (pos > 0) {
	            var last = this.contents[pos - 1];
	            if (last == '\n')
	                return this;
	        }
	        while (pos < this.contents.length - 1) {
	            var nextchar = this.contents[pos];
	            if (nextchar != ' ' || nextchar == '\r' || nextchar == '\n')
	                break;
	            pos++;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.extendSpaces = function () {
	        var pos = this.end;
	        while (pos < this.contents.length - 1) {
	            var nextchar = this.contents[pos];
	            if (nextchar != ' ')
	                break;
	            pos++;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.extendSpacesBack = function () {
	        var pos = this.start;
	        while (pos > 0) {
	            var nextchar = this.contents[pos - 1];
	            if (nextchar != ' ')
	                break;
	            pos--;
	        }
	        return new TextRange(this.contents, pos, this.end);
	    };
	    TextRange.prototype.extendCharIfAny = function (ch) {
	        var pos = this.end;
	        if (pos < this.contents.length - 1 && this.contents[pos] == ch) {
	            pos++;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.extendCharIfAnyBack = function (ch) {
	        var pos = this.start;
	        if (pos > 0 && this.contents[pos - 1] == ch) {
	            pos--;
	        }
	        return new TextRange(this.contents, pos, this.end);
	    };
	    TextRange.prototype.extendToNewlines = function () {
	        var pos = this.end;
	        if (pos > 0) {
	            var last = this.contents[pos - 1];
	            if (last == '\n')
	                return this;
	        }
	        while (pos < this.contents.length - 1) {
	            var nextchar = this.contents[pos];
	            if (nextchar != '\r' && nextchar != '\n')
	                break;
	            pos++;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.extendUntilNewlinesBack = function () {
	        var pos = this.start;
	        while (pos > 0) {
	            var nextchar = this.contents[pos - 1];
	            if (nextchar == '\r' || nextchar == '\n')
	                break;
	            pos--;
	        }
	        return new TextRange(this.contents, pos, this.end);
	    };
	    TextRange.prototype.reduceNewlinesEnd = function () {
	        var pos = this.end;
	        while (pos > this.start) {
	            var last = this.contents[pos - 1];
	            if (last != '\r' && last != '\n')
	                break;
	            pos--;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.reduceSpaces = function () {
	        var pos = this.end;
	        while (pos > this.start) {
	            var last = this.contents[pos - 1];
	            if (last != ' ')
	                break;
	            pos--;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.replace = function (text) {
	        return this.sub(0, this.start) + text + this.sub(this.end, this.unitText().length);
	    };
	    TextRange.prototype.remove = function () {
	        return this.sub(0, this.start) + this.sub(this.end, this.unitText().length);
	    };
	    return TextRange;
	}());
	exports.TextRange = TextRange;
	//# sourceMappingURL=textutil.js.map

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var RamlWrapper = __webpack_require__(20);
	function getWrapperConstructor(definition) {
	    if (!definition.isBuiltIn())
	        return null;
	    return classMap[definition.nameId()];
	}
	/**
	 * @hidden
	 * Build Wrapper node corresponding to the High Level node
	 **/
	function buildWrapperNode(node, setAsTopLevel) {
	    if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	    var definition = node.definition();
	    var nodeClassName = definition.nameId();
	    var wrapperConstructor = getWrapperConstructor(definition);
	    if (!wrapperConstructor) {
	        var priorities = determineSuperclassesPriorities(definition);
	        var superTypes = definition.allSuperTypes().sort(function (x, y) { return priorities[x.nameId()] - priorities[y.nameId()]; });
	        var wr = null;
	        for (var i = 0; i < superTypes.length; i++) {
	            var superTypeName = superTypes[i].nameId();
	            wrapperConstructor = getWrapperConstructor(superTypes[i]);
	            if (superTypeName == "DataElement") {
	                wr = superTypeName;
	                //This is only case of nested hierarchy
	                continue;
	            }
	            if (superTypeName == "hl.BasicNode") {
	                //depth first
	                continue;
	            }
	            if (wrapperConstructor) {
	                break;
	            }
	        }
	        if (!wrapperConstructor) {
	            wr = superTypeName;
	        }
	    }
	    if (!wrapperConstructor) {
	        wrapperConstructor = classMap["hl.BasicNode"];
	    }
	    return wrapperConstructor(node, setAsTopLevel);
	}
	exports.buildWrapperNode = buildWrapperNode;
	function determineSuperclassesPriorities(td, priorities, path) {
	    if (priorities === void 0) { priorities = {}; }
	    if (path === void 0) { path = {}; }
	    var typeName = td.nameId();
	    if (path[typeName]) {
	        return;
	    }
	    path[typeName] = true;
	    var rank = (priorities[typeName] != null && priorities[typeName] + 1) || 0;
	    var superTypes = td.superTypes();
	    superTypes.forEach(function (x) {
	        var name = x.nameId();
	        var r = priorities[name];
	        if (r == null || rank > r) {
	            priorities[name] = rank;
	            determineSuperclassesPriorities(x, priorities, path);
	        }
	    });
	    delete path[typeName];
	    return priorities;
	}
	var classMap = {
	    "AbstractSecurityScheme": function (x, y) { return new RamlWrapper.AbstractSecuritySchemeImpl(x, y); },
	    "Annotable": function (x, y) { return new RamlWrapper.AnnotableImpl(x, y); },
	    "AnnotationRef": function (x) { return new RamlWrapper.AnnotationRefImpl(x); },
	    "AnnotationTarget": function (x) { return new RamlWrapper.AnnotationTargetImpl(x); },
	    "AnyType": function (x) { return new RamlWrapper.AnyTypeImpl(x); },
	    "Api": function (x, y) { return new RamlWrapper.ApiImpl(x, y); },
	    "ArrayTypeDeclaration": function (x, y) { return new RamlWrapper.ArrayTypeDeclarationImpl(x, y); },
	    "BasicSecurityScheme": function (x, y) { return new RamlWrapper.BasicSecuritySchemeImpl(x, y); },
	    "BooleanType": function (x) { return new RamlWrapper.BooleanTypeImpl(x); },
	    "BooleanTypeDeclaration": function (x, y) { return new RamlWrapper.BooleanTypeDeclarationImpl(x, y); },
	    "ContentType": function (x) { return new RamlWrapper.ContentTypeImpl(x); },
	    "CustomSecurityScheme": function (x, y) { return new RamlWrapper.CustomSecuritySchemeImpl(x, y); },
	    "DateOnlyType": function (x) { return new RamlWrapper.DateOnlyTypeImpl(x); },
	    "DateOnlyTypeDeclaration": function (x, y) { return new RamlWrapper.DateOnlyTypeDeclarationImpl(x, y); },
	    "DateTimeOnlyType": function (x) { return new RamlWrapper.DateTimeOnlyTypeImpl(x); },
	    "DateTimeOnlyTypeDeclaration": function (x, y) { return new RamlWrapper.DateTimeOnlyTypeDeclarationImpl(x, y); },
	    "DateTimeType": function (x) { return new RamlWrapper.DateTimeTypeImpl(x); },
	    "DateTimeTypeDeclaration": function (x, y) { return new RamlWrapper.DateTimeTypeDeclarationImpl(x, y); },
	    "DigestSecurityScheme": function (x, y) { return new RamlWrapper.DigestSecuritySchemeImpl(x, y); },
	    "DocumentationItem": function (x, y) { return new RamlWrapper.DocumentationItemImpl(x, y); },
	    "Extension": function (x, y) { return new RamlWrapper.ExtensionImpl(x, y); },
	    "FileType": function (x) { return new RamlWrapper.FileTypeImpl(x); },
	    "FileTypeDeclaration": function (x, y) { return new RamlWrapper.FileTypeDeclarationImpl(x, y); },
	    "FixedUriString": function (x) { return new RamlWrapper.FixedUriStringImpl(x); },
	    "FragmentDeclaration": function (x, y) { return new RamlWrapper.FragmentDeclarationImpl(x, y); },
	    "FullUriTemplateString": function (x) { return new RamlWrapper.FullUriTemplateStringImpl(x); },
	    "IntegerType": function (x) { return new RamlWrapper.IntegerTypeImpl(x); },
	    "IntegerTypeDeclaration": function (x, y) { return new RamlWrapper.IntegerTypeDeclarationImpl(x, y); },
	    "Library": function (x, y) { return new RamlWrapper.LibraryImpl(x, y); },
	    "LibraryBase": function (x, y) { return new RamlWrapper.LibraryBaseImpl(x, y); },
	    "LocationKind": function (x) { return new RamlWrapper.LocationKindImpl(x); },
	    "MarkdownString": function (x) { return new RamlWrapper.MarkdownStringImpl(x); },
	    "Method": function (x, y) { return new RamlWrapper.MethodImpl(x, y); },
	    "MethodBase": function (x, y) { return new RamlWrapper.MethodBaseImpl(x, y); },
	    "MimeType": function (x) { return new RamlWrapper.MimeTypeImpl(x); },
	    "ModelLocation": function (x) { return new RamlWrapper.ModelLocationImpl(x); },
	    "NullType": function (x) { return new RamlWrapper.NullTypeImpl(x); },
	    "NumberType": function (x) { return new RamlWrapper.NumberTypeImpl(x); },
	    "NumberTypeDeclaration": function (x, y) { return new RamlWrapper.NumberTypeDeclarationImpl(x, y); },
	    "OAuth1SecurityScheme": function (x, y) { return new RamlWrapper.OAuth1SecuritySchemeImpl(x, y); },
	    "OAuth1SecuritySchemeSettings": function (x, y) { return new RamlWrapper.OAuth1SecuritySchemeSettingsImpl(x, y); },
	    "OAuth2SecurityScheme": function (x, y) { return new RamlWrapper.OAuth2SecuritySchemeImpl(x, y); },
	    "OAuth2SecuritySchemeSettings": function (x, y) { return new RamlWrapper.OAuth2SecuritySchemeSettingsImpl(x, y); },
	    "ObjectTypeDeclaration": function (x, y) { return new RamlWrapper.ObjectTypeDeclarationImpl(x, y); },
	    "Operation": function (x, y) { return new RamlWrapper.OperationImpl(x, y); },
	    "Overlay": function (x, y) { return new RamlWrapper.OverlayImpl(x, y); },
	    "PassThroughSecurityScheme": function (x, y) { return new RamlWrapper.PassThroughSecuritySchemeImpl(x, y); },
	    "Reference": function (x) { return new RamlWrapper.ReferenceImpl(x); },
	    "RelativeUriString": function (x) { return new RamlWrapper.RelativeUriStringImpl(x); },
	    "Resource": function (x, y) { return new RamlWrapper.ResourceImpl(x, y); },
	    "ResourceBase": function (x, y) { return new RamlWrapper.ResourceBaseImpl(x, y); },
	    "ResourceType": function (x, y) { return new RamlWrapper.ResourceTypeImpl(x, y); },
	    "ResourceTypeRef": function (x) { return new RamlWrapper.ResourceTypeRefImpl(x); },
	    "Response": function (x, y) { return new RamlWrapper.ResponseImpl(x, y); },
	    "SchemaString": function (x) { return new RamlWrapper.SchemaStringImpl(x); },
	    "SecuritySchemePart": function (x, y) { return new RamlWrapper.SecuritySchemePartImpl(x, y); },
	    "SecuritySchemeRef": function (x) { return new RamlWrapper.SecuritySchemeRefImpl(x); },
	    "SecuritySchemeSettings": function (x, y) { return new RamlWrapper.SecuritySchemeSettingsImpl(x, y); },
	    "StatusCodeString": function (x) { return new RamlWrapper.StatusCodeStringImpl(x); },
	    "StringType": function (x) { return new RamlWrapper.StringTypeImpl(x); },
	    "StringTypeDeclaration": function (x, y) { return new RamlWrapper.StringTypeDeclarationImpl(x, y); },
	    "TimeOnlyType": function (x) { return new RamlWrapper.TimeOnlyTypeImpl(x); },
	    "TimeOnlyTypeDeclaration": function (x, y) { return new RamlWrapper.TimeOnlyTypeDeclarationImpl(x, y); },
	    "Trait": function (x, y) { return new RamlWrapper.TraitImpl(x, y); },
	    "TraitRef": function (x) { return new RamlWrapper.TraitRefImpl(x); },
	    "TypeDeclaration": function (x, y) { return new RamlWrapper.TypeDeclarationImpl(x, y); },
	    "UnionTypeDeclaration": function (x, y) { return new RamlWrapper.UnionTypeDeclarationImpl(x, y); },
	    "UriTemplate": function (x) { return new RamlWrapper.UriTemplateImpl(x); },
	    "UsesDeclaration": function (x, y) { return new RamlWrapper.UsesDeclarationImpl(x, y); },
	    "ValueType": function (x) { return new RamlWrapper.ValueTypeImpl(x); },
	    "XMLFacetInfo": function (x, y) { return new RamlWrapper.XMLFacetInfoImpl(x, y); }
	};
	//# sourceMappingURL=raml10factory.js.map

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var RamlWrapper = __webpack_require__(47);
	function getWrapperConstructor(definition) {
	    if (!definition.isBuiltIn())
	        return null;
	    return classMap[definition.nameId()];
	}
	/**
	 * @hidden
	 * Build Wrapper node corresponding to the High Level node
	 **/
	function buildWrapperNode(node, setAsTopLevel) {
	    if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	    var definition = node.definition();
	    var nodeClassName = definition.nameId();
	    var wrapperConstructor = getWrapperConstructor(definition);
	    if (!wrapperConstructor) {
	        var priorities = determineSuperclassesPriorities(definition);
	        var superTypes = definition.allSuperTypes().sort(function (x, y) { return priorities[x.nameId()] - priorities[y.nameId()]; });
	        var wr = null;
	        for (var i = 0; i < superTypes.length; i++) {
	            var superTypeName = superTypes[i].nameId();
	            wrapperConstructor = getWrapperConstructor(superTypes[i]);
	            if (superTypeName == "DataElement") {
	                wr = superTypeName;
	                //This is only case of nested hierarchy
	                continue;
	            }
	            if (superTypeName == "hl.BasicNode") {
	                //depth first
	                continue;
	            }
	            if (wrapperConstructor) {
	                break;
	            }
	        }
	        if (!wrapperConstructor) {
	            wr = superTypeName;
	        }
	    }
	    if (!wrapperConstructor) {
	        wrapperConstructor = classMap["hl.BasicNode"];
	    }
	    return wrapperConstructor(node, setAsTopLevel);
	}
	exports.buildWrapperNode = buildWrapperNode;
	function determineSuperclassesPriorities(td, priorities, path) {
	    if (priorities === void 0) { priorities = {}; }
	    if (path === void 0) { path = {}; }
	    var typeName = td.nameId();
	    if (path[typeName]) {
	        return;
	    }
	    path[typeName] = true;
	    var rank = (priorities[typeName] != null && priorities[typeName] + 1) || 0;
	    var superTypes = td.superTypes();
	    superTypes.forEach(function (x) {
	        var name = x.nameId();
	        var r = priorities[name];
	        if (r == null || rank > r) {
	            priorities[name] = rank;
	            determineSuperclassesPriorities(x, priorities, path);
	        }
	    });
	    delete path[typeName];
	    return priorities;
	}
	var classMap = {
	    "AbstractSecurityScheme": function (x, y) { return new RamlWrapper.AbstractSecuritySchemeImpl(x, y); },
	    "AnyType": function (x) { return new RamlWrapper.AnyTypeImpl(x); },
	    "Api": function (x, y) { return new RamlWrapper.ApiImpl(x, y); },
	    "BasicSecurityScheme": function (x, y) { return new RamlWrapper.BasicSecuritySchemeImpl(x, y); },
	    "BodyLike": function (x, y) { return new RamlWrapper.BodyLikeImpl(x, y); },
	    "BooleanType": function (x) { return new RamlWrapper.BooleanTypeImpl(x); },
	    "BooleanTypeDeclaration": function (x, y) { return new RamlWrapper.BooleanTypeDeclarationImpl(x, y); },
	    "CustomSecurityScheme": function (x, y) { return new RamlWrapper.CustomSecuritySchemeImpl(x, y); },
	    "DateTypeDeclaration": function (x, y) { return new RamlWrapper.DateTypeDeclarationImpl(x, y); },
	    "DigestSecurityScheme": function (x, y) { return new RamlWrapper.DigestSecuritySchemeImpl(x, y); },
	    "DocumentationItem": function (x, y) { return new RamlWrapper.DocumentationItemImpl(x, y); },
	    "ExampleString": function (x) { return new RamlWrapper.ExampleStringImpl(x); },
	    "FileTypeDeclaration": function (x, y) { return new RamlWrapper.FileTypeDeclarationImpl(x, y); },
	    "FixedUri": function (x) { return new RamlWrapper.FixedUriImpl(x); },
	    "FullUriTemplateString": function (x) { return new RamlWrapper.FullUriTemplateStringImpl(x); },
	    "GlobalSchema": function (x, y) { return new RamlWrapper.GlobalSchemaImpl(x, y); },
	    "IntegerTypeDeclaration": function (x, y) { return new RamlWrapper.IntegerTypeDeclarationImpl(x, y); },
	    "JSONBody": function (x, y) { return new RamlWrapper.JSONBodyImpl(x, y); },
	    "JSONExample": function (x) { return new RamlWrapper.JSONExampleImpl(x); },
	    "JSonSchemaString": function (x) { return new RamlWrapper.JSonSchemaStringImpl(x); },
	    "MarkdownString": function (x) { return new RamlWrapper.MarkdownStringImpl(x); },
	    "Method": function (x, y) { return new RamlWrapper.MethodImpl(x, y); },
	    "MethodBase": function (x, y) { return new RamlWrapper.MethodBaseImpl(x, y); },
	    "MimeType": function (x) { return new RamlWrapper.MimeTypeImpl(x); },
	    "NumberType": function (x) { return new RamlWrapper.NumberTypeImpl(x); },
	    "NumberTypeDeclaration": function (x, y) { return new RamlWrapper.NumberTypeDeclarationImpl(x, y); },
	    "OAuth1SecurityScheme": function (x, y) { return new RamlWrapper.OAuth1SecuritySchemeImpl(x, y); },
	    "OAuth1SecuritySchemeSettings": function (x, y) { return new RamlWrapper.OAuth1SecuritySchemeSettingsImpl(x, y); },
	    "OAuth2SecurityScheme": function (x, y) { return new RamlWrapper.OAuth2SecuritySchemeImpl(x, y); },
	    "OAuth2SecuritySchemeSettings": function (x, y) { return new RamlWrapper.OAuth2SecuritySchemeSettingsImpl(x, y); },
	    "Parameter": function (x, y) { return new RamlWrapper.ParameterImpl(x, y); },
	    "ParameterLocation": function (x) { return new RamlWrapper.ParameterLocationImpl(x); },
	    "RAMLSimpleElement": function (x, y) { return new RamlWrapper.RAMLSimpleElementImpl(x, y); },
	    "Reference": function (x) { return new RamlWrapper.ReferenceImpl(x); },
	    "RelativeUriString": function (x) { return new RamlWrapper.RelativeUriStringImpl(x); },
	    "Resource": function (x, y) { return new RamlWrapper.ResourceImpl(x, y); },
	    "ResourceType": function (x, y) { return new RamlWrapper.ResourceTypeImpl(x, y); },
	    "ResourceTypeRef": function (x) { return new RamlWrapper.ResourceTypeRefImpl(x); },
	    "Response": function (x, y) { return new RamlWrapper.ResponseImpl(x, y); },
	    "SchemaString": function (x) { return new RamlWrapper.SchemaStringImpl(x); },
	    "SecuritySchemePart": function (x, y) { return new RamlWrapper.SecuritySchemePartImpl(x, y); },
	    "SecuritySchemeRef": function (x) { return new RamlWrapper.SecuritySchemeRefImpl(x); },
	    "SecuritySchemeSettings": function (x, y) { return new RamlWrapper.SecuritySchemeSettingsImpl(x, y); },
	    "StatusCodeString": function (x) { return new RamlWrapper.StatusCodeStringImpl(x); },
	    "StringType": function (x) { return new RamlWrapper.StringTypeImpl(x); },
	    "StringTypeDeclaration": function (x, y) { return new RamlWrapper.StringTypeDeclarationImpl(x, y); },
	    "Trait": function (x, y) { return new RamlWrapper.TraitImpl(x, y); },
	    "TraitRef": function (x) { return new RamlWrapper.TraitRefImpl(x); },
	    "UriTemplate": function (x) { return new RamlWrapper.UriTemplateImpl(x); },
	    "ValueType": function (x) { return new RamlWrapper.ValueTypeImpl(x); },
	    "XMLBody": function (x, y) { return new RamlWrapper.XMLBodyImpl(x, y); },
	    "XMLExample": function (x) { return new RamlWrapper.XMLExampleImpl(x); },
	    "XMLSchemaString": function (x) { return new RamlWrapper.XMLSchemaStringImpl(x); }
	};
	//# sourceMappingURL=raml08factory.js.map

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/main.d.ts" />
	"use strict";
	var def = __webpack_require__(36);
	var ramlTypes = def.rt;
	var hl = __webpack_require__(10);
	var lowLevel = __webpack_require__(11);
	var universes = __webpack_require__(22);
	var _ = __webpack_require__(63);
	function getExtraProviderSource(extraProvider) {
	    var sourceExtra = extraProvider.getExtra(ramlTypes.SOURCE_EXTRA);
	    if (sourceExtra == null)
	        return null;
	    if (def.isSourceProvider(sourceExtra)) {
	        return sourceExtra;
	    }
	    if (lowLevel.isLowLevelNode(sourceExtra)) {
	        return {
	            getSource: function () {
	                return sourceExtra.highLevelNode();
	            }
	        };
	    }
	    if (hl.isParseResult(sourceExtra)) {
	        return {
	            getSource: function () {
	                return sourceExtra;
	            }
	        };
	    }
	    return null;
	}
	exports.getExtraProviderSource = getExtraProviderSource;
	function getRTypeSource(rType) {
	    return getExtraProviderSource(rType);
	}
	exports.getRTypeSource = getRTypeSource;
	function findRTypeByNominal(nominalType) {
	    var adapters = nominalType.getAdapters();
	    if (!adapters)
	        return null;
	    return _.find(adapters, function (adapter) {
	        return def.rt.isParsedType(adapter);
	    });
	}
	exports.findRTypeByNominal = findRTypeByNominal;
	function getNominalTypeSource(nominalType) {
	    if (!nominalType)
	        return null;
	    var sourceExtra = nominalType.getExtra(ramlTypes.SOURCE_EXTRA);
	    if (sourceExtra) {
	        return getExtraProviderSource(nominalType);
	    }
	    var rType = findRTypeByNominal(nominalType);
	    if (rType) {
	        return getRTypeSource(rType);
	    }
	    return null;
	}
	exports.getNominalTypeSource = getNominalTypeSource;
	function getNominalPropertySource(type, name) {
	    var typeSource = getNominalTypeSource(type);
	    if (!typeSource)
	        return null;
	    return {
	        getSource: function () {
	            var typeNode = typeSource.getSource();
	            var typeNodeElement = typeNode.asElement();
	            if (typeNodeElement == null)
	                return null;
	            var propertyElements = typeNodeElement.elementsOfKind(universes.Universe10.ObjectTypeDeclaration.properties.properties.name);
	            if (propertyElements == null || propertyElements.length == 0)
	                return null;
	            return _.find(propertyElements, function (propertyElement) {
	                return name == propertyElement.attrValue(universes.Universe10.TypeDeclaration.properties.name.name);
	            });
	        }
	    };
	}
	exports.getNominalPropertySource = getNominalPropertySource;
	function getNominalPropertySource2(property) {
	    return getNominalPropertySource(property.domain(), property.nameId());
	}
	exports.getNominalPropertySource2 = getNominalPropertySource2;
	//# sourceMappingURL=sourceFinder.js.map

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var hlImpl = __webpack_require__(16);
	var jsyaml = __webpack_require__(27);
	var def = __webpack_require__(36);
	var ramlService = def;
	var defaultCalculator = __webpack_require__(68);
	var search = __webpack_require__(23);
	var universeHelpers = __webpack_require__(14);
	var tckDumper = __webpack_require__(69);
	var yaml = __webpack_require__(72);
	var BasicNodeImpl = (function () {
	    /**
	     * @hidden
	     **/
	    function BasicNodeImpl(_node, setAsWrapper) {
	        if (setAsWrapper === void 0) { setAsWrapper = true; }
	        this._node = _node;
	        this._meta = new NodeMetadataImpl(false, false, universeHelpers.isMethodType(this.highLevel().definition()) && this.optional());
	        if (setAsWrapper) {
	            _node.setWrapperNode(this);
	        }
	    }
	    /**
	     * @hidden
	     **/
	    BasicNodeImpl.prototype.wrapperClassName = function () {
	        return 'BasicNodeImpl';
	    };
	    BasicNodeImpl.prototype.kind = function () {
	        return 'BasicNode';
	    };
	    /**
	     * @return Direct ancestor in RAML hierarchy
	     **/
	    BasicNodeImpl.prototype.parent = function () {
	        var parent = this._node.parent();
	        return parent ? parent.wrapperNode() : null;
	    };
	    /**
	     * @hidden
	     * @return Underlying node of the High Level model
	     **/
	    BasicNodeImpl.prototype.highLevel = function () {
	        return this._node;
	    };
	    /**
	     * @hidden
	     * Replace underlying high level node
	     **/
	    BasicNodeImpl.prototype.patchNode = function (node) {
	        this._node = node;
	    };
	    /**
	     * @hidden
	     **/
	    BasicNodeImpl.prototype.attributes = function (name, constr) {
	        var attrs = this._node.attributes(name);
	        if (!attrs || attrs.length == 0) {
	            var defaultValue = this.getDefaultsCalculator().
	                attributeDefaultIfEnabled(this._node, this._node.definition().property(name));
	            if (defaultValue == null)
	                return [];
	            return Array.isArray(defaultValue) ? defaultValue : [defaultValue];
	        }
	        //TODO not sure if we want to artificially create missing attributes having
	        //default values
	        return attributesToValues(attrs, constr);
	    };
	    /**
	     * @hidden
	     **/
	    BasicNodeImpl.prototype.attribute = function (name, constr) {
	        var attr = this._node.attr(name);
	        if (constr && !(constr == this.toString ||
	            constr == this.toBoolean ||
	            constr == this.toNumber ||
	            constr == this.toAny)) {
	            //we're not putting values directly inside anything, besides the default
	            //convertors for default types we support
	            if (attr == null)
	                return null;
	            return constr(attr);
	        }
	        var attributeValue = attr ? attr.value() : null;
	        if (attributeValue == null) {
	            attributeValue = this.getDefaultsCalculator().
	                attributeDefaultIfEnabled(this._node, this._node.definition().property(name));
	        }
	        if (attributeValue == null)
	            return null;
	        if (constr) {
	            return constr(attributeValue);
	        }
	        else {
	            return attributeValue;
	        }
	    };
	    /**
	     * @hidden
	     **/
	    BasicNodeImpl.prototype.elements = function (name) {
	        var elements = this._node.elementsOfKind(name);
	        if (!elements) {
	            return null;
	        }
	        return elements.map(function (x) { return x.wrapperNode(); });
	    };
	    /**
	     * @hidden
	     **/
	    BasicNodeImpl.prototype.element = function (name) {
	        var element = this._node.element(name);
	        if (!element) {
	            return null;
	        }
	        return element.wrapperNode();
	    };
	    /**
	     * Append node as child
	     * @param node node to be appended
	     **/
	    BasicNodeImpl.prototype.add = function (node) {
	        this.highLevel().add(node.highLevel());
	    };
	    /**
	     * Append node as property value
	     * @param node node to be set as property value
	     * @param prop name of property to set value for
	     **/
	    BasicNodeImpl.prototype.addToProp = function (node, prop) {
	        var hl = node.highLevel();
	        var pr = this.highLevel().definition().property(prop);
	        hl._prop = pr;
	        this.highLevel().add(hl);
	    };
	    /**
	     * Remove node from children set
	     * @param node node to be removed
	     **/
	    BasicNodeImpl.prototype.remove = function (node) {
	        this.highLevel().remove(node.highLevel());
	    };
	    /**
	     * @return YAML string representing the node
	     **/
	    BasicNodeImpl.prototype.dump = function () {
	        return this.highLevel().dump("yaml");
	    };
	    BasicNodeImpl.prototype.toString = function (arg) {
	        var obj;
	        //kind of instanceof for hl.IAttribute without actually calling instanceof
	        if (arg.lowLevel && arg.property) {
	            obj = arg.value();
	        }
	        else {
	            obj = arg;
	        }
	        return obj != null ? obj.toString() : obj;
	    };
	    BasicNodeImpl.prototype.toAny = function (arg) {
	        return arg;
	    };
	    BasicNodeImpl.prototype.toBoolean = function (arg) {
	        var obj;
	        //kind of instanceof for hl.IAttribute without actually calling instanceof
	        if (arg.lowLevel && arg.property) {
	            obj = arg.value();
	        }
	        else {
	            obj = arg;
	        }
	        return obj != null ? obj.toString() == 'true' : obj;
	    };
	    BasicNodeImpl.prototype.toNumber = function (arg) {
	        var obj;
	        //kind of instanceof for hl.IAttribute without actually calling instanceof
	        if (arg.lowLevel && arg.property) {
	            obj = arg.value();
	        }
	        else {
	            obj = arg;
	        }
	        if (!obj) {
	            return obj;
	        }
	        try {
	            var nValue = parseFloat(obj.toString());
	            return nValue;
	        }
	        catch (e) { }
	        return Number.MAX_VALUE;
	    };
	    /**
	     * @return Array of errors
	     **/
	    BasicNodeImpl.prototype.errors = function () {
	        var _this = this;
	        var issues = [];
	        var highLevelErrors = this._node.errors();
	        if (highLevelErrors != null) {
	            issues = issues.concat(highLevelErrors);
	        }
	        var rawResult = issues.map(function (x) { return _this.basicError(x); });
	        var result = this.filterErrors(rawResult);
	        return result;
	    };
	    BasicNodeImpl.prototype.filterErrors = function (rawErrors) {
	        var result = [];
	        var errorsMap = {};
	        rawErrors.map(function (x) { errorsMap[JSON.stringify(x)] = x; });
	        var keys = Object.keys(errorsMap);
	        for (var i = 0; i < keys.length; i++) {
	            result.push(errorsMap[keys[i]]);
	        }
	        //console.log("errorsMap:" + JSON.stringify(errorsMap, null, 4));
	        //console.log("rawErrors:" + JSON.stringify(rawErrors, null, 4));
	        //console.log("result:" + JSON.stringify(result, null, 4));
	        return result;
	    };
	    BasicNodeImpl.prototype.basicError = function (x) {
	        var _this = this;
	        var lineMapper = (x.node && x.node.lowLevel() && x.node.lowLevel().unit().lineMapper())
	            || this._node.lowLevel().unit().lineMapper();
	        var startPoint = null;
	        try {
	            startPoint = lineMapper.position(x.start);
	        }
	        catch (e) {
	            console.warn(e);
	        }
	        var endPoint = null;
	        try {
	            endPoint = lineMapper.position(x.end);
	        }
	        catch (e) {
	            console.warn(e);
	        }
	        var path;
	        if (x.path) {
	            path = x.path;
	        }
	        else if (x.node) {
	            path = x.node.lowLevel().unit().path();
	        }
	        else {
	            path = search.declRoot(this.highLevel()).lowLevel().unit().path();
	        }
	        var eObj = {
	            code: x.code,
	            message: x.message,
	            path: path,
	            range: {
	                start: startPoint,
	                end: endPoint
	            },
	            isWarning: x.isWarning
	        };
	        if (x.extras && x.extras.length > 0) {
	            eObj.trace = x.extras.map(function (y) { return _this.basicError(y); });
	        }
	        return eObj;
	    };
	    /**
	     * @return object representing class of the node
	     **/
	    BasicNodeImpl.prototype.definition = function () {
	        return this.highLevel().definition();
	    };
	    /**
	     * @return for user class instances returns object representing actual user class
	     **/
	    BasicNodeImpl.prototype.runtimeDefinition = function () {
	        if (universeHelpers.isTypeDeclarationSibling(this.highLevel().definition())) {
	            return this.highLevel().localType();
	        }
	        return null;
	    };
	    BasicNodeImpl.prototype.toJSON = function (serializeOptions) {
	        var oldDefaults = defaultAttributeDefaultsValue;
	        defaultAttributeDefaultsValue = this.attributeDefaults();
	        try {
	            return new tckDumper.TCKDumper(serializeOptions).dump(this);
	        }
	        finally {
	            defaultAttributeDefaultsValue = oldDefaults;
	        }
	    };
	    /**
	     * @return Whether the element is an optional sibling of trait or resource type
	     **/
	    BasicNodeImpl.prototype.optional = function () {
	        var highLevel = this.highLevel();
	        return highLevel != null ? highLevel.optional() : false;
	    };
	    /**
	     * @return For siblings of traits or resource types returns an array of optional properties names.
	     **/
	    BasicNodeImpl.prototype.optionalProperties = function () {
	        if (!this.highLevel()) {
	            return [];
	        }
	        return this.highLevel().optionalProperties();
	    };
	    /**
	     * @hidden
	     **/
	    BasicNodeImpl.prototype.getDefaultsCalculator = function () {
	        if (this.defaultsCalculator) {
	            return this.defaultsCalculator;
	        }
	        if (this.parent()) {
	            this.defaultsCalculator = this.parent().getDefaultsCalculator();
	        }
	        if (!this.defaultsCalculator) {
	            this.defaultsCalculator = new defaultCalculator.AttributeDefaultsCalculator(defaultAttributeDefaultsValue);
	        }
	        return this.defaultsCalculator;
	    };
	    /**
	     * @hidden
	     **/
	    BasicNodeImpl.prototype.setAttributeDefaults = function (attributeDefaults) {
	        this.defaultsCalculator = new defaultCalculator.AttributeDefaultsCalculator(attributeDefaults);
	    };
	    BasicNodeImpl.prototype.attributeDefaults = function () {
	        return this.getDefaultsCalculator() && this.getDefaultsCalculator().isEnabled();
	    };
	    BasicNodeImpl.prototype.meta = function () {
	        return fillElementMeta(this);
	    };
	    BasicNodeImpl.prototype.RAMLVersion = function () {
	        return this.highLevel().definition().universe().version();
	    };
	    return BasicNodeImpl;
	}());
	exports.BasicNodeImpl = BasicNodeImpl;
	var defaultAttributeDefaultsValue = true;
	var AttributeNodeImpl = (function () {
	    function AttributeNodeImpl(attr) {
	        this._meta = new ValueMetadataImpl();
	        this.attr = attr;
	    }
	    /**
	     * @return Underlying High Level attribute node
	     **/
	    AttributeNodeImpl.prototype.highLevel = function () { return this.attr; };
	    /**
	     * @hidden
	     **/
	    AttributeNodeImpl.prototype.wrapperClassName = function () {
	        return 'AttributeNodeImpl';
	    };
	    AttributeNodeImpl.prototype.kind = function () {
	        return 'AttributeNode';
	    };
	    /**
	     * @return Whether the element is an optional sibling of trait or resource type
	     **/
	    AttributeNodeImpl.prototype.optional = function () {
	        var highLevel = this.highLevel();
	        return highLevel != null ? highLevel.optional() : false;
	    };
	    AttributeNodeImpl.prototype.meta = function () {
	        return this._meta;
	    };
	    AttributeNodeImpl.prototype.RAMLVersion = function () {
	        return this.highLevel().definition().universe().version();
	    };
	    AttributeNodeImpl.prototype.parent = function () {
	        var parent = this.attr.parent();
	        return parent ? parent.wrapperNode() : null;
	    };
	    AttributeNodeImpl.prototype.toJSON = function (serializeOptions) {
	        return new tckDumper.TCKDumper(serializeOptions).dump(this);
	    };
	    return AttributeNodeImpl;
	}());
	exports.AttributeNodeImpl = AttributeNodeImpl;
	/**
	 * @hidden
	 **/
	function toStructuredValue(node) {
	    var value = node.value();
	    if (typeof value === 'string' || value == null) {
	        var mockNode = jsyaml.createNode(value, null, node.lowLevel().unit());
	        mockNode._actualNode().startPosition = node.lowLevel().valueStart();
	        mockNode._actualNode().endPosition = node.lowLevel().valueEnd();
	        var stv = new hlImpl.StructuredValue(mockNode, node.parent(), node.property());
	        return stv;
	    }
	    else {
	        return value;
	    }
	}
	exports.toStructuredValue = toStructuredValue;
	var TypeInstanceImpl = (function () {
	    function TypeInstanceImpl(nodes, type) {
	        this.type = type;
	        if (!Array.isArray(nodes)) {
	            this.node = nodes;
	        }
	        else {
	            this.children = nodes;
	        }
	    }
	    TypeInstanceImpl.prototype.properties = function () {
	        return this.isArray() ? [] : this.getChildren().map(function (x) { return new TypeInstancePropertyImpl(x); });
	    };
	    TypeInstanceImpl.prototype.getChildren = function () {
	        return (this.node && this.node.children()) || this.children;
	    };
	    TypeInstanceImpl.prototype.value = function () {
	        return this.node && this.node.value();
	    };
	    TypeInstanceImpl.prototype.isScalar = function () {
	        if (!this.node) {
	            return false;
	        }
	        if (this.node.children().length != 0) {
	            return false;
	        }
	        if (this.type) {
	            return this.type.isScalar();
	        }
	        return true;
	    };
	    TypeInstanceImpl.prototype.toJSON = function () {
	        return new tckDumper.TCKDumper().serializeTypeInstance(this);
	    };
	    TypeInstanceImpl.prototype.isArray = function () {
	        if (!this.node) {
	            return false;
	        }
	        if (this.type) {
	            return this.type.isArray();
	        }
	        return this.node && this.node.valueKind() == yaml.Kind.SEQ;
	    };
	    TypeInstanceImpl.prototype.items = function () {
	        return this.isArray() ? this.node.children().map(function (x) { return new TypeInstanceImpl(x); }) : null;
	    };
	    return TypeInstanceImpl;
	}());
	exports.TypeInstanceImpl = TypeInstanceImpl;
	var TypeInstancePropertyImpl = (function () {
	    function TypeInstancePropertyImpl(node) {
	        this.node = node;
	    }
	    TypeInstancePropertyImpl.prototype.name = function () {
	        return this.node.optional() ? this.node.key() + "?" : this.node.key();
	    };
	    TypeInstancePropertyImpl.prototype.value = function () {
	        if (this.isArray()) {
	            var children = this.node.children();
	            return children.length > 0 ? new TypeInstanceImpl(children[0]) : null;
	        }
	        else {
	            return new TypeInstanceImpl(this.node);
	        }
	    };
	    TypeInstancePropertyImpl.prototype.values = function () {
	        return this.isArray()
	            ? this.node.children().map(function (x) { return new TypeInstanceImpl(x); })
	            : [new TypeInstanceImpl(this.node)];
	    };
	    TypeInstancePropertyImpl.prototype.isArray = function () {
	        var children = this.node.children();
	        if (children.length > 0 && children[0].key() == null) {
	            return true;
	        }
	        var hl = this.node.highLevelNode();
	        if (hl) {
	            var prop = hl.property();
	            if (prop) {
	                var range = prop.range();
	                if (range) {
	                    return range.isArray();
	                }
	            }
	        }
	        return this.node.valueKind() == yaml.Kind.SEQ;
	    };
	    return TypeInstancePropertyImpl;
	}());
	exports.TypeInstancePropertyImpl = TypeInstancePropertyImpl;
	var ValueMetadataImpl = (function () {
	    function ValueMetadataImpl(_insertedAsDefault, _calculated, _optional) {
	        if (_insertedAsDefault === void 0) { _insertedAsDefault = false; }
	        if (_calculated === void 0) { _calculated = false; }
	        if (_optional === void 0) { _optional = false; }
	        this._insertedAsDefault = _insertedAsDefault;
	        this._calculated = _calculated;
	        this._optional = _optional;
	    }
	    ValueMetadataImpl.prototype.calculated = function () { return this._calculated; };
	    ValueMetadataImpl.prototype.insertedAsDefault = function () { return this._insertedAsDefault; };
	    ValueMetadataImpl.prototype.setCalculated = function () {
	        this._calculated = true;
	    };
	    ValueMetadataImpl.prototype.setInsertedAsDefault = function () {
	        this._insertedAsDefault = true;
	    };
	    ValueMetadataImpl.prototype.setOptional = function () {
	        this._optional = true;
	    };
	    ValueMetadataImpl.prototype.optional = function () {
	        return this._optional;
	    };
	    ValueMetadataImpl.prototype.isDefault = function () {
	        return !(this._insertedAsDefault || this._calculated || this._optional);
	    };
	    ValueMetadataImpl.prototype.toJSON = function () {
	        var obj = {};
	        if (this._calculated) {
	            obj['calculated'] = true;
	        }
	        if (this._insertedAsDefault) {
	            obj['insertedAsDefault'] = true;
	        }
	        if (this._optional) {
	            obj['optional'] = true;
	        }
	        return obj;
	    };
	    return ValueMetadataImpl;
	}());
	exports.ValueMetadataImpl = ValueMetadataImpl;
	var NodeMetadataImpl = (function (_super) {
	    __extends(NodeMetadataImpl, _super);
	    function NodeMetadataImpl() {
	        _super.apply(this, arguments);
	        this.valuesMeta = {};
	    }
	    NodeMetadataImpl.prototype.primitiveValuesMeta = function () { return this.valuesMeta; };
	    NodeMetadataImpl.prototype.registerInsertedAsDefaultValue = function (propName) {
	        var pMeta = this.valuesMeta[propName];
	        if (pMeta == null) {
	            this.valuesMeta[propName] = new ValueMetadataImpl(true);
	        }
	        else {
	            pMeta.setInsertedAsDefault();
	        }
	    };
	    NodeMetadataImpl.prototype.registerCalculatedValue = function (propName) {
	        var pMeta = this.valuesMeta[propName];
	        if (pMeta == null) {
	            this.valuesMeta[propName] = new ValueMetadataImpl(false, true);
	        }
	        else {
	            pMeta.setCalculated();
	        }
	    };
	    NodeMetadataImpl.prototype.registerOptionalValue = function (propName) {
	        var pMeta = this.valuesMeta[propName];
	        if (pMeta == null) {
	            this.valuesMeta[propName] = new ValueMetadataImpl(false, false, true);
	        }
	        else {
	            pMeta.setOptional();
	        }
	    };
	    NodeMetadataImpl.prototype.resetPrimitiveValuesMeta = function () {
	        this.valuesMeta = {};
	    };
	    NodeMetadataImpl.prototype.isDefault = function () {
	        if (!_super.prototype.isDefault.call(this)) {
	            return false;
	        }
	        return Object.keys(this.valuesMeta).length == 0;
	    };
	    NodeMetadataImpl.prototype.toJSON = function () {
	        var _this = this;
	        var obj = _super.prototype.toJSON.call(this);
	        var valuesObj = {};
	        var propKeys = Object.keys(this.valuesMeta);
	        if (propKeys.length > 0) {
	            propKeys.forEach(function (x) {
	                var childMeta = _this.valuesMeta[x].toJSON();
	                if (Object.keys(childMeta).length > 0) {
	                    valuesObj[x] = childMeta;
	                }
	            });
	            obj['primitiveValuesMeta'] = valuesObj;
	        }
	        return obj;
	    };
	    return NodeMetadataImpl;
	}(ValueMetadataImpl));
	exports.NodeMetadataImpl = NodeMetadataImpl;
	function fillElementMeta(node) {
	    var meta = node._meta;
	    meta.resetPrimitiveValuesMeta();
	    var highLevelNode = node.highLevel();
	    highLevelNode.definition().allProperties().forEach(function (p) {
	        var name = p.nameId();
	        var attrs = highLevelNode.attributes(name);
	        var gotValue = false;
	        var optional = false;
	        attrs.forEach(function (a) {
	            gotValue = gotValue || a.value() != null;
	            optional = optional || a.optional();
	        });
	        if (!gotValue) {
	            var calculator = node.getDefaultsCalculator();
	            var defVal = calculator.attributeDefaultIfEnabled(highLevelNode, p);
	            if (defVal != null) {
	                var insertionKind = calculator.insertionKind(highLevelNode, p);
	                if (insertionKind == defaultCalculator.InsertionKind.CALCULATED) {
	                    meta.registerCalculatedValue(name);
	                }
	                else if (insertionKind == defaultCalculator.InsertionKind.BY_DEFAULT) {
	                    meta.registerInsertedAsDefaultValue(name);
	                }
	            }
	        }
	    });
	    return meta;
	}
	exports.fillElementMeta = fillElementMeta;
	function attributesToValues(attrs, constr) {
	    if (constr) {
	        return attrs.map(function (x) { return constr(x); });
	    }
	    else {
	        return attrs.map(function (x) { return x.value(); });
	    }
	}
	exports.attributesToValues = attributesToValues;
	//# sourceMappingURL=parserCore.js.map

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var stubs = __webpack_require__(17);
	var def = __webpack_require__(36);
	var core = __webpack_require__(46);
	var apiLoader = __webpack_require__(9);
	var helper = __webpack_require__(48);
	var ApiImpl = (function (_super) {
	    __extends(ApiImpl, _super);
	    function ApiImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * The title property is a short plain text description of the RESTful API. The value SHOULD be suitable for use as a title for the contained user documentation.
	     **/
	    ApiImpl.prototype.title = function () {
	        return _super.prototype.attribute.call(this, 'title', this.toString);
	    };
	    /**
	     * @hidden
	     * Set title value
	     **/
	    ApiImpl.prototype.setTitle = function (param) {
	        this.highLevel().attrOrCreate("title").setValue("" + param);
	        return this;
	    };
	    /**
	     * If the RAML API definition is targeted to a specific API version, the API definition MUST contain a version property. The version property is OPTIONAL and should not be used if: The API itself is not versioned. The API definition does not change between versions. The API architect can decide whether a change to user documentation elements, but no change to the API's resources, constitutes a version change. The API architect MAY use any versioning scheme so long as version numbers retain the same format. For example, 'v3', 'v3.0', and 'V3' are all allowed, but are not considered to be equal.
	     **/
	    ApiImpl.prototype.version = function () {
	        return _super.prototype.attribute.call(this, 'version', this.toString);
	    };
	    /**
	     * @hidden
	     * Set version value
	     **/
	    ApiImpl.prototype.setVersion = function (param) {
	        this.highLevel().attrOrCreate("version").setValue("" + param);
	        return this;
	    };
	    /**
	     * (Optional during development; Required after implementation) A RESTful API's resources are defined relative to the API's base URI. The use of the baseUri field is OPTIONAL to allow describing APIs that have not yet been implemented. After the API is implemented (even a mock implementation) and can be accessed at a service endpoint, the API definition MUST contain a baseUri property. The baseUri property's value MUST conform to the URI specification RFC2396 or a Level 1 Template URI as defined in RFC6570. The baseUri property SHOULD only be used as a reference value.
	     **/
	    ApiImpl.prototype.baseUri = function () {
	        return _super.prototype.attribute.call(this, 'baseUri', function (attr) { return new FullUriTemplateStringImpl(attr); });
	    };
	    /**
	     * Base uri parameters are named parameters which described template parameters in the base uri
	     * @hidden
	     **/
	    ApiImpl.prototype.baseUriParameters_original = function () {
	        return _super.prototype.elements.call(this, 'baseUriParameters');
	    };
	    /**
	     * URI parameters can be further defined by using the uriParameters property. The use of uriParameters is OPTIONAL. The uriParameters property MUST be a map in which each key MUST be the name of the URI parameter as defined in the baseUri property. The uriParameters CANNOT contain a key named version because it is a reserved URI parameter name. The value of the uriParameters property is itself a map that specifies  the property's attributes as named parameters
	     **/
	    ApiImpl.prototype.uriParameters = function () {
	        return _super.prototype.elements.call(this, 'uriParameters');
	    };
	    /**
	     * A RESTful API can be reached HTTP, HTTPS, or both. The protocols property MAY be used to specify the protocols that an API supports. If the protocols property is not specified, the protocol specified at the baseUri property is used. The protocols property MUST be an array of strings, of values `HTTP` and/or `HTTPS`.
	     **/
	    ApiImpl.prototype.protocols = function () {
	        return _super.prototype.attributes.call(this, 'protocols', this.toString);
	    };
	    /**
	     * @hidden
	     * Set protocols value
	     **/
	    ApiImpl.prototype.setProtocols = function (param) {
	        this.highLevel().attrOrCreate("protocols").setValue("" + param);
	        return this;
	    };
	    /**
	     * (Optional) The media types returned by API responses, and expected from API requests that accept a body, MAY be defaulted by specifying the mediaType property. This property is specified at the root level of the API definition. The property's value MAY be a single string with a valid media type described in the specification.
	     **/
	    ApiImpl.prototype.mediaType = function () {
	        return _super.prototype.attribute.call(this, 'mediaType', function (attr) { return new MimeTypeImpl(attr); });
	    };
	    /**
	     * To better achieve consistency and simplicity, the API definition SHOULD include an OPTIONAL schemas property in the root section. The schemas property specifies collections of schemas that could be used anywhere in the API definition. The value of the schemas property is an array of maps; in each map, the keys are the schema name, and the values are schema definitions. The schema definitions MAY be included inline or by using the RAML !include user-defined data type.
	     **/
	    ApiImpl.prototype.schemas = function () {
	        return _super.prototype.elements.call(this, 'schemas');
	    };
	    /**
	     * Declarations of traits used in this API
	     * @hidden
	     **/
	    ApiImpl.prototype.traits_original = function () {
	        return _super.prototype.elements.call(this, 'traits');
	    };
	    /**
	     * A list of the security schemes to apply to all methods, these must be defined in the securitySchemes declaration.
	     **/
	    ApiImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemeRefImpl(attr); });
	    };
	    /**
	     * Security schemes that can be applied using securedBy
	     **/
	    ApiImpl.prototype.securitySchemes = function () {
	        return _super.prototype.elements.call(this, 'securitySchemes');
	    };
	    /**
	     * Declaration of resource types used in this API
	     * @hidden
	     **/
	    ApiImpl.prototype.resourceTypes_original = function () {
	        return _super.prototype.elements.call(this, 'resourceTypes');
	    };
	    /**
	     * Resources are identified by their relative URI, which MUST begin with a slash (/). A resource defined as a root-level property is called a top-level resource. Its property's key is the resource's URI relative to the baseUri. A resource defined as a child property of another resource is called a nested resource, and its property's key is its URI relative to its parent resource's URI. Every property whose key begins with a slash (/), and is either at the root of the API definition or is the child property of a resource property, is a resource property. The key of a resource, i.e. its relative URI, MAY consist of multiple URI path fragments separated by slashes; e.g. `/bom/items` may indicate the collection of items in a bill of materials as a single resource. However, if the individual URI path fragments are themselves resources, the API definition SHOULD use nested resources to describe this structure; e.g. if `/bom` is itself a resource then `/items` should be a nested resource of `/bom`, while `/bom/items` should not be used.
	     **/
	    ApiImpl.prototype.resources = function () {
	        return _super.prototype.elements.call(this, 'resources');
	    };
	    /**
	     * The API definition can include a variety of documents that serve as a user guides and reference documentation for the API. Such documents can clarify how the API works or provide business context. Documentation-generators MUST include all the sections in an API definition's documentation property in the documentation output, and they MUST preserve the order in which the documentation is declared. To add user documentation to the API, include the documentation property at the root of the API definition. The documentation property MUST be an array of documents. Each document MUST contain title and content attributes, both of which are REQUIRED. If the documentation property is specified, it MUST include at least one document. Documentation-generators MUST process the content field as if it was defined using Markdown.
	     **/
	    ApiImpl.prototype.documentation = function () {
	        return _super.prototype.elements.call(this, 'documentation');
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ApiImpl.prototype.wrapperClassName = function () { return "ApiImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ApiImpl.prototype.kind = function () { return "Api"; };
	    /**
	     * @return RAML version of the node
	     * @hidden
	     **/
	    ApiImpl.prototype.RAMLVersion_original = function () { return "RAML08"; };
	    /**
	     * Equivalent API with traits and resource types expanded
	     **/
	    ApiImpl.prototype.expand = function () {
	        return helper.expandTraitsAndResourceTypes(this);
	    };
	    /**
	     * Declarations of traits used in this API
	     **/
	    ApiImpl.prototype.traits = function () {
	        return helper.traitsPrimary(this);
	    };
	    /**
	     * Retrieve all traits including those defined in libraries *
	     * @deprecated
	     **/
	    ApiImpl.prototype.allTraits = function () {
	        return helper.allTraits(this);
	    };
	    /**
	     * Declaration of resource types used in this API
	     **/
	    ApiImpl.prototype.resourceTypes = function () {
	        return helper.resourceTypesPrimary(this);
	    };
	    /**
	     * Retrieve all resource types including those defined in libraries
	     * @deprecated
	     **/
	    ApiImpl.prototype.allResourceTypes = function () {
	        return helper.allResourceTypes(this);
	    };
	    /**
	     * Get child resource by its relative path
	     **/
	    ApiImpl.prototype.childResource = function (relPath) {
	        return helper.childResource(this, relPath);
	    };
	    /**
	     * Retrieve all resources of the Api
	     **/
	    ApiImpl.prototype.allResources = function () {
	        return helper.allResources(this);
	    };
	    /**
	     * Base uri parameters are named parameters which described template parameters in the base uri
	     **/
	    ApiImpl.prototype.baseUriParameters = function () {
	        return helper.baseUriParametersPrimary(this);
	    };
	    /**
	     * Retrieve an ordered list of all base uri parameters regardless of whether they are described in `baseUriParameters` or not
	     * Consider a fragment of RAML specification:
	     * ```yaml
	     * version: v1
	     * baseUri: https://{organization}.example.com/{version}/{service}
	     * baseUriParameters:
	     * service:
	     * ```
	     * Here `version` and `organization` are base uri parameters which are not described in the `baseUriParameters` node,
	     * Thus, they are not among `Api.baseUriParameters()`, but they are among `Api.allBaseUriParameters()`.
	     * @deprecated
	     **/
	    ApiImpl.prototype.allBaseUriParameters = function () {
	        return helper.baseUriParameters(this);
	    };
	    /**
	     * Protocols used by the API. Returns the `protocols` property value if it is specified.
	     * Otherwise, returns protocol, specified in the base URI.
	     * @deprecated
	     **/
	    ApiImpl.prototype.allProtocols = function () {
	        return helper.allProtocols(this);
	    };
	    /**
	     * @return RAML version of the node
	     **/
	    ApiImpl.prototype.RAMLVersion = function () {
	        return helper.RAMLVersion(this);
	    };
	    return ApiImpl;
	}(core.BasicNodeImpl));
	exports.ApiImpl = ApiImpl;
	var ValueTypeImpl = (function (_super) {
	    __extends(ValueTypeImpl, _super);
	    function ValueTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ValueTypeImpl.prototype.wrapperClassName = function () { return "ValueTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ValueTypeImpl.prototype.kind = function () { return "ValueType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ValueTypeImpl.prototype.RAMLVersion = function () { return "undefined"; };
	    /**
	     * @return JS representation of the node value
	     **/
	    ValueTypeImpl.prototype.value = function () { return this.attr.value(); };
	    return ValueTypeImpl;
	}(core.AttributeNodeImpl));
	exports.ValueTypeImpl = ValueTypeImpl;
	var AnyTypeImpl = (function (_super) {
	    __extends(AnyTypeImpl, _super);
	    function AnyTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    AnyTypeImpl.prototype.wrapperClassName = function () { return "AnyTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    AnyTypeImpl.prototype.kind = function () { return "AnyType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    AnyTypeImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return AnyTypeImpl;
	}(ValueTypeImpl));
	exports.AnyTypeImpl = AnyTypeImpl;
	var NumberTypeImpl = (function (_super) {
	    __extends(NumberTypeImpl, _super);
	    function NumberTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    NumberTypeImpl.prototype.wrapperClassName = function () { return "NumberTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    NumberTypeImpl.prototype.kind = function () { return "NumberType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    NumberTypeImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    /**
	     * @return Number representation of the node value
	     **/
	    NumberTypeImpl.prototype.value = function () { return this.attr.value(); };
	    return NumberTypeImpl;
	}(ValueTypeImpl));
	exports.NumberTypeImpl = NumberTypeImpl;
	var BooleanTypeImpl = (function (_super) {
	    __extends(BooleanTypeImpl, _super);
	    function BooleanTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    BooleanTypeImpl.prototype.wrapperClassName = function () { return "BooleanTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    BooleanTypeImpl.prototype.kind = function () { return "BooleanType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    BooleanTypeImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    /**
	     * @return Boolean representation of the node value
	     **/
	    BooleanTypeImpl.prototype.value = function () { return this.attr.value(); };
	    return BooleanTypeImpl;
	}(ValueTypeImpl));
	exports.BooleanTypeImpl = BooleanTypeImpl;
	var ReferenceImpl = (function (_super) {
	    __extends(ReferenceImpl, _super);
	    function ReferenceImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ReferenceImpl.prototype.wrapperClassName = function () { return "ReferenceImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ReferenceImpl.prototype.kind = function () { return "Reference"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ReferenceImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    /**
	     * @return StructuredValue object representing the node value
	     **/
	    ReferenceImpl.prototype.value = function () { return core.toStructuredValue(this.attr); };
	    ReferenceImpl.prototype.structuredValue = function () {
	        return helper.structuredValue(this);
	    };
	    ReferenceImpl.prototype.name = function () {
	        return helper.referenceName(this);
	    };
	    return ReferenceImpl;
	}(core.AttributeNodeImpl));
	exports.ReferenceImpl = ReferenceImpl;
	var ResourceTypeRefImpl = (function (_super) {
	    __extends(ResourceTypeRefImpl, _super);
	    function ResourceTypeRefImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ResourceTypeRefImpl.prototype.wrapperClassName = function () { return "ResourceTypeRefImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ResourceTypeRefImpl.prototype.kind = function () { return "ResourceTypeRef"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ResourceTypeRefImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    ResourceTypeRefImpl.prototype.resourceType = function () {
	        return helper.referencedResourceType(this);
	    };
	    return ResourceTypeRefImpl;
	}(ReferenceImpl));
	exports.ResourceTypeRefImpl = ResourceTypeRefImpl;
	var ResourceTypeImpl = (function (_super) {
	    __extends(ResourceTypeImpl, _super);
	    function ResourceTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Name of the resource type
	     **/
	    ResourceTypeImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     * @hidden
	     * Set name value
	     **/
	    ResourceTypeImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    /**
	     * Instructions on how and when the resource type should be used.
	     **/
	    ResourceTypeImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /**
	     * @hidden
	     * Set usage value
	     **/
	    ResourceTypeImpl.prototype.setUsage = function (param) {
	        this.highLevel().attrOrCreate("usage").setValue("" + param);
	        return this;
	    };
	    /**
	     * Methods that are part of this resource type definition
	     **/
	    ResourceTypeImpl.prototype.methods = function () {
	        return _super.prototype.elements.call(this, 'methods');
	    };
	    /**
	     * Instantiation of applyed traits
	     **/
	    ResourceTypeImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /**
	     * Instantiation of applyed resource type
	     **/
	    ResourceTypeImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', function (attr) { return new ResourceTypeRefImpl(attr); });
	    };
	    /**
	     * securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource. To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.
	     **/
	    ResourceTypeImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemeRefImpl(attr); });
	    };
	    /**
	     * Uri parameters of this resource
	     **/
	    ResourceTypeImpl.prototype.uriParameters = function () {
	        return _super.prototype.elements.call(this, 'uriParameters');
	    };
	    /**
	     * An alternate, human-friendly name for the resource type
	     **/
	    ResourceTypeImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     * @hidden
	     * Set displayName value
	     **/
	    ResourceTypeImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /**
	     * A resource or a method can override a base URI template's values. This is useful to restrict or change the default or parameter selection in the base URI. The baseUriParameters property MAY be used to override any or all parameters defined at the root level baseUriParameters property, as well as base URI parameters not specified at the root level.
	     **/
	    ResourceTypeImpl.prototype.baseUriParameters = function () {
	        return _super.prototype.elements.call(this, 'baseUriParameters');
	    };
	    /**
	     * The description attribute describes the intended use or meaning of the $self. This value MAY be formatted using Markdown.
	     **/
	    ResourceTypeImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ResourceTypeImpl.prototype.wrapperClassName = function () { return "ResourceTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ResourceTypeImpl.prototype.kind = function () { return "ResourceType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ResourceTypeImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    ResourceTypeImpl.prototype.parametrizedProperties = function () {
	        return helper.getTemplateParametrizedProperties(this);
	    };
	    return ResourceTypeImpl;
	}(core.BasicNodeImpl));
	exports.ResourceTypeImpl = ResourceTypeImpl;
	/**
	 * Method object allows description of http methods
	 **/
	var MethodBaseImpl = (function (_super) {
	    __extends(MethodBaseImpl, _super);
	    function MethodBaseImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Resource methods MAY have one or more responses. Responses MAY be described using the description property, and MAY include example attributes or schema properties.
	     **/
	    MethodBaseImpl.prototype.responses = function () {
	        return _super.prototype.elements.call(this, 'responses');
	    };
	    /**
	     * Some method verbs expect the resource to be sent as a request body. For example, to create a resource, the request must include the details of the resource to create. Resources CAN have alternate representations. For example, an API might support both JSON and XML representations. A method's body is defined in the body property as a hashmap, in which the key MUST be a valid media type.
	     **/
	    MethodBaseImpl.prototype.body = function () {
	        return _super.prototype.elements.call(this, 'body');
	    };
	    /**
	     * A method can override an API's protocols value for that single method by setting a different value for the fields.
	     **/
	    MethodBaseImpl.prototype.protocols = function () {
	        return _super.prototype.attributes.call(this, 'protocols', this.toString);
	    };
	    /**
	     * @hidden
	     * Set protocols value
	     **/
	    MethodBaseImpl.prototype.setProtocols = function (param) {
	        this.highLevel().attrOrCreate("protocols").setValue("" + param);
	        return this;
	    };
	    /**
	     * A list of the security schemas to apply, these must be defined in the securitySchemes declaration. To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme. Security schemas may also be applied to a resource with securedBy, which is equivalent to applying the security schemas to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.
	     **/
	    MethodBaseImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemeRefImpl(attr); });
	    };
	    /**
	     * A resource or a method can override a base URI template's values. This is useful to restrict or change the default or parameter selection in the base URI. The baseUriParameters property MAY be used to override any or all parameters defined at the root level baseUriParameters property, as well as base URI parameters not specified at the root level.
	     **/
	    MethodBaseImpl.prototype.baseUriParameters = function () {
	        return _super.prototype.elements.call(this, 'baseUriParameters');
	    };
	    /**
	     * An APIs resources MAY be filtered (to return a subset of results) or altered (such as transforming a response body from JSON to XML format) by the use of query strings. If the resource or its method supports a query string, the query string MUST be defined by the queryParameters property
	     **/
	    MethodBaseImpl.prototype.queryParameters = function () {
	        return _super.prototype.elements.call(this, 'queryParameters');
	    };
	    /**
	     * Headers that allowed at this position
	     **/
	    MethodBaseImpl.prototype.headers = function () {
	        return _super.prototype.elements.call(this, 'headers');
	    };
	    MethodBaseImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    MethodBaseImpl.prototype.wrapperClassName = function () { return "MethodBaseImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    MethodBaseImpl.prototype.kind = function () { return "MethodBase"; };
	    /**
	     * @return RAML version of the node
	     **/
	    MethodBaseImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return MethodBaseImpl;
	}(core.BasicNodeImpl));
	exports.MethodBaseImpl = MethodBaseImpl;
	var ResponseImpl = (function (_super) {
	    __extends(ResponseImpl, _super);
	    function ResponseImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Responses MUST be a map of one or more HTTP status codes, where each status code itself is a map that describes that status code.
	     **/
	    ResponseImpl.prototype.code = function () {
	        return _super.prototype.attribute.call(this, 'code', function (attr) { return new StatusCodeStringImpl(attr); });
	    };
	    /**
	     * An API's methods may support custom header values in responses. The custom, non-standard HTTP headers MUST be specified by the headers property. API's may include the the placeholder token {?} in a header name to indicate that any number of headers that conform to the specified format can be sent in responses. This is particularly useful for APIs that allow HTTP headers that conform to some naming convention to send arbitrary, custom data.
	     **/
	    ResponseImpl.prototype.headers = function () {
	        return _super.prototype.elements.call(this, 'headers');
	    };
	    /**
	     * Each response MAY contain a body property, which conforms to the same structure as request body properties (see Body). Responses that can return more than one response code MAY therefore have multiple bodies defined. For APIs without a priori knowledge of the response types for their responses, `* /*` MAY be used to indicate that responses that do not matching other defined data types MUST be accepted. Processing applications MUST match the most descriptive media type first if `* /*` is used.
	     **/
	    ResponseImpl.prototype.body = function () {
	        return _super.prototype.elements.call(this, 'body');
	    };
	    /**
	     * The description attribute describes the intended use or meaning of the $self. This value MAY be formatted using Markdown.
	     **/
	    ResponseImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ResponseImpl.prototype.wrapperClassName = function () { return "ResponseImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ResponseImpl.prototype.kind = function () { return "Response"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ResponseImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    /**
	     * true for codes < 400 and false otherwise
	     **/
	    ResponseImpl.prototype.isOkRange = function () {
	        return helper.isOkRange(this);
	    };
	    return ResponseImpl;
	}(core.BasicNodeImpl));
	exports.ResponseImpl = ResponseImpl;
	var StringTypeImpl = (function (_super) {
	    __extends(StringTypeImpl, _super);
	    function StringTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    StringTypeImpl.prototype.wrapperClassName = function () { return "StringTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    StringTypeImpl.prototype.kind = function () { return "StringType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    StringTypeImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    /**
	     * @return String representation of the node value
	     **/
	    StringTypeImpl.prototype.value = function () { return this.attr.value(); };
	    return StringTypeImpl;
	}(ValueTypeImpl));
	exports.StringTypeImpl = StringTypeImpl;
	var StatusCodeStringImpl = (function (_super) {
	    __extends(StatusCodeStringImpl, _super);
	    function StatusCodeStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    StatusCodeStringImpl.prototype.wrapperClassName = function () { return "StatusCodeStringImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    StatusCodeStringImpl.prototype.kind = function () { return "StatusCodeString"; };
	    /**
	     * @return RAML version of the node
	     **/
	    StatusCodeStringImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return StatusCodeStringImpl;
	}(StringTypeImpl));
	exports.StatusCodeStringImpl = StatusCodeStringImpl;
	var ParameterImpl = (function (_super) {
	    __extends(ParameterImpl, _super);
	    function ParameterImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * name of the parameter
	     **/
	    ParameterImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     * @hidden
	     * Set name value
	     **/
	    ParameterImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    /**
	     * An alternate, human-friendly name for the parameter
	     **/
	    ParameterImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     * @hidden
	     * Set displayName value
	     **/
	    ParameterImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /**
	     * The type attribute specifies the primitive type of the parameter's resolved value. API clients MUST return/throw an error if the parameter's resolved value does not match the specified type. If type is not specified, it defaults to string.
	     **/
	    ParameterImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', this.toString);
	    };
	    /**
	     * @hidden
	     * Set type value
	     **/
	    ParameterImpl.prototype.setType = function (param) {
	        this.highLevel().attrOrCreate("type").setValue("" + param);
	        return this;
	    };
	    /**
	     * Location of the parameter (can not be edited by user)
	     **/
	    ParameterImpl.prototype.location = function () {
	        return _super.prototype.attribute.call(this, 'location', function (attr) { return new ParameterLocationImpl(attr); });
	    };
	    /**
	     * Set to true if parameter is required
	     **/
	    ParameterImpl.prototype.required = function () {
	        return _super.prototype.attribute.call(this, 'required', this.toBoolean);
	    };
	    /**
	     * @hidden
	     * Set required value
	     **/
	    ParameterImpl.prototype.setRequired = function (param) {
	        this.highLevel().attrOrCreate("required").setValue("" + param);
	        return this;
	    };
	    /**
	     * The default attribute specifies the default value to use for the property if the property is omitted or its value is not specified. This SHOULD NOT be interpreted as a requirement for the client to send the default attribute's value if there is no other value to send. Instead, the default attribute's value is the value the server uses if the client does not send a value.
	     **/
	    ParameterImpl.prototype["default"] = function () {
	        return _super.prototype.attribute.call(this, 'default', this.toAny);
	    };
	    /**
	     * @hidden
	     * Set default value
	     **/
	    ParameterImpl.prototype.setDefault = function (param) {
	        this.highLevel().attrOrCreate("default").setValue("" + param);
	        return this;
	    };
	    /**
	     * (Optional) The example attribute shows an example value for the property. This can be used, e.g., by documentation generators to generate sample values for the property.
	     **/
	    ParameterImpl.prototype.example = function () {
	        return _super.prototype.attribute.call(this, 'example', this.toString);
	    };
	    /**
	     * @hidden
	     * Set example value
	     **/
	    ParameterImpl.prototype.setExample = function (param) {
	        this.highLevel().attrOrCreate("example").setValue("" + param);
	        return this;
	    };
	    /**
	     * The repeat attribute specifies that the parameter can be repeated. If the parameter can be used multiple times, the repeat parameter value MUST be set to 'true'. Otherwise, the default value is 'false' and the parameter may not be repeated.
	     **/
	    ParameterImpl.prototype.repeat = function () {
	        return _super.prototype.attribute.call(this, 'repeat', this.toBoolean);
	    };
	    /**
	     * @hidden
	     * Set repeat value
	     **/
	    ParameterImpl.prototype.setRepeat = function (param) {
	        this.highLevel().attrOrCreate("repeat").setValue("" + param);
	        return this;
	    };
	    /**
	     * The description attribute describes the intended use or meaning of the $self. This value MAY be formatted using Markdown.
	     **/
	    ParameterImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ParameterImpl.prototype.wrapperClassName = function () { return "ParameterImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ParameterImpl.prototype.kind = function () { return "Parameter"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ParameterImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return ParameterImpl;
	}(core.BasicNodeImpl));
	exports.ParameterImpl = ParameterImpl;
	var ParameterLocationImpl = (function () {
	    function ParameterLocationImpl(attr) {
	        this.attr = attr;
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ParameterLocationImpl.prototype.wrapperClassName = function () { return "ParameterLocationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ParameterLocationImpl.prototype.kind = function () { return "ParameterLocation"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ParameterLocationImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return ParameterLocationImpl;
	}());
	exports.ParameterLocationImpl = ParameterLocationImpl;
	/**
	 * Mardown string is a string which can contain markdown as an extension this markdown should support links with RAML Pointers since 1.0
	 **/
	var MarkdownStringImpl = (function (_super) {
	    __extends(MarkdownStringImpl, _super);
	    function MarkdownStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    MarkdownStringImpl.prototype.wrapperClassName = function () { return "MarkdownStringImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    MarkdownStringImpl.prototype.kind = function () { return "MarkdownString"; };
	    /**
	     * @return RAML version of the node
	     **/
	    MarkdownStringImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return MarkdownStringImpl;
	}(StringTypeImpl));
	exports.MarkdownStringImpl = MarkdownStringImpl;
	/**
	 * Value must be a string
	 **/
	var StringTypeDeclarationImpl = (function (_super) {
	    __extends(StringTypeDeclarationImpl, _super);
	    function StringTypeDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createStringTypeDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * (Optional, applicable only for parameters of type string) The pattern attribute is a regular expression that a parameter of type string MUST match. Regular expressions MUST follow the regular expression specification from ECMA 262/Perl 5. The pattern MAY be enclosed in double quotes for readability and clarity.
	     **/
	    StringTypeDeclarationImpl.prototype.pattern = function () {
	        return _super.prototype.attribute.call(this, 'pattern', this.toString);
	    };
	    /**
	     * @hidden
	     * Set pattern value
	     **/
	    StringTypeDeclarationImpl.prototype.setPattern = function (param) {
	        this.highLevel().attrOrCreate("pattern").setValue("" + param);
	        return this;
	    };
	    /**
	     * (Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error.
	     **/
	    StringTypeDeclarationImpl.prototype.enum = function () {
	        return _super.prototype.attributes.call(this, 'enum', this.toString);
	    };
	    /**
	     * @hidden
	     * Set enum value
	     **/
	    StringTypeDeclarationImpl.prototype.setEnum = function (param) {
	        this.highLevel().attrOrCreate("enum").setValue("" + param);
	        return this;
	    };
	    /**
	     * (Optional, applicable only for parameters of type string) The minLength attribute specifies the parameter value's minimum number of characters.
	     **/
	    StringTypeDeclarationImpl.prototype.minLength = function () {
	        return _super.prototype.attribute.call(this, 'minLength', this.toNumber);
	    };
	    /**
	     * @hidden
	     * Set minLength value
	     **/
	    StringTypeDeclarationImpl.prototype.setMinLength = function (param) {
	        this.highLevel().attrOrCreate("minLength").setValue("" + param);
	        return this;
	    };
	    /**
	     * (Optional, applicable only for parameters of type string) The maxLength attribute specifies the parameter value's maximum number of characters.
	     **/
	    StringTypeDeclarationImpl.prototype.maxLength = function () {
	        return _super.prototype.attribute.call(this, 'maxLength', this.toNumber);
	    };
	    /**
	     * @hidden
	     * Set maxLength value
	     **/
	    StringTypeDeclarationImpl.prototype.setMaxLength = function (param) {
	        this.highLevel().attrOrCreate("maxLength").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    StringTypeDeclarationImpl.prototype.wrapperClassName = function () { return "StringTypeDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    StringTypeDeclarationImpl.prototype.kind = function () { return "StringTypeDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    StringTypeDeclarationImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return StringTypeDeclarationImpl;
	}(ParameterImpl));
	exports.StringTypeDeclarationImpl = StringTypeDeclarationImpl;
	/**
	 * Value must be a boolean
	 **/
	var BooleanTypeDeclarationImpl = (function (_super) {
	    __extends(BooleanTypeDeclarationImpl, _super);
	    function BooleanTypeDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createBooleanTypeDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    BooleanTypeDeclarationImpl.prototype.wrapperClassName = function () { return "BooleanTypeDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    BooleanTypeDeclarationImpl.prototype.kind = function () { return "BooleanTypeDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    BooleanTypeDeclarationImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return BooleanTypeDeclarationImpl;
	}(ParameterImpl));
	exports.BooleanTypeDeclarationImpl = BooleanTypeDeclarationImpl;
	/**
	 * Value MUST be a number. Indicate floating point numbers as defined by YAML.
	 **/
	var NumberTypeDeclarationImpl = (function (_super) {
	    __extends(NumberTypeDeclarationImpl, _super);
	    function NumberTypeDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createNumberTypeDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * (Optional, applicable only for parameters of type number or integer) The minimum attribute specifies the parameter's minimum value.
	     **/
	    NumberTypeDeclarationImpl.prototype.minimum = function () {
	        return _super.prototype.attribute.call(this, 'minimum', this.toNumber);
	    };
	    /**
	     * @hidden
	     * Set minimum value
	     **/
	    NumberTypeDeclarationImpl.prototype.setMinimum = function (param) {
	        this.highLevel().attrOrCreate("minimum").setValue("" + param);
	        return this;
	    };
	    /**
	     * (Optional, applicable only for parameters of type number or integer) The maximum attribute specifies the parameter's maximum value.
	     **/
	    NumberTypeDeclarationImpl.prototype.maximum = function () {
	        return _super.prototype.attribute.call(this, 'maximum', this.toNumber);
	    };
	    /**
	     * @hidden
	     * Set maximum value
	     **/
	    NumberTypeDeclarationImpl.prototype.setMaximum = function (param) {
	        this.highLevel().attrOrCreate("maximum").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    NumberTypeDeclarationImpl.prototype.wrapperClassName = function () { return "NumberTypeDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    NumberTypeDeclarationImpl.prototype.kind = function () { return "NumberTypeDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    NumberTypeDeclarationImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return NumberTypeDeclarationImpl;
	}(ParameterImpl));
	exports.NumberTypeDeclarationImpl = NumberTypeDeclarationImpl;
	/**
	 * Value MUST be a integer.
	 **/
	var IntegerTypeDeclarationImpl = (function (_super) {
	    __extends(IntegerTypeDeclarationImpl, _super);
	    function IntegerTypeDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createIntegerTypeDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    IntegerTypeDeclarationImpl.prototype.wrapperClassName = function () { return "IntegerTypeDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    IntegerTypeDeclarationImpl.prototype.kind = function () { return "IntegerTypeDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    IntegerTypeDeclarationImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return IntegerTypeDeclarationImpl;
	}(NumberTypeDeclarationImpl));
	exports.IntegerTypeDeclarationImpl = IntegerTypeDeclarationImpl;
	/**
	 * Value MUST be a string representation of a date as defined in RFC2616 Section 3.3.
	 **/
	var DateTypeDeclarationImpl = (function (_super) {
	    __extends(DateTypeDeclarationImpl, _super);
	    function DateTypeDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createDateTypeDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    DateTypeDeclarationImpl.prototype.wrapperClassName = function () { return "DateTypeDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    DateTypeDeclarationImpl.prototype.kind = function () { return "DateTypeDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    DateTypeDeclarationImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return DateTypeDeclarationImpl;
	}(ParameterImpl));
	exports.DateTypeDeclarationImpl = DateTypeDeclarationImpl;
	/**
	 * (Applicable only to Form properties) Value is a file. Client generators SHOULD use this type to handle file uploads correctly.
	 **/
	var FileTypeDeclarationImpl = (function (_super) {
	    __extends(FileTypeDeclarationImpl, _super);
	    function FileTypeDeclarationImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createFileTypeDeclaration(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    FileTypeDeclarationImpl.prototype.wrapperClassName = function () { return "FileTypeDeclarationImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    FileTypeDeclarationImpl.prototype.kind = function () { return "FileTypeDeclaration"; };
	    /**
	     * @return RAML version of the node
	     **/
	    FileTypeDeclarationImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return FileTypeDeclarationImpl;
	}(ParameterImpl));
	exports.FileTypeDeclarationImpl = FileTypeDeclarationImpl;
	var BodyLikeImpl = (function (_super) {
	    __extends(BodyLikeImpl, _super);
	    function BodyLikeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Mime type of the request or response body
	     **/
	    BodyLikeImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     * @hidden
	     * Set name value
	     **/
	    BodyLikeImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    /**
	     * The structure of a request or response body MAY be further specified by the schema property under the appropriate media type. The schema key CANNOT be specified if a body's media type is application/x-www-form-urlencoded or multipart/form-data. All parsers of RAML MUST be able to interpret JSON Schema and XML Schema. Schema MAY be declared inline or in an external file. However, if the schema is sufficiently large so as to make it difficult for a person to read the API definition, or the schema is reused across multiple APIs or across multiple miles in the same API, the !include user-defined data type SHOULD be used instead of including the content inline. Alternatively, the value of the schema field MAY be the name of a schema specified in the root-level schemas property, or it MAY be declared in an external file and included by using the by using the RAML !include user-defined data type.
	     **/
	    BodyLikeImpl.prototype.schema = function () {
	        return _super.prototype.attribute.call(this, 'schema', function (attr) { return new SchemaStringImpl(attr); });
	    };
	    /**
	     * Documentation generators MUST use body properties' example attributes to generate example invocations.
	     **/
	    BodyLikeImpl.prototype.example = function () {
	        return _super.prototype.attribute.call(this, 'example', function (attr) { return new ExampleStringImpl(attr); });
	    };
	    /**
	     * Web forms REQUIRE special encoding and custom declaration. If the API's media type is either application/x-www-form-urlencoded or multipart/form-data, the formParameters property MUST specify the name-value pairs that the API is expecting. The formParameters property is a map in which the key is the name of the web form parameter, and the value is itself a map the specifies the web form parameter's attributes.
	     **/
	    BodyLikeImpl.prototype.formParameters = function () {
	        return _super.prototype.elements.call(this, 'formParameters');
	    };
	    /**
	     * Human readable description of the body
	     **/
	    BodyLikeImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    BodyLikeImpl.prototype.wrapperClassName = function () { return "BodyLikeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    BodyLikeImpl.prototype.kind = function () { return "BodyLike"; };
	    /**
	     * @return RAML version of the node
	     **/
	    BodyLikeImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    BodyLikeImpl.prototype.schemaContent = function () {
	        return helper.schemaContent(this);
	    };
	    return BodyLikeImpl;
	}(core.BasicNodeImpl));
	exports.BodyLikeImpl = BodyLikeImpl;
	/**
	 * Schema at this moment only two subtypes are supported (json schema and xsd)
	 **/
	var SchemaStringImpl = (function (_super) {
	    __extends(SchemaStringImpl, _super);
	    function SchemaStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    SchemaStringImpl.prototype.wrapperClassName = function () { return "SchemaStringImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    SchemaStringImpl.prototype.kind = function () { return "SchemaString"; };
	    /**
	     * @return RAML version of the node
	     **/
	    SchemaStringImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return SchemaStringImpl;
	}(StringTypeImpl));
	exports.SchemaStringImpl = SchemaStringImpl;
	/**
	 * JSON schema
	 **/
	var JSonSchemaStringImpl = (function (_super) {
	    __extends(JSonSchemaStringImpl, _super);
	    function JSonSchemaStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    JSonSchemaStringImpl.prototype.wrapperClassName = function () { return "JSonSchemaStringImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    JSonSchemaStringImpl.prototype.kind = function () { return "JSonSchemaString"; };
	    /**
	     * @return RAML version of the node
	     **/
	    JSonSchemaStringImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return JSonSchemaStringImpl;
	}(SchemaStringImpl));
	exports.JSonSchemaStringImpl = JSonSchemaStringImpl;
	/**
	 * XSD schema
	 **/
	var XMLSchemaStringImpl = (function (_super) {
	    __extends(XMLSchemaStringImpl, _super);
	    function XMLSchemaStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    XMLSchemaStringImpl.prototype.wrapperClassName = function () { return "XMLSchemaStringImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    XMLSchemaStringImpl.prototype.kind = function () { return "XMLSchemaString"; };
	    /**
	     * @return RAML version of the node
	     **/
	    XMLSchemaStringImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return XMLSchemaStringImpl;
	}(SchemaStringImpl));
	exports.XMLSchemaStringImpl = XMLSchemaStringImpl;
	var ExampleStringImpl = (function (_super) {
	    __extends(ExampleStringImpl, _super);
	    function ExampleStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ExampleStringImpl.prototype.wrapperClassName = function () { return "ExampleStringImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ExampleStringImpl.prototype.kind = function () { return "ExampleString"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ExampleStringImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return ExampleStringImpl;
	}(StringTypeImpl));
	exports.ExampleStringImpl = ExampleStringImpl;
	var JSONExampleImpl = (function (_super) {
	    __extends(JSONExampleImpl, _super);
	    function JSONExampleImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    JSONExampleImpl.prototype.wrapperClassName = function () { return "JSONExampleImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    JSONExampleImpl.prototype.kind = function () { return "JSONExample"; };
	    /**
	     * @return RAML version of the node
	     **/
	    JSONExampleImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return JSONExampleImpl;
	}(ExampleStringImpl));
	exports.JSONExampleImpl = JSONExampleImpl;
	var XMLExampleImpl = (function (_super) {
	    __extends(XMLExampleImpl, _super);
	    function XMLExampleImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    XMLExampleImpl.prototype.wrapperClassName = function () { return "XMLExampleImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    XMLExampleImpl.prototype.kind = function () { return "XMLExample"; };
	    /**
	     * @return RAML version of the node
	     **/
	    XMLExampleImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return XMLExampleImpl;
	}(ExampleStringImpl));
	exports.XMLExampleImpl = XMLExampleImpl;
	/**
	 * Needed to set connection between xml related mime types and xsd schema
	 **/
	var XMLBodyImpl = (function (_super) {
	    __extends(XMLBodyImpl, _super);
	    function XMLBodyImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createXMLBody(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * XSD Schema
	     **/
	    XMLBodyImpl.prototype.schema = function () {
	        return _super.prototype.attribute.call(this, 'schema', function (attr) { return new XMLSchemaStringImpl(attr); });
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    XMLBodyImpl.prototype.wrapperClassName = function () { return "XMLBodyImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    XMLBodyImpl.prototype.kind = function () { return "XMLBody"; };
	    /**
	     * @return RAML version of the node
	     **/
	    XMLBodyImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return XMLBodyImpl;
	}(BodyLikeImpl));
	exports.XMLBodyImpl = XMLBodyImpl;
	/**
	 * Needed to set connection between json related mime types and json schema
	 **/
	var JSONBodyImpl = (function (_super) {
	    __extends(JSONBodyImpl, _super);
	    function JSONBodyImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createJSONBody(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * JSON Schema
	     **/
	    JSONBodyImpl.prototype.schema = function () {
	        return _super.prototype.attribute.call(this, 'schema', function (attr) { return new JSonSchemaStringImpl(attr); });
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    JSONBodyImpl.prototype.wrapperClassName = function () { return "JSONBodyImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    JSONBodyImpl.prototype.kind = function () { return "JSONBody"; };
	    /**
	     * @return RAML version of the node
	     **/
	    JSONBodyImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return JSONBodyImpl;
	}(BodyLikeImpl));
	exports.JSONBodyImpl = JSONBodyImpl;
	var SecuritySchemeRefImpl = (function (_super) {
	    __extends(SecuritySchemeRefImpl, _super);
	    function SecuritySchemeRefImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    SecuritySchemeRefImpl.prototype.wrapperClassName = function () { return "SecuritySchemeRefImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    SecuritySchemeRefImpl.prototype.kind = function () { return "SecuritySchemeRef"; };
	    /**
	     * @return RAML version of the node
	     **/
	    SecuritySchemeRefImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    SecuritySchemeRefImpl.prototype.securitySchemeName = function () {
	        return helper.securitySchemeName(this);
	    };
	    SecuritySchemeRefImpl.prototype.securityScheme = function () {
	        return helper.securityScheme(this);
	    };
	    return SecuritySchemeRefImpl;
	}(ReferenceImpl));
	exports.SecuritySchemeRefImpl = SecuritySchemeRefImpl;
	/**
	 * Declares globally referable security schema definition
	 **/
	var AbstractSecuritySchemeImpl = (function (_super) {
	    __extends(AbstractSecuritySchemeImpl, _super);
	    function AbstractSecuritySchemeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Name of the security scheme
	     **/
	    AbstractSecuritySchemeImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     * @hidden
	     * Set name value
	     **/
	    AbstractSecuritySchemeImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    /**
	     * The securitySchemes property MUST be used to specify an API's security mechanisms, including the required settings and the authentication methods that the API supports. one authentication method is allowed if the API supports them.
	     **/
	    AbstractSecuritySchemeImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', this.toString);
	    };
	    /**
	     * @hidden
	     * Set type value
	     **/
	    AbstractSecuritySchemeImpl.prototype.setType = function (param) {
	        this.highLevel().attrOrCreate("type").setValue("" + param);
	        return this;
	    };
	    /**
	     * The description attribute MAY be used to describe a security schemes property.
	     **/
	    AbstractSecuritySchemeImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     * A description of the request components related to Security that are determined by the scheme: the headers, query parameters or responses. As a best practice, even for standard security schemes, API designers SHOULD describe these properties of security schemes. Including the security scheme description completes an API documentation.
	     **/
	    AbstractSecuritySchemeImpl.prototype.describedBy = function () {
	        return _super.prototype.element.call(this, 'describedBy');
	    };
	    /**
	     * The settings attribute MAY be used to provide security scheme-specific information. The required attributes vary depending on the type of security scheme is being declared. It describes the minimum set of properties which any processing application MUST provide and validate if it chooses to implement the security scheme. Processing applications MAY choose to recognize other properties for things such as token lifetime, preferred cryptographic algorithms, and more.
	     **/
	    AbstractSecuritySchemeImpl.prototype.settings = function () {
	        return _super.prototype.element.call(this, 'settings');
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    AbstractSecuritySchemeImpl.prototype.wrapperClassName = function () { return "AbstractSecuritySchemeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    AbstractSecuritySchemeImpl.prototype.kind = function () { return "AbstractSecurityScheme"; };
	    /**
	     * @return RAML version of the node
	     **/
	    AbstractSecuritySchemeImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return AbstractSecuritySchemeImpl;
	}(core.BasicNodeImpl));
	exports.AbstractSecuritySchemeImpl = AbstractSecuritySchemeImpl;
	var SecuritySchemePartImpl = (function (_super) {
	    __extends(SecuritySchemePartImpl, _super);
	    function SecuritySchemePartImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchemePart(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * An alternate, human-friendly name for the security scheme part
	     **/
	    SecuritySchemePartImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     * @hidden
	     * Set displayName value
	     **/
	    SecuritySchemePartImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /**
	     * Instantiation of applyed traits
	     **/
	    SecuritySchemePartImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /**
	     * Headers that allowed at this position
	     **/
	    SecuritySchemePartImpl.prototype.headers = function () {
	        return _super.prototype.elements.call(this, 'headers');
	    };
	    /**
	     * An APIs resources MAY be filtered (to return a subset of results) or altered (such as transforming a response body from JSON to XML format) by the use of query strings. If the resource or its method supports a query string, the query string MUST be defined by the queryParameters property
	     **/
	    SecuritySchemePartImpl.prototype.queryParameters = function () {
	        return _super.prototype.elements.call(this, 'queryParameters');
	    };
	    /**
	     * Optional array of responses, describing the possible responses that could be sent.
	     **/
	    SecuritySchemePartImpl.prototype.responses = function () {
	        return _super.prototype.elements.call(this, 'responses');
	    };
	    /**
	     * A longer, human-friendly description of the security scheme part
	     **/
	    SecuritySchemePartImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    SecuritySchemePartImpl.prototype.wrapperClassName = function () { return "SecuritySchemePartImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    SecuritySchemePartImpl.prototype.kind = function () { return "SecuritySchemePart"; };
	    /**
	     * @return RAML version of the node
	     **/
	    SecuritySchemePartImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return SecuritySchemePartImpl;
	}(MethodBaseImpl));
	exports.SecuritySchemePartImpl = SecuritySchemePartImpl;
	var TraitRefImpl = (function (_super) {
	    __extends(TraitRefImpl, _super);
	    function TraitRefImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    TraitRefImpl.prototype.wrapperClassName = function () { return "TraitRefImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    TraitRefImpl.prototype.kind = function () { return "TraitRef"; };
	    /**
	     * @return RAML version of the node
	     **/
	    TraitRefImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    TraitRefImpl.prototype.trait = function () {
	        return helper.referencedTrait(this);
	    };
	    return TraitRefImpl;
	}(ReferenceImpl));
	exports.TraitRefImpl = TraitRefImpl;
	var TraitImpl = (function (_super) {
	    __extends(TraitImpl, _super);
	    function TraitImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createTrait(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * Name of the trait
	     **/
	    TraitImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /**
	     * @hidden
	     * Set name value
	     **/
	    TraitImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    /**
	     * Instructions on how and when the trait should be used.
	     **/
	    TraitImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /**
	     * @hidden
	     * Set usage value
	     **/
	    TraitImpl.prototype.setUsage = function (param) {
	        this.highLevel().attrOrCreate("usage").setValue("" + param);
	        return this;
	    };
	    /**
	     * An alternate, human-friendly name for the trait
	     **/
	    TraitImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     * @hidden
	     * Set displayName value
	     **/
	    TraitImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    TraitImpl.prototype.wrapperClassName = function () { return "TraitImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    TraitImpl.prototype.kind = function () { return "Trait"; };
	    /**
	     * @return RAML version of the node
	     **/
	    TraitImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    TraitImpl.prototype.parametrizedProperties = function () {
	        return helper.getTemplateParametrizedProperties(this);
	    };
	    return TraitImpl;
	}(MethodBaseImpl));
	exports.TraitImpl = TraitImpl;
	var SecuritySchemeSettingsImpl = (function (_super) {
	    __extends(SecuritySchemeSettingsImpl, _super);
	    function SecuritySchemeSettingsImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    SecuritySchemeSettingsImpl.prototype.wrapperClassName = function () { return "SecuritySchemeSettingsImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    SecuritySchemeSettingsImpl.prototype.kind = function () { return "SecuritySchemeSettings"; };
	    /**
	     * @return RAML version of the node
	     **/
	    SecuritySchemeSettingsImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return SecuritySchemeSettingsImpl;
	}(core.BasicNodeImpl));
	exports.SecuritySchemeSettingsImpl = SecuritySchemeSettingsImpl;
	var OAuth1SecuritySchemeSettingsImpl = (function (_super) {
	    __extends(OAuth1SecuritySchemeSettingsImpl, _super);
	    function OAuth1SecuritySchemeSettingsImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth1SecuritySchemeSettings(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * The URI of the Temporary Credential Request endpoint as defined in RFC5849 Section 2.1
	     **/
	    OAuth1SecuritySchemeSettingsImpl.prototype.requestTokenUri = function () {
	        return _super.prototype.attribute.call(this, 'requestTokenUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /**
	     * The URI of the Resource Owner Authorization endpoint as defined in RFC5849 Section 2.2
	     **/
	    OAuth1SecuritySchemeSettingsImpl.prototype.authorizationUri = function () {
	        return _super.prototype.attribute.call(this, 'authorizationUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /**
	     * The URI of the Token Request endpoint as defined in RFC5849 Section 2.3
	     **/
	    OAuth1SecuritySchemeSettingsImpl.prototype.tokenCredentialsUri = function () {
	        return _super.prototype.attribute.call(this, 'tokenCredentialsUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    OAuth1SecuritySchemeSettingsImpl.prototype.wrapperClassName = function () { return "OAuth1SecuritySchemeSettingsImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    OAuth1SecuritySchemeSettingsImpl.prototype.kind = function () { return "OAuth1SecuritySchemeSettings"; };
	    /**
	     * @return RAML version of the node
	     **/
	    OAuth1SecuritySchemeSettingsImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return OAuth1SecuritySchemeSettingsImpl;
	}(SecuritySchemeSettingsImpl));
	exports.OAuth1SecuritySchemeSettingsImpl = OAuth1SecuritySchemeSettingsImpl;
	/**
	 * This  type describes fixed uris
	 **/
	var FixedUriImpl = (function (_super) {
	    __extends(FixedUriImpl, _super);
	    function FixedUriImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    FixedUriImpl.prototype.wrapperClassName = function () { return "FixedUriImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    FixedUriImpl.prototype.kind = function () { return "FixedUri"; };
	    /**
	     * @return RAML version of the node
	     **/
	    FixedUriImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return FixedUriImpl;
	}(StringTypeImpl));
	exports.FixedUriImpl = FixedUriImpl;
	var OAuth2SecuritySchemeSettingsImpl = (function (_super) {
	    __extends(OAuth2SecuritySchemeSettingsImpl, _super);
	    function OAuth2SecuritySchemeSettingsImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth2SecuritySchemeSettings(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * The URI of the Token Endpoint as defined in RFC6749 Section 3.2. Not required forby implicit grant type.
	     **/
	    OAuth2SecuritySchemeSettingsImpl.prototype.accessTokenUri = function () {
	        return _super.prototype.attribute.call(this, 'accessTokenUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /**
	     * The URI of the Authorization Endpoint as defined in RFC6749 Section 3.1. Required forby authorization_code and implicit grant types.
	     **/
	    OAuth2SecuritySchemeSettingsImpl.prototype.authorizationUri = function () {
	        return _super.prototype.attribute.call(this, 'authorizationUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /**
	     * A list of the Authorization grants supported by the API as defined in RFC6749 Sections 4.1, 4.2, 4.3 and 4.4, can be any of: authorization_code, password, client_credentials, implicit, or refresh_token.
	     **/
	    OAuth2SecuritySchemeSettingsImpl.prototype.authorizationGrants = function () {
	        return _super.prototype.attributes.call(this, 'authorizationGrants', this.toString);
	    };
	    /**
	     * @hidden
	     * Set authorizationGrants value
	     **/
	    OAuth2SecuritySchemeSettingsImpl.prototype.setAuthorizationGrants = function (param) {
	        this.highLevel().attrOrCreate("authorizationGrants").setValue("" + param);
	        return this;
	    };
	    /**
	     * A list of scopes supported by the security scheme as defined in RFC6749 Section 3.3
	     **/
	    OAuth2SecuritySchemeSettingsImpl.prototype.scopes = function () {
	        return _super.prototype.attributes.call(this, 'scopes', this.toString);
	    };
	    /**
	     * @hidden
	     * Set scopes value
	     **/
	    OAuth2SecuritySchemeSettingsImpl.prototype.setScopes = function (param) {
	        this.highLevel().attrOrCreate("scopes").setValue("" + param);
	        return this;
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    OAuth2SecuritySchemeSettingsImpl.prototype.wrapperClassName = function () { return "OAuth2SecuritySchemeSettingsImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    OAuth2SecuritySchemeSettingsImpl.prototype.kind = function () { return "OAuth2SecuritySchemeSettings"; };
	    /**
	     * @return RAML version of the node
	     **/
	    OAuth2SecuritySchemeSettingsImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return OAuth2SecuritySchemeSettingsImpl;
	}(SecuritySchemeSettingsImpl));
	exports.OAuth2SecuritySchemeSettingsImpl = OAuth2SecuritySchemeSettingsImpl;
	/**
	 * Declares globally referable security schema definition
	 **/
	var OAuth2SecuritySchemeImpl = (function (_super) {
	    __extends(OAuth2SecuritySchemeImpl, _super);
	    function OAuth2SecuritySchemeImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth2SecurityScheme(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    OAuth2SecuritySchemeImpl.prototype.settings = function () {
	        return _super.prototype.element.call(this, 'settings');
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    OAuth2SecuritySchemeImpl.prototype.wrapperClassName = function () { return "OAuth2SecuritySchemeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    OAuth2SecuritySchemeImpl.prototype.kind = function () { return "OAuth2SecurityScheme"; };
	    /**
	     * @return RAML version of the node
	     **/
	    OAuth2SecuritySchemeImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return OAuth2SecuritySchemeImpl;
	}(AbstractSecuritySchemeImpl));
	exports.OAuth2SecuritySchemeImpl = OAuth2SecuritySchemeImpl;
	/**
	 * Declares globally referable security schema definition
	 **/
	var OAuth1SecuritySchemeImpl = (function (_super) {
	    __extends(OAuth1SecuritySchemeImpl, _super);
	    function OAuth1SecuritySchemeImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth1SecurityScheme(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    OAuth1SecuritySchemeImpl.prototype.settings = function () {
	        return _super.prototype.element.call(this, 'settings');
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    OAuth1SecuritySchemeImpl.prototype.wrapperClassName = function () { return "OAuth1SecuritySchemeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    OAuth1SecuritySchemeImpl.prototype.kind = function () { return "OAuth1SecurityScheme"; };
	    /**
	     * @return RAML version of the node
	     **/
	    OAuth1SecuritySchemeImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return OAuth1SecuritySchemeImpl;
	}(AbstractSecuritySchemeImpl));
	exports.OAuth1SecuritySchemeImpl = OAuth1SecuritySchemeImpl;
	/**
	 * Declares globally referable security schema definition
	 **/
	var BasicSecuritySchemeImpl = (function (_super) {
	    __extends(BasicSecuritySchemeImpl, _super);
	    function BasicSecuritySchemeImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createBasicSecurityScheme(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    BasicSecuritySchemeImpl.prototype.wrapperClassName = function () { return "BasicSecuritySchemeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    BasicSecuritySchemeImpl.prototype.kind = function () { return "BasicSecurityScheme"; };
	    /**
	     * @return RAML version of the node
	     **/
	    BasicSecuritySchemeImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return BasicSecuritySchemeImpl;
	}(AbstractSecuritySchemeImpl));
	exports.BasicSecuritySchemeImpl = BasicSecuritySchemeImpl;
	/**
	 * Declares globally referable security schema definition
	 **/
	var DigestSecuritySchemeImpl = (function (_super) {
	    __extends(DigestSecuritySchemeImpl, _super);
	    function DigestSecuritySchemeImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createDigestSecurityScheme(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    DigestSecuritySchemeImpl.prototype.wrapperClassName = function () { return "DigestSecuritySchemeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    DigestSecuritySchemeImpl.prototype.kind = function () { return "DigestSecurityScheme"; };
	    /**
	     * @return RAML version of the node
	     **/
	    DigestSecuritySchemeImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return DigestSecuritySchemeImpl;
	}(AbstractSecuritySchemeImpl));
	exports.DigestSecuritySchemeImpl = DigestSecuritySchemeImpl;
	/**
	 * Declares globally referable security schema definition
	 **/
	var CustomSecuritySchemeImpl = (function (_super) {
	    __extends(CustomSecuritySchemeImpl, _super);
	    function CustomSecuritySchemeImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createCustomSecurityScheme(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    CustomSecuritySchemeImpl.prototype.wrapperClassName = function () { return "CustomSecuritySchemeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    CustomSecuritySchemeImpl.prototype.kind = function () { return "CustomSecurityScheme"; };
	    /**
	     * @return RAML version of the node
	     **/
	    CustomSecuritySchemeImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return CustomSecuritySchemeImpl;
	}(AbstractSecuritySchemeImpl));
	exports.CustomSecuritySchemeImpl = CustomSecuritySchemeImpl;
	var MethodImpl = (function (_super) {
	    __extends(MethodImpl, _super);
	    function MethodImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createMethod(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * Method that can be called
	     **/
	    MethodImpl.prototype.method = function () {
	        return _super.prototype.attribute.call(this, 'method', this.toString);
	    };
	    /**
	     * @hidden
	     * Set method value
	     **/
	    MethodImpl.prototype.setMethod = function (param) {
	        this.highLevel().attrOrCreate("method").setValue("" + param);
	        return this;
	    };
	    /**
	     * Instantiation of applyed traits
	     **/
	    MethodImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    MethodImpl.prototype.wrapperClassName = function () { return "MethodImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    MethodImpl.prototype.kind = function () { return "Method"; };
	    /**
	     * @return RAML version of the node
	     **/
	    MethodImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    /**
	     * For methods of Resources returns parent resource. For methods of ResourceTypes returns null.
	     **/
	    MethodImpl.prototype.parentResource = function () {
	        return helper.parentResource(this);
	    };
	    /**
	     * Api owning the resource as a sibling
	     **/
	    MethodImpl.prototype.ownerApi = function () {
	        return helper.ownerApi(this);
	    };
	    /**
	     * For methods of Resources: `{parent Resource relative path} {methodName}`.
	     * For methods of ResourceTypes: `{parent ResourceType name} {methodName}`.
	     * For other methods throws Exception.
	     **/
	    MethodImpl.prototype.methodId = function () {
	        return helper.methodId(this);
	    };
	    /**
	     * Returns security schemes, resource or method is secured with. If no security schemes are set at resource or method level,
	     * returns schemes defined with `securedBy` at API level.
	     * @deprecated
	     **/
	    MethodImpl.prototype.allSecuredBy = function () {
	        return helper.allSecuredBy(this);
	    };
	    return MethodImpl;
	}(MethodBaseImpl));
	exports.MethodImpl = MethodImpl;
	/**
	 * This sub type of the string represents mime types
	 **/
	var MimeTypeImpl = (function (_super) {
	    __extends(MimeTypeImpl, _super);
	    function MimeTypeImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    MimeTypeImpl.prototype.wrapperClassName = function () { return "MimeTypeImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    MimeTypeImpl.prototype.kind = function () { return "MimeType"; };
	    /**
	     * @return RAML version of the node
	     **/
	    MimeTypeImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return MimeTypeImpl;
	}(StringTypeImpl));
	exports.MimeTypeImpl = MimeTypeImpl;
	/**
	 * This type currently serves both for absolute and relative urls
	 **/
	var UriTemplateImpl = (function (_super) {
	    __extends(UriTemplateImpl, _super);
	    function UriTemplateImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    UriTemplateImpl.prototype.wrapperClassName = function () { return "UriTemplateImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    UriTemplateImpl.prototype.kind = function () { return "UriTemplate"; };
	    /**
	     * @return RAML version of the node
	     **/
	    UriTemplateImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return UriTemplateImpl;
	}(StringTypeImpl));
	exports.UriTemplateImpl = UriTemplateImpl;
	/**
	 * This  type describes relative uri templates
	 **/
	var RelativeUriStringImpl = (function (_super) {
	    __extends(RelativeUriStringImpl, _super);
	    function RelativeUriStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    RelativeUriStringImpl.prototype.wrapperClassName = function () { return "RelativeUriStringImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    RelativeUriStringImpl.prototype.kind = function () { return "RelativeUriString"; };
	    /**
	     * @return RAML version of the node
	     **/
	    RelativeUriStringImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return RelativeUriStringImpl;
	}(UriTemplateImpl));
	exports.RelativeUriStringImpl = RelativeUriStringImpl;
	/**
	 * This  type describes absolute uri templates
	 **/
	var FullUriTemplateStringImpl = (function (_super) {
	    __extends(FullUriTemplateStringImpl, _super);
	    function FullUriTemplateStringImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    FullUriTemplateStringImpl.prototype.wrapperClassName = function () { return "FullUriTemplateStringImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    FullUriTemplateStringImpl.prototype.kind = function () { return "FullUriTemplateString"; };
	    /**
	     * @return RAML version of the node
	     **/
	    FullUriTemplateStringImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return FullUriTemplateStringImpl;
	}(UriTemplateImpl));
	exports.FullUriTemplateStringImpl = FullUriTemplateStringImpl;
	var RAMLSimpleElementImpl = (function (_super) {
	    __extends(RAMLSimpleElementImpl, _super);
	    function RAMLSimpleElementImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    RAMLSimpleElementImpl.prototype.wrapperClassName = function () { return "RAMLSimpleElementImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    RAMLSimpleElementImpl.prototype.kind = function () { return "RAMLSimpleElement"; };
	    /**
	     * @return RAML version of the node
	     **/
	    RAMLSimpleElementImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return RAMLSimpleElementImpl;
	}(core.BasicNodeImpl));
	exports.RAMLSimpleElementImpl = RAMLSimpleElementImpl;
	var DocumentationItemImpl = (function (_super) {
	    __extends(DocumentationItemImpl, _super);
	    function DocumentationItemImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createDocumentationItem(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * title of documentation section
	     **/
	    DocumentationItemImpl.prototype.title = function () {
	        return _super.prototype.attribute.call(this, 'title', this.toString);
	    };
	    /**
	     * @hidden
	     * Set title value
	     **/
	    DocumentationItemImpl.prototype.setTitle = function (param) {
	        this.highLevel().attrOrCreate("title").setValue("" + param);
	        return this;
	    };
	    /**
	     * Content of documentation section
	     **/
	    DocumentationItemImpl.prototype.content = function () {
	        return _super.prototype.attribute.call(this, 'content', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    DocumentationItemImpl.prototype.wrapperClassName = function () { return "DocumentationItemImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    DocumentationItemImpl.prototype.kind = function () { return "DocumentationItem"; };
	    /**
	     * @return RAML version of the node
	     **/
	    DocumentationItemImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return DocumentationItemImpl;
	}(RAMLSimpleElementImpl));
	exports.DocumentationItemImpl = DocumentationItemImpl;
	/**
	 * Content of the schema
	 **/
	var GlobalSchemaImpl = (function (_super) {
	    __extends(GlobalSchemaImpl, _super);
	    function GlobalSchemaImpl(nodeOrKey, setAsTopLevel) {
	        if (setAsTopLevel === void 0) { setAsTopLevel = true; }
	        _super.call(this, (typeof nodeOrKey == "string") ? createGlobalSchema(nodeOrKey) : nodeOrKey, setAsTopLevel);
	        this.nodeOrKey = nodeOrKey;
	        this.setAsTopLevel = setAsTopLevel;
	    }
	    /**
	     * Name of the global schema, used to refer on schema content
	     **/
	    GlobalSchemaImpl.prototype.key = function () {
	        return _super.prototype.attribute.call(this, 'key', this.toString);
	    };
	    /**
	     * @hidden
	     * Set key value
	     **/
	    GlobalSchemaImpl.prototype.setKey = function (param) {
	        this.highLevel().attrOrCreate("key").setValue("" + param);
	        return this;
	    };
	    /**
	     * Content of the schema
	     **/
	    GlobalSchemaImpl.prototype.value = function () {
	        return _super.prototype.attribute.call(this, 'value', function (attr) { return new SchemaStringImpl(attr); });
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    GlobalSchemaImpl.prototype.wrapperClassName = function () { return "GlobalSchemaImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    GlobalSchemaImpl.prototype.kind = function () { return "GlobalSchema"; };
	    /**
	     * @return RAML version of the node
	     **/
	    GlobalSchemaImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    return GlobalSchemaImpl;
	}(RAMLSimpleElementImpl));
	exports.GlobalSchemaImpl = GlobalSchemaImpl;
	var ResourceImpl = (function (_super) {
	    __extends(ResourceImpl, _super);
	    function ResourceImpl() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Relative URL of this resource from the parent resource
	     **/
	    ResourceImpl.prototype.relativeUri = function () {
	        return _super.prototype.attribute.call(this, 'relativeUri', function (attr) { return new RelativeUriStringImpl(attr); });
	    };
	    /**
	     * Instantiation of applyed resource type
	     **/
	    ResourceImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', function (attr) { return new ResourceTypeRefImpl(attr); });
	    };
	    /**
	     * Instantiation of applyed traits
	     **/
	    ResourceImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /**
	     * securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource. To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.
	     **/
	    ResourceImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemeRefImpl(attr); });
	    };
	    /**
	     * Uri parameters of this resource
	     * @hidden
	     **/
	    ResourceImpl.prototype.uriParameters_original = function () {
	        return _super.prototype.elements.call(this, 'uriParameters');
	    };
	    /**
	     * Methods that can be called on this resource
	     **/
	    ResourceImpl.prototype.methods = function () {
	        return _super.prototype.elements.call(this, 'methods');
	    };
	    /**
	     * Children resources
	     **/
	    ResourceImpl.prototype.resources = function () {
	        return _super.prototype.elements.call(this, 'resources');
	    };
	    /**
	     * An alternate, human-friendly name for the resource
	     **/
	    ResourceImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /**
	     * @hidden
	     * Set displayName value
	     **/
	    ResourceImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /**
	     * A resource or a method can override a base URI template's values. This is useful to restrict or change the default or parameter selection in the base URI. The baseUriParameters property MAY be used to override any or all parameters defined at the root level baseUriParameters property, as well as base URI parameters not specified at the root level.
	     **/
	    ResourceImpl.prototype.baseUriParameters = function () {
	        return _super.prototype.elements.call(this, 'baseUriParameters');
	    };
	    /**
	     * The description attribute describes the intended use or meaning of the $self. This value MAY be formatted using Markdown.
	     **/
	    ResourceImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /**
	     * @hidden
	     * @return Actual name of instance class
	     **/
	    ResourceImpl.prototype.wrapperClassName = function () { return "ResourceImpl"; };
	    /**
	     * @return Actual name of instance interface
	     **/
	    ResourceImpl.prototype.kind = function () { return "Resource"; };
	    /**
	     * @return RAML version of the node
	     **/
	    ResourceImpl.prototype.RAMLVersion = function () { return "RAML08"; };
	    /**
	     * Path relative to API root
	     **/
	    ResourceImpl.prototype.completeRelativeUri = function () {
	        return helper.completeRelativeUri(this);
	    };
	    /**
	     * baseUri of owning Api concatenated with completeRelativeUri
	     **/
	    ResourceImpl.prototype.absoluteUri = function () {
	        return helper.absoluteUri(this);
	    };
	    /**
	     * Parent resource for non top level resources
	     **/
	    ResourceImpl.prototype.parentResource = function () {
	        return helper.parent(this);
	    };
	    /**
	     * Get child resource by its relative path
	     **/
	    ResourceImpl.prototype.childResource = function (relPath) {
	        return helper.childResource(this, relPath);
	    };
	    /**
	     * Get child method by its name
	     **/
	    ResourceImpl.prototype.childMethod = function (method) {
	        return helper.childMethod(this, method);
	    };
	    /**
	     * Api owning the resource as a sibling
	     **/
	    ResourceImpl.prototype.ownerApi = function () {
	        return helper.ownerApi(this);
	    };
	    /**
	     * Uri parameters of this resource
	     **/
	    ResourceImpl.prototype.uriParameters = function () {
	        return helper.uriParametersPrimary(this);
	    };
	    /**
	     * Retrieve an ordered list of all uri parameters including those which are not described in the `uriParameters` node.
	     * Consider a fragment of RAML specification:
	     * ```yaml
	     * /resource/{objectId}/{propertyId}:
	     * uriParameters:
	     * objectId:
	     * ```
	     * Here `propertyId` uri parameter is not described in the `uriParameters` node,
	     * Thus, it is not among Resource.uriParameters(), but it is among Resource.allUriParameters().
	     * @deprecated
	     **/
	    ResourceImpl.prototype.allUriParameters = function () {
	        return helper.uriParameters(this);
	    };
	    /**
	     * Retrieve an ordered list of all absolute uri parameters. Returns a union of `Api.allBaseUriParameters()`
	     * for `Api` owning the `Resource` and `Resource.allUriParameters()`.
	     **/
	    ResourceImpl.prototype.absoluteUriParameters = function () {
	        return helper.absoluteUriParameters(this);
	    };
	    /**
	     * Returns security schemes, resource or method is secured with. If no security schemes are set at resource or method level,
	     * returns schemes defined with `securedBy` at API level.
	     * @deprecated
	     **/
	    ResourceImpl.prototype.allSecuredBy = function () {
	        return helper.allSecuredBy(this);
	    };
	    return ResourceImpl;
	}(core.BasicNodeImpl));
	exports.ResourceImpl = ResourceImpl;
	/**
	 * @hidden
	 **/
	function createApi(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("Api");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createTypeInstance(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("TypeInstance");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createTypeInstanceProperty(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("TypeInstanceProperty");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createResourceType(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("ResourceType");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createMethod(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("Method");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createMethodBase(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("MethodBase");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createResponse(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("Response");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createParameter(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("Parameter");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createStringTypeDeclaration(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("StringTypeDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createBooleanTypeDeclaration(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("BooleanTypeDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createNumberTypeDeclaration(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("NumberTypeDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createIntegerTypeDeclaration(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("IntegerTypeDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createDateTypeDeclaration(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("DateTypeDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createFileTypeDeclaration(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("FileTypeDeclaration");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createBodyLike(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("BodyLike");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createXMLBody(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("XMLBody");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createJSONBody(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("JSONBody");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createAbstractSecurityScheme(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("AbstractSecurityScheme");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createSecuritySchemePart(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("SecuritySchemePart");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createTrait(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("Trait");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createSecuritySchemeSettings(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("SecuritySchemeSettings");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createOAuth1SecuritySchemeSettings(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("OAuth1SecuritySchemeSettings");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createOAuth2SecuritySchemeSettings(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("OAuth2SecuritySchemeSettings");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createOAuth2SecurityScheme(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("OAuth2SecurityScheme");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createOAuth1SecurityScheme(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("OAuth1SecurityScheme");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createBasicSecurityScheme(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("BasicSecurityScheme");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createDigestSecurityScheme(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("DigestSecurityScheme");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createCustomSecurityScheme(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("CustomSecurityScheme");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createGlobalSchema(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("GlobalSchema");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createRAMLSimpleElement(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("RAMLSimpleElement");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createDocumentationItem(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("DocumentationItem");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	/**
	 * @hidden
	 **/
	function createResource(key) {
	    var universe = def.getUniverse("RAML08");
	    var nc = universe.type("Resource");
	    var node = stubs.createStubNode(nc, null, key);
	    return node;
	}
	function loadApiSync(apiPath, arg1, arg2) {
	    return apiLoader.loadApi(apiPath, arg1, arg2).getOrElse(null);
	}
	exports.loadApiSync = loadApiSync;
	function loadRAMLSync(ramlPath, arg1, arg2) {
	    return apiLoader.loadApi(ramlPath, arg1, arg2).getOrElse(null);
	}
	exports.loadRAMLSync = loadRAMLSync;
	function loadApi(apiPath, arg1, arg2) {
	    return apiLoader.loadApiAsync(apiPath, arg1, arg2);
	}
	exports.loadApi = loadApi;
	function loadRAML(ramlPath, arg1, arg2) {
	    return apiLoader.loadRAMLAsync(ramlPath, arg1, arg2);
	}
	exports.loadRAML = loadRAML;
	/**
	 * Gets AST node by runtime type, if runtime type matches any.
	 * @param runtimeType - runtime type to find the match for
	 */
	function getLanguageElementByRuntimeType(runtimeType) {
	    return apiLoader.getLanguageElementByRuntimeType(runtimeType);
	}
	exports.getLanguageElementByRuntimeType = getLanguageElementByRuntimeType;
	//# sourceMappingURL=raml08parser.js.map

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var RamlWrapperImpl = __webpack_require__(47);
	var factory = __webpack_require__(44);
	var core = __webpack_require__(46);
	var hl = __webpack_require__(10);
	var hlimpl = __webpack_require__(16);
	var universes = __webpack_require__(22);
	var expander = __webpack_require__(24);
	var lowLevelProxy = __webpack_require__(39);
	var linter = __webpack_require__(25);
	var util = __webpack_require__(32);
	var search = __webpack_require__(23);
	var universeHelpers = __webpack_require__(14);
	var ll = __webpack_require__(27);
	var path = __webpack_require__(15);
	//export function resolveType(p:RamlWrapper.TypeDeclaration):hl.ITypeDefinition{
	//    var tpe=typeexpression.typeFromNode(p.highLevel());
	//    return tpe.toRuntime();
	//}
	function load(pth) {
	    var m = new ll.Project(path.dirname(pth));
	    var unit = m.unit(path.basename(pth));
	    if (unit) {
	        if (unit.isRAMLUnit()) {
	            return hlimpl.fromUnit(unit).wrapperNode();
	        }
	    }
	    return null;
	}
	exports.load = load;
	/**
	 * __$helperMethod__
	 * Equivalent API with traits and resource types expanded
	 * __$meta__={"name":"expand"}
	 **/
	function expandTraitsAndResourceTypes(api) {
	    var lowLevelNode = api.highLevel().lowLevel();
	    if (lowLevelNode instanceof lowLevelProxy.LowLevelProxyNode) {
	        return api;
	    }
	    return expander.expandTraitsAndResourceTypes(api);
	}
	exports.expandTraitsAndResourceTypes = expandTraitsAndResourceTypes;
	//__$helperMethod__ Path relative to API root
	function completeRelativeUri(res) {
	    var uri = '';
	    var parent = res;
	    do {
	        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
	        uri = res.relativeUri().value() + uri;
	        parent = res.parent();
	    } while (parent.definition().key().name == universes.Universe08.Resource.name);
	    return uri;
	}
	exports.completeRelativeUri = completeRelativeUri;
	//__$helperMethod__ baseUri of owning Api concatenated with completeRelativeUri
	function absoluteUri(res) {
	    var uri = '';
	    var parent = res;
	    do {
	        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
	        uri = res.relativeUri().value() + uri;
	        parent = res.parent();
	    } while (parent.definition().key().name == universes.Universe08.Resource.name);
	    uri = uri.replace(/\/\//g, '/');
	    var buri = parent.baseUri();
	    var base = buri ? buri.value() : "";
	    base = base ? base : '';
	    if (util.stringEndsWith(base, '/')) {
	        uri = uri.substring(1);
	    }
	    uri = base + uri;
	    return uri;
	}
	exports.absoluteUri = absoluteUri;
	function qName(c) {
	    return hlimpl.qName(c.highLevel(), c.highLevel().root());
	}
	exports.qName = qName;
	/**
	 * __$helperMethod__
	 * __$meta__{"name":"traits","override":true}
	 **/
	function traitsPrimary(a) {
	    return allTraits(a);
	}
	exports.traitsPrimary = traitsPrimary;
	/**
	 * __$helperMethod__ Retrieve all traits including those defined in libraries *
	 * __$meta__{"deprecated":true}
	 */
	function allTraits(a) {
	    return findTemplates(a, function (d) { return universeHelpers.isTraitType(d); });
	}
	exports.allTraits = allTraits;
	/**
	 *__$helperMethod__
	 *__$meta__{"name":"resourceTypes","override":true}
	 **/
	function resourceTypesPrimary(a) {
	    return allResourceTypes(a);
	}
	exports.resourceTypesPrimary = resourceTypesPrimary;
	/**
	 * __$helperMethod__ Retrieve all resource types including those defined in libraries
	 * __$meta__{"deprecated":true}
	 */
	function allResourceTypes(a) {
	    return findTemplates(a, function (d) { return universeHelpers.isResourceTypeType(d); });
	}
	exports.allResourceTypes = allResourceTypes;
	function findTemplates(a, filter) {
	    var arr = search.globalDeclarations(a.highLevel()).filter(function (x) { return filter(x.definition()); });
	    var ll = a.highLevel().lowLevel();
	    var nodePath = ll.includePath();
	    if (!nodePath) {
	        nodePath = ll.unit().path();
	    }
	    var topLevelArr = arr.map(function (x) {
	        var topLevelNode;
	        var p = x.lowLevel().unit().path();
	        if (p != nodePath) {
	            topLevelNode = factory.buildWrapperNode(x, false);
	            topLevelNode.meta().setCalculated();
	        }
	        else {
	            topLevelNode = x.wrapperNode();
	        }
	        return topLevelNode;
	    });
	    return topLevelArr;
	}
	;
	function relativeUriSegments(res) {
	    var result = [];
	    var parent = res;
	    do {
	        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
	        result.push(res.relativeUri().value());
	        parent = res.parent();
	    } while (parent.definition().key().name == universes.Universe08.Resource.name);
	    return result.reverse();
	}
	exports.relativeUriSegments = relativeUriSegments;
	//__$helperMethod__ For methods of Resources returns parent resource. For methods of ResourceTypes returns null.
	function parentResource(method) {
	    if (method.parent() instanceof RamlWrapperImpl.ResourceImpl) {
	        return method.parent();
	    }
	    return null;
	}
	exports.parentResource = parentResource;
	//__$helperMethod__ Parent resource for non top level resources __$meta__={"name":"parentResource"}
	function parent(resource) {
	    var parent = resource.parent();
	    if (parent.definition().key().name == universes.Universe08.Resource.name) {
	        parent;
	    }
	    return null;
	}
	exports.parent = parent;
	//__$helperMethod__ Get child resource by its relative path
	function childResource(container, relPath) {
	    if (container == null) {
	        return null;
	    }
	    var resources = container.resources();
	    if (!resources) {
	        return null;
	    }
	    resources = resources.filter(function (x) { return x.relativeUri().value() == relPath; });
	    if (resources.length == 0) {
	        return null;
	    }
	    return resources[0];
	}
	exports.childResource = childResource;
	function getResource(container, path) {
	    if (!container) {
	        return null;
	    }
	    var res = null;
	    for (var i = 0; i < path.length; i++) {
	        res = childResource(container, path[i]);
	        if (!res) {
	            return null;
	        }
	        container = res;
	    }
	    return res;
	}
	exports.getResource = getResource;
	//__$helperMethod__ Get child method by its name
	function childMethod(resource, method) {
	    if (!resource) {
	        return null;
	    }
	    return resource.methods().filter(function (x) { return x.method() == method; });
	}
	exports.childMethod = childMethod;
	function getMethod(container, path, method) {
	    var resource = getResource(container, path);
	    if (resource == null) {
	        return null;
	    }
	    return childMethod(resource, method);
	}
	exports.getMethod = getMethod;
	function isApi(obj) {
	    return (obj.definition().key().name == universes.Universe08.Api.name);
	}
	;
	//__$helperMethod__ Api owning the resource as a sibling
	function ownerApi(method) {
	    var obj = method;
	    while (!isApi(obj)) {
	        obj = obj.parent();
	    }
	    return obj;
	}
	exports.ownerApi = ownerApi;
	/**
	 * __$helperMethod__
	 * For methods of Resources: `{parent Resource relative path} {methodName}`.
	 * For methods of ResourceTypes: `{parent ResourceType name} {methodName}`.
	 * For other methods throws Exception.
	 **/
	function methodId(method) {
	    var parent = method.parent();
	    if (parent instanceof RamlWrapperImpl.ResourceImpl) {
	        return completeRelativeUri(parent) + ' ' + method.method().toLowerCase();
	    }
	    else if (parent instanceof RamlWrapperImpl.ResourceTypeImpl) {
	        return parent.name() + ' ' + method.method().toLowerCase();
	    }
	    throw new Error("Method is supposed to be owned by Resource or ResourceType.\nHere the method is owned by " + method.definition().key().name);
	}
	exports.methodId = methodId;
	//__$helperMethod__ true for codes < 400 and false otherwise
	function isOkRange(response) {
	    var str = response.code().value();
	    var err = linter.validateResponseString(str);
	    if (err != null) {
	        return false;
	    }
	    try {
	        if (parseInt(str.charAt(0)) < 4) {
	            return true;
	        }
	    }
	    catch (e) { }
	    return false;
	}
	exports.isOkRange = isOkRange;
	//__$helperMethod__  Retrieve all resources of the Api
	function allResources(api) {
	    var resources = [];
	    var visitor = function (res) {
	        resources.push(res);
	        res.resources().forEach(function (x) { return visitor(x); });
	    };
	    api.resources().forEach(function (x) { return visitor(x); });
	    return resources;
	}
	exports.allResources = allResources;
	//export function matchUri(apiRootRelativeUri:string, resource:RamlWrapper.Resource):Opt<ParamValue[]>{
	//
	//    var allParameters:Raml08Parser.NamedParameterMap = {}
	//    var opt:Opt<RamlWrapper.Resource> = new Opt<RamlWrapper.Resource>(resource);
	//    while(opt.isDefined()){
	//        var res:RamlWrapper.Resource = opt.getOrThrow();
	//        uriParameters(res).forEach(x=>allParameters[x.name()]=new ParamWrapper(x));
	//        opt = parent(res);
	//    }
	//    var result = ramlPathMatch(completeRelativeUri(resource), allParameters, {})(apiRootRelativeUri);
	//    if (result) {
	//        return new Opt<ParamValue[]>(Object.keys((<any>result).params)
	//            .map(x=>new ParamValue(x, result['params'][x])));
	//    }
	//    return Opt.empty<ParamValue[]>();
	//}
	var schemaContentChars = ['{', '<'];
	//export function schema(body:RamlWrapper.TypeDeclaration, api:RamlWrapper.Api):Opt<SchemaDef>{
	//
	//    var schemaNode = body.schema();
	//    if(!schemaNode){
	//        return Opt.empty<SchemaDef>();
	//    }
	//    var schemaString = schemaNode;
	//    var isContent:boolean = false;
	//    schemaContentChars.forEach(x=>{try{ isContent = isContent||schemaString.indexOf(x)>=0}catch(e){}});
	//    var schDef:SchemaDef;
	//    if(isContent) {
	//        schDef = new SchemaDef(schemaString);
	//    }
	//    else{
	//        var globalSchemes = api.schemas().filter(x=>x.key()==schemaString);
	//        if(globalSchemes.length>0){
	//            schDef = new SchemaDef(globalSchemes[0].value().value(),globalSchemes[0].key());
	//        }
	//        else{
	//            return Opt.empty<SchemaDef>();
	//        }
	//    }
	//    return new Opt<SchemaDef>(schDef);
	//}
	/**
	 * __$helperMethod__
	 * Retrieve an ordered list of all uri parameters including those which are not described in the `uriParameters` node.
	 * Consider a fragment of RAML specification:
	 * ```yaml
	 * /resource/{objectId}/{propertyId}:
	 *   uriParameters:
	 *     objectId:
	 * ```
	 * Here `propertyId` uri parameter is not described in the `uriParameters` node,
	 * but it is among Resource.uriParameters().
	 * __$meta__={"name":"uriParameters","override": true}
	 **/
	function uriParametersPrimary(resource) {
	    return uriParameters(resource);
	}
	exports.uriParametersPrimary = uriParametersPrimary;
	/**
	 * __$helperMethod__
	 * Retrieve an ordered list of all uri parameters including those which are not described in the `uriParameters` node.
	 * Consider a fragment of RAML specification:
	 * ```yaml
	 * /resource/{objectId}/{propertyId}:
	 *   uriParameters:
	 *     objectId:
	 * ```
	 * Here `propertyId` uri parameter is not described in the `uriParameters` node,
	 * Thus, it is not among Resource.uriParameters(), but it is among Resource.allUriParameters().
	 * __$meta__={"name":"allUriParameters","deprecated":true}
	 **/
	function uriParameters(resource) {
	    var uri = resource.relativeUri().value();
	    var params = resource.uriParameters_original();
	    var propName = universes.Universe08.Resource.properties.uriParameters.name;
	    return extractParams(params, uri, resource, propName);
	}
	exports.uriParameters = uriParameters;
	/**
	 * __$helperMethod__
	 * Retrieve an ordered list of all base uri parameters regardless of whether they are described in `baseUriParameters` or not
	 * Consider a fragment of RAML specification:
	 * ```yaml
	 * version: v1
	 * baseUri: https://{organization}.example.com/{version}/{service}
	 * baseUriParameters:
	 *   service:
	 * ```
	 * Here `version` and `organization` are base uri parameters which are not described in the `baseUriParameters` node,
	 * but they are among `Api.baseUriParameters()`.
	 * __$meta__={"name":"baseUriParameters","override":true}
	 **/
	function baseUriParametersPrimary(api) {
	    return baseUriParameters(api);
	}
	exports.baseUriParametersPrimary = baseUriParametersPrimary;
	/**
	 * __$helperMethod__
	 * Retrieve an ordered list of all base uri parameters regardless of whether they are described in `baseUriParameters` or not
	 * Consider a fragment of RAML specification:
	 * ```yaml
	 * version: v1
	 * baseUri: https://{organization}.example.com/{version}/{service}
	 * baseUriParameters:
	 *   service:
	 * ```
	 * Here `version` and `organization` are base uri parameters which are not described in the `baseUriParameters` node,
	 * Thus, they are not among `Api.baseUriParameters()`, but they are among `Api.allBaseUriParameters()`.
	 * __$meta__={"name":"allBaseUriParameters","deprecated":true}
	 **/
	function baseUriParameters(api) {
	    var uri = api.baseUri() ? api.baseUri().value() : '';
	    var params = api.baseUriParameters_original();
	    var propName = universes.Universe08.Api.properties.baseUriParameters.name;
	    return extractParams(params, uri, api, propName);
	}
	exports.baseUriParameters = baseUriParameters;
	/**
	 * __$helperMethod__
	 * Retrieve an ordered list of all absolute uri parameters. Returns a union of `Api.allBaseUriParameters()`
	 * for `Api` owning the `Resource` and `Resource.allUriParameters()`.
	 **/
	function absoluteUriParameters(res) {
	    var params = [];
	    var parent = res;
	    do {
	        res = parent;
	        params = uriParameters(res).concat(params);
	        parent = res.parent();
	    } while (parent.definition().key().name == universes.Universe10.Resource.name);
	    var api = parent;
	    var baseUriParams = api.baseUriParameters();
	    params = baseUriParameters(api).concat(params);
	    return params;
	}
	exports.absoluteUriParameters = absoluteUriParameters;
	/**
	 * _//_$helperMethod__
	 * Protocols used by the API. Returns the `protocols` property value if it is specified.
	 * Otherwise, returns protocol, specified in the base URI.
	 * __$meta__={"name":"protocols","override":true}
	 **/
	function protocolsPrimary(api) {
	    return allProtocols(api);
	}
	exports.protocolsPrimary = protocolsPrimary;
	/**
	 * __$helperMethod__
	 * Protocols used by the API. Returns the `protocols` property value if it is specified.
	 * Otherwise, returns protocol, specified in the base URI.
	 * __$meta__{"deprecated":true}
	 **/
	function allProtocols(api) {
	    return api.protocols().map(function (x) { return x.toUpperCase(); });
	    //var attributeDefaults = (<RamlWrapper.ApiImpl>api).attributeDefaults();
	    //var result = (<RamlWrapper.ApiImpl>api).protocols_original();
	    //if(result.length!=0||!attributeDefaults){
	    //    return result;
	    //}
	    //var baseUriAttr = api.baseUri();
	    //if(baseUriAttr) {
	    //    var baseUri = baseUriAttr.value();
	    //    if (baseUri) {
	    //        var ind = baseUri.indexOf('://');
	    //        if (ind >= 0) {
	    //            result = [baseUri.substring(0, ind)];
	    //        }
	    //        if(result.length==0){
	    //            result = [ 'HTTP' ];
	    //        }
	    //    }
	    //}
	    //return result;
	}
	exports.allProtocols = allProtocols;
	/**
	 * _//_$helperMethod__
	 * Returns security schemes, resource or method is secured with. If no security schemes are set at resource or method level,
	 * returns schemes defined with `securedBy` at API level.
	 * __$meta__={"name":"securedBy","override":true}
	 **/
	function securedByPrimary(resourceOrMethod) {
	    return allSecuredBy(resourceOrMethod);
	}
	exports.securedByPrimary = securedByPrimary;
	/**
	 * __$helperMethod__
	 * Returns security schemes, resource or method is secured with. If no security schemes are set at resource or method level,
	 * returns schemes defined with `securedBy` at API level.
	 * __$meta__{"deprecated":true}
	 **/
	function allSecuredBy(resourceOrMethod) {
	    //var currentSecuredBy = (<RamlWrapper.ResourceImpl|RamlWrapper.MethodImpl>resourceOrMethod).securedBy_original();
	    //if (currentSecuredBy && currentSecuredBy.length > 0) {
	    //    return currentSecuredBy;
	    //}
	    //
	    ////instanceof, but have to avoid direct usage of instanceof in JS.
	    //if (resourceOrMethod.highLevel().definition().key() == universes.Universe08.Method) {
	    //    var resource = <RamlWrapper.ResourceImpl>(<RamlWrapper.Method>resourceOrMethod).parentResource();
	    //    if (resource && resource.securedBy_original() && resource.securedBy_original().length > 0) {
	    //        return resource.securedBy();
	    //    }
	    //}
	    return resourceOrMethod.securedBy();
	}
	exports.allSecuredBy = allSecuredBy;
	/**
	 * __$helperMethod__
	 * __$meta__={"primary":true}
	 **/
	function securitySchemeName(schemeReference) {
	    var highLevel = schemeReference.highLevel();
	    if (!highLevel)
	        return "";
	    var attributeValue = highLevel.value();
	    if (!attributeValue)
	        return "";
	    return attributeValue.toString();
	}
	exports.securitySchemeName = securitySchemeName;
	/**
	 * __$helperMethod__
	 * __$meta__={"primary":true}
	 **/
	function securityScheme(schemeReference) {
	    var highLevel = schemeReference.highLevel();
	    if (!highLevel)
	        return null;
	    var declaration = search.findDeclarationByNode(highLevel, search.LocationKind.VALUE_COMPLETION);
	    if (!declaration)
	        return null;
	    if (!declaration.getKind || declaration.getKind() != hl.NodeKind.NODE) {
	        return null;
	    }
	    var result = declaration.wrapperNode();
	    if (!(result instanceof RamlWrapperImpl.AbstractSecuritySchemeImpl)) {
	        //I do not see how to avoid instanceof here
	        return null;
	    }
	    return result;
	}
	exports.securityScheme = securityScheme;
	/**
	 * __$helperMethod__
	 * __$meta__={"primary":true}
	 **/
	function RAMLVersion(api) {
	    return api.highLevel().definition().universe().version();
	}
	exports.RAMLVersion = RAMLVersion;
	/**
	 * __$helperMethod__
	 * __$meta__={"primary":true}
	 **/
	function structuredValue(reference) {
	    var hl = reference.value().lowLevel();
	    return new core.TypeInstanceImpl(hl);
	}
	exports.structuredValue = structuredValue;
	/**
	 * __$helperMethod__
	 * __$meta__={"name":"name","primary":true}
	 **/
	function referenceName(reference) {
	    var val = reference.highLevel().value();
	    return (typeof val == 'string') || val == null ? val : val.valueName();
	}
	exports.referenceName = referenceName;
	/**
	 * __$helperMethod__
	 * __$meta__={"name":"trait","primary":true}
	 **/
	function referencedTrait(ref) {
	    return referencedObject(ref);
	}
	exports.referencedTrait = referencedTrait;
	/**
	 * __$helperMethod__
	 * __$meta__={"name":"resourceType","primary":true}
	 **/
	function referencedResourceType(ref) {
	    return referencedObject(ref);
	}
	exports.referencedResourceType = referencedResourceType;
	function referencedObject(ref) {
	    var attr = ref.highLevel();
	    var parent = attr.parent();
	    var vn = ref.name();
	    var cands = search.referenceTargets(attr.property(), parent).filter(function (x) { return hlimpl.qName(x, parent) == vn; });
	    if (cands.length == 0) {
	        return null;
	    }
	    return cands[0].wrapperNode();
	}
	function extractParams(params, uri, owner, propName) {
	    var ownerHl = owner.highLevel();
	    var prop = ownerHl.definition().property(propName);
	    if (!uri) {
	        return [];
	    }
	    var describedParams = {};
	    params.forEach(function (x) {
	        var arr = describedParams[x.name()];
	        if (!arr) {
	            arr = [];
	            describedParams[x.name()] = arr;
	        }
	        arr.push(x);
	    });
	    var allParams = [];
	    var prev = 0;
	    var mentionedParams = {};
	    for (var i = uri.indexOf('{'); i >= 0; i = uri.indexOf('{', prev)) {
	        prev = uri.indexOf('}', ++i);
	        var paramName = uri.substring(i, prev);
	        mentionedParams[paramName] = true;
	        if (describedParams[paramName]) {
	            describedParams[paramName].forEach(function (x) { return allParams.push(x); });
	        }
	        else {
	            var uriParameter = new RamlWrapperImpl.StringTypeDeclarationImpl(paramName);
	            uriParameter.setName(paramName);
	            var hlNode = uriParameter.highLevel();
	            hlNode.setParent(ownerHl);
	            uriParameter.meta().setCalculated();
	            hlNode.patchProp(prop);
	            allParams.push(uriParameter);
	        }
	    }
	    Object.keys(describedParams).filter(function (x) { return !mentionedParams[x]; })
	        .forEach(function (x) { return describedParams[x].forEach(function (y) { return allParams.push(y); }); });
	    return allParams;
	}
	;
	/**
	 * __$helperMethod__
	 * __$meta__={"primary":true}
	 **/
	function schemaContent(bodyDeclaration) {
	    var schemaDecl = bodyDeclaration.schema();
	    if (schemaDecl == null) {
	        return null;
	    }
	    var schemaString = schemaDecl.value();
	    if (!schemaString) {
	        return null;
	    }
	    var schemaAttribute = bodyDeclaration.highLevel().attr(universes.Universe08.BodyLike.properties.schema.name);
	    if (!schemaAttribute) {
	        return schemaString;
	    }
	    var declaration = search.findDeclarationByNode(schemaAttribute, search.LocationKind.VALUE_COMPLETION);
	    if (!declaration)
	        return schemaString;
	    if (!declaration.getKind || declaration.getKind() != hl.NodeKind.NODE) {
	        return schemaString;
	    }
	    //we found the schema declaration and should get its contents
	    if (declaration.definition().key() != universes.Universe08.GlobalSchema) {
	        return schemaString;
	    }
	    var valueAttribute = declaration.attr(universes.Universe08.GlobalSchema.properties.value.name);
	    if (valueAttribute == null) {
	        return null;
	    }
	    return valueAttribute.value();
	}
	exports.schemaContent = schemaContent;
	/**
	 * __$helperMethod__
	 * __$meta__={"name":"parametrizedProperties","primary":true}
	 **/
	function getTemplateParametrizedProperties(node) {
	    var highLevelNode = node.highLevel();
	    if (highLevelNode == null) {
	        return null;
	    }
	    var lowLevelNode = highLevelNode.lowLevel();
	    if (lowLevelNode == null) {
	        return null;
	    }
	    var children = lowLevelNode.children().filter(function (x) { return x.key().indexOf("<<") >= 0; });
	    if (children.length == 0) {
	        return null;
	    }
	    var result = new core.TypeInstanceImpl(children);
	    return result;
	}
	exports.getTemplateParametrizedProperties = getTemplateParametrizedProperties;
	//
	//export class SchemaDef{
	//
	//    constructor(private _content:string, private _name?:string){}
	//
	//    name():string{return this._name}
	//
	//    content(): string{return this._content}
	//}
	//
	//
	//export class ParamValue{
	//    key:string
	//    value:any
	//
	//    constructor(key:string, value:any) {
	//        this.key = key;
	//        this.value = value;
	//    }
	//}
	//
	//
	//class ParamWrapper implements Raml08Parser.BasicNamedParameter{
	//
	//    constructor(private _param:RamlWrapper.TypeDeclaration){
	//
	//        this.description = _param.description() ? _param.description().value() : this.description;
	//
	//        this.displayName = _param.displayName();
	//
	////        this.enum = _param.enum();
	//
	//        this.type = _param.type().length > 0 ? _param.type()[0] : "string";
	//
	//        this.example = _param.example();
	//
	//        this.repeat = _param.repeat();
	//
	//        this.required = _param.required();
	//
	//        this.default = _param.default();
	//    }
	//
	//    description: Raml08Parser.MarkdownString
	//
	//    displayName: string
	//
	//    'enum': any[]
	//
	//    type: string
	//
	//    example: any
	//
	//    repeat: boolean
	//
	//    required: boolean
	//
	//    'default': any
	//
	//}
	//# sourceMappingURL=wrapperHelper08.js.map

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/// <reference path="../../../typings/main.d.ts" />
	var ll = __webpack_require__(11);
	var hlimpl = __webpack_require__(16);
	var yaml = __webpack_require__(72);
	var jsyaml = __webpack_require__(27);
	var proxy = __webpack_require__(39);
	var universeDef = __webpack_require__(22);
	var _ = __webpack_require__(63);
	var universeHelpers = __webpack_require__(14);
	var namespaceResolver = __webpack_require__(54);
	var def = __webpack_require__(36);
	var typeExpressions = def.rt.typeExpressions;
	(function (PatchMode) {
	    PatchMode[PatchMode["DEFAULT"] = 0] = "DEFAULT";
	    PatchMode[PatchMode["PATH"] = 1] = "PATH";
	})(exports.PatchMode || (exports.PatchMode = {}));
	var PatchMode = exports.PatchMode;
	var ReferencePatcher = (function () {
	    function ReferencePatcher(mode) {
	        if (mode === void 0) { mode = PatchMode.DEFAULT; }
	        this.mode = mode;
	        this._outerDependencies = {};
	    }
	    ReferencePatcher.prototype.process = function (hlNode, rootNode, removeUses, patchNodeName) {
	        if (rootNode === void 0) { rootNode = hlNode; }
	        if (removeUses === void 0) { removeUses = false; }
	        if (patchNodeName === void 0) { patchNodeName = false; }
	        if (hlNode.lowLevel()["libProcessed"]) {
	            return;
	        }
	        var resolver = hlNode.lowLevel().unit().project().namespaceResolver();
	        this.patchReferences(hlNode, rootNode, resolver);
	        if (patchNodeName) {
	            this.patchNodeName(hlNode, rootNode.lowLevel().unit(), resolver);
	        }
	        if (removeUses) {
	            this.removeUses(hlNode.lowLevel());
	        }
	        else {
	            this.patchUses(hlNode.lowLevel(), resolver);
	        }
	        this.resetTypes(hlNode);
	        hlNode.resetChildren();
	        hlNode.lowLevel()["libProcessed"] = true;
	    };
	    ReferencePatcher.prototype.patchReferences = function (node, rootNode, resolver, units) {
	        if (rootNode === void 0) { rootNode = node; }
	        if (resolver === void 0) { resolver = new namespaceResolver.NamespaceResolver(); }
	        if (units === void 0) { units = [rootNode.lowLevel().unit()]; }
	        var isNode;
	        if (node.definition().property(universeDef.Universe10.TypeDeclaration.properties.annotations.name) != null) {
	            var cNode = node.lowLevel();
	            if (!(cNode instanceof proxy.LowLevelCompositeNode)) {
	                return;
	            }
	            var isPropertyName = universeDef.Universe10.MethodBase.properties.is.name;
	            var traitNodes = node.attributes(isPropertyName);
	            cNode.preserveAnnotations();
	            node.resetChildren();
	            if (traitNodes.length != 0) {
	                isNode = patchMethodIs(node, traitNodes.map(function (x) { return x.lowLevel(); }).map(function (x) {
	                    return {
	                        node: x,
	                        transformer: x.transformer()
	                    };
	                }));
	            }
	        }
	        var attrs = node.attrs();
	        for (var _i = 0, attrs_1 = attrs; _i < attrs_1.length; _i++) {
	            var attr = attrs_1[_i];
	            var appended = this.appendUnitIfNeeded(attr, units);
	            this.patchReferenceAttr(attr, rootNode, resolver, units);
	            this.popUnitIfNeeded(units, appended);
	        }
	        if (universeHelpers.isTypeDeclarationDescendant(node.definition())) {
	            var appended = this.appendUnitIfNeeded(node, units);
	            this.patchType(node, rootNode, resolver, units);
	            this.popUnitIfNeeded(units, appended);
	        }
	        var childNodes = node.elements();
	        for (var _a = 0, childNodes_1 = childNodes; _a < childNodes_1.length; _a++) {
	            var ch = childNodes_1[_a];
	            var appended = this.appendUnitIfNeeded(ch, units);
	            this.patchReferences(ch, rootNode, resolver, units);
	            this.popUnitIfNeeded(units, appended);
	        }
	        if (isNode) {
	            isNode.filterChildren();
	        }
	    };
	    ReferencePatcher.prototype.patchReferenceAttr = function (attr, rootNode, resolver, units) {
	        var property = attr.property();
	        var range = property.range();
	        if (!range.isAssignableFrom(universeDef.Universe10.Reference.name)) {
	            return;
	        }
	        var value = attr.value();
	        if (value == null) {
	            return;
	        }
	        var llNode = attr.lowLevel();
	        if (!(llNode instanceof proxy.LowLevelProxyNode)) {
	            return;
	        }
	        var transformer = llNode.transformer();
	        var isAnnotation = universeHelpers.isAnnotationsProperty(property);
	        if (typeof value == "string") {
	            var stringToPatch = value;
	            if (transformer != null) {
	                var actualNode = toOriginal(llNode);
	                stringToPatch = actualNode.value();
	            }
	            if (isAnnotation) {
	                stringToPatch = stringToPatch.substring(1, stringToPatch.length - 1);
	            }
	            var newValue = this.resolveReferenceValue(stringToPatch, rootNode.lowLevel().unit(), units, resolver, transformer, range);
	            if (newValue != null) {
	                var newValue1 = isAnnotation ? "(" + newValue.value() + ")" : newValue.value();
	                attr.lowLevel().setValueOverride(newValue1);
	                this.registerPatchedReference(newValue);
	            }
	        }
	        else {
	            var sValue = value;
	            var key = sValue.lowLevel().key();
	            var stringToPatch = key;
	            if (transformer != null) {
	                var actualNode = toOriginal(sValue.lowLevel());
	                stringToPatch = actualNode.key();
	            }
	            if (key != null) {
	                if (isAnnotation) {
	                    stringToPatch = stringToPatch.substring(1, stringToPatch.length - 1);
	                }
	                var newValue = this.resolveReferenceValue(stringToPatch, rootNode.lowLevel().unit(), units, resolver, transformer, range);
	                if (newValue != null) {
	                    var newValue1 = isAnnotation ? "(" + newValue.value() + ")" : newValue.value();
	                    sValue.lowLevel().setKeyOverride(newValue1);
	                    this.registerPatchedReference(newValue);
	                }
	            }
	        }
	    };
	    ReferencePatcher.prototype.patchType = function (node, rootNode, resolver, units) {
	        var _this = this;
	        var nodeType = node.definition();
	        var isExternal = node.localType().isExternal();
	        if (!isExternal) {
	            for (var _i = 0, _a = node.localType().allSuperTypes(); _i < _a.length; _i++) {
	                var st = _a[_i];
	                isExternal = st.isExternal();
	                if (isExternal) {
	                    break;
	                }
	            }
	        }
	        if (!isExternal) {
	            var rootUnit = rootNode.lowLevel().unit();
	            var rootPath = rootUnit.absolutePath();
	            //if(rootPath != localPath) {
	            var typeAttributes = node.attributes(universeDef.Universe10.TypeDeclaration.properties.type.name);
	            if (typeAttributes.length == 0) {
	                typeAttributes = node.attributes(universeDef.Universe10.TypeDeclaration.properties.schema.name);
	            }
	            for (var _b = 0, typeAttributes_1 = typeAttributes; _b < typeAttributes_1.length; _b++) {
	                var typeAttr = typeAttributes_1[_b];
	                var llNode = typeAttr.lowLevel();
	                if (!(llNode instanceof proxy.LowLevelProxyNode)) {
	                    continue;
	                }
	                var localUnit = typeAttr.lowLevel().unit();
	                var localPath = localUnit.absolutePath();
	                var value = typeAttr.value();
	                if (typeof value == "string") {
	                    var gotExpression = checkExpression(value);
	                    var transformer = llNode.transformer();
	                    var stringToPatch = value;
	                    var escapeData = { status: ParametersEscapingStatus.NOT_REQUIRED };
	                    var additionalUnits = transformer ? transformer.unitsChain : null;
	                    if (transformer != null || value.indexOf("<<") >= 0) {
	                        var actualNode = toOriginal(llNode);
	                        var actualValue = actualNode.value();
	                        escapeData = escapeTemplateParameters(actualValue);
	                        if (escapeData.status == ParametersEscapingStatus.OK) {
	                            if (gotExpression) {
	                                stringToPatch = escapeData.resultingString;
	                            }
	                            else {
	                                stringToPatch = actualValue;
	                            }
	                        }
	                        else {
	                            transformer = null;
	                        }
	                    }
	                    var appendedAdditional;
	                    if (additionalUnits) {
	                        appendedAdditional = [];
	                        for (var _c = 0, additionalUnits_1 = additionalUnits; _c < additionalUnits_1.length; _c++) {
	                            var u = additionalUnits_1[_c];
	                            appendedAdditional.push(this.appendUnitIfNeeded(u, units));
	                        }
	                    }
	                    var appendedAttrUnit = this.appendUnitIfNeeded(typeAttr, units);
	                    var newValue;
	                    if (gotExpression) {
	                        var expressionPatchFailed = false;
	                        var expr = typeExpressions.parse(stringToPatch);
	                        var gotPatch = false;
	                        typeExpressions.visit(expr, function (x) {
	                            if (x.type == "name") {
	                                var lit = x;
	                                var typeName = lit.value;
	                                var unescapeData = { status: ParametersEscapingStatus.NOT_REQUIRED };
	                                var unescaped;
	                                if (escapeData.status == ParametersEscapingStatus.OK) {
	                                    unescaped = escapeData.substitutions[typeName];
	                                    if (unescaped == null) {
	                                        unescapeData = unescapeTemplateParameters(typeName, escapeData.substitutions);
	                                        if (unescapeData.status == ParametersEscapingStatus.OK) {
	                                            typeName = unescapeData.resultingString;
	                                        }
	                                        else if (unescapeData.status == ParametersEscapingStatus.ERROR) {
	                                            expressionPatchFailed = true;
	                                            return;
	                                        }
	                                    }
	                                    else {
	                                        typeName = unescaped;
	                                    }
	                                }
	                                if (transformer == null && (unescaped != null || unescapeData.status == ParametersEscapingStatus.OK)) {
	                                    lit.value = typeName;
	                                    return;
	                                }
	                                var patched = _this.resolveReferenceValue(typeName, rootUnit, units, resolver, transformer, nodeType);
	                                if (patched != null) {
	                                    lit.value = patched.value();
	                                    gotPatch = true;
	                                    _this.registerPatchedReference(patched);
	                                }
	                            }
	                        });
	                        if (gotPatch && !expressionPatchFailed) {
	                            newValue = typeExpressions.serializeToString(expr);
	                        }
	                        else {
	                            newValue = value;
	                        }
	                    }
	                    else if (!(escapeData.status == ParametersEscapingStatus.OK && transformer == null)) {
	                        var patched = this.resolveReferenceValue(stringToPatch, rootUnit, units, resolver, transformer, nodeType);
	                        if (patched != null) {
	                            this.registerPatchedReference(patched);
	                            newValue = patched.value();
	                        }
	                    }
	                    if (newValue != null) {
	                        typeAttr.lowLevel().setValueOverride(newValue);
	                        typeAttr.overrideValue(null);
	                    }
	                    this.popUnitIfNeeded(units, appendedAttrUnit);
	                    if (appendedAdditional) {
	                        for (var _d = 0, _e = appendedAdditional.reverse(); _d < _e.length; _d++) {
	                            var ap = _e[_d];
	                            this.popUnitIfNeeded(units, ap);
	                        }
	                    }
	                }
	                else {
	                    var llTypeNode = _.find(node.lowLevel().children(), function (x) { return x.key() == "type"; });
	                    if (llTypeNode) {
	                        var def = node.definition().universe().type(universeDef.Universe10.TypeDeclaration.name);
	                        var newNode = new hlimpl.ASTNodeImpl(llTypeNode, null, def, null);
	                        var appended = this.appendUnitIfNeeded(newNode, units);
	                        this.patchReferences(newNode, rootNode, resolver, units);
	                        this.popUnitIfNeeded(units, appended);
	                    }
	                }
	            }
	        }
	    };
	    ReferencePatcher.prototype.resolveReferenceValue = function (stringToPatch, rootUnit, units, resolver, transformer, range) {
	        var _this = this;
	        var isAnnotation = universeHelpers.isAnnotationRefTypeOrDescendant(range);
	        var newValue;
	        if (transformer) {
	            if (stringToPatch && stringToPatch.indexOf("<<") >= 0) {
	                var doContinue = true;
	                var types = rootUnit.highLevel().types();
	                newValue = transformer.transform(stringToPatch, true, function () { return doContinue; }, function (val, tr) {
	                    var newVal = _this.resolveReferenceValueBasic(val, rootUnit, resolver, tr.unitsChain, range);
	                    if (newVal == null) {
	                        newVal = new PatchedReference(null, val, _this.collectionName(range), rootUnit, PatchMode.DEFAULT);
	                    }
	                    if (isAnnotation) {
	                        if (types.getAnnotationType(newVal.value()) != null) {
	                            doContinue = false;
	                        }
	                        else {
	                            doContinue = false;
	                        }
	                    }
	                    else if (types.getType(newVal.value()) != null) {
	                        doContinue = false;
	                    }
	                    else {
	                        doContinue = false;
	                    }
	                    return newVal;
	                }).value;
	            }
	        }
	        if (newValue === undefined) {
	            newValue = this.resolveReferenceValueBasic(stringToPatch, rootUnit, resolver, units, range);
	        }
	        return newValue;
	    };
	    ReferencePatcher.prototype.patchNodeName = function (hlNode, rootUnit, resolver) {
	        var llNode = hlNode.lowLevel();
	        var key = llNode.key();
	        var range = hlNode.definition();
	        if (universeHelpers.isTypeDeclarationSibling(range)) {
	            var localType = hlNode.localType();
	            if (localType.isAnnotationType()) {
	                range = localType;
	            }
	        }
	        var patched = this.resolveReferenceValueBasic(key, rootUnit, resolver, [llNode.unit()], range);
	        if (patched != null) {
	            llNode.setKeyOverride(patched.value());
	        }
	    };
	    ReferencePatcher.prototype.resolveReferenceValueBasic = function (value, rootUnit, resolver, units, range) {
	        var isType = universeHelpers.isTypeDeclarationDescendant(range);
	        var ind = value.lastIndexOf(".");
	        var referencedUnit;
	        var plainName;
	        if (ind >= 0) {
	            var oldNS = value.substring(0, ind);
	            plainName = value.substring(ind + 1);
	            for (var i = units.length; i > 0; i--) {
	                var localUnit = units[i - 1];
	                var nsMap = resolver.nsMap(localUnit);
	                if (nsMap == null) {
	                    continue;
	                }
	                var info = nsMap[oldNS];
	                if (info == null) {
	                    continue;
	                }
	                referencedUnit = info.unit;
	                if (referencedUnit != null) {
	                    break;
	                }
	            }
	        }
	        else {
	            if (isType && def.rt.builtInTypes().get(value) != null) {
	                return null;
	            }
	            plainName = value;
	            referencedUnit = units[units.length - 1];
	        }
	        var collectionName = this.collectionName(range);
	        if (referencedUnit == null || referencedUnit.absolutePath() == rootUnit.absolutePath()) {
	            return null;
	        }
	        if (this.mode == PatchMode.PATH) {
	            if (resolver.resolveNamespace(rootUnit, referencedUnit) == null) {
	                return null;
	            }
	            var aPath = referencedUnit.absolutePath().replace(/\\/g, "/");
	            if (!ll.isWebPath(aPath)) {
	                aPath = "file://" + aPath;
	            }
	            newNS = aPath + "#/" + collectionName;
	        }
	        else {
	            var newNS = resolver.resolveNamespace(rootUnit, referencedUnit);
	            if (newNS == null) {
	                return null;
	            }
	        }
	        return new PatchedReference(newNS, plainName, collectionName, referencedUnit, this.mode);
	    };
	    ReferencePatcher.prototype.patchUses = function (node, resolver) {
	        if (!(node instanceof proxy.LowLevelCompositeNode)) {
	            return;
	        }
	        var unit = node.unit();
	        var extendedUnitMap = resolver.expandedPathMap(unit);
	        if (extendedUnitMap == null) {
	            return;
	        }
	        var unitMap = resolver.pathMap(unit);
	        if (!unitMap) {
	            unitMap = {};
	        }
	        var cNode = node;
	        var originalChildren = node.children();
	        var usesNodes = originalChildren.filter(function (x) {
	            return x.key() == universeDef.Universe10.FragmentDeclaration.properties.uses.name;
	        });
	        var oNode = toOriginal(node);
	        var yamlNode = oNode;
	        while (yamlNode instanceof proxy.LowLevelProxyNode) {
	            yamlNode = yamlNode.originalNode();
	        }
	        var usesInfos = Object.keys(unitMap).map(function (x) { return extendedUnitMap[x]; });
	        var extendedUsesInfos = Object.keys(extendedUnitMap).map(function (x) { return extendedUnitMap[x]; })
	            .filter(function (x) { return !unitMap[x.absolutePath()]; } /*&&this.usedNamespaces[x.namespace()]*/ /*&&this.usedNamespaces[x.namespace()]*/);
	        var u = node.unit();
	        var unitPath = u.absolutePath();
	        var existingLibs = {};
	        var usesNode;
	        if (usesNodes.length > 0) {
	            usesNode = usesNodes[0];
	            usesNode.children().forEach(function (x) { return existingLibs[x.key()] = true; });
	        }
	        else {
	            var newUses = jsyaml.createMapNode("uses");
	            newUses["_parent"] = yamlNode;
	            newUses.setUnit(yamlNode.unit());
	            usesNode = cNode.replaceChild(null, newUses);
	        }
	        for (var _i = 0, _a = usesInfos.concat(extendedUsesInfos); _i < _a.length; _i++) {
	            var ui = _a[_i];
	            var up = ui.absolutePath();
	            if (existingLibs[ui.namespace()]) {
	                continue;
	            }
	            var ip = ui.includePath;
	            var mapping = jsyaml.createMapping(ui.namespace(), ip);
	            mapping.setUnit(yamlNode.unit());
	            usesNode.replaceChild(null, mapping);
	        }
	    };
	    ReferencePatcher.prototype.removeUses = function (node) {
	        if (!(node instanceof proxy.LowLevelCompositeNode)) {
	            return;
	        }
	        var cNode = node;
	        var originalChildren = node.children();
	        var usesNodes = originalChildren.filter(function (x) {
	            return x.key() == universeDef.Universe10.FragmentDeclaration.properties.uses.name;
	        });
	        if (usesNodes.length > 0) {
	            cNode.removeChild(usesNodes[0]);
	        }
	    };
	    ReferencePatcher.prototype.resetTypes = function (hlNode) {
	        for (var _i = 0, _a = hlNode.elements(); _i < _a.length; _i++) {
	            var ch = _a[_i];
	            this.resetTypes(ch);
	        }
	        delete hlNode.lowLevel().actual().types;
	        delete hlNode["_ptype"];
	        delete hlNode["_types"];
	        hlNode.setAssociatedType(null);
	    };
	    ;
	    ReferencePatcher.prototype.appendUnitIfNeeded = function (node, units) {
	        if (node instanceof jsyaml.CompilationUnit) {
	            var unit = node;
	            if (unit.absolutePath() != units[units.length - 1].absolutePath()) {
	                units.push(unit);
	                return true;
	            }
	            return false;
	        }
	        var originalNode = toOriginal(node.lowLevel());
	        var originalUnit = originalNode.unit();
	        if (originalNode.valueKind() == yaml.Kind.INCLUDE_REF) {
	            var ref = originalNode.includePath();
	            var includedUnit = originalUnit.resolve(ref);
	            units.push(includedUnit);
	            return true;
	        }
	        else {
	            if (originalUnit.absolutePath() != units[units.length - 1].absolutePath()) {
	                units.push(originalUnit);
	                return true;
	            }
	            return false;
	        }
	    };
	    ReferencePatcher.prototype.popUnitIfNeeded = function (units, appended) {
	        if (appended) {
	            units.pop();
	        }
	    };
	    ReferencePatcher.prototype.registerPatchedReference = function (ref) {
	        var collectionName = ref.collectionName();
	        if (!collectionName) {
	            return;
	        }
	        var aPath = ref.referencedUnit().absolutePath();
	        var libMap = this._outerDependencies[aPath];
	        if (libMap == null) {
	            libMap = {};
	            this._outerDependencies[aPath] = libMap;
	        }
	        var collectionMap = libMap[collectionName];
	        if (collectionMap == null) {
	            collectionMap = {};
	            libMap[collectionName] = collectionMap;
	        }
	        collectionMap[ref.name()] = ref;
	    };
	    ReferencePatcher.prototype.collectionName = function (range) {
	        var collectionName;
	        if (universeHelpers.isResourceTypeRefType(range) || universeHelpers.isResourceTypeType(range)) {
	            collectionName = def.universesInfo.Universe10.LibraryBase.properties.resourceTypes.name;
	        }
	        else if (universeHelpers.isTraitRefType(range) || universeHelpers.isTraitType(range)) {
	            collectionName = def.universesInfo.Universe10.LibraryBase.properties.traits.name;
	        }
	        else if (universeHelpers.isSecuritySchemeRefType(range) || universeHelpers.isSecuritySchemaTypeDescendant(range)) {
	            collectionName = def.universesInfo.Universe10.LibraryBase.properties.securitySchemes.name;
	        }
	        else if (universeHelpers.isAnnotationRefTypeOrDescendant(range) || range.isAnnotationType()) {
	            collectionName = def.universesInfo.Universe10.LibraryBase.properties.annotationTypes.name;
	        }
	        else if (universeHelpers.isTypeDeclarationDescendant(range)) {
	            collectionName = def.universesInfo.Universe10.LibraryBase.properties.types.name;
	        }
	        return collectionName;
	    };
	    ReferencePatcher.prototype.expandLibraries = function (api) {
	        if (api.lowLevel().actual().libExpanded) {
	            return;
	        }
	        var llNode = api.lowLevel();
	        var unit = llNode.unit();
	        var rootPath = unit.absolutePath();
	        var project = unit.project();
	        var usedNamespaces = Object.keys(this._outerDependencies).filter(function (x) { return x != rootPath; });
	        var libModels = [];
	        var resolver = llNode.unit().project().namespaceResolver();
	        for (var _i = 0, usedNamespaces_1 = usedNamespaces; _i < usedNamespaces_1.length; _i++) {
	            var ns = usedNamespaces_1[_i];
	            var libUnit = project.unit(ns, true);
	            if (libUnit && resolver.resolveNamespace(unit, libUnit) != null) {
	                var dependencies = this._outerDependencies[ns];
	                var libModel = this.extractLibModel(libUnit, dependencies);
	                libModels.push(libModel);
	            }
	        }
	        var gotContribution = false;
	        for (var _a = 0, libModels_1 = libModels; _a < libModels_1.length; _a++) {
	            var libModel = libModels_1[_a];
	            for (var _b = 0, _c = Object.keys(libModel); _b < _c.length; _b++) {
	                var cName = _c[_b];
	                var collection = libModel[cName];
	                if (collection instanceof ElementsCollection) {
	                    gotContribution = gotContribution || this.contributeCollection(api.lowLevel(), collection, resolver);
	                }
	            }
	        }
	        this.resetTypes(api);
	        api.resetChildren();
	        var apiPath = api.lowLevel().unit().absolutePath();
	        for (var _d = 0, _e = api.children(); _d < _e.length; _d++) {
	            var ch = _e[_d];
	            if (!ch.isElement()) {
	                continue;
	            }
	            var chPath = ch.lowLevel().unit().absolutePath();
	            if (chPath == apiPath && ch.lowLevel().includePath() == null) {
	                continue;
	            }
	            var definition = ch.asElement().definition();
	            if (this.collectionName(definition) != null) {
	                this.process(ch.asElement(), api, true, true);
	            }
	        }
	        if (gotContribution) {
	            this.expandLibraries(api);
	        }
	        this.removeUses(api.lowLevel());
	        api.lowLevel().actual().libExpanded = true;
	        this.resetTypes(api);
	        api.resetChildren();
	    };
	    ReferencePatcher.prototype.contributeCollection = function (llApi, collection, resolver) {
	        var name = collection.name;
	        var llNode = _.find(llApi.children(), function (x) { return x.key() == name; });
	        if (llNode == null) {
	            var n = jsyaml.createMapNode(name);
	            llNode = llApi.replaceChild(null, n);
	        }
	        var result = false;
	        for (var _i = 0, _a = collection.array; _i < _a.length; _i++) {
	            var e = _a[_i];
	            if (llNode.children().some(function (x) {
	                var oNode = toOriginal(x);
	                if (oNode.unit().absolutePath() != e.lowLevel().unit().absolutePath()) {
	                    return false;
	                }
	                return e.lowLevel().key() == oNode.key() && e.lowLevel().unit().absolutePath() == oNode.unit().absolutePath();
	            })) {
	                continue;
	            }
	            llNode.replaceChild(null, e.lowLevel());
	            result = true;
	        }
	        return result;
	    };
	    ReferencePatcher.prototype.extractLibModel = function (unit, dependencies) {
	        var result = new LibModel();
	        var hlNode = unit.highLevel();
	        if (hlNode && hlNode.isElement()) {
	            for (var _i = 0, _a = Object.keys(dependencies); _i < _a.length; _i++) {
	                var cName = _a[_i];
	                var dep = dependencies[cName];
	                var collection = new ElementsCollection(cName);
	                for (var _b = 0, _c = hlNode.asElement().elementsOfKind(cName); _b < _c.length; _b++) {
	                    var el = _c[_b];
	                    if (dep[el.name()]) {
	                        collection.array.push(el);
	                    }
	                }
	                result[cName] = collection;
	            }
	        }
	        return result;
	    };
	    return ReferencePatcher;
	}());
	exports.ReferencePatcher = ReferencePatcher;
	var ParametersEscapingStatus;
	(function (ParametersEscapingStatus) {
	    ParametersEscapingStatus[ParametersEscapingStatus["OK"] = 0] = "OK";
	    ParametersEscapingStatus[ParametersEscapingStatus["NOT_REQUIRED"] = 1] = "NOT_REQUIRED";
	    ParametersEscapingStatus[ParametersEscapingStatus["ERROR"] = 2] = "ERROR";
	})(ParametersEscapingStatus || (ParametersEscapingStatus = {}));
	var PARAM_OCCURENCE_STR = "__P_A_R_A_M_E_T_E_R__";
	function escapeTemplateParameters(str) {
	    if (str == null || typeof str != "string") {
	        return { status: ParametersEscapingStatus.NOT_REQUIRED };
	    }
	    var resultingString = "";
	    var map = {};
	    var prev = 0;
	    for (var i = str.indexOf("<<"); i >= 0; i = str.indexOf("<<", prev)) {
	        resultingString += str.substring(prev, i);
	        prev = str.indexOf(">>", i);
	        if (prev < 0) {
	            return { status: ParametersEscapingStatus.ERROR };
	        }
	        prev += ">>".length;
	        var paramStr = str.substring(i, prev);
	        var substitution = PARAM_OCCURENCE_STR + i + PARAM_OCCURENCE_STR;
	        map[substitution] = paramStr;
	        resultingString += substitution;
	    }
	    if (resultingString.length == 0) {
	        return { status: ParametersEscapingStatus.NOT_REQUIRED };
	    }
	    resultingString += str.substring(prev, str.length);
	    return {
	        resultingString: resultingString,
	        substitutions: map,
	        status: ParametersEscapingStatus.OK
	    };
	}
	function unescapeTemplateParameters(str, substitutions) {
	    if (str == null) {
	        return { status: ParametersEscapingStatus.NOT_REQUIRED };
	    }
	    var resultingString = "";
	    var prev = 0;
	    for (var i = str.indexOf(PARAM_OCCURENCE_STR); i >= 0; i = str.indexOf(PARAM_OCCURENCE_STR, prev)) {
	        prev = str.indexOf(PARAM_OCCURENCE_STR, i + 1);
	        prev += PARAM_OCCURENCE_STR.length;
	        if (prev < 0) {
	            return { status: ParametersEscapingStatus.ERROR };
	        }
	        var substitution = str.substring(i, prev);
	        var originalParamOccurence = substitutions[substitution];
	        if (originalParamOccurence == null) {
	            return { status: ParametersEscapingStatus.ERROR };
	        }
	        resultingString += originalParamOccurence;
	    }
	    if (resultingString.length == 0) {
	        return { status: ParametersEscapingStatus.NOT_REQUIRED };
	    }
	    resultingString += str.substring(prev, str.length);
	    return {
	        resultingString: resultingString,
	        substitutions: substitutions,
	        status: ParametersEscapingStatus.OK
	    };
	}
	function checkExpression(value) {
	    var gotExpression = false;
	    for (var i = 0; i < value.length; i++) {
	        var ch = value.charAt(i);
	        if (ch == "|" || ch == "(" || ch == "[") {
	            gotExpression = true;
	            break;
	        }
	    }
	    return gotExpression;
	}
	;
	function patchMethodIs(node, traits) {
	    var llMethod = node.lowLevel();
	    var ramlVersion = node.definition().universe().version();
	    var originalLlMethod = toOriginal(llMethod);
	    var isPropertyName = universeDef.Universe10.MethodBase.properties.is.name;
	    var isNode = _.find(llMethod.children(), function (x) { return x.key() == isPropertyName; });
	    if (isNode == null) {
	        var newLLIsNode = new jsyaml.ASTNode(yaml.newMapping(yaml.newScalar(isPropertyName), yaml.newItems()), originalLlMethod.unit(), originalLlMethod, null, null);
	        isNode = llMethod.replaceChild(null, newLLIsNode);
	    }
	    var originalIsNode = _.find(originalLlMethod.children(), function (x) { return x.key() == isPropertyName; });
	    var childrenToPreserve = originalIsNode != null ? originalIsNode.children() : [];
	    var newTraits = childrenToPreserve.concat(traits.map(function (x) {
	        var llChNode = prepareTraitRefNode(x.node, isNode);
	        if (llChNode != null) {
	            var cNode = new proxy.LowLevelCompositeNode(llChNode, isNode, x.transformer, ramlVersion);
	            return cNode;
	        }
	        return null;
	    })).filter(function (x) { return x != null; });
	    isNode.setChildren(newTraits);
	    isNode.filterChildren();
	    return isNode;
	}
	exports.patchMethodIs = patchMethodIs;
	function prepareTraitRefNode(llNode, llParent) {
	    llParent = toOriginal(llParent);
	    llNode = toOriginal(llNode);
	    var yNode = llNode.actual();
	    if (yNode == null) {
	        return null;
	    }
	    if (llNode.key() == universeDef.Universe10.MethodBase.properties.is.name) {
	        yNode = llNode.yamlNode().value;
	    }
	    if (yNode == null) {
	        return null;
	    }
	    if (yNode.kind == yaml.Kind.SEQ) {
	        yNode = yNode.items[0];
	    }
	    if (yNode == null) {
	        return null;
	    }
	    var result = new jsyaml.ASTNode(yNode, llNode.unit(), llParent, null, null);
	    return result;
	}
	exports.prepareTraitRefNode = prepareTraitRefNode;
	function toOriginal(node) {
	    for (var i = 0; i < 2 && node instanceof proxy.LowLevelProxyNode; i++) {
	        node = node.originalNode();
	    }
	    return node;
	}
	var PatchedReference = (function () {
	    function PatchedReference(_namespace, _name, _collectionName, _referencedUnit, _mode) {
	        this._namespace = _namespace;
	        this._name = _name;
	        this._collectionName = _collectionName;
	        this._referencedUnit = _referencedUnit;
	        this._mode = _mode;
	    }
	    PatchedReference.prototype.namespace = function () { return this._namespace; };
	    PatchedReference.prototype.name = function () { return this._name; };
	    PatchedReference.prototype.collectionName = function () { return this._collectionName; };
	    PatchedReference.prototype.referencedUnit = function () { return this._referencedUnit; };
	    PatchedReference.prototype.mode = function () { return this._mode; };
	    PatchedReference.prototype.value = function () {
	        if (this._namespace == null) {
	            return this._name;
	        }
	        var delim = this._mode == PatchMode.PATH ? "/" : ".";
	        return this._namespace + delim + this._name;
	    };
	    return PatchedReference;
	}());
	exports.PatchedReference = PatchedReference;
	var ElementsCollection = (function () {
	    function ElementsCollection(name) {
	        this.name = name;
	        this.array = [];
	    }
	    return ElementsCollection;
	}());
	var LibModel = (function () {
	    function LibModel() {
	    }
	    return LibModel;
	}());
	//# sourceMappingURL=referencePatcher.js.map

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/main.d.ts" />
	"use strict";
	/**
	 * Created by kor on 05/05/15.
	 */
	var yaml = __webpack_require__(72);
	var lowlevel = __webpack_require__(11);
	var hlimpl = __webpack_require__(16);
	var util = __webpack_require__(32);
	var llImpl = __webpack_require__(27);
	var Error = yaml.YAMLException;
	var CompilationUnit = (function () {
	    function CompilationUnit(_absolutePath, _path, _content, _project, _isTopoLevel, serializeOptions) {
	        if (serializeOptions === void 0) { serializeOptions = {}; }
	        this._absolutePath = _absolutePath;
	        this._path = _path;
	        this._content = _content;
	        this._project = _project;
	        this._isTopoLevel = _isTopoLevel;
	        this.serializeOptions = serializeOptions;
	        this._node = new AstNode(this, JSON.parse(this._content), null, serializeOptions);
	    }
	    CompilationUnit.prototype.highLevel = function () {
	        return hlimpl.fromUnit(this);
	    };
	    CompilationUnit.prototype.absolutePath = function () {
	        return this._absolutePath;
	    };
	    CompilationUnit.prototype.clone = function () {
	        return null;
	    };
	    CompilationUnit.prototype.contents = function () {
	        return this._content;
	    };
	    CompilationUnit.prototype.lexerErrors = function () {
	        return [];
	    };
	    CompilationUnit.prototype.path = function () {
	        return this._content;
	    };
	    CompilationUnit.prototype.isTopLevel = function () {
	        return this._isTopoLevel;
	    };
	    CompilationUnit.prototype.ast = function () {
	        return this._node;
	    };
	    CompilationUnit.prototype.expandedHighLevel = function () {
	        return this.highLevel();
	    };
	    CompilationUnit.prototype.isDirty = function () {
	        return true;
	    };
	    CompilationUnit.prototype.getIncludeNodes = function () {
	        return [];
	    };
	    CompilationUnit.prototype.resolveAsync = function (p) {
	        return null;
	    };
	    CompilationUnit.prototype.isRAMLUnit = function () {
	        return true;
	    };
	    CompilationUnit.prototype.project = function () {
	        return this._project;
	    };
	    CompilationUnit.prototype.updateContent = function (newContent) { };
	    CompilationUnit.prototype.ramlVersion = function () {
	        throw new Error('not implemented');
	    };
	    CompilationUnit.prototype.lineMapper = function () { return new lowlevel.LineMapperImpl(this.contents(), this.absolutePath()); };
	    CompilationUnit.prototype.resolve = function (p) { return null; }; // TODO FIXME 
	    /**
	     * Returns true if this unit is overlay or extension, false otherwise.
	     */
	    CompilationUnit.prototype.isOverlayOrExtension = function () {
	        return false;
	    };
	    /**
	     * Returns master reference if presents, null otherwise.
	     */
	    CompilationUnit.prototype.getMasterReferenceNode = function () {
	        return null;
	    };
	    return CompilationUnit;
	}());
	exports.CompilationUnit = CompilationUnit;
	//export interface IProject{
	//    units():ICompilationUnit[];//returns units with apis in this folder
	//
	//    execute(cmd:CompositeCommand)
	//
	//    executeTextChange(textCommand:TextChangeCommand);//this may result in broken nodes?
	//
	//    addListener(listener:IASTListener);
	//
	//    removeListener(listener:IASTListener)
	//
	//    addTextChangeListener(listener:ITextChangeCommandListener);
	//    removeTextChangeListener(listener:ITextChangeCommandListener);
	//}
	//export interface IASTListener{
	//    (delta:ASTDelta)
	//}
	//
	//export interface ITextChangeCommandListener{
	//    (delta:TextChangeCommand)
	//}
	//export class ASTDelta{
	//    commands:ASTChangeCommand[]
	//}
	//export interface ASTVisitor{
	//    (node:ILowLevelASTNode):boolean
	//}
	var AstNode = (function () {
	    function AstNode(_unit, _object, _parent, options, _key) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        this._unit = _unit;
	        this._object = _object;
	        this._parent = _parent;
	        this.options = options;
	        this._key = _key;
	        this._isOptional = false;
	        if (this._object instanceof Object) {
	            Object.keys(this._object).forEach(function (x) {
	                var u = unescapeKey(x, _this.options);
	                if (u != x) {
	                    var val = _this._object[x];
	                    delete _this._object[x];
	                    _this._object[u] = val;
	                }
	            });
	        }
	        if (this._key) {
	            if (util.stringEndsWith(this._key, '?')) {
	                this._isOptional = true;
	                this._key = this._key.substring(0, this._key.length - 1);
	            }
	        }
	    }
	    AstNode.prototype.keyKind = function () {
	        return null;
	    };
	    AstNode.prototype.isAnnotatedScalar = function () {
	        return false;
	    };
	    AstNode.prototype.hasInnerIncludeError = function () {
	        return false;
	    };
	    AstNode.prototype.start = function () { return -1; };
	    AstNode.prototype.end = function () { return -1; };
	    AstNode.prototype.value = function () {
	        return this._object;
	    };
	    AstNode.prototype.actual = function () {
	        return this._object;
	    };
	    AstNode.prototype.includeErrors = function () { return []; };
	    AstNode.prototype.includePath = function () { return null; };
	    AstNode.prototype.includeReference = function () { return null; };
	    AstNode.prototype.key = function () { return this._key; };
	    AstNode.prototype.optional = function () { return this._isOptional; };
	    AstNode.prototype.children = function () {
	        var _this = this;
	        if (!this._object) {
	            return [];
	        }
	        if (Array.isArray(this._object)) {
	            return this._object.map(function (x) { return new AstNode(_this._unit, x, _this, _this.options); });
	        }
	        else if (this._object instanceof Object) {
	            return Object.keys(this._object).map(function (x) { return new AstNode(_this._unit, _this._object[x], _this, _this.options, x); });
	        }
	        else {
	            return [];
	        }
	    };
	    AstNode.prototype.parent = function () { return this._parent; };
	    AstNode.prototype.unit = function () { return this._unit; };
	    AstNode.prototype.includeBaseUnit = function () { return this._unit; };
	    AstNode.prototype.anchorId = function () { return null; };
	    AstNode.prototype.errors = function () { return []; };
	    AstNode.prototype.anchoredFrom = function () { return this; };
	    AstNode.prototype.includedFrom = function () { return this; };
	    AstNode.prototype.visit = function (v) {
	        if (v(this)) {
	            this.children().forEach(function (x) { return x.visit(v); });
	        }
	    };
	    AstNode.prototype.dumpToObject = function () {
	        return this._object;
	    };
	    AstNode.prototype.addChild = function (n) { };
	    AstNode.prototype.execute = function (cmd) { };
	    AstNode.prototype.dump = function () { return JSON.stringify(this._object); };
	    AstNode.prototype.keyStart = function () { return -1; };
	    AstNode.prototype.keyEnd = function () { return -1; };
	    AstNode.prototype.valueStart = function () { return -1; };
	    AstNode.prototype.valueEnd = function () { return -1; };
	    AstNode.prototype.isValueLocal = function () { return true; };
	    AstNode.prototype.kind = function () {
	        if (Array.isArray(this._object)) {
	            return yaml.Kind.SEQ;
	        }
	        else if (this._object instanceof Object) {
	            return yaml.Kind.MAP;
	        }
	        else {
	            return yaml.Kind.SCALAR;
	        }
	    };
	    AstNode.prototype.valueKind = function () {
	        if (!this._object) {
	            return null;
	        }
	        var valType = typeof this._object;
	        if (Array.isArray(this._object)) {
	            return yaml.Kind.SEQ;
	        }
	        else if (valType == "object") {
	            return yaml.Kind.MAP;
	        }
	        else if (valType == "string" || valType == "number" || valType == "boolean") {
	            return yaml.Kind.SCALAR;
	        }
	        return null;
	    };
	    AstNode.prototype.anchorValueKind = function () {
	        return null;
	    };
	    AstNode.prototype.show = function (msg) { };
	    AstNode.prototype.setHighLevelParseResult = function (highLevelParseResult) {
	        this._highLevelParseResult = highLevelParseResult;
	    };
	    AstNode.prototype.highLevelParseResult = function () {
	        return this._highLevelParseResult;
	    };
	    AstNode.prototype.setHighLevelNode = function (highLevel) {
	        this._highLevelNode = highLevel;
	    };
	    AstNode.prototype.highLevelNode = function () {
	        return this._highLevelNode;
	    };
	    AstNode.prototype.text = function (unitText) {
	        throw new Error("not implemented");
	    };
	    AstNode.prototype.copy = function () {
	        throw new Error("not implemented");
	    };
	    AstNode.prototype.markup = function (json) {
	        throw new Error("not implemented");
	    };
	    AstNode.prototype.nodeDefinition = function () {
	        return llImpl.getDefinitionForLowLevelNode(this);
	    };
	    AstNode.prototype.includesContents = function () {
	        return false;
	    };
	    return AstNode;
	}());
	exports.AstNode = AstNode;
	function serialize2(n, full) {
	    if (full === void 0) { full = false; }
	    if (!n) {
	        return null;
	    }
	    var kind = n.kind();
	    if (kind == yaml.Kind.ANCHOR_REF) {
	        kind = n.anchorValueKind();
	    }
	    if (kind == yaml.Kind.INCLUDE_REF) {
	        if (n.unit() != null) {
	            var includePath = n.includePath();
	            var resolved = null;
	            try {
	                resolved = n.unit().resolve(includePath);
	            }
	            catch (Error) {
	            }
	            if (resolved == null) {
	                return null;
	            }
	            else if (resolved.isRAMLUnit() && this.canInclude(resolved)) {
	                var ast = resolved.ast();
	                if (ast) {
	                    return serialize2(ast, full);
	                }
	            }
	        }
	        return null;
	    }
	    if (kind == yaml.Kind.SEQ) {
	        var arr = [];
	        for (var _i = 0, _a = n.children(); _i < _a.length; _i++) {
	            var ch = _a[_i];
	            arr.push(serialize2(ch, full));
	        }
	        return arr;
	    }
	    if (kind == yaml.Kind.ANCHOR_REF) {
	        return serialize2(n.anchoredFrom(), full);
	    }
	    if (kind == yaml.Kind.MAPPING) {
	        var v = {};
	        var key = "" + n.key(true);
	        var valueKind = n.valueKind();
	        if (valueKind == yaml.Kind.INCLUDE_REF) {
	            var children = n.children();
	            if (children.length == 0) {
	                v[key] = null;
	            }
	            else {
	                if (children[0].key() == null) {
	                    valueKind = yaml.Kind.SEQ;
	                }
	                else {
	                    valueKind = yaml.Kind.MAP;
	                }
	            }
	        }
	        if (valueKind == yaml.Kind.ANCHOR_REF) {
	            valueKind = n.anchorValueKind();
	        }
	        if (valueKind == yaml.Kind.SCALAR) {
	            v[key] = n.value();
	        }
	        else if (valueKind == yaml.Kind.SEQ) {
	            var arr = [];
	            v[key] = arr;
	            for (var _b = 0, _c = n.children(); _b < _c.length; _b++) {
	                var ch = _c[_b];
	                arr.push(serialize2(ch, true));
	            }
	        }
	        else if (valueKind == yaml.Kind.MAP) {
	            var obj = {};
	            v[key] = obj;
	            for (var _d = 0, _e = n.children(); _d < _e.length; _d++) {
	                var ch = _e[_d];
	                var chKey = "" + ch.key(true);
	                var serialized = serialize2(ch, true);
	                obj[chKey] = serialized === undefined ? null : serialized;
	            }
	        }
	        return v[key];
	    }
	    if (kind == yaml.Kind.SCALAR) {
	        var q = n.value(false);
	        return q;
	    }
	    if (kind == yaml.Kind.MAP) {
	        var obj = {};
	        for (var _f = 0, _g = n.children(); _f < _g.length; _f++) {
	            var ch = _g[_f];
	            var chKey = "" + ch.key(true);
	            var serialized = serialize2(ch, true);
	            obj[chKey] = serialized === undefined ? null : serialized;
	        }
	        return obj;
	    }
	}
	exports.serialize2 = serialize2;
	function serialize(node, options) {
	    if (options === void 0) { options = {}; }
	    options = options || {};
	    if (node.children().length == 0) {
	        return node.value();
	    }
	    if (!node.children()[0].key()) {
	        var arr = [];
	        node.children().forEach(function (x) {
	            arr.push(serialize(x, options));
	        });
	        return arr;
	    }
	    else {
	        var obj = {};
	        node.children().forEach(function (x) {
	            obj[escapeKey(x.key(options.rawKey), options)] = serialize(x, options);
	        });
	        if (options && options.writeErrors) {
	            var errors = collectErrors(node);
	            if (errors != null && errors.length > 0) {
	                obj['__$errors__'] = errors;
	            }
	        }
	        return obj;
	    }
	}
	exports.serialize = serialize;
	function collectErrors(node) {
	    var errors = [].concat(node.errors());
	    node.children().forEach(function (ch) {
	        var children = ch.children();
	        if (children.length == 0) {
	            ch.errors().forEach(function (e) { return errors.push(e); });
	            return;
	        }
	        if (!children[0].key()) {
	            children.forEach(function (x) {
	                if (x.children().length == 0) {
	                    x.errors().forEach(function (e) { return errors.push(e); });
	                }
	            });
	        }
	    });
	    return errors;
	}
	function escapeKey(key, options) {
	    if (!options || !key) {
	        return key;
	    }
	    if (options.escapeNumericKeys && key.replace(/\d/g, '').trim().length == 0) {
	        return '__$EscapedKey$__' + key;
	    }
	    return key;
	}
	function unescapeKey(key, options) {
	    if (!key) {
	        return key;
	    }
	    options = options || {};
	    if (options.escapeNumericKeys
	        && util.stringStartsWith(key, '__$EscapedKey$__')
	        && key.substring('__$EscapedKey$__'.length).replace(/\d/g, '').trim().length == 0) {
	        return key.substring('__$EscapedKey$__'.length);
	    }
	    return key;
	}
	//# sourceMappingURL=json2lowLevel.js.map

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/main.d.ts" />
	"use strict";
	var hl = __webpack_require__(10);
	var linter = __webpack_require__(25);
	function escapeUri(u) {
	    var ss = "";
	    var level = 0;
	    for (var i = 0; i < u.length; i++) {
	        var c = u.charAt(i);
	        if (level == 0) {
	            ss = ss + c;
	        }
	        if (c == '{') {
	            level++;
	        }
	        if (c == '}') {
	            level--;
	        }
	    }
	    return ss;
	}
	var OverloadingValidator = (function () {
	    function OverloadingValidator() {
	        this.uriToResources = {};
	        this.conflictingUriToResources = {};
	    }
	    OverloadingValidator.prototype.validateApi = function (api, acceptor) {
	        var _this = this;
	        var resources = api.resources();
	        resources.forEach(function (resource) {
	            _this.acceptResource(resource);
	            var subResources = resource.resources();
	            subResources.forEach(function (subResource) { return _this.acceptResource(subResource); });
	        });
	        for (var uri in this.conflictingUriToResources) {
	            var resources = this.conflictingUriToResources[uri];
	            if (resources.length > 1) {
	                //we should be only reporting resources, which have different keys or parent.
	                //otherwise it is handled by the general key validator
	                //thus performing additional filtering
	                var idToSimilarResources = {};
	                resources.forEach(function (resource) {
	                    var highLevel = resource.highLevel();
	                    var complexId = "";
	                    if (highLevel.parent() != null) {
	                        complexId += highLevel.parent().id() + ".";
	                    }
	                    complexId += highLevel.localId();
	                    var resourcesWithId = idToSimilarResources[complexId];
	                    if (resourcesWithId == null) {
	                        resourcesWithId = [];
	                        idToSimilarResources[complexId] = resourcesWithId;
	                    }
	                    resourcesWithId.push(resource);
	                });
	                //var isTemplateOverlap=uri.indexOf('{')!=-1;
	                var ids = Object.keys(idToSimilarResources);
	                if (ids.length > 1) {
	                    //if we have more than a single id of conflicting resources
	                    resources.forEach(function (resource) {
	                        acceptor.accept(linter.createIssue(hl.IssueCode.KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT, "Resources share same URI", resource.highLevel(), false));
	                    });
	                }
	            }
	        }
	    };
	    OverloadingValidator.prototype.acceptResource = function (resource) {
	        var uri = resource.absoluteUri();
	        var resources = this.uriToResources[uri];
	        if (!resources) {
	            resources = [];
	            this.uriToResources[uri] = resources;
	        }
	        resources.push(resource);
	        if (resources.length > 1) {
	            this.conflictingUriToResources[uri] = resources;
	        }
	        //resource.methods().forEach(m=>{
	        //    this.acceptMethod(resource,m);
	        //})
	    };
	    return OverloadingValidator;
	}());
	module.exports = OverloadingValidator;
	//# sourceMappingURL=overloadingValidator.js.map

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/main.d.ts" />
	"use strict";
	var DomParser = __webpack_require__(75);
	function xmlToJson(xml) {
	    // Create the return object
	    var obj = {};
	    if (xml.nodeType == 1) {
	        // do attributes
	        if (xml.attributes.length > 0) {
	            for (var j = 0; j < xml.attributes.length; j++) {
	                var attribute = xml.attributes.item(j);
	                obj["@" + attribute.nodeName] = attribute.nodeValue;
	            }
	        }
	    }
	    else if (xml.nodeType == 3) {
	        obj = xml.nodeValue;
	    }
	    // do children
	    if (xml.hasChildNodes()) {
	        for (var i = 0; i < xml.childNodes.length; i++) {
	            var item = xml.childNodes.item(i);
	            var nodeName = item.nodeName;
	            if (nodeName == undefined) {
	                continue;
	            }
	            if (typeof (obj[nodeName]) == "undefined") {
	                obj[nodeName] = xmlToJson(item);
	            }
	            else {
	                if (typeof (obj[nodeName].push) == "undefined") {
	                    var old = obj[nodeName];
	                    obj[nodeName] = [];
	                    obj[nodeName].push(old);
	                }
	                obj[nodeName].push(xmlToJson(item));
	            }
	        }
	    }
	    return obj;
	}
	;
	function cleanupText(j) {
	    if (typeof j === "object") {
	        for (var p in j) {
	            if (typeof (j[p]) == "object") {
	                for (var k in j[p]) {
	                    if (k == '#text') {
	                        var txt = j[p]['#text'];
	                        if (typeof (txt) != 'string') {
	                            txt = txt.join("");
	                        }
	                        txt = txt.trim();
	                        if (txt.length == 0) {
	                            delete j[p]['#text'];
	                        }
	                    }
	                }
	                cleanupText(j[p]);
	            }
	        }
	    }
	    return j;
	}
	function cleanupJson(j) {
	    if (typeof j === "object") {
	        for (var p in j) {
	            if (typeof (j[p]) == "object") {
	                var keys = Object.keys(j[p]);
	                if (keys.length == 1) {
	                    if (keys[0] == '#text') {
	                        j[p] = j[p]['#text'];
	                    }
	                }
	                cleanupJson(j[p]);
	            }
	        }
	    }
	    return j;
	}
	function parseXML(value) {
	    var v = new DomParser.DOMParser();
	    if (!value || value.trim().indexOf("<<") == 0)
	        return null;
	    var parsed = v.parseFromString(value);
	    return cleanupJson(cleanupText(xmlToJson(parsed)));
	}
	module.exports = parseXML;
	//# sourceMappingURL=xmlutil.js.map

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var contentprovider = __webpack_require__(31);
	var def = __webpack_require__(36);
	var su = def.getSchemaUtils();
	function isScheme(content) {
	    try {
	        var schemeObject = JSON.parse(content);
	        return schemeObject['$schema'];
	    }
	    catch (exception) {
	        return false;
	    }
	}
	exports.isScheme = isScheme;
	function startDownloadingReferencesAsync(schemaContent, unit) {
	    var schemaObject = su.getJSONSchema(schemaContent, new contentprovider.ContentProvider(unit));
	    var missedReferences = schemaObject.getMissingReferences([]).map(function (reference) { return schemaObject.contentAsync(reference); });
	    if (missedReferences.length === 0) {
	        return Promise.resolve(unit);
	    }
	    var allReferences = Promise.all(missedReferences);
	    var result = getRefs(allReferences, schemaObject);
	    return result.then(function () { return unit; });
	}
	exports.startDownloadingReferencesAsync = startDownloadingReferencesAsync;
	function getReferences(schemaContent, unit) {
	    var schemaObject = su.getJSONSchema(schemaContent, new contentprovider.ContentProvider(unit));
	    return schemaObject.getMissingReferences([], true);
	}
	exports.getReferences = getReferences;
	function getRefs(promise, schemaObject) {
	    return promise.then(function (references) {
	        if (references.length > 0) {
	            var missedRefs = schemaObject.getMissingReferences(references);
	            if (missedRefs.length === 0) {
	                return [];
	            }
	            var promises = [];
	            missedRefs.forEach(function (ref) {
	                promises.push(schemaObject.contentAsync(ref));
	            });
	            return getRefs(Promise.all(promises.concat(references)), schemaObject);
	        }
	        return Promise.resolve([]);
	    });
	}
	//# sourceMappingURL=schemaAsync.js.map

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/main.d.ts" />
	"use strict";
	var ll = __webpack_require__(11);
	var path = __webpack_require__(15);
	var universes = __webpack_require__(22);
	var universeHelpers = __webpack_require__(14);
	var resourceRegistry = __webpack_require__(28);
	var NamespaceResolver = (function () {
	    function NamespaceResolver() {
	        this.expandedAbsToNsMap = {};
	        this.byPathMap = {};
	        this.byNsMap = {};
	        this._hasFragments = {};
	    }
	    NamespaceResolver.prototype.resolveNamespace = function (from, to) {
	        if (to == null) {
	            return null;
	        }
	        var toPath = to.absolutePath();
	        var unitMap = this.expandedPathMap(from);
	        if (!unitMap) {
	            return null;
	        }
	        var usesInfo = unitMap[toPath];
	        return usesInfo != null ? usesInfo.namespace() : null;
	    };
	    NamespaceResolver.prototype.expandedPathMap = function (unit) {
	        var fromPath = unit.absolutePath();
	        var unitMap = this.expandedAbsToNsMap[fromPath];
	        if (unitMap === undefined) {
	            unitMap = this.calculateExpandedNamespaces(unit);
	            if (Object.keys(unitMap).length == 0) {
	                unitMap = null;
	            }
	            this.expandedAbsToNsMap[fromPath] = unitMap;
	        }
	        return unitMap;
	    };
	    NamespaceResolver.prototype.calculateExpandedNamespaces = function (_unit) {
	        var _this = this;
	        var rootPath = path.dirname(_unit.absolutePath());
	        var result = {};
	        var usesInfoArray = [];
	        while (_unit) {
	            usesInfoArray.push(new UsesInfo([], _unit, ""));
	            var u = _unit;
	            _unit = null;
	            var hlNode = u.highLevel();
	            if (hlNode.isElement()) {
	                var hlElem = hlNode.asElement();
	                var definition = hlElem.definition();
	                if (universeHelpers.isOverlayType(definition) || universeHelpers.isExtensionType(definition)) {
	                    var eValue = hlElem.attr(universes.Universe10.Extension.properties.extends.name).value();
	                    _unit = u.resolve(eValue);
	                    if (_unit && resourceRegistry.isWaitingFor(_unit.absolutePath())) {
	                        _unit = null;
	                    }
	                }
	            }
	        }
	        for (var i = 0; i < usesInfoArray.length; i++) {
	            var visited = {};
	            var usedUnits = {};
	            var info = usesInfoArray[i];
	            var unit = info.unit;
	            var hlPR = unit.highLevel();
	            if (!hlPR.isElement()) {
	                continue;
	            }
	            var steps = info.steps() + 1;
	            var visit = function (x) {
	                var children = x.children();
	                if (x.parent() == null) {
	                    var nodeUnit = x.unit();
	                    var localPath = nodeUnit.absolutePath();
	                    if (visited[localPath]) {
	                        return;
	                    }
	                    visited[localPath] = true;
	                    if (localPath != unit.absolutePath()) {
	                        _this._hasFragments[unit.absolutePath()] = true;
	                    }
	                    var map = _this.pathMap(nodeUnit);
	                    if (map) {
	                        for (var _i = 0, _a = Object.keys(map); _i < _a.length; _i++) {
	                            var absPath = _a[_i];
	                            var childInfo = map[absPath];
	                            var segments = info.namespaceSegments.concat(childInfo.namespaceSegments);
	                            var existing = result[absPath];
	                            if (existing) {
	                                if (existing.steps() < steps) {
	                                    continue;
	                                }
	                                else if (existing.steps() == steps
	                                    && _this.lexLessEq(existing.namespaceSegments, segments)) {
	                                    continue;
	                                }
	                            }
	                            var includePath;
	                            var childInclude = childInfo.includePath;
	                            if (path.isAbsolute(info.includePath) || ll.isWebPath(info.includePath)) {
	                                includePath = childInfo.absolutePath();
	                            }
	                            else if (path.isAbsolute(childInclude) || ll.isWebPath(childInclude)) {
	                                includePath = childInfo.absolutePath();
	                            }
	                            else {
	                                includePath = path.relative(rootPath, childInfo.absolutePath());
	                            }
	                            includePath = includePath.replace(/\\/g, "/");
	                            var ui = new UsesInfo(segments, childInfo.unit, includePath);
	                            if (!usedUnits[ui.absolutePath()]) {
	                                result[absPath] = ui;
	                                usesInfoArray.push(ui);
	                                usedUnits[ui.absolutePath()] = true;
	                            }
	                        }
	                    }
	                }
	                children.forEach(function (y) {
	                    if (y.includedFrom()) {
	                        y = y.parent();
	                    }
	                    visit(y);
	                });
	                if (x.parent() == null) {
	                    visited[x.unit().absolutePath()] = false;
	                }
	            };
	            visit(unit.ast());
	        }
	        var namespaces = {};
	        for (var _i = 0, _a = Object.keys(result); _i < _a.length; _i++) {
	            var key = _a[_i];
	            var info = result[key];
	            var ns = info.namespace();
	            var i = 0;
	            while (namespaces[ns]) {
	                ns = info.namespace() + i++;
	            }
	            if (ns != info.namespace()) {
	                info.namespaceSegments = ns.split(".");
	            }
	            namespaces[ns] = true;
	        }
	        return result;
	    };
	    NamespaceResolver.prototype.pathMap = function (unit) {
	        var fromPath = unit.absolutePath();
	        var unitMap = this.byPathMap[fromPath];
	        if (unitMap === undefined) {
	            unitMap = this.calculateNamespaces(unit);
	            if (Object.keys(unitMap).length == 0) {
	                unitMap = null;
	            }
	            this.byPathMap[fromPath] = unitMap;
	        }
	        return unitMap;
	    };
	    NamespaceResolver.prototype.nsMap = function (unit) {
	        var fromPath = unit.absolutePath();
	        var unitMap = this.byNsMap[fromPath];
	        if (unitMap === undefined) {
	            var map = this.pathMap(unit);
	            if (map == null) {
	                unitMap = null;
	            }
	            else {
	                unitMap = {};
	                for (var _i = 0, _a = Object.keys(map); _i < _a.length; _i++) {
	                    var aPath = _a[_i];
	                    var info = map[aPath];
	                    unitMap[info.namespace()] = info;
	                }
	            }
	            this.byNsMap[fromPath] = unitMap;
	        }
	        return unitMap;
	    };
	    NamespaceResolver.prototype.calculateNamespaces = function (unit) {
	        var rootPath = path.dirname(unit.absolutePath());
	        var result = {};
	        var rootNode = unit.ast();
	        var usesNodes = rootNode.children().filter(function (x) { return x.key()
	            == universes.Universe10.FragmentDeclaration.properties.uses.name; });
	        if (rootNode.actual() && rootNode.actual()["usesNode"]) {
	            usesNodes = [rootNode.actual()["usesNode"]];
	        }
	        if (usesNodes.length == 0) {
	            return result;
	        }
	        var usesDeclarationNodes = [];
	        for (var _i = 0, usesNodes_1 = usesNodes; _i < usesNodes_1.length; _i++) {
	            var un = usesNodes_1[_i];
	            usesDeclarationNodes = usesDeclarationNodes.concat(un.children());
	        }
	        if (usesDeclarationNodes.length == 0) {
	            return result;
	        }
	        for (var _a = 0, usesDeclarationNodes_1 = usesDeclarationNodes; _a < usesDeclarationNodes_1.length; _a++) {
	            var un = usesDeclarationNodes_1[_a];
	            var key = un.key();
	            var value = un.value();
	            var libUnit = unit.resolve(value);
	            if (libUnit == null) {
	                continue;
	            }
	            var segments = [key];
	            var absPath = libUnit.absolutePath();
	            var includePath;
	            if (path.isAbsolute(value) || ll.isWebPath(value)) {
	                includePath = libUnit.absolutePath();
	            }
	            else {
	                includePath = path.relative(rootPath, libUnit.absolutePath());
	            }
	            includePath = includePath.replace(/\\/g, "/");
	            var ui = new UsesInfo(segments, libUnit, includePath);
	            result[absPath] = ui;
	        }
	        var hlNode = unit.highLevel();
	        if (hlNode.isElement()) {
	            var hlElem = hlNode.asElement();
	            var definition = hlElem.definition();
	            if (universeHelpers.isOverlayType(definition) || universeHelpers.isExtensionType(definition)) {
	                var eValue = hlElem.attr(universes.Universe10.Extension.properties.extends.name).value();
	                var extendedUnit;
	                try {
	                    extendedUnit = unit.resolve(eValue);
	                }
	                catch (e) { }
	                if (extendedUnit) {
	                    var m = this.pathMap(extendedUnit);
	                    if (m) {
	                        for (var _b = 0, _c = Object.keys(m); _b < _c.length; _b++) {
	                            var k = _c[_b];
	                            result[k] = m[k];
	                        }
	                    }
	                }
	            }
	        }
	        return result;
	    };
	    NamespaceResolver.prototype.lexLessEq = function (a, b) {
	        if (a.length > b.length) {
	            return false;
	        }
	        if (a.length < b.length) {
	            return true;
	        }
	        for (var i = 0; i < a.length; i++) {
	            var seg_a = a[i];
	            var seg_b = b[i];
	            if (seg_a < seg_b) {
	                return true;
	            }
	            else if (seg_a > seg_b) {
	                return false;
	            }
	        }
	        return true;
	    };
	    NamespaceResolver.prototype.hasFragments = function (unit) {
	        this.calculateExpandedNamespaces(unit);
	        return this._hasFragments[unit.absolutePath()] ? true : false;
	    };
	    return NamespaceResolver;
	}());
	exports.NamespaceResolver = NamespaceResolver;
	var UsesInfo = (function () {
	    function UsesInfo(namespaceSegments, unit, includePath) {
	        this.namespaceSegments = namespaceSegments;
	        this.unit = unit;
	        this.includePath = includePath;
	    }
	    UsesInfo.prototype.steps = function () {
	        return this.namespaceSegments.length;
	    };
	    UsesInfo.prototype.namespace = function () {
	        return this.namespaceSegments.join(".");
	    };
	    UsesInfo.prototype.absolutePath = function () {
	        return this.unit.absolutePath();
	    };
	    return UsesInfo;
	}());
	exports.UsesInfo = UsesInfo;
	//# sourceMappingURL=namespaceResolver.js.map

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/main.d.ts" />
	"use strict";
	var ramlSanitize = __webpack_require__(76);
	var ramlValidate = __webpack_require__(77);
	var REGEXP_MATCH = {
	    number: '[-+]?\\d+(?:\\.\\d+)?',
	    integer: '[-+]?\\d+',
	    date: '(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d{2} (?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d{4} (?:[0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d GMT',
	    boolean: '(?:true|false)'
	};
	var ESCAPE_CHARACTERS = /([.*+?=^!:${}()|[\]\/\\])/g;
	var REGEXP_REPLACE = new RegExp([
	    // Match RAML parameters with an optional prefix.
	    '([.\\/])?\\{([^}]+)\\}',
	    // Match any escape characters.
	    ESCAPE_CHARACTERS.source
	].join('|'), 'g');
	function toRegExp(path, parameters, keys, options) {
	    var end = options.end !== false;
	    var strict = options.strict;
	    var flags = '';
	    if (!options.sensitive) {
	        flags += 'i';
	    }
	    var route = path.replace(REGEXP_REPLACE, function (match, prefix, key, escape) {
	        if (escape) {
	            return '\\' + escape;
	        }
	        // Push the current key into the keys array.
	        keys.push({
	            name: key,
	            prefix: prefix || '/'
	        });
	        prefix = prefix ? '\\' + prefix : '';
	        // TODO: Support an array of parameters.
	        var param = parameters[key];
	        var capture = param && REGEXP_MATCH[param.type] || '[^' + (prefix || '\\/') + ']+';
	        var optional = param && param.required === false;
	        if (Array.isArray(param.enum) && param.enum.length) {
	            capture = '(?:' + param.enum.map(function (value) {
	                return String(value).replace(ESCAPE_CHARACTERS, '\\$1');
	            }).join('|') + ')';
	        }
	        return prefix + '(' + capture + ')' + (optional ? '?' : '');
	    });
	    var endsWithSlash = path.charAt(path.length - 1) === '/';
	    // In non-strict mode we allow a slash at the end of match. If the path to
	    // match already ends with a slash, we remove it for consistency. The slash
	    // is valid at the end of a path match, not in the middle. This is important
	    // in non-ending mode, where "/test/" shouldn't match "/test//route".
	    if (!strict) {
	        route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
	    }
	    if (end) {
	        route += '$';
	    }
	    else {
	        // In non-ending mode, we need the capturing groups to match as much as
	        // possible by using a positive lookahead to the end or next path segment.
	        route += strict && endsWithSlash ? '' : '(?=\\/|$)';
	    }
	    return new RegExp('^' + route + (end ? '$' : ''), flags);
	}
	function decodeParam(param) {
	    try {
	        return decodeURIComponent(param);
	    }
	    catch (_) {
	        var err = new Error('Failed to decode param "' + param + '"');
	        err.status = 400;
	        throw err;
	    }
	}
	function ramlPathMatch(path, parameters, options) {
	    options = options || {};
	    if (path === '/' && options.end === false) {
	        return truth;
	    }
	    parameters = parameters || {};
	    var keys = [];
	    var re = toRegExp(path, parameters, keys, options);
	    var sanitize = ramlSanitize.sanitize()(parameters);
	    var validate = ramlValidate.validate()(parameters);
	    return function (pathname) {
	        var m = re.exec(pathname);
	        if (!m) {
	            return false;
	        }
	        if (parameters['mediaTypeExtension']) {
	            if (m.length > 1 && !m[m.length - 1]) {
	                var beforeLast = m[m.length - 2];
	                var ind = beforeLast.lastIndexOf('.');
	                if (ind >= 0) {
	                    m[m.length - 2] = beforeLast.substring(0, ind);
	                    m[m.length - 1] = beforeLast.substring(ind);
	                }
	            }
	        }
	        var path = m[0];
	        var params = {};
	        for (var i = 1; i < m.length; i++) {
	            var key = keys[i - 1];
	            var param = m[i];
	            params[key.name] = param == null ? param : decodeParam(param);
	        }
	        params = sanitize(params);
	        if (!validate(params).valid) {
	            return false;
	        }
	        return {
	            path: path,
	            params: params
	        };
	    };
	}
	exports.ramlPathMatch = ramlPathMatch;
	function truth(path) {
	    return { path: '', params: {} };
	}
	// export = ramlPathMatch 
	//# sourceMappingURL=raml-path-match.js.map

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.universeDumps = {
	    RAML08: toModule(__webpack_require__(88)),
	    RAML10: toModule(__webpack_require__(89))
	};
	function toModule(arr) {
	    var main = arr[0];
	    var map = {};
	    arr.forEach(function (x) { return map[x['name']] = x; });
	    arr.forEach(function (x) {
	        var imports = x['imports'];
	        Object.keys(imports).forEach(function (y) {
	            var name = imports[y];
	            imports[y] = map[name];
	        });
	    });
	    return main;
	}
	//# sourceMappingURL=index.js.map

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../typings/main.d.ts" />
	var tsModel = __webpack_require__(91);
	var def = __webpack_require__(36);
	var _ = __webpack_require__(87);
	var aHandlers = __webpack_require__(79);
	var services = def;
	var FieldWrapper = (function () {
	    function FieldWrapper(_field, _clazz) {
	        this._field = _field;
	        this._clazz = _clazz;
	    }
	    FieldWrapper.prototype.name = function () {
	        return this._field.name;
	    };
	    FieldWrapper.prototype.range = function () {
	        return this._clazz.getModule().typeFor(this._field.type, this._clazz);
	    };
	    FieldWrapper.prototype.isMultiValue = function () {
	        return this._field.type.typeKind == tsModel.TypeKind.ARRAY;
	    };
	    FieldWrapper.prototype.isKey = function () {
	        return _.find(this._field.annotations, function (x) { return x.name == "MetaModel.key"; }) != null;
	    };
	    FieldWrapper.prototype.isSimpleValue = function () {
	        return _.find(this._field.annotations, function (x) { return x.name == "MetaModel.value"; }) != null;
	    };
	    FieldWrapper.prototype.annotations = function () {
	        return this._field.annotations;
	    };
	    return FieldWrapper;
	}());
	var FieldConstraint = (function () {
	    function FieldConstraint(_field, _clazz) {
	        this._field = _field;
	        this._clazz = _clazz;
	    }
	    FieldConstraint.prototype.name = function () {
	        return this._field.name;
	    };
	    FieldConstraint.prototype.value = function () {
	        return this._field.valueConstraint;
	    };
	    return FieldConstraint;
	}());
	var ClassWrapper = (function () {
	    function ClassWrapper(_clazz, mw) {
	        this._clazz = _clazz;
	        this.mw = mw;
	    }
	    ClassWrapper.prototype.typeMeta = function () {
	        return this._clazz.annotations;
	    };
	    ClassWrapper.prototype.path = function () {
	        return this.mw.path();
	    };
	    ClassWrapper.prototype.getModule = function () {
	        return this.mw;
	    };
	    ClassWrapper.prototype.typeArgs = function () {
	        return this._clazz.typeParameters;
	    };
	    ClassWrapper.prototype.typConstraints = function () {
	        var _this = this;
	        return this._clazz.typeParameterConstraint.map(function (x) {
	            if (x) {
	                return _this.mw.classForName(x);
	            }
	            return null;
	        });
	    };
	    ClassWrapper.prototype.methods = function () {
	        return this._clazz.methods;
	    };
	    ClassWrapper.prototype.name = function () {
	        return this._clazz.name;
	    };
	    ClassWrapper.prototype.members = function () {
	        var _this = this;
	        return this._clazz.fields.filter(function (x) { return x.valueConstraint == null; }).map(function (x) { return new FieldWrapper(x, _this); });
	    };
	    ClassWrapper.prototype.constraints = function () {
	        var _this = this;
	        return this._clazz.fields.filter(function (x) { return x.valueConstraint != null; }).map(function (x) { return new FieldConstraint(x, _this); });
	    };
	    ClassWrapper.prototype.isSubTypeOf = function (of) {
	        if (this == of) {
	            return true;
	        }
	        var _res = false;
	        this.getAllSuperTypes().forEach(function (x) {
	            if (!_res) {
	                _res = _res || x.isSubTypeOf(of);
	            }
	        });
	        return _res;
	    };
	    ClassWrapper.prototype.getExtendsClauses = function () {
	        return this._clazz.extends;
	    };
	    ClassWrapper.prototype.getSuperTypes = function () {
	        var _this = this;
	        var result = [];
	        this._clazz.extends.forEach(function (x) {
	            var tp = _this.mw.classForName(x.typeName);
	            if (tp) {
	                result.push(tp);
	            }
	        });
	        return result;
	    };
	    ClassWrapper.prototype.getAllSuperTypes = function () {
	        var _this = this;
	        var result = [];
	        this._clazz.extends.forEach(function (x) {
	            var tp = _this.mw.classForName(x.typeName);
	            if (tp) {
	                var mm = tp.getAllSuperTypes();
	                result.push(tp);
	                result.concat(mm);
	            }
	        });
	        return _.unique(result);
	    };
	    ClassWrapper.prototype.annotationOverridings = function () { return this._clazz.annotationOverridings; };
	    return ClassWrapper;
	}());
	var AbstractSimpleWrapper = (function () {
	    function AbstractSimpleWrapper() {
	    }
	    AbstractSimpleWrapper.prototype.members = function () {
	        return []; //this._clazz.members.map(x=>new FieldWrapper(x,this))
	    };
	    AbstractSimpleWrapper.prototype.methods = function () { return []; };
	    AbstractSimpleWrapper.prototype.isSubTypeOf = function (of) {
	        return false;
	    };
	    AbstractSimpleWrapper.prototype.getSuperTypes = function () {
	        return [];
	    };
	    AbstractSimpleWrapper.prototype.getAllSuperTypes = function () {
	        return [];
	    };
	    AbstractSimpleWrapper.prototype.name = function () {
	        return null;
	    };
	    AbstractSimpleWrapper.prototype.constraints = function () {
	        return [];
	    };
	    AbstractSimpleWrapper.prototype.typeMeta = function () {
	        return [];
	    };
	    AbstractSimpleWrapper.prototype.getModule = function () {
	        throw new Error("Not implemented");
	    };
	    AbstractSimpleWrapper.prototype.annotationOverridings = function () { return {}; };
	    return AbstractSimpleWrapper;
	}());
	var EnumWrapper = (function (_super) {
	    __extends(EnumWrapper, _super);
	    function EnumWrapper(_clazz, mw) {
	        _super.call(this);
	        this._clazz = _clazz;
	        this.mw = mw;
	    }
	    EnumWrapper.prototype.getModule = function () {
	        return this.mw;
	    };
	    EnumWrapper.prototype.values = function () {
	        return this._clazz.members;
	    };
	    EnumWrapper.prototype.name = function () {
	        return this._clazz.name;
	    };
	    return EnumWrapper;
	}(AbstractSimpleWrapper));
	var UnionWrapper = (function (_super) {
	    __extends(UnionWrapper, _super);
	    function UnionWrapper(_clazz, mw) {
	        _super.call(this);
	        this._clazz = _clazz;
	        this.mw = mw;
	    }
	    UnionWrapper.prototype.elements = function () {
	        return this._clazz;
	    };
	    UnionWrapper.prototype.name = function () {
	        return this._clazz.map(function (x) { return x.name(); }).join("|");
	    };
	    return UnionWrapper;
	}(AbstractSimpleWrapper));
	var ModuleWrapper = (function () {
	    function ModuleWrapper(_univers) {
	        var _this = this;
	        this._univers = _univers;
	        this.name2Class = {};
	        this.namespaceToMod = {};
	        this._classes = [];
	        _univers.classes.forEach(function (x) {
	            var c = new ClassWrapper(x, _this);
	            _this._classes.push(c);
	            _this.name2Class[x.name] = c;
	            if (x.moduleName) {
	                //FIXME
	                _this.name2Class[x.moduleName + "." + x.name] = c;
	            }
	        });
	        _univers.enumDeclarations.forEach(function (x) {
	            var c = new EnumWrapper(x, _this);
	            _this._classes.push(c);
	            _this.name2Class[x.name] = c;
	        });
	    }
	    ModuleWrapper.prototype.typeFor = function (t, ow) {
	        var _this = this;
	        switch (t.typeKind) {
	            case tsModel.TypeKind.BASIC:
	                var bt = t;
	                var typeName = bt.typeName;
	                if (typeName == "string") {
	                    typeName = "StringType";
	                }
	                if (typeName == "number") {
	                    typeName = "NumberType";
	                }
	                if (typeName == "boolean") {
	                    typeName = "BooleanType";
	                }
	                if (typeName == "any") {
	                    typeName = "AnyType";
	                }
	                var ti = _.indexOf(ow.typeArgs(), typeName);
	                if (ti != -1) {
	                    var cnst = ow.typConstraints()[ti];
	                    if (!cnst) {
	                        return this.classForName("ValueType");
	                    }
	                    return cnst;
	                }
	                return this.classForName(typeName);
	            case tsModel.TypeKind.UNION:
	                var ut = t;
	                return new UnionWrapper(ut.options.map(function (x) { return _this.typeFor(x, ow); }), this);
	            case tsModel.TypeKind.ARRAY:
	                var at = t;
	                return this.typeFor(at.base, ow);
	        }
	        return null;
	    };
	    ModuleWrapper.prototype.path = function () {
	        return this._univers.name;
	    };
	    ModuleWrapper.prototype.classForName = function (name, stack) {
	        var _this = this;
	        if (stack === void 0) { stack = {}; }
	        if (!name) {
	            return null;
	        }
	        var result = this.name2Class[name];
	        if (!result && !stack[this.path()]) {
	            stack[this.path()] = this;
	            var nmsp = name.indexOf(".");
	            if (nmsp != -1) {
	                var actualMod = this.namespaceToMod[name.substring(0, nmsp)];
	                if (!actualMod) {
	                    throw new Error();
	                }
	                return actualMod.classForName(name.substring(nmsp + 1), stack);
	            }
	            Object.keys(this.namespaceToMod).forEach(function (x) {
	                if (x != "MetaModel") {
	                    var nm = _this.namespaceToMod[x].classForName(name, stack);
	                    if (nm) {
	                        result = nm;
	                    }
	                }
	            });
	        }
	        return result;
	    };
	    ModuleWrapper.prototype.classes = function () {
	        return this._classes;
	    };
	    return ModuleWrapper;
	}());
	var wrapperToType = function (range, u) {
	    if (range) {
	        var rangeType;
	        if (range instanceof UnionWrapper) {
	            var uw = range;
	            throw new Error("Union type support was removed from definition system");
	        }
	        else {
	            rangeType = u.type(range.name());
	        }
	        return rangeType;
	    }
	    else {
	        return;
	    }
	};
	var registerClasses = function (m, u) {
	    var valueType = m.classForName("ValueType");
	    m.classes().forEach(function (x) {
	        if (x instanceof EnumWrapper) {
	            var et = new def.EnumType(x.name(), u, x.getModule().path());
	            et.values = x.values();
	            u.register(et);
	            return;
	        }
	        if (x.isSubTypeOf(valueType)) {
	            var st = x.getAllSuperTypes();
	            st.push(x);
	            var refTo = null;
	            st.forEach(function (t) {
	                var cs = t.getExtendsClauses();
	                cs.forEach(function (z) {
	                    if (z.typeKind == tsModel.TypeKind.BASIC) {
	                        var bas = z;
	                        if (bas.basicName == 'Reference') {
	                            var of = bas.typeArguments[0];
	                            refTo = of.typeName;
	                            var di = refTo.indexOf('.');
	                            if (di != -1) {
	                                refTo = refTo.substring(di + 1);
	                            }
	                        }
	                    }
	                });
	            });
	            if (refTo) {
	                //console.log("New reference type" + x.name())
	                var ref = new def.ReferenceType(x.name(), x.getModule().path(), refTo, u);
	                ref.setBuiltIn(true);
	                u.register(ref);
	            }
	            else {
	                var vt = new def.ValueType(x.name(), u, x.getModule().path());
	                vt.setBuiltIn(true);
	                u.register(vt);
	            }
	        }
	        else {
	            var gt = new def.NodeClass(x.name(), u, x.getModule().path());
	            gt.setBuiltIn(true);
	            u.register(gt);
	        }
	    });
	};
	var registerHierarchy = function (m, u) {
	    m.classes().forEach(function (x) {
	        x.getSuperTypes().forEach(function (y) {
	            var tp0 = u.type(x.name());
	            var tp1 = u.type(y.name());
	            if (!tp0 || !tp1) {
	                var tp0 = u.type(x.name());
	                var tp1 = u.type(y.name());
	                throw new Error();
	            }
	            u.registerSuperClass(tp0, tp1);
	        });
	    });
	};
	var registerEverything = function (m, u) {
	    m.classes().forEach(function (x) {
	        var tp = u.type(x.name());
	        x.typeMeta().forEach(function (a) {
	            var rangeType = wrapperToType(x, u);
	            aHandlers.handleTypeAnnotation(a, rangeType);
	        });
	        x.members().forEach(function (x) {
	            var range = x.range();
	            var rangeType = wrapperToType(range, u);
	            if (rangeType == null) {
	                console.log(range + ":" + x.name());
	            }
	            var custom = x.annotations().map(function (y) { return y.name; }).indexOf('MetaModel.customHandling') >= 0;
	            createProp(x, tp, rangeType, custom);
	        });
	        Object.keys(x.annotationOverridings()).forEach(function (fName) {
	            var arr = [].concat(x.annotationOverridings()[fName]);
	            var map = {};
	            arr.forEach(function (ann) { return map[ann.name] = true; });
	            var targetField;
	            var stArr = x.getSuperTypes();
	            var stMap = {};
	            for (var i = 0; i < stArr.length; i++) {
	                var st = stArr[i];
	                if (stMap[st.name()]) {
	                    continue;
	                }
	                stMap[st.name()] = true;
	                st.getSuperTypes().forEach(function (sst) { return stArr.push(sst); });
	                var arr1 = st.annotationOverridings()[fName];
	                if (arr1) {
	                    arr1.filter(function (ann) { return !map[ann.name]; }).forEach(function (ann) {
	                        map[ann.name] = true;
	                        arr.push(ann);
	                    });
	                }
	                else {
	                    var stFields = st.members();
	                    for (var j = 0; j < stFields.length; j++) {
	                        var stField = stFields[j];
	                        if (stField.name() == fName) {
	                            targetField = stField;
	                            break;
	                        }
	                    }
	                }
	                if (targetField) {
	                    var arr2 = targetField.annotations();
	                    arr2.filter(function (ann) { return !map[ann.name]; }).forEach(function (ann) {
	                        map[ann.name] = true;
	                        arr.push(ann);
	                    });
	                    break;
	                }
	            }
	            if (!targetField) {
	                return;
	            }
	            var range = targetField.range();
	            var rangeType = wrapperToType(range, u);
	            if (rangeType == null) {
	                console.log(range + ":" + x.name());
	            }
	            createProp(targetField, tp, rangeType, false, arr);
	        });
	        x.methods().forEach(function (x) {
	            var at = tp;
	            //at.addMethod(x.name, x.text);
	            //console.log(x.name);
	            //createMember(x, <def.AbstractType>tp, rangeType)
	        });
	        x.constraints().forEach(function (x) {
	            if (x.value().isCallConstraint) {
	                throw new Error();
	            }
	            var mm = x.value();
	            tp.addRequirement(x.name(), "" + mm.value);
	        });
	    });
	    u.types().forEach(function (x) {
	        var at = x;
	        at.getAdapter(services.RAMLService).getAliases().forEach(function (y) { return u.registerAlias(y, at); });
	    });
	};
	var processModule = function (ts, u, used, declared) {
	    if (ts.name.indexOf("metamodel.ts") != -1) {
	        return; //FIXME
	    }
	    if (declared[ts.name]) {
	        return declared[ts.name];
	    }
	    var m = new ModuleWrapper(ts);
	    used[ts.name] = m;
	    declared[ts.name] = m;
	    Object.keys(ts.imports).forEach(function (x) {
	        var pMod = ts.imports[x];
	        if (used[pMod.name]) {
	            m.namespaceToMod[x] = used[pMod.name];
	            return;
	        }
	        var vMod = processModule(pMod, u, used, declared);
	        m.namespaceToMod[x] = vMod;
	    });
	    used[ts.name] = null;
	    return m;
	};
	function toDefSystem(ts, q) {
	    var u = new def.Universe(q, "");
	    var c = {};
	    processModule(ts, u, {}, c);
	    Object.keys(c).forEach(function (x) {
	        registerClasses(c[x], u);
	    });
	    Object.keys(c).forEach(function (x) {
	        registerHierarchy(c[x], u);
	    });
	    Object.keys(c).forEach(function (x) {
	        registerEverything(c[x], u);
	    });
	    u.types().forEach(function (x) {
	        if (x instanceof def.NodeClass) {
	            var cl = x;
	            cl.properties().forEach(function (y) {
	                var t = y.range();
	                var ap = y;
	                if (!t.hasValueTypeInHierarchy()) {
	                    t.properties().forEach(function (p0) {
	                        if (p0.getAdapter(services.RAMLPropertyService).isKey()) {
	                            var kp = p0.keyPrefix();
	                            if (kp) {
	                                ap.withKeyRestriction(kp);
	                                ap.merge();
	                            }
	                            var eo = p0.enumOptions();
	                            if (eo) {
	                                ap.withEnumOptions(eo);
	                                ap.merge();
	                            }
	                        }
	                    });
	                }
	            });
	            if (cl.getAdapter(services.RAMLService).isGlobalDeclaration()) {
	                if (cl.getAdapter(services.RAMLService).getActuallyExports() && cl.getAdapter(services.RAMLService).getActuallyExports() != "$self") {
	                    var tp = cl.property(cl.getAdapter(services.RAMLService).getActuallyExports()).range();
	                    if (tp.hasValueTypeInHierarchy()) {
	                        var vt = tp.getAdapter(services.RAMLService);
	                        vt.setGloballyDeclaredBy(cl);
	                    }
	                }
	                if (cl.getAdapter(services.RAMLService).getConvertsToGlobal()) {
	                    var tp = u.type(cl.getAdapter(services.RAMLService).getConvertsToGlobal());
	                    if (tp.hasValueTypeInHierarchy()) {
	                        var vt = tp.getAdapter(services.RAMLService);
	                        vt.setGloballyDeclaredBy(cl);
	                    }
	                }
	            }
	        }
	    });
	    return u;
	}
	exports.toDefSystem = toDefSystem;
	var processAnnotations = function (x, p, annotations) {
	    if (!annotations) {
	        annotations = x.annotations();
	    }
	    annotations.forEach(function (x) {
	        var nm = x.name.substring(x.name.lastIndexOf(".") + 1);
	        if (!aHandlers.annotationHandlers[nm]) {
	            console.log("Can not find handler for:");
	        }
	        aHandlers.annotationHandlers[nm](x, p);
	    });
	};
	function createProp(x, clazz, t, custom, annotations) {
	    var p = def.prop(x.name(), "", clazz, t, custom);
	    if (x.isMultiValue()) {
	        p.withMultiValue(true);
	    }
	    p.unmerge();
	    if (!t) {
	        console.log(x.name() + ":" + clazz.nameId() + " has undefined type");
	    }
	    if (!t.hasValueTypeInHierarchy()) {
	        t.properties().forEach(function (p0) {
	            if (p0.getAdapter(services.RAMLPropertyService).isKey()) {
	                var kp = p0.keyPrefix();
	                if (kp) {
	                    p.withKeyRestriction(kp);
	                    p.merge();
	                }
	                var eo = p0.enumOptions();
	                if (eo) {
	                    p.withEnumOptions(eo);
	                    p.merge();
	                }
	            }
	        });
	    }
	    processAnnotations(x, p, annotations);
	}
	//# sourceMappingURL=tsStruct2Def.js.map

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Universes = {
	    "Universe08": {
	        "GlobalSchema": {
	            "name": "GlobalSchema",
	            "properties": {
	                "key": {
	                    "name": "key",
	                    "range": "StringType",
	                    "domain": "GlobalSchema"
	                },
	                "value": {
	                    "name": "value",
	                    "range": "SchemaString",
	                    "domain": "GlobalSchema"
	                }
	            }
	        },
	        "Api": {
	            "name": "Api",
	            "properties": {
	                "title": {
	                    "name": "title",
	                    "range": "StringType",
	                    "domain": "Api"
	                },
	                "version": {
	                    "name": "version",
	                    "range": "StringType",
	                    "domain": "Api"
	                },
	                "baseUri": {
	                    "name": "baseUri",
	                    "range": "FullUriTemplateString",
	                    "domain": "Api"
	                },
	                "baseUriParameters": {
	                    "name": "baseUriParameters",
	                    "range": "Parameter",
	                    "domain": "Api"
	                },
	                "uriParameters": {
	                    "name": "uriParameters",
	                    "range": "Parameter",
	                    "domain": "Api"
	                },
	                "protocols": {
	                    "name": "protocols",
	                    "range": "StringType",
	                    "domain": "Api"
	                },
	                "mediaType": {
	                    "name": "mediaType",
	                    "range": "MimeType",
	                    "domain": "Api"
	                },
	                "schemas": {
	                    "name": "schemas",
	                    "range": "GlobalSchema",
	                    "domain": "Api"
	                },
	                "traits": {
	                    "name": "traits",
	                    "range": "Trait",
	                    "domain": "Api"
	                },
	                "securedBy": {
	                    "name": "securedBy",
	                    "range": "SecuritySchemeRef",
	                    "domain": "Api"
	                },
	                "securitySchemes": {
	                    "name": "securitySchemes",
	                    "range": "AbstractSecurityScheme",
	                    "domain": "Api"
	                },
	                "resourceTypes": {
	                    "name": "resourceTypes",
	                    "range": "ResourceType",
	                    "domain": "Api"
	                },
	                "resources": {
	                    "name": "resources",
	                    "range": "Resource",
	                    "domain": "Api"
	                },
	                "documentation": {
	                    "name": "documentation",
	                    "range": "DocumentationItem",
	                    "domain": "Api"
	                },
	                "RAMLVersion": {
	                    "name": "RAMLVersion"
	                }
	            }
	        },
	        "DocumentationItem": {
	            "name": "DocumentationItem",
	            "properties": {
	                "title": {
	                    "name": "title",
	                    "range": "StringType",
	                    "domain": "DocumentationItem"
	                },
	                "content": {
	                    "name": "content",
	                    "range": "MarkdownString",
	                    "domain": "DocumentationItem"
	                }
	            }
	        },
	        "ValueType": {
	            "name": "ValueType",
	            "properties": {}
	        },
	        "StringType": {
	            "name": "StringType",
	            "properties": {}
	        },
	        "AnyType": {
	            "name": "AnyType",
	            "properties": {}
	        },
	        "NumberType": {
	            "name": "NumberType",
	            "properties": {}
	        },
	        "BooleanType": {
	            "name": "BooleanType",
	            "properties": {}
	        },
	        "Referencable": {
	            "name": "Referencable",
	            "properties": {}
	        },
	        "Reference": {
	            "name": "Reference",
	            "properties": {
	                "structuredValue": {
	                    "name": "structuredValue"
	                },
	                "name": {
	                    "name": "name"
	                }
	            }
	        },
	        "DeclaresDynamicType": {
	            "name": "DeclaresDynamicType",
	            "properties": {}
	        },
	        "UriTemplate": {
	            "name": "UriTemplate",
	            "properties": {}
	        },
	        "RelativeUriString": {
	            "name": "RelativeUriString",
	            "properties": {}
	        },
	        "FullUriTemplateString": {
	            "name": "FullUriTemplateString",
	            "properties": {}
	        },
	        "FixedUri": {
	            "name": "FixedUri",
	            "properties": {}
	        },
	        "MarkdownString": {
	            "name": "MarkdownString",
	            "properties": {}
	        },
	        "SchemaString": {
	            "name": "SchemaString",
	            "properties": {}
	        },
	        "JSonSchemaString": {
	            "name": "JSonSchemaString",
	            "properties": {}
	        },
	        "XMLSchemaString": {
	            "name": "XMLSchemaString",
	            "properties": {}
	        },
	        "ExampleString": {
	            "name": "ExampleString",
	            "properties": {}
	        },
	        "StatusCodeString": {
	            "name": "StatusCodeString",
	            "properties": {}
	        },
	        "JSONExample": {
	            "name": "JSONExample",
	            "properties": {}
	        },
	        "XMLExample": {
	            "name": "XMLExample",
	            "properties": {}
	        },
	        "TypeInstance": {
	            "name": "TypeInstance",
	            "properties": {
	                "properties": {
	                    "name": "properties",
	                    "range": "TypeInstanceProperty",
	                    "domain": "TypeInstance"
	                },
	                "isScalar": {
	                    "name": "isScalar",
	                    "range": "BooleanType",
	                    "domain": "TypeInstance"
	                },
	                "value": {
	                    "name": "value",
	                    "range": "AnyType",
	                    "domain": "TypeInstance"
	                }
	            }
	        },
	        "TypeInstanceProperty": {
	            "name": "TypeInstanceProperty",
	            "properties": {
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "TypeInstanceProperty"
	                },
	                "value": {
	                    "name": "value",
	                    "range": "TypeInstance",
	                    "domain": "TypeInstanceProperty"
	                },
	                "values": {
	                    "name": "values",
	                    "range": "TypeInstance",
	                    "domain": "TypeInstanceProperty"
	                },
	                "isArray": {
	                    "name": "isArray",
	                    "range": "BooleanType",
	                    "domain": "TypeInstanceProperty"
	                }
	            }
	        },
	        "RAMLSimpleElement": {
	            "name": "RAMLSimpleElement",
	            "properties": {}
	        },
	        "Parameter": {
	            "name": "Parameter",
	            "properties": {
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "displayName": {
	                    "name": "displayName",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "type": {
	                    "name": "type",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "location": {
	                    "name": "location",
	                    "range": "ParameterLocation",
	                    "domain": "Parameter"
	                },
	                "required": {
	                    "name": "required",
	                    "range": "BooleanType",
	                    "domain": "Parameter"
	                },
	                "default": {
	                    "name": "default",
	                    "range": "AnyType",
	                    "domain": "Parameter"
	                },
	                "example": {
	                    "name": "example",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "repeat": {
	                    "name": "repeat",
	                    "range": "BooleanType",
	                    "domain": "Parameter"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "Parameter"
	                }
	            }
	        },
	        "StringTypeDeclaration": {
	            "name": "StringTypeDeclaration",
	            "properties": {
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "displayName": {
	                    "name": "displayName",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "type": {
	                    "name": "type",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "location": {
	                    "name": "location",
	                    "range": "ParameterLocation",
	                    "domain": "Parameter"
	                },
	                "required": {
	                    "name": "required",
	                    "range": "BooleanType",
	                    "domain": "Parameter"
	                },
	                "default": {
	                    "name": "default",
	                    "range": "AnyType",
	                    "domain": "Parameter"
	                },
	                "example": {
	                    "name": "example",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "repeat": {
	                    "name": "repeat",
	                    "range": "BooleanType",
	                    "domain": "Parameter"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "Parameter"
	                },
	                "pattern": {
	                    "name": "pattern",
	                    "range": "StringType",
	                    "domain": "StringTypeDeclaration"
	                },
	                "enum": {
	                    "name": "enum",
	                    "range": "StringType",
	                    "domain": "StringTypeDeclaration"
	                },
	                "minLength": {
	                    "name": "minLength",
	                    "range": "NumberType",
	                    "domain": "StringTypeDeclaration"
	                },
	                "maxLength": {
	                    "name": "maxLength",
	                    "range": "NumberType",
	                    "domain": "StringTypeDeclaration"
	                }
	            }
	        },
	        "BooleanTypeDeclaration": {
	            "name": "BooleanTypeDeclaration",
	            "properties": {
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "displayName": {
	                    "name": "displayName",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "type": {
	                    "name": "type",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "location": {
	                    "name": "location",
	                    "range": "ParameterLocation",
	                    "domain": "Parameter"
	                },
	                "required": {
	                    "name": "required",
	                    "range": "BooleanType",
	                    "domain": "Parameter"
	                },
	                "default": {
	                    "name": "default",
	                    "range": "AnyType",
	                    "domain": "Parameter"
	                },
	                "example": {
	                    "name": "example",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "repeat": {
	                    "name": "repeat",
	                    "range": "BooleanType",
	                    "domain": "Parameter"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "Parameter"
	                }
	            }
	        },
	        "NumberTypeDeclaration": {
	            "name": "NumberTypeDeclaration",
	            "properties": {
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "displayName": {
	                    "name": "displayName",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "type": {
	                    "name": "type",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "location": {
	                    "name": "location",
	                    "range": "ParameterLocation",
	                    "domain": "Parameter"
	                },
	                "required": {
	                    "name": "required",
	                    "range": "BooleanType",
	                    "domain": "Parameter"
	                },
	                "default": {
	                    "name": "default",
	                    "range": "AnyType",
	                    "domain": "Parameter"
	                },
	                "example": {
	                    "name": "example",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "repeat": {
	                    "name": "repeat",
	                    "range": "BooleanType",
	                    "domain": "Parameter"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "Parameter"
	                },
	                "minimum": {
	                    "name": "minimum",
	                    "range": "NumberType",
	                    "domain": "NumberTypeDeclaration"
	                },
	                "maximum": {
	                    "name": "maximum",
	                    "range": "NumberType",
	                    "domain": "NumberTypeDeclaration"
	                }
	            }
	        },
	        "IntegerTypeDeclaration": {
	            "name": "IntegerTypeDeclaration",
	            "properties": {
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "displayName": {
	                    "name": "displayName",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "type": {
	                    "name": "type",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "location": {
	                    "name": "location",
	                    "range": "ParameterLocation",
	                    "domain": "Parameter"
	                },
	                "required": {
	                    "name": "required",
	                    "range": "BooleanType",
	                    "domain": "Parameter"
	                },
	                "default": {
	                    "name": "default",
	                    "range": "AnyType",
	                    "domain": "Parameter"
	                },
	                "example": {
	                    "name": "example",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "repeat": {
	                    "name": "repeat",
	                    "range": "BooleanType",
	                    "domain": "Parameter"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "Parameter"
	                },
	                "minimum": {
	                    "name": "minimum",
	                    "range": "NumberType",
	                    "domain": "NumberTypeDeclaration"
	                },
	                "maximum": {
	                    "name": "maximum",
	                    "range": "NumberType",
	                    "domain": "NumberTypeDeclaration"
	                }
	            }
	        },
	        "DateTypeDeclaration": {
	            "name": "DateTypeDeclaration",
	            "properties": {
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "displayName": {
	                    "name": "displayName",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "type": {
	                    "name": "type",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "location": {
	                    "name": "location",
	                    "range": "ParameterLocation",
	                    "domain": "Parameter"
	                },
	                "required": {
	                    "name": "required",
	                    "range": "BooleanType",
	                    "domain": "Parameter"
	                },
	                "default": {
	                    "name": "default",
	                    "range": "AnyType",
	                    "domain": "Parameter"
	                },
	                "example": {
	                    "name": "example",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "repeat": {
	                    "name": "repeat",
	                    "range": "BooleanType",
	                    "domain": "Parameter"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "Parameter"
	                }
	            }
	        },
	        "FileTypeDeclaration": {
	            "name": "FileTypeDeclaration",
	            "properties": {
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "displayName": {
	                    "name": "displayName",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "type": {
	                    "name": "type",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "location": {
	                    "name": "location",
	                    "range": "ParameterLocation",
	                    "domain": "Parameter"
	                },
	                "required": {
	                    "name": "required",
	                    "range": "BooleanType",
	                    "domain": "Parameter"
	                },
	                "default": {
	                    "name": "default",
	                    "range": "AnyType",
	                    "domain": "Parameter"
	                },
	                "example": {
	                    "name": "example",
	                    "range": "StringType",
	                    "domain": "Parameter"
	                },
	                "repeat": {
	                    "name": "repeat",
	                    "range": "BooleanType",
	                    "domain": "Parameter"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "Parameter"
	                }
	            }
	        },
	        "ParameterLocation": {
	            "name": "ParameterLocation",
	            "properties": {}
	        },
	        "MimeType": {
	            "name": "MimeType",
	            "properties": {}
	        },
	        "BodyLike": {
	            "name": "BodyLike",
	            "properties": {
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "BodyLike"
	                },
	                "schema": {
	                    "name": "schema",
	                    "range": "SchemaString",
	                    "domain": "BodyLike"
	                },
	                "example": {
	                    "name": "example",
	                    "range": "ExampleString",
	                    "domain": "BodyLike"
	                },
	                "formParameters": {
	                    "name": "formParameters",
	                    "range": "Parameter",
	                    "domain": "BodyLike"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "BodyLike"
	                },
	                "schemaContent": {
	                    "name": "schemaContent"
	                }
	            }
	        },
	        "XMLBody": {
	            "name": "XMLBody",
	            "properties": {
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "BodyLike"
	                },
	                "schema": {
	                    "name": "schema",
	                    "range": "XMLSchemaString",
	                    "domain": "XMLBody"
	                },
	                "example": {
	                    "name": "example",
	                    "range": "ExampleString",
	                    "domain": "BodyLike"
	                },
	                "formParameters": {
	                    "name": "formParameters",
	                    "range": "Parameter",
	                    "domain": "BodyLike"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "BodyLike"
	                }
	            }
	        },
	        "JSONBody": {
	            "name": "JSONBody",
	            "properties": {
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "BodyLike"
	                },
	                "schema": {
	                    "name": "schema",
	                    "range": "JSonSchemaString",
	                    "domain": "JSONBody"
	                },
	                "example": {
	                    "name": "example",
	                    "range": "ExampleString",
	                    "domain": "BodyLike"
	                },
	                "formParameters": {
	                    "name": "formParameters",
	                    "range": "Parameter",
	                    "domain": "BodyLike"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "BodyLike"
	                }
	            }
	        },
	        "Response": {
	            "name": "Response",
	            "properties": {
	                "code": {
	                    "name": "code",
	                    "range": "StatusCodeString",
	                    "domain": "Response"
	                },
	                "headers": {
	                    "name": "headers",
	                    "range": "Parameter",
	                    "domain": "Response"
	                },
	                "body": {
	                    "name": "body",
	                    "range": "BodyLike",
	                    "domain": "Response"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "Response"
	                }
	            }
	        },
	        "Resource": {
	            "name": "Resource",
	            "properties": {
	                "relativeUri": {
	                    "name": "relativeUri",
	                    "range": "RelativeUriString",
	                    "domain": "Resource"
	                },
	                "type": {
	                    "name": "type",
	                    "range": "ResourceTypeRef",
	                    "domain": "Resource"
	                },
	                "is": {
	                    "name": "is",
	                    "range": "TraitRef",
	                    "domain": "Resource"
	                },
	                "securedBy": {
	                    "name": "securedBy",
	                    "range": "SecuritySchemeRef",
	                    "domain": "Resource"
	                },
	                "uriParameters": {
	                    "name": "uriParameters",
	                    "range": "Parameter",
	                    "domain": "Resource"
	                },
	                "methods": {
	                    "name": "methods",
	                    "range": "Method",
	                    "domain": "Resource"
	                },
	                "resources": {
	                    "name": "resources",
	                    "range": "Resource",
	                    "domain": "Resource"
	                },
	                "displayName": {
	                    "name": "displayName",
	                    "range": "StringType",
	                    "domain": "Resource"
	                },
	                "baseUriParameters": {
	                    "name": "baseUriParameters",
	                    "range": "Parameter",
	                    "domain": "Resource"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "Resource"
	                }
	            }
	        },
	        "ResourceTypeRef": {
	            "name": "ResourceTypeRef",
	            "properties": {
	                "resourceType": {
	                    "name": "resourceType"
	                }
	            }
	        },
	        "ResourceType": {
	            "name": "ResourceType",
	            "properties": {
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "ResourceType"
	                },
	                "usage": {
	                    "name": "usage",
	                    "range": "StringType",
	                    "domain": "ResourceType"
	                },
	                "methods": {
	                    "name": "methods",
	                    "range": "Method",
	                    "domain": "ResourceType"
	                },
	                "is": {
	                    "name": "is",
	                    "range": "TraitRef",
	                    "domain": "ResourceType"
	                },
	                "type": {
	                    "name": "type",
	                    "range": "ResourceTypeRef",
	                    "domain": "ResourceType"
	                },
	                "securedBy": {
	                    "name": "securedBy",
	                    "range": "SecuritySchemeRef",
	                    "domain": "ResourceType"
	                },
	                "uriParameters": {
	                    "name": "uriParameters",
	                    "range": "Parameter",
	                    "domain": "ResourceType"
	                },
	                "displayName": {
	                    "name": "displayName",
	                    "range": "StringType",
	                    "domain": "ResourceType"
	                },
	                "baseUriParameters": {
	                    "name": "baseUriParameters",
	                    "range": "Parameter",
	                    "domain": "ResourceType"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "ResourceType"
	                },
	                "parametrizedProperties": {
	                    "name": "parametrizedProperties"
	                }
	            }
	        },
	        "MethodBase": {
	            "name": "MethodBase",
	            "properties": {
	                "responses": {
	                    "name": "responses",
	                    "range": "Response",
	                    "domain": "MethodBase"
	                },
	                "body": {
	                    "name": "body",
	                    "range": "BodyLike",
	                    "domain": "MethodBase"
	                },
	                "protocols": {
	                    "name": "protocols",
	                    "range": "StringType",
	                    "domain": "MethodBase"
	                },
	                "securedBy": {
	                    "name": "securedBy",
	                    "range": "SecuritySchemeRef",
	                    "domain": "MethodBase"
	                },
	                "baseUriParameters": {
	                    "name": "baseUriParameters",
	                    "range": "Parameter",
	                    "domain": "MethodBase"
	                },
	                "queryParameters": {
	                    "name": "queryParameters",
	                    "range": "Parameter",
	                    "domain": "MethodBase"
	                },
	                "headers": {
	                    "name": "headers",
	                    "range": "Parameter",
	                    "domain": "MethodBase"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "MethodBase"
	                }
	            }
	        },
	        "Method": {
	            "name": "Method",
	            "properties": {
	                "responses": {
	                    "name": "responses",
	                    "range": "Response",
	                    "domain": "MethodBase"
	                },
	                "body": {
	                    "name": "body",
	                    "range": "BodyLike",
	                    "domain": "MethodBase"
	                },
	                "protocols": {
	                    "name": "protocols",
	                    "range": "StringType",
	                    "domain": "MethodBase"
	                },
	                "securedBy": {
	                    "name": "securedBy",
	                    "range": "SecuritySchemeRef",
	                    "domain": "MethodBase"
	                },
	                "baseUriParameters": {
	                    "name": "baseUriParameters",
	                    "range": "Parameter",
	                    "domain": "MethodBase"
	                },
	                "queryParameters": {
	                    "name": "queryParameters",
	                    "range": "Parameter",
	                    "domain": "MethodBase"
	                },
	                "headers": {
	                    "name": "headers",
	                    "range": "Parameter",
	                    "domain": "MethodBase"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "MethodBase"
	                },
	                "method": {
	                    "name": "method",
	                    "range": "StringType",
	                    "domain": "Method"
	                },
	                "is": {
	                    "name": "is",
	                    "range": "TraitRef",
	                    "domain": "Method"
	                }
	            }
	        },
	        "Trait": {
	            "name": "Trait",
	            "properties": {
	                "responses": {
	                    "name": "responses",
	                    "range": "Response",
	                    "domain": "MethodBase"
	                },
	                "body": {
	                    "name": "body",
	                    "range": "BodyLike",
	                    "domain": "MethodBase"
	                },
	                "protocols": {
	                    "name": "protocols",
	                    "range": "StringType",
	                    "domain": "MethodBase"
	                },
	                "securedBy": {
	                    "name": "securedBy",
	                    "range": "SecuritySchemeRef",
	                    "domain": "MethodBase"
	                },
	                "baseUriParameters": {
	                    "name": "baseUriParameters",
	                    "range": "Parameter",
	                    "domain": "MethodBase"
	                },
	                "queryParameters": {
	                    "name": "queryParameters",
	                    "range": "Parameter",
	                    "domain": "MethodBase"
	                },
	                "headers": {
	                    "name": "headers",
	                    "range": "Parameter",
	                    "domain": "MethodBase"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "MethodBase"
	                },
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "Trait"
	                },
	                "usage": {
	                    "name": "usage",
	                    "range": "StringType",
	                    "domain": "Trait"
	                },
	                "displayName": {
	                    "name": "displayName",
	                    "range": "StringType",
	                    "domain": "Trait"
	                },
	                "parametrizedProperties": {
	                    "name": "parametrizedProperties"
	                }
	            }
	        },
	        "TraitRef": {
	            "name": "TraitRef",
	            "properties": {
	                "trait": {
	                    "name": "trait"
	                }
	            }
	        },
	        "SecuritySchemePart": {
	            "name": "SecuritySchemePart",
	            "properties": {
	                "responses": {
	                    "name": "responses",
	                    "range": "Response",
	                    "domain": "SecuritySchemePart"
	                },
	                "body": {
	                    "name": "body",
	                    "range": "BodyLike",
	                    "domain": "MethodBase"
	                },
	                "protocols": {
	                    "name": "protocols",
	                    "range": "StringType",
	                    "domain": "MethodBase"
	                },
	                "securedBy": {
	                    "name": "securedBy",
	                    "range": "SecuritySchemeRef",
	                    "domain": "MethodBase"
	                },
	                "baseUriParameters": {
	                    "name": "baseUriParameters",
	                    "range": "Parameter",
	                    "domain": "MethodBase"
	                },
	                "queryParameters": {
	                    "name": "queryParameters",
	                    "range": "Parameter",
	                    "domain": "SecuritySchemePart"
	                },
	                "headers": {
	                    "name": "headers",
	                    "range": "Parameter",
	                    "domain": "SecuritySchemePart"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "SecuritySchemePart"
	                },
	                "displayName": {
	                    "name": "displayName",
	                    "range": "StringType",
	                    "domain": "SecuritySchemePart"
	                },
	                "is": {
	                    "name": "is",
	                    "range": "TraitRef",
	                    "domain": "SecuritySchemePart"
	                }
	            }
	        },
	        "SecuritySchemeSettings": {
	            "name": "SecuritySchemeSettings",
	            "properties": {}
	        },
	        "AbstractSecurityScheme": {
	            "name": "AbstractSecurityScheme",
	            "properties": {
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "type": {
	                    "name": "type",
	                    "range": "StringType",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "describedBy": {
	                    "name": "describedBy",
	                    "range": "SecuritySchemePart",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "settings": {
	                    "name": "settings",
	                    "range": "SecuritySchemeSettings",
	                    "domain": "AbstractSecurityScheme"
	                }
	            }
	        },
	        "SecuritySchemeRef": {
	            "name": "SecuritySchemeRef",
	            "properties": {
	                "securitySchemeName": {
	                    "name": "securitySchemeName"
	                },
	                "securityScheme": {
	                    "name": "securityScheme"
	                }
	            }
	        },
	        "OAuth1SecuritySchemeSettings": {
	            "name": "OAuth1SecuritySchemeSettings",
	            "properties": {
	                "requestTokenUri": {
	                    "name": "requestTokenUri",
	                    "range": "FixedUri",
	                    "domain": "OAuth1SecuritySchemeSettings"
	                },
	                "authorizationUri": {
	                    "name": "authorizationUri",
	                    "range": "FixedUri",
	                    "domain": "OAuth1SecuritySchemeSettings"
	                },
	                "tokenCredentialsUri": {
	                    "name": "tokenCredentialsUri",
	                    "range": "FixedUri",
	                    "domain": "OAuth1SecuritySchemeSettings"
	                }
	            }
	        },
	        "OAuth2SecuritySchemeSettings": {
	            "name": "OAuth2SecuritySchemeSettings",
	            "properties": {
	                "accessTokenUri": {
	                    "name": "accessTokenUri",
	                    "range": "FixedUri",
	                    "domain": "OAuth2SecuritySchemeSettings"
	                },
	                "authorizationUri": {
	                    "name": "authorizationUri",
	                    "range": "FixedUri",
	                    "domain": "OAuth2SecuritySchemeSettings"
	                },
	                "authorizationGrants": {
	                    "name": "authorizationGrants",
	                    "range": "StringType",
	                    "domain": "OAuth2SecuritySchemeSettings"
	                },
	                "scopes": {
	                    "name": "scopes",
	                    "range": "StringType",
	                    "domain": "OAuth2SecuritySchemeSettings"
	                }
	            }
	        },
	        "OAuth2SecurityScheme": {
	            "name": "OAuth2SecurityScheme",
	            "properties": {
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "type": {
	                    "name": "type",
	                    "range": "StringType",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "describedBy": {
	                    "name": "describedBy",
	                    "range": "SecuritySchemePart",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "settings": {
	                    "name": "settings",
	                    "range": "OAuth2SecuritySchemeSettings",
	                    "domain": "OAuth2SecurityScheme"
	                }
	            }
	        },
	        "OAuth1SecurityScheme": {
	            "name": "OAuth1SecurityScheme",
	            "properties": {
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "type": {
	                    "name": "type",
	                    "range": "StringType",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "describedBy": {
	                    "name": "describedBy",
	                    "range": "SecuritySchemePart",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "settings": {
	                    "name": "settings",
	                    "range": "OAuth1SecuritySchemeSettings",
	                    "domain": "OAuth1SecurityScheme"
	                }
	            }
	        },
	        "BasicSecurityScheme": {
	            "name": "BasicSecurityScheme",
	            "properties": {
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "type": {
	                    "name": "type",
	                    "range": "StringType",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "describedBy": {
	                    "name": "describedBy",
	                    "range": "SecuritySchemePart",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "settings": {
	                    "name": "settings",
	                    "range": "SecuritySchemeSettings",
	                    "domain": "AbstractSecurityScheme"
	                }
	            }
	        },
	        "DigestSecurityScheme": {
	            "name": "DigestSecurityScheme",
	            "properties": {
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "type": {
	                    "name": "type",
	                    "range": "StringType",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "describedBy": {
	                    "name": "describedBy",
	                    "range": "SecuritySchemePart",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "settings": {
	                    "name": "settings",
	                    "range": "SecuritySchemeSettings",
	                    "domain": "AbstractSecurityScheme"
	                }
	            }
	        },
	        "CustomSecurityScheme": {
	            "name": "CustomSecurityScheme",
	            "properties": {
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "type": {
	                    "name": "type",
	                    "range": "StringType",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "description": {
	                    "name": "description",
	                    "range": "MarkdownString",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "describedBy": {
	                    "name": "describedBy",
	                    "range": "SecuritySchemePart",
	                    "domain": "AbstractSecurityScheme"
	                },
	                "settings": {
	                    "name": "settings",
	                    "range": "SecuritySchemeSettings",
	                    "domain": "AbstractSecurityScheme"
	                }
	            }
	        }
	    },
	    "Universe10": {
	        "Library": {
	            "name": "Library",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "uses": {
	                    "name": "uses"
	                },
	                "schemas": {
	                    "name": "schemas"
	                },
	                "types": {
	                    "name": "types"
	                },
	                "traits": {
	                    "name": "traits"
	                },
	                "resourceTypes": {
	                    "name": "resourceTypes"
	                },
	                "annotationTypes": {
	                    "name": "annotationTypes"
	                },
	                "securitySchemes": {
	                    "name": "securitySchemes"
	                },
	                "usage": {
	                    "name": "usage"
	                },
	                "name": {
	                    "name": "name"
	                }
	            }
	        },
	        "LibraryBase": {
	            "name": "LibraryBase",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "uses": {
	                    "name": "uses"
	                },
	                "schemas": {
	                    "name": "schemas"
	                },
	                "types": {
	                    "name": "types"
	                },
	                "traits": {
	                    "name": "traits"
	                },
	                "resourceTypes": {
	                    "name": "resourceTypes"
	                },
	                "annotationTypes": {
	                    "name": "annotationTypes"
	                },
	                "securitySchemes": {
	                    "name": "securitySchemes"
	                }
	            }
	        },
	        "Api": {
	            "name": "Api",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "uses": {
	                    "name": "uses"
	                },
	                "schemas": {
	                    "name": "schemas"
	                },
	                "types": {
	                    "name": "types"
	                },
	                "traits": {
	                    "name": "traits"
	                },
	                "resourceTypes": {
	                    "name": "resourceTypes"
	                },
	                "annotationTypes": {
	                    "name": "annotationTypes"
	                },
	                "securitySchemes": {
	                    "name": "securitySchemes"
	                },
	                "title": {
	                    "name": "title"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "version": {
	                    "name": "version"
	                },
	                "baseUri": {
	                    "name": "baseUri"
	                },
	                "baseUriParameters": {
	                    "name": "baseUriParameters"
	                },
	                "protocols": {
	                    "name": "protocols"
	                },
	                "mediaType": {
	                    "name": "mediaType"
	                },
	                "securedBy": {
	                    "name": "securedBy"
	                },
	                "resources": {
	                    "name": "resources"
	                },
	                "documentation": {
	                    "name": "documentation"
	                },
	                "RAMLVersion": {
	                    "name": "RAMLVersion",
	                    "range": "StringType",
	                    "domain": "Api"
	                }
	            }
	        },
	        "Overlay": {
	            "name": "Overlay",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "uses": {
	                    "name": "uses"
	                },
	                "schemas": {
	                    "name": "schemas"
	                },
	                "types": {
	                    "name": "types"
	                },
	                "traits": {
	                    "name": "traits"
	                },
	                "resourceTypes": {
	                    "name": "resourceTypes"
	                },
	                "annotationTypes": {
	                    "name": "annotationTypes"
	                },
	                "securitySchemes": {
	                    "name": "securitySchemes"
	                },
	                "title": {
	                    "name": "title"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "version": {
	                    "name": "version"
	                },
	                "baseUri": {
	                    "name": "baseUri"
	                },
	                "baseUriParameters": {
	                    "name": "baseUriParameters"
	                },
	                "protocols": {
	                    "name": "protocols"
	                },
	                "mediaType": {
	                    "name": "mediaType"
	                },
	                "securedBy": {
	                    "name": "securedBy"
	                },
	                "resources": {
	                    "name": "resources"
	                },
	                "documentation": {
	                    "name": "documentation"
	                },
	                "usage": {
	                    "name": "usage"
	                },
	                "extends": {
	                    "name": "extends"
	                }
	            }
	        },
	        "Extension": {
	            "name": "Extension",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "uses": {
	                    "name": "uses"
	                },
	                "schemas": {
	                    "name": "schemas"
	                },
	                "types": {
	                    "name": "types"
	                },
	                "traits": {
	                    "name": "traits"
	                },
	                "resourceTypes": {
	                    "name": "resourceTypes"
	                },
	                "annotationTypes": {
	                    "name": "annotationTypes"
	                },
	                "securitySchemes": {
	                    "name": "securitySchemes"
	                },
	                "title": {
	                    "name": "title"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "version": {
	                    "name": "version"
	                },
	                "baseUri": {
	                    "name": "baseUri"
	                },
	                "baseUriParameters": {
	                    "name": "baseUriParameters"
	                },
	                "protocols": {
	                    "name": "protocols"
	                },
	                "mediaType": {
	                    "name": "mediaType"
	                },
	                "securedBy": {
	                    "name": "securedBy"
	                },
	                "resources": {
	                    "name": "resources"
	                },
	                "documentation": {
	                    "name": "documentation"
	                },
	                "usage": {
	                    "name": "usage"
	                },
	                "extends": {
	                    "name": "extends"
	                }
	            }
	        },
	        "UsesDeclaration": {
	            "name": "UsesDeclaration",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "key": {
	                    "name": "key"
	                },
	                "value": {
	                    "name": "value"
	                }
	            }
	        },
	        "FragmentDeclaration": {
	            "name": "FragmentDeclaration",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "uses": {
	                    "name": "uses"
	                }
	            }
	        },
	        "DocumentationItem": {
	            "name": "DocumentationItem",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "title": {
	                    "name": "title"
	                },
	                "content": {
	                    "name": "content"
	                }
	            }
	        },
	        "ValueType": {
	            "name": "ValueType",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "StringType": {
	            "name": "StringType",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "AnyType": {
	            "name": "AnyType",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "NumberType": {
	            "name": "NumberType",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "IntegerType": {
	            "name": "IntegerType",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "NullType": {
	            "name": "NullType",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "TimeOnlyType": {
	            "name": "TimeOnlyType",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "DateOnlyType": {
	            "name": "DateOnlyType",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "DateTimeOnlyType": {
	            "name": "DateTimeOnlyType",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "DateTimeType": {
	            "name": "DateTimeType",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "FileType": {
	            "name": "FileType",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "BooleanType": {
	            "name": "BooleanType",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "Reference": {
	            "name": "Reference",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "structuredValue": {
	                    "name": "structuredValue",
	                    "range": "TypeInstance",
	                    "domain": "Reference"
	                },
	                "name": {
	                    "name": "name",
	                    "range": "StringType",
	                    "domain": "Reference"
	                }
	            }
	        },
	        "UriTemplate": {
	            "name": "UriTemplate",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "StatusCodeString": {
	            "name": "StatusCodeString",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "RelativeUriString": {
	            "name": "RelativeUriString",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "FullUriTemplateString": {
	            "name": "FullUriTemplateString",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "FixedUriString": {
	            "name": "FixedUriString",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "ContentType": {
	            "name": "ContentType",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "MarkdownString": {
	            "name": "MarkdownString",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "SchemaString": {
	            "name": "SchemaString",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "ExampleSpec": {
	            "name": "ExampleSpec",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "value": {
	                    "name": "value"
	                },
	                "strict": {
	                    "name": "strict"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "structuredValue": {
	                    "name": "structuredValue",
	                    "range": "TypeInstance",
	                    "domain": "ExampleSpec"
	                }
	            }
	        },
	        "TypeDeclaration": {
	            "name": "TypeDeclaration",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "facets": {
	                    "name": "facets"
	                },
	                "schema": {
	                    "name": "schema"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "location": {
	                    "name": "location"
	                },
	                "locationKind": {
	                    "name": "locationKind"
	                },
	                "default": {
	                    "name": "default"
	                },
	                "example": {
	                    "name": "example"
	                },
	                "examples": {
	                    "name": "examples"
	                },
	                "required": {
	                    "name": "required"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "xml": {
	                    "name": "xml"
	                },
	                "allowedTargets": {
	                    "name": "allowedTargets"
	                },
	                "isAnnotation": {
	                    "name": "isAnnotation"
	                },
	                "fixedFacets": {
	                    "name": "fixedFacets",
	                    "range": "TypeInstance",
	                    "domain": "TypeDeclaration"
	                },
	                "structuredType": {
	                    "name": "structuredType",
	                    "range": "TypeInstance",
	                    "domain": "TypeDeclaration"
	                },
	                "parametrizedProperties": {
	                    "name": "parametrizedProperties",
	                    "range": "TypeInstance",
	                    "domain": "TypeDeclaration"
	                }
	            }
	        },
	        "XMLFacetInfo": {
	            "name": "XMLFacetInfo",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "attribute": {
	                    "name": "attribute"
	                },
	                "wrapped": {
	                    "name": "wrapped"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "namespace": {
	                    "name": "namespace"
	                },
	                "prefix": {
	                    "name": "prefix"
	                }
	            }
	        },
	        "ArrayTypeDeclaration": {
	            "name": "ArrayTypeDeclaration",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "facets": {
	                    "name": "facets"
	                },
	                "schema": {
	                    "name": "schema"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "location": {
	                    "name": "location"
	                },
	                "locationKind": {
	                    "name": "locationKind"
	                },
	                "default": {
	                    "name": "default"
	                },
	                "example": {
	                    "name": "example"
	                },
	                "examples": {
	                    "name": "examples"
	                },
	                "required": {
	                    "name": "required"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "xml": {
	                    "name": "xml"
	                },
	                "allowedTargets": {
	                    "name": "allowedTargets"
	                },
	                "isAnnotation": {
	                    "name": "isAnnotation"
	                },
	                "uniqueItems": {
	                    "name": "uniqueItems"
	                },
	                "items": {
	                    "name": "items"
	                },
	                "minItems": {
	                    "name": "minItems"
	                },
	                "maxItems": {
	                    "name": "maxItems"
	                }
	            }
	        },
	        "UnionTypeDeclaration": {
	            "name": "UnionTypeDeclaration",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "facets": {
	                    "name": "facets"
	                },
	                "schema": {
	                    "name": "schema"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "location": {
	                    "name": "location"
	                },
	                "locationKind": {
	                    "name": "locationKind"
	                },
	                "default": {
	                    "name": "default"
	                },
	                "example": {
	                    "name": "example"
	                },
	                "examples": {
	                    "name": "examples"
	                },
	                "required": {
	                    "name": "required"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "xml": {
	                    "name": "xml"
	                },
	                "allowedTargets": {
	                    "name": "allowedTargets"
	                },
	                "isAnnotation": {
	                    "name": "isAnnotation"
	                }
	            }
	        },
	        "ObjectTypeDeclaration": {
	            "name": "ObjectTypeDeclaration",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "facets": {
	                    "name": "facets"
	                },
	                "schema": {
	                    "name": "schema"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "location": {
	                    "name": "location"
	                },
	                "locationKind": {
	                    "name": "locationKind"
	                },
	                "default": {
	                    "name": "default"
	                },
	                "example": {
	                    "name": "example"
	                },
	                "examples": {
	                    "name": "examples"
	                },
	                "required": {
	                    "name": "required"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "xml": {
	                    "name": "xml"
	                },
	                "allowedTargets": {
	                    "name": "allowedTargets"
	                },
	                "isAnnotation": {
	                    "name": "isAnnotation"
	                },
	                "properties": {
	                    "name": "properties"
	                },
	                "minProperties": {
	                    "name": "minProperties"
	                },
	                "maxProperties": {
	                    "name": "maxProperties"
	                },
	                "additionalProperties": {
	                    "name": "additionalProperties"
	                },
	                "discriminator": {
	                    "name": "discriminator"
	                },
	                "discriminatorValue": {
	                    "name": "discriminatorValue"
	                }
	            }
	        },
	        "StringTypeDeclaration": {
	            "name": "StringTypeDeclaration",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "facets": {
	                    "name": "facets"
	                },
	                "schema": {
	                    "name": "schema"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "location": {
	                    "name": "location"
	                },
	                "locationKind": {
	                    "name": "locationKind"
	                },
	                "default": {
	                    "name": "default"
	                },
	                "example": {
	                    "name": "example"
	                },
	                "examples": {
	                    "name": "examples"
	                },
	                "required": {
	                    "name": "required"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "xml": {
	                    "name": "xml"
	                },
	                "allowedTargets": {
	                    "name": "allowedTargets"
	                },
	                "isAnnotation": {
	                    "name": "isAnnotation"
	                },
	                "pattern": {
	                    "name": "pattern"
	                },
	                "minLength": {
	                    "name": "minLength"
	                },
	                "maxLength": {
	                    "name": "maxLength"
	                },
	                "enum": {
	                    "name": "enum"
	                }
	            }
	        },
	        "BooleanTypeDeclaration": {
	            "name": "BooleanTypeDeclaration",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "facets": {
	                    "name": "facets"
	                },
	                "schema": {
	                    "name": "schema"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "location": {
	                    "name": "location"
	                },
	                "locationKind": {
	                    "name": "locationKind"
	                },
	                "default": {
	                    "name": "default"
	                },
	                "example": {
	                    "name": "example"
	                },
	                "examples": {
	                    "name": "examples"
	                },
	                "required": {
	                    "name": "required"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "xml": {
	                    "name": "xml"
	                },
	                "allowedTargets": {
	                    "name": "allowedTargets"
	                },
	                "isAnnotation": {
	                    "name": "isAnnotation"
	                }
	            }
	        },
	        "NumberTypeDeclaration": {
	            "name": "NumberTypeDeclaration",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "facets": {
	                    "name": "facets"
	                },
	                "schema": {
	                    "name": "schema"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "location": {
	                    "name": "location"
	                },
	                "locationKind": {
	                    "name": "locationKind"
	                },
	                "default": {
	                    "name": "default"
	                },
	                "example": {
	                    "name": "example"
	                },
	                "examples": {
	                    "name": "examples"
	                },
	                "required": {
	                    "name": "required"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "xml": {
	                    "name": "xml"
	                },
	                "allowedTargets": {
	                    "name": "allowedTargets"
	                },
	                "isAnnotation": {
	                    "name": "isAnnotation"
	                },
	                "minimum": {
	                    "name": "minimum"
	                },
	                "maximum": {
	                    "name": "maximum"
	                },
	                "enum": {
	                    "name": "enum"
	                },
	                "format": {
	                    "name": "format"
	                },
	                "multipleOf": {
	                    "name": "multipleOf"
	                }
	            }
	        },
	        "IntegerTypeDeclaration": {
	            "name": "IntegerTypeDeclaration",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "facets": {
	                    "name": "facets"
	                },
	                "schema": {
	                    "name": "schema"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "location": {
	                    "name": "location"
	                },
	                "locationKind": {
	                    "name": "locationKind"
	                },
	                "default": {
	                    "name": "default"
	                },
	                "example": {
	                    "name": "example"
	                },
	                "examples": {
	                    "name": "examples"
	                },
	                "required": {
	                    "name": "required"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "xml": {
	                    "name": "xml"
	                },
	                "allowedTargets": {
	                    "name": "allowedTargets"
	                },
	                "isAnnotation": {
	                    "name": "isAnnotation"
	                },
	                "minimum": {
	                    "name": "minimum"
	                },
	                "maximum": {
	                    "name": "maximum"
	                },
	                "enum": {
	                    "name": "enum"
	                },
	                "format": {
	                    "name": "format"
	                },
	                "multipleOf": {
	                    "name": "multipleOf"
	                }
	            }
	        },
	        "DateOnlyTypeDeclaration": {
	            "name": "DateOnlyTypeDeclaration",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "facets": {
	                    "name": "facets"
	                },
	                "schema": {
	                    "name": "schema"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "location": {
	                    "name": "location"
	                },
	                "locationKind": {
	                    "name": "locationKind"
	                },
	                "default": {
	                    "name": "default"
	                },
	                "example": {
	                    "name": "example"
	                },
	                "examples": {
	                    "name": "examples"
	                },
	                "required": {
	                    "name": "required"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "xml": {
	                    "name": "xml"
	                },
	                "allowedTargets": {
	                    "name": "allowedTargets"
	                },
	                "isAnnotation": {
	                    "name": "isAnnotation"
	                }
	            }
	        },
	        "TimeOnlyTypeDeclaration": {
	            "name": "TimeOnlyTypeDeclaration",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "facets": {
	                    "name": "facets"
	                },
	                "schema": {
	                    "name": "schema"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "location": {
	                    "name": "location"
	                },
	                "locationKind": {
	                    "name": "locationKind"
	                },
	                "default": {
	                    "name": "default"
	                },
	                "example": {
	                    "name": "example"
	                },
	                "examples": {
	                    "name": "examples"
	                },
	                "required": {
	                    "name": "required"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "xml": {
	                    "name": "xml"
	                },
	                "allowedTargets": {
	                    "name": "allowedTargets"
	                },
	                "isAnnotation": {
	                    "name": "isAnnotation"
	                }
	            }
	        },
	        "DateTimeOnlyTypeDeclaration": {
	            "name": "DateTimeOnlyTypeDeclaration",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "facets": {
	                    "name": "facets"
	                },
	                "schema": {
	                    "name": "schema"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "location": {
	                    "name": "location"
	                },
	                "locationKind": {
	                    "name": "locationKind"
	                },
	                "default": {
	                    "name": "default"
	                },
	                "example": {
	                    "name": "example"
	                },
	                "examples": {
	                    "name": "examples"
	                },
	                "required": {
	                    "name": "required"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "xml": {
	                    "name": "xml"
	                },
	                "allowedTargets": {
	                    "name": "allowedTargets"
	                },
	                "isAnnotation": {
	                    "name": "isAnnotation"
	                }
	            }
	        },
	        "DateTimeTypeDeclaration": {
	            "name": "DateTimeTypeDeclaration",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "facets": {
	                    "name": "facets"
	                },
	                "schema": {
	                    "name": "schema"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "location": {
	                    "name": "location"
	                },
	                "locationKind": {
	                    "name": "locationKind"
	                },
	                "default": {
	                    "name": "default"
	                },
	                "example": {
	                    "name": "example"
	                },
	                "examples": {
	                    "name": "examples"
	                },
	                "required": {
	                    "name": "required"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "xml": {
	                    "name": "xml"
	                },
	                "allowedTargets": {
	                    "name": "allowedTargets"
	                },
	                "isAnnotation": {
	                    "name": "isAnnotation"
	                },
	                "format": {
	                    "name": "format"
	                }
	            }
	        },
	        "TypeInstance": {
	            "name": "TypeInstance",
	            "properties": {
	                "properties": {
	                    "name": "properties"
	                },
	                "isScalar": {
	                    "name": "isScalar"
	                },
	                "value": {
	                    "name": "value"
	                },
	                "isArray": {
	                    "name": "isArray"
	                },
	                "items": {
	                    "name": "items"
	                }
	            }
	        },
	        "TypeInstanceProperty": {
	            "name": "TypeInstanceProperty",
	            "properties": {
	                "name": {
	                    "name": "name"
	                },
	                "value": {
	                    "name": "value"
	                },
	                "values": {
	                    "name": "values"
	                },
	                "isArray": {
	                    "name": "isArray"
	                }
	            }
	        },
	        "ModelLocation": {
	            "name": "ModelLocation",
	            "properties": {}
	        },
	        "LocationKind": {
	            "name": "LocationKind",
	            "properties": {}
	        },
	        "MimeType": {
	            "name": "MimeType",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "Response": {
	            "name": "Response",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "code": {
	                    "name": "code"
	                },
	                "headers": {
	                    "name": "headers"
	                },
	                "body": {
	                    "name": "body"
	                },
	                "description": {
	                    "name": "description"
	                }
	            }
	        },
	        "Annotable": {
	            "name": "Annotable",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "AnnotationRef": {
	            "name": "AnnotationRef",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "annotation": {
	                    "name": "annotation",
	                    "range": "TypeDeclaration",
	                    "domain": "AnnotationRef"
	                }
	            }
	        },
	        "AnnotationTarget": {
	            "name": "AnnotationTarget",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "TraitRef": {
	            "name": "TraitRef",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "trait": {
	                    "name": "trait",
	                    "range": "Trait",
	                    "domain": "TraitRef"
	                }
	            }
	        },
	        "Trait": {
	            "name": "Trait",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "queryParameters": {
	                    "name": "queryParameters"
	                },
	                "headers": {
	                    "name": "headers"
	                },
	                "queryString": {
	                    "name": "queryString"
	                },
	                "responses": {
	                    "name": "responses"
	                },
	                "body": {
	                    "name": "body"
	                },
	                "protocols": {
	                    "name": "protocols"
	                },
	                "is": {
	                    "name": "is"
	                },
	                "securedBy": {
	                    "name": "securedBy"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "usage": {
	                    "name": "usage"
	                },
	                "parametrizedProperties": {
	                    "name": "parametrizedProperties",
	                    "range": "TypeInstance",
	                    "domain": "Trait"
	                }
	            }
	        },
	        "MethodBase": {
	            "name": "MethodBase",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "queryParameters": {
	                    "name": "queryParameters"
	                },
	                "headers": {
	                    "name": "headers"
	                },
	                "queryString": {
	                    "name": "queryString"
	                },
	                "responses": {
	                    "name": "responses"
	                },
	                "body": {
	                    "name": "body"
	                },
	                "protocols": {
	                    "name": "protocols"
	                },
	                "is": {
	                    "name": "is"
	                },
	                "securedBy": {
	                    "name": "securedBy"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "displayName": {
	                    "name": "displayName"
	                }
	            }
	        },
	        "Method": {
	            "name": "Method",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "queryParameters": {
	                    "name": "queryParameters"
	                },
	                "headers": {
	                    "name": "headers"
	                },
	                "queryString": {
	                    "name": "queryString"
	                },
	                "responses": {
	                    "name": "responses"
	                },
	                "body": {
	                    "name": "body"
	                },
	                "protocols": {
	                    "name": "protocols"
	                },
	                "is": {
	                    "name": "is"
	                },
	                "securedBy": {
	                    "name": "securedBy"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "method": {
	                    "name": "method"
	                },
	                "parametrizedProperties": {
	                    "name": "parametrizedProperties",
	                    "range": "TypeInstance",
	                    "domain": "Method"
	                }
	            }
	        },
	        "Operation": {
	            "name": "Operation",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "queryParameters": {
	                    "name": "queryParameters"
	                },
	                "headers": {
	                    "name": "headers"
	                },
	                "queryString": {
	                    "name": "queryString"
	                },
	                "responses": {
	                    "name": "responses"
	                }
	            }
	        },
	        "SecuritySchemePart": {
	            "name": "SecuritySchemePart",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "queryParameters": {
	                    "name": "queryParameters"
	                },
	                "headers": {
	                    "name": "headers"
	                },
	                "queryString": {
	                    "name": "queryString"
	                },
	                "responses": {
	                    "name": "responses"
	                }
	            }
	        },
	        "SecuritySchemeSettings": {
	            "name": "SecuritySchemeSettings",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "OAuth1SecuritySchemeSettings": {
	            "name": "OAuth1SecuritySchemeSettings",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "requestTokenUri": {
	                    "name": "requestTokenUri"
	                },
	                "authorizationUri": {
	                    "name": "authorizationUri"
	                },
	                "tokenCredentialsUri": {
	                    "name": "tokenCredentialsUri"
	                },
	                "signatures": {
	                    "name": "signatures"
	                }
	            }
	        },
	        "OAuth2SecuritySchemeSettings": {
	            "name": "OAuth2SecuritySchemeSettings",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "accessTokenUri": {
	                    "name": "accessTokenUri"
	                },
	                "authorizationUri": {
	                    "name": "authorizationUri"
	                },
	                "authorizationGrants": {
	                    "name": "authorizationGrants"
	                },
	                "scopes": {
	                    "name": "scopes"
	                }
	            }
	        },
	        "SecuritySchemeRef": {
	            "name": "SecuritySchemeRef",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "securitySchemeName": {
	                    "name": "securitySchemeName",
	                    "range": "StringType",
	                    "domain": "SecuritySchemeRef"
	                },
	                "securityScheme": {
	                    "name": "securityScheme",
	                    "range": "AbstractSecurityScheme",
	                    "domain": "SecuritySchemeRef"
	                }
	            }
	        },
	        "AbstractSecurityScheme": {
	            "name": "AbstractSecurityScheme",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "describedBy": {
	                    "name": "describedBy"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "settings": {
	                    "name": "settings"
	                }
	            }
	        },
	        "OAuth2SecurityScheme": {
	            "name": "OAuth2SecurityScheme",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "describedBy": {
	                    "name": "describedBy"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "settings": {
	                    "name": "settings"
	                }
	            }
	        },
	        "OAuth1SecurityScheme": {
	            "name": "OAuth1SecurityScheme",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "describedBy": {
	                    "name": "describedBy"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "settings": {
	                    "name": "settings"
	                }
	            }
	        },
	        "PassThroughSecurityScheme": {
	            "name": "PassThroughSecurityScheme",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "describedBy": {
	                    "name": "describedBy"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "settings": {
	                    "name": "settings"
	                }
	            }
	        },
	        "BasicSecurityScheme": {
	            "name": "BasicSecurityScheme",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "describedBy": {
	                    "name": "describedBy"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "settings": {
	                    "name": "settings"
	                }
	            }
	        },
	        "DigestSecurityScheme": {
	            "name": "DigestSecurityScheme",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "describedBy": {
	                    "name": "describedBy"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "settings": {
	                    "name": "settings"
	                }
	            }
	        },
	        "CustomSecurityScheme": {
	            "name": "CustomSecurityScheme",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "describedBy": {
	                    "name": "describedBy"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "settings": {
	                    "name": "settings"
	                }
	            }
	        },
	        "ResourceTypeRef": {
	            "name": "ResourceTypeRef",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "resourceType": {
	                    "name": "resourceType",
	                    "range": "ResourceType",
	                    "domain": "ResourceTypeRef"
	                }
	            }
	        },
	        "ResourceType": {
	            "name": "ResourceType",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "methods": {
	                    "name": "methods"
	                },
	                "is": {
	                    "name": "is"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "securedBy": {
	                    "name": "securedBy"
	                },
	                "uriParameters": {
	                    "name": "uriParameters"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "usage": {
	                    "name": "usage"
	                },
	                "parametrizedProperties": {
	                    "name": "parametrizedProperties",
	                    "range": "TypeInstance",
	                    "domain": "ResourceType"
	                }
	            }
	        },
	        "ResourceBase": {
	            "name": "ResourceBase",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "methods": {
	                    "name": "methods"
	                },
	                "is": {
	                    "name": "is"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "securedBy": {
	                    "name": "securedBy"
	                },
	                "uriParameters": {
	                    "name": "uriParameters"
	                }
	            }
	        },
	        "Resource": {
	            "name": "Resource",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "methods": {
	                    "name": "methods"
	                },
	                "is": {
	                    "name": "is"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "securedBy": {
	                    "name": "securedBy"
	                },
	                "uriParameters": {
	                    "name": "uriParameters"
	                },
	                "relativeUri": {
	                    "name": "relativeUri"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "resources": {
	                    "name": "resources"
	                }
	            }
	        },
	        "FileTypeDeclaration": {
	            "name": "FileTypeDeclaration",
	            "properties": {
	                "annotations": {
	                    "name": "annotations"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "facets": {
	                    "name": "facets"
	                },
	                "schema": {
	                    "name": "schema"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "location": {
	                    "name": "location"
	                },
	                "locationKind": {
	                    "name": "locationKind"
	                },
	                "default": {
	                    "name": "default"
	                },
	                "example": {
	                    "name": "example"
	                },
	                "examples": {
	                    "name": "examples"
	                },
	                "required": {
	                    "name": "required"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "xml": {
	                    "name": "xml"
	                },
	                "allowedTargets": {
	                    "name": "allowedTargets"
	                },
	                "isAnnotation": {
	                    "name": "isAnnotation"
	                },
	                "fileTypes": {
	                    "name": "fileTypes"
	                },
	                "minLength": {
	                    "name": "minLength"
	                },
	                "maxLength": {
	                    "name": "maxLength"
	                }
	            }
	        }
	    }
	};
	module.exports = Universes;
	//# sourceMappingURL=universe.js.map

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    draining = true;
	    var currentQueue;
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        var i = -1;
	        while (++i < len) {
	            currentQueue[i]();
	        }
	        len = queue.length;
	    }
	    draining = false;
	}
	process.nextTick = function (fun) {
	    queue.push(fun);
	    if (!draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	exports.XMLHttpRequest = XMLHttpRequest;

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * media-typer
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	/**
	 * RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
	 *
	 * parameter     = token "=" ( token | quoted-string )
	 * token         = 1*<any CHAR except CTLs or separators>
	 * separators    = "(" | ")" | "<" | ">" | "@"
	 *               | "," | ";" | ":" | "\" | <">
	 *               | "/" | "[" | "]" | "?" | "="
	 *               | "{" | "}" | SP | HT
	 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
	 * qdtext        = <any TEXT except <">>
	 * quoted-pair   = "\" CHAR
	 * CHAR          = <any US-ASCII character (octets 0 - 127)>
	 * TEXT          = <any OCTET except CTLs, but including LWS>
	 * LWS           = [CRLF] 1*( SP | HT )
	 * CRLF          = CR LF
	 * CR            = <US-ASCII CR, carriage return (13)>
	 * LF            = <US-ASCII LF, linefeed (10)>
	 * SP            = <US-ASCII SP, space (32)>
	 * SHT           = <US-ASCII HT, horizontal-tab (9)>
	 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
	 * OCTET         = <any 8-bit sequence of data>
	 */
	var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
	var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/
	var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/

	/**
	 * RegExp to match quoted-pair in RFC 2616
	 *
	 * quoted-pair = "\" CHAR
	 * CHAR        = <any US-ASCII character (octets 0 - 127)>
	 */
	var qescRegExp = /\\([\u0000-\u007f])/g;

	/**
	 * RegExp to match chars that must be quoted-pair in RFC 2616
	 */
	var quoteRegExp = /([\\"])/g;

	/**
	 * RegExp to match type in RFC 6838
	 *
	 * type-name = restricted-name
	 * subtype-name = restricted-name
	 * restricted-name = restricted-name-first *126restricted-name-chars
	 * restricted-name-first  = ALPHA / DIGIT
	 * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
	 *                          "$" / "&" / "-" / "^" / "_"
	 * restricted-name-chars =/ "." ; Characters before first dot always
	 *                              ; specify a facet name
	 * restricted-name-chars =/ "+" ; Characters after last plus always
	 *                              ; specify a structured syntax suffix
	 * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
	 * DIGIT =  %x30-39             ; 0-9
	 */
	var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/
	var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/
	var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;

	/**
	 * Module exports.
	 */

	exports.format = format
	exports.parse = parse

	/**
	 * Format object to media type.
	 *
	 * @param {object} obj
	 * @return {string}
	 * @api public
	 */

	function format(obj) {
	  if (!obj || typeof obj !== 'object') {
	    throw new TypeError('argument obj is required')
	  }

	  var parameters = obj.parameters
	  var subtype = obj.subtype
	  var suffix = obj.suffix
	  var type = obj.type

	  if (!type || !typeNameRegExp.test(type)) {
	    throw new TypeError('invalid type')
	  }

	  if (!subtype || !subtypeNameRegExp.test(subtype)) {
	    throw new TypeError('invalid subtype')
	  }

	  // format as type/subtype
	  var string = type + '/' + subtype

	  // append +suffix
	  if (suffix) {
	    if (!typeNameRegExp.test(suffix)) {
	      throw new TypeError('invalid suffix')
	    }

	    string += '+' + suffix
	  }

	  // append parameters
	  if (parameters && typeof parameters === 'object') {
	    var param
	    var params = Object.keys(parameters).sort()

	    for (var i = 0; i < params.length; i++) {
	      param = params[i]

	      if (!tokenRegExp.test(param)) {
	        throw new TypeError('invalid parameter name')
	      }

	      string += '; ' + param + '=' + qstring(parameters[param])
	    }
	  }

	  return string
	}

	/**
	 * Parse media type to object.
	 *
	 * @param {string|object} string
	 * @return {Object}
	 * @api public
	 */

	function parse(string) {
	  if (!string) {
	    throw new TypeError('argument string is required')
	  }

	  // support req/res-like objects as argument
	  if (typeof string === 'object') {
	    string = getcontenttype(string)
	  }

	  if (typeof string !== 'string') {
	    throw new TypeError('argument string is required to be a string')
	  }

	  var index = string.indexOf(';')
	  var type = index !== -1
	    ? string.substr(0, index)
	    : string

	  var key
	  var match
	  var obj = splitType(type)
	  var params = {}
	  var value

	  paramRegExp.lastIndex = index

	  while (match = paramRegExp.exec(string)) {
	    if (match.index !== index) {
	      throw new TypeError('invalid parameter format')
	    }

	    index += match[0].length
	    key = match[1].toLowerCase()
	    value = match[2]

	    if (value[0] === '"') {
	      // remove quotes and escapes
	      value = value
	        .substr(1, value.length - 2)
	        .replace(qescRegExp, '$1')
	    }

	    params[key] = value
	  }

	  if (index !== -1 && index !== string.length) {
	    throw new TypeError('invalid parameter format')
	  }

	  obj.parameters = params

	  return obj
	}

	/**
	 * Get content-type from req/res objects.
	 *
	 * @param {object}
	 * @return {Object}
	 * @api private
	 */

	function getcontenttype(obj) {
	  if (typeof obj.getHeader === 'function') {
	    // res-like
	    return obj.getHeader('content-type')
	  }

	  if (typeof obj.headers === 'object') {
	    // req-like
	    return obj.headers && obj.headers['content-type']
	  }
	}

	/**
	 * Quote a string if necessary.
	 *
	 * @param {string} val
	 * @return {string}
	 * @api private
	 */

	function qstring(val) {
	  var str = String(val)

	  // no need to quote tokens
	  if (tokenRegExp.test(str)) {
	    return str
	  }

	  if (str.length > 0 && !textRegExp.test(str)) {
	    throw new TypeError('invalid parameter value')
	  }

	  return '"' + str.replace(quoteRegExp, '\\$1') + '"'
	}

	/**
	 * Simply "type/subtype+siffx" into parts.
	 *
	 * @param {string} string
	 * @return {Object}
	 * @api private
	 */

	function splitType(string) {
	  var match = typeRegExp.exec(string.toLowerCase())

	  if (!match) {
	    throw new TypeError('invalid media type')
	  }

	  var type = match[1]
	  var subtype = match[2]
	  var suffix

	  // suffix after last +
	  var index = subtype.lastIndexOf('+')
	  if (index !== -1) {
	    suffix = subtype.substr(index + 1)
	    subtype = subtype.substr(0, index)
	  }

	  var obj = {
	    type: type,
	    subtype: subtype,
	    suffix: suffix
	  }

	  return obj
	}


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var json = typeof JSON !== 'undefined' ? JSON : __webpack_require__(93);

	module.exports = function (obj, opts) {
	    if (!opts) opts = {};
	    if (typeof opts === 'function') opts = { cmp: opts };
	    var space = opts.space || '';
	    if (typeof space === 'number') space = Array(space+1).join(' ');
	    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
	    var replacer = opts.replacer || function(key, value) { return value; };

	    var cmp = opts.cmp && (function (f) {
	        return function (node) {
	            return function (a, b) {
	                var aobj = { key: a, value: node[a] };
	                var bobj = { key: b, value: node[b] };
	                return f(aobj, bobj);
	            };
	        };
	    })(opts.cmp);

	    var seen = [];
	    return (function stringify (parent, key, node, level) {
	        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
	        var colonSeparator = space ? ': ' : ':';

	        if (node && node.toJSON && typeof node.toJSON === 'function') {
	            node = node.toJSON();
	        }

	        node = replacer.call(parent, key, node);

	        if (node === undefined) {
	            return;
	        }
	        if (typeof node !== 'object' || node === null) {
	            return json.stringify(node);
	        }
	        if (isArray(node)) {
	            var out = [];
	            for (var i = 0; i < node.length; i++) {
	                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
	                out.push(indent + space + item);
	            }
	            return '[' + out.join(',') + indent + ']';
	        }
	        else {
	            if (seen.indexOf(node) !== -1) {
	                if (cycles) return json.stringify('__cycle__');
	                throw new TypeError('Converting circular structure to JSON');
	            }
	            else seen.push(node);

	            var keys = objectKeys(node).sort(cmp && cmp(node));
	            var out = [];
	            for (var i = 0; i < keys.length; i++) {
	                var key = keys[i];
	                var value = stringify(node, key, node[key], level+1);

	                if(!value) continue;

	                var keyValue = json.stringify(key)
	                    + colonSeparator
	                    + value;
	                ;
	                out.push(indent + space + keyValue);
	            }
	            seen.splice(seen.indexOf(node), 1);
	            return '{' + out.join(',') + indent + '}';
	        }
	    })({ '': obj }, '', obj, 0);
	};

	var isArray = Array.isArray || function (x) {
	    return {}.toString.call(x) === '[object Array]';
	};

	var objectKeys = Object.keys || function (obj) {
	    var has = Object.prototype.hasOwnProperty || function () { return true };
	    var keys = [];
	    for (var key in obj) {
	        if (has.call(obj, key)) keys.push(key);
	    }
	    return keys;
	};


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
	//     http://underscorejs.org
	//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind,
	    nativeCreate       = Object.create;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.8.3';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      case 2: return function(value, other) {
	        return func.call(context, value, other);
	      };
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };

	  // A mostly-internal function to generate callbacks that can be applied
	  // to each element in a collection, returning the desired result  either
	  // identity, an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value)) return _.matcher(value);
	    return _.property(value);
	  };
	  _.iteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };

	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, undefinedOnly) {
	    return function(obj) {
	      var length = arguments.length;
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };

	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };

	  var property = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = property('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };

	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Optimized iterator function as using arguments.length
	    // in the main function will deoptimize the, see #1991.
	    function iterator(obj, iteratee, memo, keys, index, length) {
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    }

	    return function(obj, iteratee, memo, context) {
	      iteratee = optimizeCb(iteratee, context, 4);
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      // Determine the initial value if none is provided.
	      if (arguments.length < 3) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      return iterator(obj, iteratee, memo, keys, index, length);
	    };
	  }

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var key;
	    if (isArrayLike(obj)) {
	      key = _.findIndex(obj, predicate, context);
	    } else {
	      key = _.findKey(obj, predicate, context);
	    }
	    if (key !== void 0 && key !== -1) return obj[key];
	  };

	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };

	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      var func = isFunc ? method : value[method];
	      return func == null ? func : func.apply(value, args);
	    });
	  };

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };

	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Shuffle a collection, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
	  _.shuffle = function(obj) {
	    var set = isArrayLike(obj) ? obj : _.values(obj);
	    var length = set.length;
	    var shuffled = Array(length);
	    for (var index = 0, rand; index < length; index++) {
	      rand = _.random(0, index);
	      if (rand !== index) shuffled[index] = shuffled[rand];
	      shuffled[rand] = set[index];
	    }
	    return shuffled;
	  };

	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };

	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iteratee(value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iteratee, context) {
	      var result = {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key]++; else result[key] = 1;
	  });

	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var pass = [], fail = [];
	    _.each(obj, function(value, key, obj) {
	      (predicate(value, key, obj) ? pass : fail).push(value);
	    });
	    return [pass, fail];
	  };

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, startIndex) {
	    var output = [], idx = 0;
	    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        //flatten current level of array or arguments object
	        if (!shallow) value = flatten(value, shallow, strict);
	        var j = 0, len = value.length;
	        output.length += len;
	        while (j < len) {
	          output[idx++] = value[j++];
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(flatten(arguments, true, true));
	  };

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      for (var j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = flatten(arguments, true, true, 1);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    return _.unzip(arguments);
	  };

	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // Generator function to create the findIndex and findLastIndex functions
	  function createPredicateIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }

	  // Returns the first index on an array-like that passes a predicate test
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };

	  // Generator function to create the indexOf and lastIndexOf functions
	  function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	            i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  }

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = step || 1;

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var args = slice.call(arguments, 2);
	    var bound = function() {
	      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
	    };
	    return bound;
	  };

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  };

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var i, length = arguments.length, key;
	    if (length <= 1) throw new Error('bindAll must be passed function names');
	    for (i = 1; i < length; i++) {
	      key = arguments[i];
	      obj[key] = _.bind(obj[key], obj);
	    }
	    return obj;
	  };

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){
	      return func.apply(null, args);
	    }, wait);
	  };

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    if (!options) options = {};
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;

	    var later = function() {
	      var last = _.now() - timestamp;

	      if (last < wait && last >= 0) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          if (!timeout) context = args = null;
	        }
	      }
	    };

	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) timeout = setTimeout(later, wait);
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }

	      return result;
	    };
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };

	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };

	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  function collectNonEnumProps(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  }

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Returns the results of applying the iteratee to each element of the object
	  // In contrast to _.map it returns an object
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys =  _.keys(obj),
	          length = keys.length,
	          results = {},
	          currentKey;
	      for (var index = 0; index < length; index++) {
	        currentKey = keys[index];
	        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	      }
	      return results;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s)
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);

	  // Returns the first key on an object that passes a predicate test
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(object, oiteratee, context) {
	    var result = {}, obj = object, iteratee, keys;
	    if (obj == null) return result;
	    if (_.isFunction(oiteratee)) {
	      keys = _.allKeys(obj);
	      iteratee = optimizeCb(oiteratee, context);
	    } else {
	      keys = flatten(arguments, false, false, 1);
	      iteratee = function(value, key, obj) { return key in obj; };
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  };

	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj, iteratee, context) {
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	    } else {
	      var keys = _.map(flatten(arguments, false, false, 1), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  };

	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };


	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return _.has(obj, 'callee');
	    };
	  }

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), and in Safari 8 (#1929).
	  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj !== +obj;
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return obj != null && hasOwnProperty.call(obj, key);
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };

	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };

	  _.noop = function(){};

	  _.property = property;

	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    return obj == null ? function(){} : function(key) {
	      return obj[key];
	    };
	  };

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };

	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };

	   // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);

	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property, fallback) {
	    var value = object == null ? void 0 : object[property];
	    if (value === void 0) {
	      value = fallback;
	    }
	    return _.isFunction(value) ? value.call(object) : value;
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escaper, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offest.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    try {
	      var render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var result = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result(this, func.apply(_, args));
	      };
	    });
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return result(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return '' + this._wrapped;
	  };

	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}.call(this));


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = Response;

	/**
	 * A response from a web request
	 *
	 * @param {Number} statusCode
	 * @param {Object} headers
	 * @param {Buffer} body
	 * @param {String} url
	 */
	function Response(statusCode, headers, body, url) {
	  if (typeof statusCode !== 'number') {
	    throw new TypeError('statusCode must be a number but was ' + (typeof statusCode));
	  }
	  if (headers === null) {
	    throw new TypeError('headers cannot be null');
	  }
	  if (typeof headers !== 'object') {
	    throw new TypeError('headers must be an object but was ' + (typeof headers));
	  }
	  this.statusCode = statusCode;
	  this.headers = {};
	  for (var key in headers) {
	    this.headers[key.toLowerCase()] = headers[key];
	  }
	  this.body = body;
	  this.url = url;
	}

	Response.prototype.getBody = function (encoding) {
	  if (this.statusCode >= 300) {
	    var err = new Error('Server responded with status code '
	                    + this.statusCode + ':\n' + this.body.toString());
	    err.statusCode = this.statusCode;
	    err.headers = this.headers;
	    err.body = this.body;
	    err.url = this.url;
	    throw err;
	  }
	  return encoding ? this.body.toString(encoding) : this.body;
	};


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var Writable = __webpack_require__(109).Writable
	var inherits = __webpack_require__(112)

	if (typeof Uint8Array === 'undefined') {
	  var U8 = __webpack_require__(107).Uint8Array
	} else {
	  var U8 = Uint8Array
	}

	function ConcatStream(opts, cb) {
	  if (!(this instanceof ConcatStream)) return new ConcatStream(opts, cb)

	  if (typeof opts === 'function') {
	    cb = opts
	    opts = {}
	  }
	  if (!opts) opts = {}

	  var encoding = opts.encoding
	  var shouldInferEncoding = false

	  if (!encoding) {
	    shouldInferEncoding = true
	  } else {
	    encoding =  String(encoding).toLowerCase()
	    if (encoding === 'u8' || encoding === 'uint8') {
	      encoding = 'uint8array'
	    }
	  }

	  Writable.call(this, { objectMode: true })

	  this.encoding = encoding
	  this.shouldInferEncoding = shouldInferEncoding

	  if (cb) this.on('finish', function () { cb(this.getBody()) })
	  this.body = []
	}

	module.exports = ConcatStream
	inherits(ConcatStream, Writable)

	ConcatStream.prototype._write = function(chunk, enc, next) {
	  this.body.push(chunk)
	  next()
	}

	ConcatStream.prototype.inferEncoding = function (buff) {
	  var firstBuffer = buff === undefined ? this.body[0] : buff;
	  if (Buffer.isBuffer(firstBuffer)) return 'buffer'
	  if (typeof Uint8Array !== 'undefined' && firstBuffer instanceof Uint8Array) return 'uint8array'
	  if (Array.isArray(firstBuffer)) return 'array'
	  if (typeof firstBuffer === 'string') return 'string'
	  if (Object.prototype.toString.call(firstBuffer) === "[object Object]") return 'object'
	  return 'buffer'
	}

	ConcatStream.prototype.getBody = function () {
	  if (!this.encoding && this.body.length === 0) return []
	  if (this.shouldInferEncoding) this.encoding = this.inferEncoding()
	  if (this.encoding === 'array') return arrayConcat(this.body)
	  if (this.encoding === 'string') return stringConcat(this.body)
	  if (this.encoding === 'buffer') return bufferConcat(this.body)
	  if (this.encoding === 'uint8array') return u8Concat(this.body)
	  return this.body
	}

	var isArray = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]'
	}

	function isArrayish (arr) {
	  return /Array\]$/.test(Object.prototype.toString.call(arr))
	}

	function stringConcat (parts) {
	  var strings = []
	  var needsToString = false
	  for (var i = 0; i < parts.length; i++) {
	    var p = parts[i]
	    if (typeof p === 'string') {
	      strings.push(p)
	    } else if (Buffer.isBuffer(p)) {
	      strings.push(p)
	    } else {
	      strings.push(Buffer(p))
	    }
	  }
	  if (Buffer.isBuffer(parts[0])) {
	    strings = Buffer.concat(strings)
	    strings = strings.toString('utf8')
	  } else {
	    strings = strings.join('')
	  }
	  return strings
	}

	function bufferConcat (parts) {
	  var bufs = []
	  for (var i = 0; i < parts.length; i++) {
	    var p = parts[i]
	    if (Buffer.isBuffer(p)) {
	      bufs.push(p)
	    } else if (typeof p === 'string' || isArrayish(p)
	    || (p && typeof p.subarray === 'function')) {
	      bufs.push(Buffer(p))
	    } else bufs.push(Buffer(String(p)))
	  }
	  return Buffer.concat(bufs)
	}

	function arrayConcat (parts) {
	  var res = []
	  for (var i = 0; i < parts.length; i++) {
	    res.push.apply(res, parts[i])
	  }
	  return res
	}

	function u8Concat (parts) {
	  var len = 0
	  for (var i = 0; i < parts.length; i++) {
	    if (typeof parts[i] === 'string') {
	      parts[i] = Buffer(parts[i])
	    }
	    len += parts[i].length
	  }
	  var u8 = new U8(len)
	  for (var i = 0, offset = 0; i < parts.length; i++) {
	    var part = parts[i]
	    for (var j = 0; j < part.length; j++) {
	      u8[offset++] = part[j]
	    }
	  }
	  return u8
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(92).Buffer))

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {function fromBase64(base64string) {
	  return (
	    base64string
	      .replace(/=/g, '')
	      .replace(/\+/g, '-')
	      .replace(/\//g, '_')
	  );
	}

	function toBase64(base64UrlString) {
	  if (Buffer.isBuffer(base64UrlString))
	    base64UrlString = base64UrlString.toString();

	  var b64str = padString(base64UrlString)
	    .replace(/\-/g, '+')
	    .replace(/_/g, '/');
	  return b64str;
	}

	function padString(string) {
	  var segmentLength = 4;
	  var stringLength = string.length;
	  var diff = string.length % segmentLength;
	  if (!diff)
	    return string;
	  var position = stringLength;
	  var padLength = segmentLength - diff;
	  var paddedStringLength = stringLength + padLength;
	  var buffer = Buffer(paddedStringLength);
	  buffer.write(string);
	  while (padLength--)
	    buffer.write('=', position++);
	  return buffer.toString();
	}

	function decodeBase64Url(base64UrlString, encoding) {
	  return Buffer(toBase64(base64UrlString), 'base64').toString(encoding);
	}

	function base64url(stringOrBuffer, encoding) {
	  return fromBase64(Buffer(stringOrBuffer, encoding).toString('base64'));
	}

	function toBuffer(base64string) {
	  return Buffer(toBase64(base64string), 'base64');
	}

	base64url.toBase64 = toBase64;
	base64url.fromBase64 = fromBase64;
	base64url.decode = decodeBase64Url;
	base64url.encode = base64url;
	base64url.toBuffer = toBuffer;

	module.exports = base64url;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(92).Buffer))

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};

	module.exports = invariant;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59)))

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var def = __webpack_require__(36);
	var universes = __webpack_require__(22);
	var universeHelpers = __webpack_require__(14);
	var services = def;
	var search = __webpack_require__(23);
	var AttributeDefaultsCalculator = (function () {
	    /**
	    /**
	     *
	     * @param enabled - if false, defaults calculator will not return defaults from
	     * attrValueOrDefault method, only original values.
	     * @constructor
	     */
	    function AttributeDefaultsCalculator(enabled) {
	        this.enabled = enabled;
	        this.valueCalculators = [
	            new RequiredPropertyCalculator(),
	            new TypePropertyCalculator(),
	            new DisplayNamePropertyCalculator(),
	            new MediaTypeCalculator(),
	            new SecuredByPropertyCalculator(),
	            new ProtocolsPropertyCalculator(),
	            new VersionParamEnumCalculator()
	        ];
	    }
	    /**
	     * Return attribute default value if defaults calculator is enabled.
	     * If attribute value is null or undefined, returns attribute default.
	     */
	    AttributeDefaultsCalculator.prototype.attributeDefaultIfEnabled = function (node, attributeProperty) {
	        if (!this.enabled)
	            return null;
	        return this.getAttributeDefault(node, attributeProperty);
	    };
	    /**
	     * Returns attribute default.
	     */
	    AttributeDefaultsCalculator.prototype.getAttributeDefault = function (node, attributeProperty) {
	        if (!node || !attributeProperty)
	            return null;
	        try {
	            return this.getAttributeDefault2(attributeProperty, node);
	        }
	        catch (Error) {
	            console.log(Error);
	            return null;
	        }
	    };
	    AttributeDefaultsCalculator.prototype.getWrapperAttributeDefault = function (wrapperNode, attributeName) {
	        var highLevelNode = wrapperNode.highLevel();
	        if (highLevelNode == null)
	            return null;
	        var property = highLevelNode.definition().property(attributeName);
	        if (property == null)
	            return null;
	        return this.getAttributeDefault(highLevelNode, property);
	    };
	    /**
	     * Returns attribute default.
	     * There are so many arguments instead of just providing a single AST node and getting
	     * anything we want from it as sometimes we create fake nodes in helpers and thus
	     * do not have actual high-level nodes at hands.
	     */
	    AttributeDefaultsCalculator.prototype.getAttributeDefault2 = function (attributeProperty, node) {
	        for (var i = 0; i < this.valueCalculators.length; i++) {
	            var calculator = this.valueCalculators[i];
	            if (calculator.matches(attributeProperty, node)) {
	                var value = calculator.calculate(attributeProperty, node);
	                if (value != null) {
	                    return value;
	                }
	            }
	        }
	        //static values defined in definition system via defaultValue, defaultIntegerValue
	        // and defaultBooleanValue annotations.
	        if (attributeProperty.defaultValue() != null) {
	            return attributeProperty.defaultValue();
	        }
	        return null;
	    };
	    AttributeDefaultsCalculator.prototype.isEnabled = function () {
	        return this.enabled;
	    };
	    AttributeDefaultsCalculator.prototype.insertionKind = function (node, attributeProperty) {
	        for (var i = 0; i < this.valueCalculators.length; i++) {
	            var calculator = this.valueCalculators[i];
	            if (calculator.matches(attributeProperty, node)) {
	                return calculator.kind();
	            }
	        }
	        if (attributeProperty.defaultValue() != null) {
	            return InsertionKind.BY_DEFAULT;
	        }
	        return null;
	    };
	    return AttributeDefaultsCalculator;
	}());
	exports.AttributeDefaultsCalculator = AttributeDefaultsCalculator;
	(function (InsertionKind) {
	    InsertionKind[InsertionKind["CALCULATED"] = 0] = "CALCULATED";
	    InsertionKind[InsertionKind["BY_DEFAULT"] = 1] = "BY_DEFAULT";
	})(exports.InsertionKind || (exports.InsertionKind = {}));
	var InsertionKind = exports.InsertionKind;
	var MediaTypeCalculator = (function () {
	    function MediaTypeCalculator() {
	    }
	    MediaTypeCalculator.prototype.calculate = function (attributeProperty, node) {
	        var root = search.declRoot(node);
	        if (root && universeHelpers.isApiSibling(root.definition())) {
	            var defaultMediaTypeAttr = root.attr(universes.Universe10.Api.properties.mediaType.name);
	            if (defaultMediaTypeAttr) {
	                return defaultMediaTypeAttr.value();
	            }
	        }
	        return null;
	    };
	    MediaTypeCalculator.prototype.matches = function (attributeProperty, node) {
	        if (!universeHelpers.isNameProperty(attributeProperty)) {
	            return false;
	        }
	        var nodeDefinition = node.definition();
	        if (!nodeDefinition) {
	            return false;
	        }
	        if (!(universeHelpers.isBodyLikeType(nodeDefinition)
	            || universeHelpers.isTypeDeclarationSibling(nodeDefinition))) {
	            return false;
	        }
	        var parentNode = node.parent();
	        if (parentNode == null) {
	            return false;
	        }
	        var parentDefinition = parentNode.definition();
	        if (parentDefinition == null) {
	            return false;
	        }
	        if (!(universeHelpers.isResponseType(parentDefinition)
	            || universeHelpers.isMethodBaseSibling(parentDefinition))) {
	            return false;
	        }
	        var ancestor = parentNode;
	        while (ancestor) {
	            var aDef = ancestor.definition();
	            if (universeHelpers.isTraitType(aDef)) {
	                return false;
	            }
	            if (universeHelpers.isResourceTypeType(aDef)) {
	                return false;
	            }
	            ancestor = ancestor.parent();
	        }
	        return true;
	    };
	    MediaTypeCalculator.prototype.kind = function () {
	        return InsertionKind.CALCULATED;
	    };
	    return MediaTypeCalculator;
	}());
	var DisplayNamePropertyCalculator = (function () {
	    function DisplayNamePropertyCalculator() {
	    }
	    DisplayNamePropertyCalculator.prototype.calculate = function (attributeProperty, node) {
	        var nodeDefinition = node.definition();
	        if (nodeDefinition == null) {
	            return null;
	        }
	        var adapter = nodeDefinition.getAdapter(services.RAMLService);
	        var keyProperty = adapter.getKeyProp();
	        if (keyProperty != null) {
	            var attributeValue = node.attrValue(keyProperty.nameId());
	            if (attributeValue != null) {
	                return attributeValue;
	            }
	            else {
	                return new AttributeDefaultsCalculator(true).getAttributeDefault(node, keyProperty);
	            }
	        }
	        return null;
	    };
	    DisplayNamePropertyCalculator.prototype.matches = function (attributeProperty, node) {
	        var nodeDefinition = node.definition();
	        if (nodeDefinition == null) {
	            return false;
	        }
	        return (universeHelpers.isTypeDeclarationSibling(nodeDefinition)
	            || nodeDefinition.isAssignableFrom(universes.Universe08.Parameter.name)
	            || universeHelpers.isResourceType(nodeDefinition))
	            && universeHelpers.isDisplayNameProperty(attributeProperty);
	    };
	    DisplayNamePropertyCalculator.prototype.kind = function () {
	        return InsertionKind.CALCULATED;
	    };
	    return DisplayNamePropertyCalculator;
	}());
	var TypePropertyCalculator = (function () {
	    function TypePropertyCalculator() {
	    }
	    TypePropertyCalculator.prototype.calculate = function (attributeProperty, node) {
	        return "object";
	    };
	    TypePropertyCalculator.prototype.matches = function (attributeProperty, node) {
	        return universeHelpers.isTypeProperty(attributeProperty)
	            && node.definition() != null
	            && universeHelpers.isObjectTypeDeclarationSibling(node.definition());
	    };
	    TypePropertyCalculator.prototype.kind = function () {
	        return InsertionKind.BY_DEFAULT;
	    };
	    return TypePropertyCalculator;
	}());
	var RequiredPropertyCalculator = (function () {
	    function RequiredPropertyCalculator() {
	    }
	    RequiredPropertyCalculator.prototype.calculate = function (attributeProperty, node) {
	        var nodeDefinition = node.definition();
	        var nodeProperty = node.property();
	        if (nodeDefinition == null) {
	            return null;
	        }
	        //if node key is ending with question mark, it optional, thus its "required" == false
	        var adapter = nodeDefinition.getAdapter(services.RAMLService);
	        var keyProperty = adapter.getKeyProp();
	        if (keyProperty != null) {
	            var attribute = node.attr(keyProperty.nameId());
	            if (attribute != null && attribute.optional()) {
	                return false;
	            }
	        }
	        if (nodeProperty != null) {
	            //the spec is unclear with regard to this parameter, but for now it looks like:
	            //for query string parameters, form parameters, and request and response headers the default is false
	            //for URI parameters the default is true
	            //for base URI parameters - unclear, but according to old JS parser behavior it looks like the default is true
	            //for all other entities we back drop to what definition system states
	            if (universeHelpers.isHeadersProperty(nodeProperty) ||
	                universeHelpers.isFormParametersProperty(nodeProperty) ||
	                universeHelpers.isQueryParametersProperty(nodeProperty)) {
	                if (attributeProperty.domain().universe().version() == "RAML08") {
	                    return false;
	                }
	                return true;
	            }
	            else if (universeHelpers.isUriParametersProperty(nodeProperty) ||
	                universeHelpers.isBaseUriParametersProperty(nodeProperty)) {
	                return true;
	            }
	        }
	        if (attributeProperty.defaultValue() != null) {
	            return attributeProperty.defaultValue();
	        }
	        return null;
	    };
	    RequiredPropertyCalculator.prototype.matches = function (attributeProperty, node) {
	        return universeHelpers.isRequiredProperty(attributeProperty);
	    };
	    RequiredPropertyCalculator.prototype.kind = function () {
	        return InsertionKind.BY_DEFAULT;
	    };
	    return RequiredPropertyCalculator;
	}());
	var SecuredByPropertyCalculator = (function () {
	    function SecuredByPropertyCalculator() {
	    }
	    SecuredByPropertyCalculator.prototype.calculate = function (attributeProperty, node) {
	        if (universeHelpers.isApiSibling(node.definition())) {
	            return null;
	        }
	        var values;
	        //instanceof, but have to avoid direct usage of instanceof in JS.
	        var definition = node.definition();
	        if (universeHelpers.isMethodType(definition)) {
	            var resource = node.parent();
	            if (resource) {
	                values = resource.wrapperNode().securedBy();
	            }
	        }
	        if (!values || values.length == 0) {
	            while (node != null && !universeHelpers.isApiSibling(node.definition())) {
	                node = node.parent();
	            }
	            if (node) {
	                values = node.wrapperNode().securedBy();
	            }
	        }
	        if (values && values.length > 0) {
	            return values;
	        }
	        return null;
	    };
	    SecuredByPropertyCalculator.prototype.matches = function (attributeProperty, node) {
	        var nodeDefinition = node.definition();
	        if (nodeDefinition == null) {
	            return false;
	        }
	        return universeHelpers.isSecuredByProperty(attributeProperty);
	    };
	    SecuredByPropertyCalculator.prototype.kind = function () {
	        return InsertionKind.CALCULATED;
	    };
	    return SecuredByPropertyCalculator;
	}());
	var ProtocolsPropertyCalculator = (function () {
	    function ProtocolsPropertyCalculator() {
	    }
	    ProtocolsPropertyCalculator.prototype.calculate = function (attributeProperty, node) {
	        while (node != null && !universeHelpers.isApiSibling(node.definition())) {
	            node = node.parent();
	        }
	        var result;
	        var baseUriAttr = node.attr(universes.Universe10.Api.properties.baseUri.name);
	        if (baseUriAttr) {
	            var baseUri = baseUriAttr.value();
	            if (baseUri) {
	                var ind = baseUri.indexOf('://');
	                if (ind >= 0) {
	                    result = [baseUri.substring(0, ind).toUpperCase()];
	                }
	                if (!result) {
	                    result = ['HTTP'];
	                }
	            }
	        }
	        return result;
	    };
	    ProtocolsPropertyCalculator.prototype.matches = function (attributeProperty, node) {
	        if (!universeHelpers.isProtocolsProperty(attributeProperty)) {
	            return false;
	        }
	        var nodeDefinition = node.definition();
	        var hasAppropriateLocation = false;
	        if (universeHelpers.isApiSibling(nodeDefinition)) {
	            hasAppropriateLocation = true;
	        }
	        else if (universeHelpers.isResourceType(nodeDefinition)) {
	            hasAppropriateLocation = true;
	        }
	        else if (universeHelpers.isMethodType(nodeDefinition)) {
	            var parentNode = node.parent();
	            hasAppropriateLocation = parentNode && universeHelpers.isResourceType(parentNode.definition());
	        }
	        return hasAppropriateLocation;
	    };
	    ProtocolsPropertyCalculator.prototype.kind = function () {
	        return InsertionKind.CALCULATED;
	    };
	    return ProtocolsPropertyCalculator;
	}());
	var VersionParamEnumCalculator = (function () {
	    function VersionParamEnumCalculator() {
	    }
	    VersionParamEnumCalculator.prototype.calculate = function (attributeProperty, node) {
	        while (node != null && !universeHelpers.isApiSibling(node.definition())) {
	            node = node.parent();
	        }
	        var versionAttr = node.attr(universes.Universe10.Api.properties.version.name);
	        if (versionAttr) {
	            var versionValue = versionAttr.value();
	            if (versionValue && versionValue.trim()) {
	                return [versionValue];
	            }
	        }
	        return null;
	    };
	    VersionParamEnumCalculator.prototype.matches = function (attributeProperty, node) {
	        if (!universeHelpers.isEnumProperty(attributeProperty)) {
	            return false;
	        }
	        var nodeProperty = node.property();
	        if (!nodeProperty) {
	            return false;
	        }
	        if (!universeHelpers.isBaseUriParametersProperty(nodeProperty)) {
	            return false;
	        }
	        var nameAttr = node.attr(universes.Universe10.TypeDeclaration.properties.name.name);
	        var paramName = nameAttr && nameAttr.value();
	        if (paramName != 'version') {
	            return false;
	        }
	        return true;
	    };
	    VersionParamEnumCalculator.prototype.kind = function () {
	        return InsertionKind.CALCULATED;
	    };
	    return VersionParamEnumCalculator;
	}());
	//# sourceMappingURL=defaultCalculator.js.map

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../../typings/main.d.ts" />
	var universe = __webpack_require__(22);
	var core = __webpack_require__(46);
	var proxy = __webpack_require__(39);
	var def = __webpack_require__(36);
	var hlImpl = __webpack_require__(16);
	var builder = __webpack_require__(26);
	var universeHelpers = __webpack_require__(14);
	var universes = __webpack_require__(22);
	var util = __webpack_require__(32);
	var RamlWrapper10 = __webpack_require__(12);
	function dump(node, serializeMeta) {
	    if (serializeMeta === void 0) { serializeMeta = true; }
	    return new TCKDumper({
	        rootNodeDetails: true,
	        serializeMetadata: serializeMeta
	    }).dump(node);
	}
	exports.dump = dump;
	var TCKDumper = (function () {
	    function TCKDumper(options) {
	        this.options = options;
	        this.nodeTransformers = [
	            new ResourcesTransformer(),
	            new TypeExampleTransformer(),
	            //new ParametersTransformer(),
	            new ArrayExpressionTransformer(),
	            new TypesTransformer(),
	            //new UsesTransformer(),
	            //new PropertiesTransformer(),
	            //new ExamplesTransformer(),
	            //new ResponsesTransformer(),
	            //new BodiesTransformer(),
	            //new AnnotationsTransformer(),
	            new SecuritySchemesTransformer(),
	            new AnnotationTypesTransformer(),
	            new TemplateParametrizedPropertiesTransformer(),
	            new TraitsTransformer(),
	            new ResourceTypesTransformer(),
	            //new FacetsTransformer(),
	            new SchemasTransformer(),
	            new ProtocolsToUpperCaseTransformer(),
	            new ResourceTypeMethodsToMapTransformer(),
	            new ReferencesTransformer(),
	            new SimpleNamesTransformer(),
	        ];
	        this.nodePropertyTransformers = [
	            //new ResourcesTransformer(),
	            //new TypeExampleTransformer(),
	            new ParametersTransformer(),
	            //new TypesTransformer(),
	            //new UsesTransformer(),
	            new PropertiesTransformer(),
	            // //new ExamplesTransformer(),
	            new ResponsesTransformer(),
	            new BodiesTransformer(),
	            new AnnotationsTransformer(),
	            //new SecuritySchemesTransformer(),
	            //new AnnotationTypesTransformer(),
	            //new TemplateParametrizedPropertiesTransformer(),
	            //new TraitsTransformer(),
	            //new ResourceTypesTransformer(),
	            new FacetsTransformer(),
	            //new SchemasTransformer(),
	            //new ProtocolsToUpperCaseTransformer(),
	            //new ResourceTypeMethodsToMapTransformer(),
	            //new ReferencesTransformer(),
	            new OneElementArrayTransformer()
	        ];
	        this.ignore = new CompositeObjectPropertyMatcher([
	            new BasicObjectPropertyMatcher(universeHelpers.isResponseType, universeHelpers.isDisplayNameProperty),
	            new BasicObjectPropertyMatcher(universeHelpers.isApiSibling, universeHelpers.isDisplayNameProperty),
	            new BasicObjectPropertyMatcher(universeHelpers.isAnnotationRefTypeOrDescendant, universeHelpers.isAnnotationProperty),
	            new BasicObjectPropertyMatcher(universeHelpers.isSecuritySchemeRefType, universeHelpers.isSecuritySchemeProperty),
	            new BasicObjectPropertyMatcher(universeHelpers.isTraitRefType, universeHelpers.isTraitProperty),
	            new BasicObjectPropertyMatcher(universeHelpers.isResourceTypeRefType, universeHelpers.isResourceTypeProperty),
	            new BasicObjectPropertyMatcher(universeHelpers.isApiSibling, universeHelpers.isRAMLVersionProperty)
	        ]);
	        this.missingProperties = new PropertiesData();
	        this.options = this.options || {};
	        if (this.options.serializeMetadata == null) {
	            this.options.serializeMetadata = true;
	        }
	    }
	    TCKDumper.prototype.printMissingProperties = function () {
	        return this.missingProperties.print();
	    };
	    TCKDumper.prototype.dump = function (node) {
	        var highLevelNode = node.highLevel();
	        var highLevelParent = highLevelNode && highLevelNode.parent();
	        var rootNodeDetails = !highLevelParent && this.options.rootNodeDetails;
	        var result = this.dumpInternal(node, rootNodeDetails);
	        return result;
	    };
	    TCKDumper.prototype.dumpInternal = function (node, rootNodeDetails) {
	        var _this = this;
	        if (rootNodeDetails === void 0) { rootNodeDetails = false; }
	        if (node == null) {
	            return null;
	        }
	        if (node instanceof core.BasicNodeImpl) {
	            var props = {};
	            var basicNode = node;
	            var definition = basicNode.highLevel().definition();
	            definition.allProperties().filter(function (x) { return !_this.ignore.match(basicNode.definition(), x); }).forEach(function (x) {
	                props[x.nameId()] = x;
	            });
	            definition.allCustomProperties().filter(function (x) { return !_this.ignore.match(basicNode.definition(), x); }).forEach(function (x) {
	                props[x.nameId()] = x;
	            });
	            var obj = this.dumpProperties(props, node);
	            if (props["schema"]) {
	                if (this.options.dumpSchemaContents) {
	                    if (props["schema"].range().key() == universes.Universe08.SchemaString) {
	                        var schemas = basicNode.highLevel().root().elementsOfKind("schemas");
	                        schemas.forEach(function (x) {
	                            if (x.name() == obj["schema"]) {
	                                var vl = x.attr("value");
	                                if (vl) {
	                                    obj["schema"] = vl.value();
	                                    obj["schemaContent"] = vl.value();
	                                }
	                            }
	                        });
	                    }
	                }
	            }
	            this.serializeScalarsAnnotations(obj, basicNode, props);
	            this.serializeMeta(obj, basicNode);
	            if (this.canBeFragment(node)) {
	                if (RamlWrapper10.isFragment(node)) {
	                    var fragment = RamlWrapper10.asFragment(node);
	                    var uses = fragment.uses();
	                    if (uses.length > 0) {
	                        obj["uses"] = uses.map(function (x) { return x.toJSON(); });
	                    }
	                }
	            }
	            this.nodeTransformers.forEach(function (x) {
	                if (x.match(node, node.highLevel().property())) {
	                    obj = x.transform(obj, node);
	                }
	            });
	            var result = {};
	            if (rootNodeDetails) {
	                if (definition) {
	                    var ramlVersion = definition.universe().version();
	                    result.ramlVersion = ramlVersion;
	                    result.type = definition.nameId();
	                }
	                result.specification = obj;
	                result.errors = this.dumpErrors(basicNode.errors());
	            }
	            else {
	                result = obj;
	            }
	            return result;
	        }
	        else if (node instanceof core.AttributeNodeImpl) {
	            var props = {};
	            var attrNode = node;
	            var definition = attrNode.highLevel().definition();
	            definition.allCustomProperties().filter(function (x) { return !_this.ignore.match(attrNode.highLevel().property().range(), x); }).forEach(function (x) {
	                props[x.nameId()] = x;
	            });
	            var isValueType = attrNode.highLevel().property().range().isValueType();
	            if (isValueType && attrNode['value']) {
	                var val = attrNode['value']();
	                if (typeof val == 'number' || typeof val == 'string' || typeof val == 'boolean') {
	                    return val;
	                }
	            }
	            var obj = this.dumpProperties(props, node);
	            this.nodeTransformers.forEach(function (x) {
	                if (x.match(node, node.highLevel().property())) {
	                    obj = x.transform(obj);
	                }
	            });
	            this.serializeScalarsAnnotations(obj, node, props);
	            this.serializeMeta(obj, attrNode);
	            return obj;
	        }
	        else if (node instanceof core.TypeInstanceImpl) {
	            return this.serializeTypeInstance(node);
	        }
	        else if (node instanceof core.TypeInstancePropertyImpl) {
	            return this.serializeTypeInstanceProperty(node);
	        }
	        return node;
	    };
	    TCKDumper.prototype.canBeFragment = function (node) {
	        var definition = node.definition();
	        var arr = [definition].concat(definition.allSubTypes());
	        var arr1 = arr.filter(function (x) { return x.getAdapter(def.RAMLService).possibleInterfaces()
	            .filter(function (y) { return y.nameId() == def.universesInfo.Universe10.FragmentDeclaration.name; }).length > 0; });
	        return arr1.length > 0;
	    };
	    TCKDumper.prototype.dumpErrors = function (errors) {
	        var _this = this;
	        return errors.map(function (x) {
	            var eObj = _this.dumpErrorBasic(x);
	            if (x.trace && x.trace.length > 0) {
	                eObj['trace'] = x.trace.map(function (y) { return _this.dumpErrorBasic(y); });
	            }
	            return eObj;
	        }).sort(function (x, y) {
	            if (x.path != y.path) {
	                return x.path.localeCompare(y.path);
	            }
	            if (x.range.start.position != y.range.start.position) {
	                return x.range.start.position - y.range.start.position;
	            }
	            return x.code - y.code;
	        });
	    };
	    TCKDumper.prototype.dumpErrorBasic = function (x) {
	        var eObj = {
	            "code": x.code,
	            "message": x.message,
	            "path": x.path,
	            "line": x.line,
	            "column": x.column,
	            "position": x.start,
	            "range": x.range
	        };
	        if (x.isWarning === true) {
	            eObj.isWarning = true;
	        }
	        return eObj;
	    };
	    TCKDumper.prototype.dumpProperties = function (props, node) {
	        var _this = this;
	        var obj = {};
	        Object.keys(props).forEach(function (propName) {
	            if (!node[propName]) {
	                _this.missingProperties.addProperty(props[propName], node.kind());
	                return;
	            }
	            var property = props[propName];
	            var value = node[propName]();
	            if (value && propName == "structuredType" && typeof value === "object") {
	                value = null;
	                var highLevelNode = node.highLevel();
	                var a = highLevelNode.lowLevel();
	                var tdl = null;
	                a.children().forEach(function (x) {
	                    if (x.key() == "type" || x.key() == "schema") {
	                        var td = highLevelNode.definition().universe().type(universe.Universe10.TypeDeclaration.name);
	                        var hasType = highLevelNode.definition().universe().type(universe.Universe10.LibraryBase.name);
	                        var tNode = new hlImpl.ASTNodeImpl(x, highLevelNode, td, hasType.property(universe.Universe10.LibraryBase.properties.types.name));
	                        tNode.patchType(builder.doDescrimination(tNode));
	                        value = dump(tNode.wrapperNode());
	                        propName = x.key();
	                    }
	                });
	            }
	            if (!value && propName == "type") {
	                return;
	            }
	            if (!value && propName == "schema") {
	                return;
	            }
	            if (node.definition
	                && universeHelpers.isTypeDeclarationSibling(node.definition())
	                && universeHelpers.isTypeProperty(property)) {
	                //custom handling of not adding "type" property to the types having "schema" inside, even though the property actually exist,
	                // thus making "type" and "schema" arrays mutually exclusive in JSON.
	                var schemaValue = node[universe.Universe10.TypeDeclaration.properties.schema.name]();
	                if (schemaValue != null && (!Array.isArray(schemaValue) || schemaValue.length != 0)) {
	                    return;
	                }
	                var highLevelNode = node.highLevel();
	                var a = highLevelNode.lowLevel();
	                var tdl = null;
	                var hasSchema = false;
	                a.children().forEach(function (x) {
	                    if (x.key() == "schema") {
	                        hasSchema = true;
	                        return;
	                    }
	                });
	                if (hasSchema) {
	                    return;
	                }
	            }
	            if (Array.isArray(value)) {
	                var propertyValue = [];
	                for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
	                    var val = value_1[_i];
	                    var dumped = _this.dumpInternal(val);
	                    if (propName === 'examples' && _this.options && _this.options.dumpXMLRepresentationOfExamples && val.expandable && val.expandable._owner) {
	                        dumped.asXMLString = val.expandable.asXMLString();
	                    }
	                    propertyValue.push(dumped);
	                }
	                if (propertyValue.length == 0 && node instanceof core.BasicNodeImpl && !_this.isDefined(node, propName)) {
	                    return;
	                }
	                for (var _a = 0, _b = _this.nodePropertyTransformers; _a < _b.length; _a++) {
	                    var x = _b[_a];
	                    if (x.match(node, property)) {
	                        propertyValue = x.transform(propertyValue, node);
	                    }
	                }
	                obj[propName] = propertyValue;
	            }
	            else {
	                var val = _this.dumpInternal(value);
	                if (val == null && node instanceof core.BasicNodeImpl && !_this.isDefined(node, propName)) {
	                    return;
	                }
	                if (node instanceof core.BasicNodeImpl) {
	                    _this.nodePropertyTransformers.forEach(function (x) {
	                        if (x.match(node, property)) {
	                            val = x.transform(val, node);
	                        }
	                    });
	                }
	                obj[propName] = val;
	                if (propName === 'example' && _this.options && _this.options.dumpXMLRepresentationOfExamples && value.expandable && value.expandable._owner) {
	                    val.asXMLString = value.expandable.asXMLString();
	                }
	            }
	        });
	        return obj;
	    };
	    TCKDumper.prototype.serializeScalarsAnnotations = function (obj, node, props) {
	        var _this = this;
	        if (node["scalarsAnnotations"]) {
	            var val = {};
	            var accessor = node["scalarsAnnotations"]();
	            for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
	                var propName = _a[_i];
	                if (accessor[propName]) {
	                    var arr = accessor[propName]();
	                    if (arr.length > 0) {
	                        if (Array.isArray(arr[0])) {
	                            var arr1 = [];
	                            arr.forEach(function (x, i) {
	                                arr1.push(x.map(function (y) { return _this.dumpInternal(y); }));
	                            });
	                            if (arr1.filter(function (x) { return x.length > 0; }).length > 0) {
	                                val[propName] = arr1;
	                            }
	                        }
	                        else {
	                            val[propName] = arr.map(function (x) { return _this.dumpInternal(x); });
	                        }
	                    }
	                }
	            }
	            if (Object.keys(val).length > 0) {
	                obj["scalarsAnnotations"] = val;
	            }
	        }
	    };
	    TCKDumper.prototype.serializeMeta = function (obj, node) {
	        if (!this.options.serializeMetadata) {
	            return;
	        }
	        var meta = node.meta();
	        if (!meta.isDefault()) {
	            obj["__METADATA__"] = meta.toJSON();
	        }
	    };
	    TCKDumper.prototype.serializeTypeInstance = function (inst) {
	        var _this = this;
	        if (inst.isScalar()) {
	            return inst.value();
	        }
	        else if (inst.isArray()) {
	            return inst.items().map(function (x) { return _this.serializeTypeInstance(x); });
	        }
	        else {
	            var props = inst.properties();
	            if (props.length == 0) {
	                return null;
	            }
	            var obj = {};
	            props.forEach(function (x) { return obj[x.name()] = _this.serializeTypeInstanceProperty(x); });
	            return obj;
	        }
	    };
	    TCKDumper.prototype.serializeTypeInstanceProperty = function (prop) {
	        var _this = this;
	        if (prop.isArray()) {
	            var values = prop.values();
	            //if(values.length==0){
	            //    return null;
	            //}
	            var arr = [];
	            values.forEach(function (x) { return arr.push(_this.serializeTypeInstance(x)); });
	            return arr;
	        }
	        else {
	            return this.serializeTypeInstance(prop.value());
	        }
	    };
	    TCKDumper.prototype.isDefined = function (node, name) {
	        var hl = node.highLevel();
	        if (hl.elementsOfKind(name).length > 0) {
	            return true;
	        }
	        if (hl.attributes(name).length > 0) {
	            return true;
	        }
	        return false;
	    };
	    return TCKDumper;
	}());
	exports.TCKDumper = TCKDumper;
	var BasicObjectPropertyMatcher = (function () {
	    function BasicObjectPropertyMatcher(typeMatcher, propMatcher) {
	        this.typeMatcher = typeMatcher;
	        this.propMatcher = propMatcher;
	    }
	    BasicObjectPropertyMatcher.prototype.match = function (td, prop) {
	        return (td == null || this.typeMatcher(td)) && ((prop == null) || this.propMatcher(prop));
	    };
	    return BasicObjectPropertyMatcher;
	}());
	var CompositeObjectPropertyMatcher = (function () {
	    function CompositeObjectPropertyMatcher(matchers) {
	        this.matchers = matchers;
	    }
	    CompositeObjectPropertyMatcher.prototype.match = function (td, prop) {
	        var l = this.matchers.length;
	        for (var i = 0; i < l; i++) {
	            if (this.matchers[i].match(td, prop)) {
	                return true;
	            }
	        }
	        return false;
	    };
	    return CompositeObjectPropertyMatcher;
	}());
	var ArrayToMapTransformer = (function () {
	    function ArrayToMapTransformer(matcher, propName) {
	        this.matcher = matcher;
	        this.propName = propName;
	    }
	    ArrayToMapTransformer.prototype.match = function (node, prop) {
	        return this.matcher.match(node.definition(), prop);
	    };
	    ArrayToMapTransformer.prototype.transform = function (value) {
	        var _this = this;
	        if (Array.isArray(value) && value.length > 0 && value[0][this.propName]) {
	            var obj = {};
	            value.forEach(function (x) {
	                var key = x[_this.propName];
	                var previous = obj[key];
	                if (previous) {
	                    if (Array.isArray(previous)) {
	                        previous.push(x);
	                    }
	                    else {
	                        obj[key] = [previous, x];
	                    }
	                }
	                else {
	                    obj[key] = x;
	                }
	            });
	            return obj;
	        }
	        return value;
	    };
	    return ArrayToMapTransformer;
	}());
	var ArrayToMappingsArrayTransformer = (function () {
	    function ArrayToMappingsArrayTransformer(matcher, propName) {
	        this.matcher = matcher;
	        this.propName = propName;
	    }
	    ArrayToMappingsArrayTransformer.prototype.match = function (node, prop) {
	        return this.matcher.match(node.definition ? node.definition() : null, prop);
	    };
	    ArrayToMappingsArrayTransformer.prototype.transform = function (value) {
	        if (Array.isArray(value)) {
	            return value;
	        }
	        else {
	            var obj = {};
	            obj[value[this.propName]] = value;
	            return obj;
	        }
	    };
	    return ArrayToMappingsArrayTransformer;
	}());
	var ParametersTransformer = (function (_super) {
	    __extends(ParametersTransformer, _super);
	    function ParametersTransformer() {
	        _super.call(this, new CompositeObjectPropertyMatcher([
	            new BasicObjectPropertyMatcher(universeHelpers.isApiSibling, universeHelpers.isBaseUriParametersProperty),
	            new BasicObjectPropertyMatcher(universeHelpers.isResourceBaseSibling, universeHelpers.isUriParametersProperty),
	            new BasicObjectPropertyMatcher(universeHelpers.isResourceBaseSibling, universeHelpers.isQueryParametersProperty),
	            new BasicObjectPropertyMatcher(universeHelpers.isTraitType, universeHelpers.isQueryParametersProperty),
	            new BasicObjectPropertyMatcher(universeHelpers.isMethodType, universeHelpers.isQueryParametersProperty),
	            new BasicObjectPropertyMatcher(universeHelpers.isSecuritySchemePartType, universeHelpers.isQueryParametersProperty),
	            new BasicObjectPropertyMatcher(universeHelpers.isTraitType, universeHelpers.isHeadersProperty),
	            new BasicObjectPropertyMatcher(universeHelpers.isMethodType, universeHelpers.isHeadersProperty),
	            new BasicObjectPropertyMatcher(universeHelpers.isSecuritySchemePartType, universeHelpers.isHeadersProperty),
	            new BasicObjectPropertyMatcher(universeHelpers.isBodyLikeType, universeHelpers.isFormParametersProperty)
	        ]), "name");
	    }
	    return ParametersTransformer;
	}(ArrayToMapTransformer));
	var TypesTransformer = (function (_super) {
	    __extends(TypesTransformer, _super);
	    function TypesTransformer() {
	        _super.call(this, new CompositeObjectPropertyMatcher([
	            new BasicObjectPropertyMatcher(universeHelpers.isLibraryBaseSibling, universeHelpers.isTypesProperty),
	            new BasicObjectPropertyMatcher(function (x) { return universeHelpers.isLibraryBaseSibling(x) && universeHelpers.isRAML10Type(x); }, universeHelpers.isSchemasProperty)
	        ]), "name");
	    }
	    TypesTransformer.prototype.match = function (node, prop) {
	        return node.parent() != null && this.matcher.match(node.parent().definition(), prop);
	    };
	    return TypesTransformer;
	}(ArrayToMappingsArrayTransformer));
	var UsesTransformer = (function (_super) {
	    __extends(UsesTransformer, _super);
	    function UsesTransformer() {
	        _super.call(this, new CompositeObjectPropertyMatcher([
	            new BasicObjectPropertyMatcher(universeHelpers.isLibraryBaseSibling, universeHelpers.isUsesProperty)
	        ]), "name");
	    }
	    return UsesTransformer;
	}(ArrayToMapTransformer));
	var PropertiesTransformer = (function (_super) {
	    __extends(PropertiesTransformer, _super);
	    function PropertiesTransformer() {
	        _super.call(this, new CompositeObjectPropertyMatcher([
	            new BasicObjectPropertyMatcher(universeHelpers.isObjectTypeDeclarationSibling, universeHelpers.isPropertiesProperty)
	        ]), "name");
	    }
	    return PropertiesTransformer;
	}(ArrayToMapTransformer));
	var ResponsesTransformer = (function (_super) {
	    __extends(ResponsesTransformer, _super);
	    function ResponsesTransformer() {
	        _super.call(this, new CompositeObjectPropertyMatcher([
	            new BasicObjectPropertyMatcher(universeHelpers.isMethodBaseSibling, universeHelpers.isResponsesProperty)
	        ]), "code");
	    }
	    return ResponsesTransformer;
	}(ArrayToMapTransformer));
	var AnnotationsTransformer = (function (_super) {
	    __extends(AnnotationsTransformer, _super);
	    function AnnotationsTransformer() {
	        _super.call(this, new CompositeObjectPropertyMatcher([
	            new BasicObjectPropertyMatcher(function (x) { return true; }, universeHelpers.isAnnotationsProperty)
	        ]), "name");
	    }
	    return AnnotationsTransformer;
	}(ArrayToMapTransformer));
	var BodiesTransformer = (function (_super) {
	    __extends(BodiesTransformer, _super);
	    function BodiesTransformer() {
	        _super.call(this, new CompositeObjectPropertyMatcher([
	            new BasicObjectPropertyMatcher(universeHelpers.isResponseType, universeHelpers.isBodyProperty),
	            new BasicObjectPropertyMatcher(universeHelpers.isMethodBaseSibling, universeHelpers.isBodyProperty)
	        ]), "name");
	    }
	    return BodiesTransformer;
	}(ArrayToMapTransformer));
	var TraitsTransformer = (function (_super) {
	    __extends(TraitsTransformer, _super);
	    function TraitsTransformer() {
	        _super.call(this, new CompositeObjectPropertyMatcher([
	            new BasicObjectPropertyMatcher(universeHelpers.isTraitType, universeHelpers.isTraitsProperty)
	        ]), "name");
	    }
	    return TraitsTransformer;
	}(ArrayToMappingsArrayTransformer));
	var ResourceTypesTransformer = (function (_super) {
	    __extends(ResourceTypesTransformer, _super);
	    function ResourceTypesTransformer() {
	        _super.call(this, new CompositeObjectPropertyMatcher([
	            new BasicObjectPropertyMatcher(universeHelpers.isResourceTypeType, universeHelpers.isResourceTypesProperty)
	        ]), "name");
	    }
	    ResourceTypesTransformer.prototype.transform = function (value) {
	        var methodsPropertyName = universes.Universe10.ResourceBase.properties.methods.name;
	        if (Array.isArray(value)) {
	            return value;
	        }
	        else {
	            var methods = value[methodsPropertyName];
	            if (methods) {
	                methods.forEach(function (m) {
	                    var keys = Object.keys(m);
	                    if (keys.length > 0) {
	                        var methodName = keys[0];
	                        value[methodName] = m[methodName];
	                    }
	                });
	            }
	            delete value[methodsPropertyName];
	            return _super.prototype.transform.call(this, value);
	        }
	    };
	    return ResourceTypesTransformer;
	}(ArrayToMappingsArrayTransformer));
	var FacetsTransformer = (function (_super) {
	    __extends(FacetsTransformer, _super);
	    function FacetsTransformer() {
	        _super.call(this, new CompositeObjectPropertyMatcher([
	            new BasicObjectPropertyMatcher(universeHelpers.isTypeDeclarationSibling, universeHelpers.isFacetsProperty)
	        ]), "name");
	    }
	    return FacetsTransformer;
	}(ArrayToMapTransformer));
	var SecuritySchemesTransformer = (function (_super) {
	    __extends(SecuritySchemesTransformer, _super);
	    function SecuritySchemesTransformer() {
	        _super.call(this, null, "name");
	    }
	    SecuritySchemesTransformer.prototype.match = function (node, prop) {
	        return prop != null && universeHelpers.isSecuritySchemesProperty(prop);
	    };
	    return SecuritySchemesTransformer;
	}(ArrayToMappingsArrayTransformer));
	var AnnotationTypesTransformer = (function (_super) {
	    __extends(AnnotationTypesTransformer, _super);
	    function AnnotationTypesTransformer() {
	        _super.call(this, new CompositeObjectPropertyMatcher([
	            new BasicObjectPropertyMatcher(universeHelpers.isLibraryBaseSibling, universeHelpers.isAnnotationTypesProperty)
	        ]), "name");
	    }
	    AnnotationTypesTransformer.prototype.match = function (node, prop) {
	        return node.parent() != null && this.matcher.match(node.parent().definition(), prop);
	    };
	    return AnnotationTypesTransformer;
	}(ArrayToMappingsArrayTransformer));
	var ResourceTypeMethodsToMapTransformer = (function (_super) {
	    __extends(ResourceTypeMethodsToMapTransformer, _super);
	    function ResourceTypeMethodsToMapTransformer() {
	        _super.call(this, null, "method");
	    }
	    ResourceTypeMethodsToMapTransformer.prototype.match = function (node, prop) {
	        return node.parent() != null
	            && universeHelpers.isResourceTypeType(node.parent().definition())
	            && universeHelpers.isMethodsProperty(prop);
	    };
	    return ResourceTypeMethodsToMapTransformer;
	}(ArrayToMappingsArrayTransformer));
	var exampleNameProp = universe.Universe10.ExampleSpec.properties.name.name;
	var exampleContentProp = universe.Universe10.ExampleSpec.properties.value.name;
	var exampleStructuredContentProp = "structuredContent";
	var ExamplesTransformer = (function () {
	    function ExamplesTransformer() {
	    }
	    ExamplesTransformer.prototype.match = function (node, prop) {
	        return universeHelpers.isExampleSpecType(node.definition());
	    };
	    ExamplesTransformer.prototype.transform = function (value) {
	        var _this = this;
	        if (Array.isArray(value) && value.length > 0) {
	            if (value[0][exampleNameProp]) {
	                var obj = {};
	                value.forEach(function (x) { return obj[x[exampleNameProp]] = _this.getActualExample(x); });
	                return obj;
	            }
	            else {
	                var arr = value.map(function (x) { return _this.getActualExample(x); });
	                return arr;
	            }
	        }
	        else {
	            return value;
	        }
	    };
	    ExamplesTransformer.prototype.getActualExample = function (exampleSpecObj) {
	        if (exampleSpecObj[exampleStructuredContentProp]) {
	            return exampleSpecObj[exampleStructuredContentProp];
	        }
	        return exampleSpecObj[exampleContentProp];
	    };
	    return ExamplesTransformer;
	}());
	var TypeExampleTransformer = (function () {
	    function TypeExampleTransformer() {
	    }
	    TypeExampleTransformer.prototype.match = function (node, prop) {
	        return node.definition && universeHelpers.isTypeDeclarationSibling(node.definition());
	    };
	    TypeExampleTransformer.prototype.transform = function (value) {
	        var isArray = Array.isArray(value);
	        var arr = isArray ? value : [value];
	        arr.forEach(function (x) {
	            var structuredExample = x['example'];
	            if (structuredExample) {
	                x['example'] = structuredExample.structuredValue;
	                x['structuredExample'] = structuredExample;
	            }
	        });
	        return isArray ? arr : arr[0];
	    };
	    return TypeExampleTransformer;
	}());
	var SchemasTransformer = (function () {
	    function SchemasTransformer() {
	        this.matcher = new BasicObjectPropertyMatcher(function (x) { return universeHelpers.isApiType(x) && universeHelpers.isRAML08Type(x); }, universeHelpers.isSchemasProperty);
	    }
	    SchemasTransformer.prototype.match = function (node, prop) {
	        return node.parent() != null && this.matcher.match(node.parent().definition(), prop);
	    };
	    SchemasTransformer.prototype.transform = function (value) {
	        if (Array.isArray(value)) {
	            return value;
	        }
	        else {
	            var obj = {};
	            obj[value.key] = value.value;
	            return obj;
	        }
	    };
	    SchemasTransformer.prototype.getActualExample = function (exampleSpecObj) {
	        if (exampleSpecObj[exampleStructuredContentProp]) {
	            return exampleSpecObj[exampleStructuredContentProp];
	        }
	        return exampleSpecObj[exampleContentProp];
	    };
	    return SchemasTransformer;
	}());
	var ProtocolsToUpperCaseTransformer = (function () {
	    function ProtocolsToUpperCaseTransformer() {
	    }
	    ProtocolsToUpperCaseTransformer.prototype.match = function (node, prop) {
	        return prop != null && universeHelpers.isProtocolsProperty(prop);
	    };
	    ProtocolsToUpperCaseTransformer.prototype.transform = function (value) {
	        if (typeof (value) == 'string') {
	            return value.toUpperCase();
	        }
	        else if (Array.isArray(value)) {
	            return value.map(function (x) { return x.toUpperCase(); });
	        }
	        return value;
	    };
	    return ProtocolsToUpperCaseTransformer;
	}());
	var OneElementArrayTransformer = (function () {
	    function OneElementArrayTransformer() {
	        this.usecases = new CompositeObjectPropertyMatcher([
	            new BasicObjectPropertyMatcher(universeHelpers.isApiSibling, universeHelpers.isMediaTypeProperty)
	        ]);
	    }
	    OneElementArrayTransformer.prototype.match = function (node, prop) {
	        return this.usecases.match(node.definition(), prop);
	    };
	    OneElementArrayTransformer.prototype.transform = function (value) {
	        if (Array.isArray(value) && value.length == 1) {
	            return value[0];
	        }
	        return value;
	    };
	    return OneElementArrayTransformer;
	}());
	var ResourcesTransformer = (function () {
	    function ResourcesTransformer() {
	    }
	    ResourcesTransformer.prototype.match = function (node, prop) {
	        return prop != null && universeHelpers.isResourcesProperty(prop);
	    };
	    ResourcesTransformer.prototype.transform = function (value) {
	        if (Array.isArray(value)) {
	            return value;
	        }
	        var relUri = value[universes.Universe10.Resource.properties.relativeUri.name];
	        if (relUri) {
	            var segments = relUri.trim().split("/");
	            while (segments.length > 0 && segments[0].length == 0) {
	                segments.shift();
	            }
	            value["relativeUriPathSegments"] = segments;
	        }
	        return value;
	    };
	    return ResourcesTransformer;
	}());
	var SimpleNamesTransformer = (function () {
	    function SimpleNamesTransformer() {
	    }
	    SimpleNamesTransformer.prototype.match = function (node, prop) {
	        if (!node.parent() || !node.parent().highLevel().lowLevel()["libProcessed"]) {
	            return false;
	        }
	        return universeHelpers.isAnnotationTypesProperty(prop)
	            || universeHelpers.isTypesProperty(prop)
	            || universeHelpers.isResourceTypesProperty(prop)
	            || universeHelpers.isTraitsProperty(prop)
	            || universeHelpers.isSecuritySchemesProperty(prop);
	    };
	    SimpleNamesTransformer.prototype.transform = function (value, node) {
	        var llNode = node.highLevel().lowLevel();
	        var key = llNode.key();
	        var original = llNode;
	        while (original instanceof proxy.LowLevelProxyNode) {
	            original = original.originalNode();
	        }
	        var oKey = original.key();
	        var aVal = value[Object.keys(value)[0]];
	        aVal.name = oKey;
	        if (aVal.displayName == key) {
	            aVal.displayName = oKey;
	        }
	        return value;
	    };
	    return SimpleNamesTransformer;
	}());
	var TemplateParametrizedPropertiesTransformer = (function () {
	    function TemplateParametrizedPropertiesTransformer() {
	    }
	    TemplateParametrizedPropertiesTransformer.prototype.match = function (node, prop) {
	        var hlNode = node.highLevel();
	        if (!hlNode) {
	            return false;
	        }
	        var d = hlNode.definition();
	        if (!d) {
	            return false;
	        }
	        return universeHelpers.isResourceTypeType(d)
	            || universeHelpers.isTraitType(d)
	            || universeHelpers.isMethodType(d)
	            || universeHelpers.isTypeDeclarationSibling(d);
	    };
	    TemplateParametrizedPropertiesTransformer.prototype.transform = function (value) {
	        if (Array.isArray(value)) {
	            return value;
	        }
	        var propName = universe.Universe10.Trait.properties.parametrizedProperties.name;
	        var parametrizedProps = value[propName];
	        if (parametrizedProps) {
	            Object.keys(parametrizedProps).forEach(function (y) {
	                value[y] = parametrizedProps[y];
	            });
	            delete value[propName];
	        }
	        return value;
	    };
	    return TemplateParametrizedPropertiesTransformer;
	}());
	var ReferencesTransformer = (function () {
	    function ReferencesTransformer() {
	    }
	    ReferencesTransformer.prototype.match = function (node, prop) {
	        return prop != null && (universeHelpers.isSecuredByProperty(prop)
	            || universeHelpers.isIsProperty(prop)
	            || (node.parent() != null && (universeHelpers.isResourceType(node.parent().highLevel().definition())
	                || universeHelpers.isResourceTypeType(node.parent().highLevel().definition()))
	                && universeHelpers.isTypeProperty(prop)));
	    };
	    ReferencesTransformer.prototype.transform = function (value) {
	        if (!value) {
	            return null;
	        }
	        if (Array.isArray(value)) {
	            return value;
	        }
	        return this.toSimpleValue(value);
	    };
	    ReferencesTransformer.prototype.toSimpleValue = function (x) {
	        var name = x['name'];
	        var params = x['structuredValue'];
	        if (params) {
	            var obj = {};
	            obj[name] = params;
	            return obj;
	        }
	        else {
	            return name;
	        }
	    };
	    return ReferencesTransformer;
	}());
	var ArrayExpressionTransformer = (function () {
	    function ArrayExpressionTransformer() {
	    }
	    ArrayExpressionTransformer.prototype.match = function (node, prop) {
	        if (!(node instanceof core.BasicNodeImpl)) {
	            return false;
	        }
	        var hlNode = node.highLevel();
	        var definition = hlNode.definition();
	        if (!universeHelpers.isTypeDeclarationDescendant(definition)) {
	            return false;
	        }
	        var lType = hlNode.localType();
	        if (!lType || !lType.isArray()) {
	            return false;
	        }
	        return true;
	    };
	    ArrayExpressionTransformer.prototype.transform = function (value) {
	        var typePropName = universes.Universe10.TypeDeclaration.properties.type.name;
	        var itemsPropName = universes.Universe10.ArrayTypeDeclaration.properties.items.name;
	        var tValue = value[typePropName];
	        if (tValue.length == 1 && util.stringEndsWith(tValue[0], "[]")) {
	            value[itemsPropName] = tValue[0].substring(0, tValue[0].length - 2);
	            tValue[0] = "array";
	        }
	        return value;
	    };
	    return ArrayExpressionTransformer;
	}());
	var PropertiesData = (function () {
	    function PropertiesData() {
	        this.map = {};
	    }
	    PropertiesData.prototype.addProperty = function (prop, wrapperKind) {
	        var data = this.map[wrapperKind];
	        if (!data) {
	            data = new TypePropertiesData(wrapperKind);
	            this.map[wrapperKind] = data;
	        }
	        data.addProperty(prop);
	    };
	    PropertiesData.prototype.print = function () {
	        var _this = this;
	        return Object.keys(this.map).map(function (x) { return _this.map[x].print(); }).join('\n') + "\n";
	    };
	    return PropertiesData;
	}());
	var TypePropertiesData = (function () {
	    function TypePropertiesData(typeName) {
	        this.typeName = typeName;
	        this.map = {};
	    }
	    TypePropertiesData.prototype.addProperty = function (prop) {
	        var name = prop.domain().nameId();
	        var data = this.map[name];
	        if (!data) {
	            data = new TypePropertiesData2(name);
	            this.map[name] = data;
	        }
	        data.addProperty(prop);
	    };
	    TypePropertiesData.prototype.print = function () {
	        var _this = this;
	        return this.typeName + ':\n' + Object.keys(this.map).map(function (x) { return '    ' + _this.map[x].print(); }).join('\n');
	    };
	    return TypePropertiesData;
	}());
	var TypePropertiesData2 = (function () {
	    function TypePropertiesData2(typeName) {
	        this.typeName = typeName;
	        this.map = {};
	    }
	    TypePropertiesData2.prototype.addProperty = function (prop) {
	        var name = prop.nameId();
	        this.map[name] = prop;
	    };
	    TypePropertiesData2.prototype.print = function () {
	        return this.typeName + ': ' + Object.keys(this.map).sort().join(', ');
	    };
	    return TypePropertiesData2;
	}());
	//# sourceMappingURL=TCKDumper.js.map

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/* global define */

	(function (root, pluralize) {
	  /* istanbul ignore else */
	  if (true) {
	    // Node.
	    module.exports = pluralize();
	  } else if (typeof define === 'function' && define.amd) {
	    // AMD, registers as an anonymous module.
	    define(function () {
	      return pluralize();
	    });
	  } else {
	    // Browser global.
	    root.pluralize = pluralize();
	  }
	})(this, function () {
	  // Rule storage - pluralize and singularize need to be run sequentially,
	  // while other rules can be optimized using an object for instant lookups.
	  var pluralRules = [];
	  var singularRules = [];
	  var uncountables = {};
	  var irregularPlurals = {};
	  var irregularSingles = {};

	  /**
	   * Title case a string.
	   *
	   * @param  {string} str
	   * @return {string}
	   */
	  function toTitleCase (str) {
	    return str.charAt(0).toUpperCase() + str.substr(1).toLowerCase();
	  }

	  /**
	   * Sanitize a pluralization rule to a usable regular expression.
	   *
	   * @param  {(RegExp|string)} rule
	   * @return {RegExp}
	   */
	  function sanitizeRule (rule) {
	    if (typeof rule === 'string') {
	      return new RegExp('^' + rule + '$', 'i');
	    }

	    return rule;
	  }

	  /**
	   * Pass in a word token to produce a function that can replicate the case on
	   * another word.
	   *
	   * @param  {string}   word
	   * @param  {string}   token
	   * @return {Function}
	   */
	  function restoreCase (word, token) {
	    // Upper cased words. E.g. "HELLO".
	    if (word === word.toUpperCase()) {
	      return token.toUpperCase();
	    }

	    // Title cased words. E.g. "Title".
	    if (word[0] === word[0].toUpperCase()) {
	      return toTitleCase(token);
	    }

	    // Lower cased words. E.g. "test".
	    return token.toLowerCase();
	  }

	  /**
	   * Interpolate a regexp string.
	   *
	   * @param  {string} str
	   * @param  {Array}  args
	   * @return {string}
	   */
	  function interpolate (str, args) {
	    return str.replace(/\$(\d{1,2})/g, function (match, index) {
	      return args[index] || '';
	    });
	  }

	  /**
	   * Sanitize a word by passing in the word and sanitization rules.
	   *
	   * @param  {String}   token
	   * @param  {String}   word
	   * @param  {Array}    collection
	   * @return {String}
	   */
	  function sanitizeWord (token, word, collection) {
	    // Empty string or doesn't need fixing.
	    if (!token.length || uncountables.hasOwnProperty(token)) {
	      return word;
	    }

	    var len = collection.length;

	    // Iterate over the sanitization rules and use the first one to match.
	    while (len--) {
	      var rule = collection[len];

	      // If the rule passes, return the replacement.
	      if (rule[0].test(word)) {
	        return word.replace(rule[0], function (match, index, word) {
	          var result = interpolate(rule[1], arguments);

	          if (match === '') {
	            return restoreCase(word[index - 1], result);
	          }

	          return restoreCase(match, result);
	        });
	      }
	    }

	    return word;
	  }

	  /**
	   * Replace a word with the updated word.
	   *
	   * @param  {Object}   replaceMap
	   * @param  {Object}   keepMap
	   * @param  {Array}    rules
	   * @return {Function}
	   */
	  function replaceWord (replaceMap, keepMap, rules) {
	    return function (word) {
	      // Get the correct token and case restoration functions.
	      var token = word.toLowerCase();

	      // Check against the keep object map.
	      if (keepMap.hasOwnProperty(token)) {
	        return restoreCase(word, token);
	      }

	      // Check against the replacement map for a direct word replacement.
	      if (replaceMap.hasOwnProperty(token)) {
	        return restoreCase(word, replaceMap[token]);
	      }

	      // Run all the rules against the word.
	      return sanitizeWord(token, word, rules);
	    };
	  }

	  /**
	   * Pluralize or singularize a word based on the passed in count.
	   *
	   * @param  {String}  word
	   * @param  {Number}  count
	   * @param  {Boolean} inclusive
	   * @return {String}
	   */
	  function pluralize (word, count, inclusive) {
	    var pluralized = count === 1
	      ? pluralize.singular(word) : pluralize.plural(word);

	    return (inclusive ? count + ' ' : '') + pluralized;
	  }

	  /**
	   * Pluralize a word.
	   *
	   * @type {Function}
	   */
	  pluralize.plural = replaceWord(
	    irregularSingles, irregularPlurals, pluralRules
	  );

	  /**
	   * Singularize a word.
	   *
	   * @type {Function}
	   */
	  pluralize.singular = replaceWord(
	    irregularPlurals, irregularSingles, singularRules
	  );

	  /**
	   * Add a pluralization rule to the collection.
	   *
	   * @param {(string|RegExp)} rule
	   * @param {string}          replacement
	   */
	  pluralize.addPluralRule = function (rule, replacement) {
	    pluralRules.push([sanitizeRule(rule), replacement]);
	  };

	  /**
	   * Add a singularization rule to the collection.
	   *
	   * @param {(string|RegExp)} rule
	   * @param {string}          replacement
	   */
	  pluralize.addSingularRule = function (rule, replacement) {
	    singularRules.push([sanitizeRule(rule), replacement]);
	  };

	  /**
	   * Add an uncountable word rule.
	   *
	   * @param {(string|RegExp)} word
	   */
	  pluralize.addUncountableRule = function (word) {
	    if (typeof word === 'string') {
	      uncountables[word.toLowerCase()] = true;
	      return;
	    }

	    // Set singular and plural references for the word.
	    pluralize.addPluralRule(word, '$0');
	    pluralize.addSingularRule(word, '$0');
	  };

	  /**
	   * Add an irregular word definition.
	   *
	   * @param {String} single
	   * @param {String} plural
	   */
	  pluralize.addIrregularRule = function (single, plural) {
	    plural = plural.toLowerCase();
	    single = single.toLowerCase();

	    irregularSingles[single] = plural;
	    irregularPlurals[plural] = single;
	  };

	  /**
	   * Irregular rules.
	   */
	  [
	    // Pronouns.
	    ['I', 'we'],
	    ['me', 'us'],
	    ['he', 'they'],
	    ['she', 'they'],
	    ['them', 'them'],
	    ['myself', 'ourselves'],
	    ['yourself', 'yourselves'],
	    ['itself', 'themselves'],
	    ['herself', 'themselves'],
	    ['himself', 'themselves'],
	    ['themself', 'themselves'],
	    ['is', 'are'],
	    ['this', 'these'],
	    ['that', 'those'],
	    // Words ending in with a consonant and `o`.
	    ['echo', 'echoes'],
	    ['dingo', 'dingoes'],
	    ['volcano', 'volcanoes'],
	    ['tornado', 'tornadoes'],
	    ['torpedo', 'torpedoes'],
	    // Ends with `us`.
	    ['genus', 'genera'],
	    ['viscus', 'viscera'],
	    // Ends with `ma`.
	    ['stigma', 'stigmata'],
	    ['stoma', 'stomata'],
	    ['dogma', 'dogmata'],
	    ['lemma', 'lemmata'],
	    ['schema', 'schemata'],
	    ['anathema', 'anathemata'],
	    // Other irregular rules.
	    ['ox', 'oxen'],
	    ['axe', 'axes'],
	    ['die', 'dice'],
	    ['yes', 'yeses'],
	    ['foot', 'feet'],
	    ['eave', 'eaves'],
	    ['goose', 'geese'],
	    ['tooth', 'teeth'],
	    ['quiz', 'quizzes'],
	    ['human', 'humans'],
	    ['proof', 'proofs'],
	    ['carve', 'carves'],
	    ['valve', 'valves'],
	    ['thief', 'thieves'],
	    ['genie', 'genies'],
	    ['groove', 'grooves'],
	    ['pickaxe', 'pickaxes'],
	    ['whiskey', 'whiskies']
	  ].forEach(function (rule) {
	    return pluralize.addIrregularRule(rule[0], rule[1]);
	  });

	  /**
	   * Pluralization rules.
	   */
	  [
	    [/s?$/i, 's'],
	    [/([^aeiou]ese)$/i, '$1'],
	    [/(ax|test)is$/i, '$1es'],
	    [/(alias|[^aou]us|tlas|gas|ris)$/i, '$1es'],
	    [/(e[mn]u)s?$/i, '$1s'],
	    [/([^l]ias|[aeiou]las|[emjzr]as|[iu]am)$/i, '$1'],
	    [/(alumn|syllab|octop|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, '$1i'],
	    [/(alumn|alg|vertebr)(?:a|ae)$/i, '$1ae'],
	    [/(seraph|cherub)(?:im)?$/i, '$1im'],
	    [/(her|at|gr)o$/i, '$1oes'],
	    [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, '$1a'],
	    [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, '$1a'],
	    [/sis$/i, 'ses'],
	    [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, '$1$2ves'],
	    [/([^aeiouy]|qu)y$/i, '$1ies'],
	    [/([^ch][ieo][ln])ey$/i, '$1ies'],
	    [/(x|ch|ss|sh|zz)$/i, '$1es'],
	    [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, '$1ices'],
	    [/(m|l)(?:ice|ouse)$/i, '$1ice'],
	    [/(pe)(?:rson|ople)$/i, '$1ople'],
	    [/(child)(?:ren)?$/i, '$1ren'],
	    [/eaux$/i, '$0'],
	    [/m[ae]n$/i, 'men'],
	    ['thou', 'you']
	  ].forEach(function (rule) {
	    return pluralize.addPluralRule(rule[0], rule[1]);
	  });

	  /**
	   * Singularization rules.
	   */
	  [
	    [/s$/i, ''],
	    [/(ss)$/i, '$1'],
	    [/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)(?:sis|ses)$/i, '$1sis'],
	    [/(^analy)(?:sis|ses)$/i, '$1sis'],
	    [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, '$1fe'],
	    [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, '$1f'],
	    [/([^aeiouy]|qu)ies$/i, '$1y'],
	    [/(^[pl]|zomb|^(?:neck)?t|[aeo][lt]|cut)ies$/i, '$1ie'],
	    [/(\b(?:mon|smil))ies$/i, '$1ey'],
	    [/(m|l)ice$/i, '$1ouse'],
	    [/(seraph|cherub)im$/i, '$1'],
	    [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|tlas|gas|(?:her|at|gr)o|ris)(?:es)?$/i, '$1'],
	    [/(e[mn]u)s?$/i, '$1'],
	    [/(movie|twelve)s$/i, '$1'],
	    [/(cris|test|diagnos)(?:is|es)$/i, '$1is'],
	    [/(alumn|syllab|octop|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, '$1us'],
	    [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, '$1um'],
	    [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, '$1on'],
	    [/(alumn|alg|vertebr)ae$/i, '$1a'],
	    [/(cod|mur|sil|vert|ind)ices$/i, '$1ex'],
	    [/(matr|append)ices$/i, '$1ix'],
	    [/(pe)(rson|ople)$/i, '$1rson'],
	    [/(child)ren$/i, '$1'],
	    [/(eau)x?$/i, '$1'],
	    [/men$/i, 'man']
	  ].forEach(function (rule) {
	    return pluralize.addSingularRule(rule[0], rule[1]);
	  });

	  /**
	   * Uncountable rules.
	   */
	  [
	    // Singular words with no plurals.
	    'advice',
	    'agenda',
	    'bison',
	    'bream',
	    'buffalo',
	    'carp',
	    'chassis',
	    'cod',
	    'cooperation',
	    'corps',
	    'digestion',
	    'debris',
	    'diabetes',
	    'energy',
	    'equipment',
	    'elk',
	    'excretion',
	    'expertise',
	    'flounder',
	    'gallows',
	    'garbage',
	    'graffiti',
	    'headquarters',
	    'health',
	    'herpes',
	    'highjinks',
	    'homework',
	    'information',
	    'jeans',
	    'justice',
	    'kudos',
	    'labour',
	    'machinery',
	    'mackerel',
	    'media',
	    'mews',
	    'moose',
	    'news',
	    'pike',
	    'plankton',
	    'pliers',
	    'pollution',
	    'premises',
	    'rain',
	    'rice',
	    'salmon',
	    'scissors',
	    'series',
	    'sewage',
	    'shambles',
	    'shrimp',
	    'species',
	    'staff',
	    'swine',
	    'trout',
	    'tuna',
	    'whiting',
	    'wildebeest',
	    'wildlife',
	    'you',
	    // Regexes.
	    /pox$/i, // "chickpox", "smallpox"
	    /ois$/i,
	    /deer$/i, // "deer", "reindeer"
	    /fish$/i, // "fish", "blowfish", "angelfish"
	    /sheep$/i,
	    /measles$/i,
	    /[^aeiou]ese$/i // "chinese", "japanese"
	  ].forEach(pluralize.addUncountableRule);

	  return pluralize;
	});


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	exports.dot = exports.dotCase = __webpack_require__(117)
	exports.swap = exports.swapCase = __webpack_require__(116)
	exports.path = exports.pathCase = __webpack_require__(119)
	exports.upper = exports.upperCase = __webpack_require__(121)
	exports.lower = exports.lowerCase = __webpack_require__(118)
	exports.camel = exports.camelCase = __webpack_require__(120)
	exports.snake = exports.snakeCase = __webpack_require__(124)
	exports.title = exports.titleCase = __webpack_require__(123)
	exports.param = exports.paramCase = __webpack_require__(122)
	exports.pascal = exports.pascalCase = __webpack_require__(125)
	exports.constant = exports.constantCase = __webpack_require__(126)
	exports.sentence = exports.sentenceCase = __webpack_require__(129)
	exports.isUpper = exports.isUpperCase = __webpack_require__(127)
	exports.isLower = exports.isLowerCase = __webpack_require__(128)
	exports.ucFirst = exports.upperCaseFirst = __webpack_require__(131)
	exports.lcFirst = exports.lowerCaseFirst = __webpack_require__(130)


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var loader = __webpack_require__(83);
	var dumper = __webpack_require__(84);
	var YAMLException = (function () {
	    function YAMLException(reason, mark) {
	        if (mark === void 0) { mark = null; }
	        this.name = 'YAMLException';
	        this.reason = reason;
	        this.mark = mark;
	        this.message = this.toString(false);
	    }
	    YAMLException.prototype.toString = function (compact) {
	        if (compact === void 0) { compact = false; }
	        var result;
	        result = 'JS-YAML: ' + (this.reason || '(unknown reason)');
	        if (!compact && this.mark) {
	            result += ' ' + this.mark.toString();
	        }
	        return result;
	    };
	    return YAMLException;
	}());
	exports.YAMLException = YAMLException;
	(function (Kind) {
	    Kind[Kind["SCALAR"] = 0] = "SCALAR";
	    Kind[Kind["MAPPING"] = 1] = "MAPPING";
	    Kind[Kind["MAP"] = 2] = "MAP";
	    Kind[Kind["SEQ"] = 3] = "SEQ";
	    Kind[Kind["ANCHOR_REF"] = 4] = "ANCHOR_REF";
	    Kind[Kind["INCLUDE_REF"] = 5] = "INCLUDE_REF";
	})(exports.Kind || (exports.Kind = {}));
	var Kind = exports.Kind;
	function newMapping(key, value) {
	    var end = (value ? value.endPosition : key.endPosition + 1);
	    var node = {
	        key: key,
	        value: value,
	        startPosition: key.startPosition,
	        endPosition: end,
	        kind: Kind.MAPPING,
	        parent: null,
	        errors: []
	    };
	    return node;
	}
	exports.newMapping = newMapping;
	function newAnchorRef(key, start, end, value) {
	    return {
	        errors: [],
	        referencesAnchor: key,
	        value: value,
	        startPosition: start,
	        endPosition: end,
	        kind: Kind.ANCHOR_REF,
	        parent: null
	    };
	}
	exports.newAnchorRef = newAnchorRef;
	function newScalar(v) {
	    if (v === void 0) { v = ""; }
	    return {
	        errors: [],
	        startPosition: -1,
	        endPosition: -1,
	        value: v,
	        kind: Kind.SCALAR,
	        parent: null,
	        doubleQuoted: false
	    };
	}
	exports.newScalar = newScalar;
	function newItems() {
	    return {
	        errors: [],
	        startPosition: -1,
	        endPosition: -1,
	        items: [],
	        kind: Kind.SEQ,
	        parent: null
	    };
	}
	exports.newItems = newItems;
	function newSeq() {
	    return newItems();
	}
	exports.newSeq = newSeq;
	function newMap(mappings) {
	    return {
	        errors: [],
	        startPosition: -1,
	        endPosition: -1,
	        mappings: mappings ? mappings : [],
	        kind: Kind.MAP,
	        parent: null
	    };
	}
	exports.newMap = newMap;
	function deprecated(name) {
	    return function () {
	        throw new Error('Function ' + name + ' is deprecated and cannot be used.');
	    };
	}
	exports.load = loader.load;
	exports.loadAll = loader.loadAll;
	exports.safeLoad = loader.safeLoad;
	exports.dump = dumper.dump;
	exports.safeDump = dumper.safeDump;
	//# sourceMappingURL=index.js.map

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// **Github:** https://github.com/zensh/lrucache
	//
	// **License:** MIT

	/* global module, define */
	;(function (root, factory) {
	  'use strict';

	  if (typeof module === 'object' && typeof module.exports === 'object') {
	    module.exports = factory();
	  } else if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else {
	    root.LRUCache = factory();
	  }
	}(typeof window === 'object' ? window : this, function () {
	  'use strict';

	  function CacheState(capacity) {
	    this.capacity = capacity > 0 ? +capacity : Number.MAX_VALUE;
	    this.data = Object.create ? Object.create(null) : {};
	    this.hash = Object.create ? Object.create(null) : {};
	    this.linkedList = {
	      length: 0,
	      head: null,
	      end: null
	    };
	  }

	  function LRUCache(capacity) {
	    if (!(this instanceof LRUCache)) return new LRUCache(capacity);
	    this._LRUCacheState = new CacheState(capacity);
	  }

	  var proto = LRUCache.prototype;

	  proto.get = function (key) {
	    var state = this._LRUCacheState;
	    var lruEntry = state.hash[key];
	    if (!lruEntry) return;
	    refresh(state.linkedList, lruEntry);
	    return state.data[key];
	  };

	  proto.set = function (key, value) {
	    var state = this._LRUCacheState;
	    var lruEntry = state.hash[key];
	    if (value === undefined) return this;
	    if (!lruEntry) {
	      state.hash[key] = {key: key};
	      state.linkedList.length += 1;
	      lruEntry = state.hash[key];
	    }
	    refresh(state.linkedList, lruEntry);
	    state.data[key] = value;
	    if (state.linkedList.length > state.capacity) this.remove(state.linkedList.end.key);
	    return this;
	  };

	  proto.update = function (key, parseFn) {
	    var state = this._LRUCacheState;
	    if (this.has(key)) {
	      var data = this.get(key);
	      this.set(key, parseFn(data));
	    }
	    return this;
	  };

	  proto.remove = function (key) {
	    var state = this._LRUCacheState;
	    var lruEntry = state.hash[key];
	    if (!lruEntry) return this;
	    if (lruEntry === state.linkedList.head) state.linkedList.head = lruEntry.p;
	    if (lruEntry === state.linkedList.end) state.linkedList.end = lruEntry.n;
	    link(lruEntry.n, lruEntry.p);
	    delete state.hash[key];
	    delete state.data[key];
	    state.linkedList.length -= 1;
	    return this;
	  };

	  proto.removeAll = function () {
	    this._LRUCacheState = new CacheState(this._LRUCacheState.capacity);
	    return this;
	  };

	  proto.info = function () {
	    var state = this._LRUCacheState;
	    return {
	      capacity: state.capacity,
	      length: state.linkedList.length
	    };
	  };

	  proto.keys = function () {
	    var state = this._LRUCacheState;
	    var keys = [], lruEntry = state.linkedList.head;
	    while (lruEntry) {
	      keys.push(lruEntry.key);
	      lruEntry = lruEntry.p;
	    }
	    return keys;
	  };

	  proto.has = function (key) {
	    return !!this._LRUCacheState.hash[key];
	  };

	  proto.staleKey = function () {
	    return this._LRUCacheState.linkedList.end && this._LRUCacheState.linkedList.end.key;
	  };

	  proto.popStale = function () {
	    var staleKey = this.staleKey();
	    if (!staleKey) return null;
	    var stale = [staleKey, this._LRUCacheState.data[staleKey]];
	    this.remove(staleKey);
	    return stale;
	  };

	  // getputkeyhead
	  function refresh(linkedList, entry) {
	    if (entry === linkedList.head) return;
	    if (!linkedList.end) {
	      linkedList.end = entry;
	    } else if (linkedList.end === entry) {
	      linkedList.end = entry.n;
	    }

	    link(entry.n, entry.p);
	    link(entry, linkedList.head);
	    linkedList.head = entry;
	    linkedList.head.n = null;
	  }

	  // 
	  function link(nextEntry, prevEntry) {
	    if (nextEntry === prevEntry) return;
	    if (nextEntry) nextEntry.p = prevEntry;
	    if (prevEntry) prevEntry.n = nextEntry;
	  }

	  LRUCache.NAME = 'LRUCache';
	  LRUCache.VERSION = 'v0.2.0';
	  return LRUCache;
	}));


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(115);
	var Response = __webpack_require__(64);
	var handleQs = __webpack_require__(90);

	module.exports = doRequest;
	function doRequest(method, url, options, callback) {
	  var result = new Promise(function (resolve, reject) {
	    var xhr = new window.XMLHttpRequest();

	    // check types of arguments

	    if (typeof method !== 'string') {
	      throw new TypeError('The method must be a string.');
	    }
	    if (typeof url !== 'string') {
	      throw new TypeError('The URL/path must be a string.');
	    }
	    if (typeof options === 'function') {
	      callback = options;
	      options = {};
	    }
	    if (options === null || options === undefined) {
	      options = {};
	    }
	    if (typeof options !== 'object') {
	      throw new TypeError('Options must be an object (or null).');
	    }
	    if (typeof callback !== 'function') {
	      callback = undefined;
	    }

	    method = method.toUpperCase();
	    options.headers = options.headers || {};


	    function attempt(n) {
	      doRequest(method, url, {
	        qs: options.qs,
	        headers: options.headers,
	        timeout: options.timeout
	      }).nodeify(function (err, res) {
	        var retry = err || res.statusCode >= 400;
	        if (typeof options.retry === 'function') {
	          retry = options.retry(err, res, n + 1);
	        }
	        if (n >= (options.maxRetries | 5)) {
	          retry = false;
	        }
	        if (retry) {
	          var delay = options.retryDelay;
	          if (typeof options.retryDelay === 'function') {
	            delay = options.retryDelay(err, res, n + 1);
	          }
	          delay = delay || 200;
	          setTimeout(function () {
	            attempt(n + 1);
	          }, delay);
	        } else {
	          if (err) reject(err);
	          else resolve(res);
	        }
	      });
	    }
	    if (options.retry && method === 'GET') {
	      return attempt(0);
	    }

	    // handle cross domain

	    var match;
	    var crossDomain = !!((match = /^([\w-]+:)?\/\/([^\/]+)/.exec(url)) && (match[2] != window.location.host));
	    if (!crossDomain) options.headers['X-Requested-With'] = 'XMLHttpRequest';

	    // handle query string
	    if (options.qs) {
	      url = handleQs(url, options.qs);
	    }

	    // handle json body
	    if (options.json) {
	      options.body = JSON.stringify(options.json);
	      options.headers['Content-Type'] = 'application/json';
	    }

	    if (options.timeout) {
	      xhr.timeout = options.timeout;
	      var start = Date.now();
	      xhr.ontimeout = function () {
	        var duration = Date.now() - start;
	        var err = new Error('Request timed out after ' + duration + 'ms');
	        err.timeout = true;
	        err.duration = duration;
	        reject(err);
	      };
	    }
	    xhr.onreadystatechange = function () {
	      if (xhr.readyState === 4) {
	        var headers = {};
	        xhr.getAllResponseHeaders().split('\r\n').forEach(function (header) {
	          var h = header.split(':');
	          if (h.length > 1) {
	            headers[h[0].toLowerCase()] = h.slice(1).join(':').trim();
	          }
	        });
	        var res = new Response(xhr.status, headers, xhr.responseText);
	        res.url = url;
	        resolve(res);
	      }
	    };

	    // method, url, async
	    xhr.open(method, url, true);

	    for (var name in options.headers) {
	      xhr.setRequestHeader(name, options.headers[name]);
	    }

	    // avoid sending empty string (#319)
	    xhr.send(options.body ? options.body : null);
	  });
	  result.getBody = function () {
	    return result.then(function (res) { return res.getBody(); });
	  };
	  return result.nodeify(callback);
	}


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	function DOMParser(options){
		this.options = options ||{locator:{}};
		
	}
	DOMParser.prototype.parseFromString = function(source,mimeType){	
		var options = this.options;
		var sax =  new XMLReader();
		var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
		var errorHandler = options.errorHandler;
		var locator = options.locator;
		var defaultNSMap = options.xmlns||{};
		var entityMap = {'lt':'<','gt':'>','amp':'&','quot':'"','apos':"'"}
		if(locator){
			domBuilder.setDocumentLocator(locator)
		}
		
		sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
		sax.domBuilder = options.domBuilder || domBuilder;
		if(/\/x?html?$/.test(mimeType)){
			entityMap.nbsp = '\xa0';
			entityMap.copy = '\xa9';
			defaultNSMap['']= 'http://www.w3.org/1999/xhtml';
		}
		defaultNSMap.xml = defaultNSMap.xml || 'http://www.w3.org/XML/1998/namespace';
		if(source){
			sax.parse(source,defaultNSMap,entityMap);
		}else{
			sax.errorHandler.error("invalid document source");
		}
		return domBuilder.document;
	}
	function buildErrorHandler(errorImpl,domBuilder,locator){
		if(!errorImpl){
			if(domBuilder instanceof DOMHandler){
				return domBuilder;
			}
			errorImpl = domBuilder ;
		}
		var errorHandler = {}
		var isCallback = errorImpl instanceof Function;
		locator = locator||{}
		function build(key){
			var fn = errorImpl[key];
			if(!fn && isCallback){
				fn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;
			}
			errorHandler[key] = fn && function(msg){
				fn('[xmldom '+key+']\t'+msg+_locator(locator));
			}||function(){};
		}
		build('warning');
		build('error');
		build('fatalError');
		return errorHandler;
	}

	//console.log('#\n\n\n\n\n\n\n####')
	/**
	 * +ContentHandler+ErrorHandler
	 * +LexicalHandler+EntityResolver2
	 * -DeclHandler-DTDHandler 
	 * 
	 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
	 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
	 */
	function DOMHandler() {
	    this.cdata = false;
	}
	function position(locator,node){
		node.lineNumber = locator.lineNumber;
		node.columnNumber = locator.columnNumber;
	}
	/**
	 * @see org.xml.sax.ContentHandler#startDocument
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
	 */ 
	DOMHandler.prototype = {
		startDocument : function() {
	    	this.document = new DOMImplementation().createDocument(null, null, null);
	    	if (this.locator) {
	        	this.document.documentURI = this.locator.systemId;
	    	}
		},
		startElement:function(namespaceURI, localName, qName, attrs) {
			var doc = this.document;
		    var el = doc.createElementNS(namespaceURI, qName||localName);
		    var len = attrs.length;
		    appendElement(this, el);
		    this.currentElement = el;
		    
			this.locator && position(this.locator,el)
		    for (var i = 0 ; i < len; i++) {
		        var namespaceURI = attrs.getURI(i);
		        var value = attrs.getValue(i);
		        var qName = attrs.getQName(i);
				var attr = doc.createAttributeNS(namespaceURI, qName);
				if( attr.getOffset){
					position(attr.getOffset(1),attr)
				}
				attr.value = attr.nodeValue = value;
				el.setAttributeNode(attr)
		    }
		},
		endElement:function(namespaceURI, localName, qName) {
			var current = this.currentElement
		    var tagName = current.tagName;
		    this.currentElement = current.parentNode;
		},
		startPrefixMapping:function(prefix, uri) {
		},
		endPrefixMapping:function(prefix) {
		},
		processingInstruction:function(target, data) {
		    var ins = this.document.createProcessingInstruction(target, data);
		    this.locator && position(this.locator,ins)
		    appendElement(this, ins);
		},
		ignorableWhitespace:function(ch, start, length) {
		},
		characters:function(chars, start, length) {
			chars = _toString.apply(this,arguments)
			//console.log(chars)
			if(this.currentElement && chars){
				if (this.cdata) {
					var charNode = this.document.createCDATASection(chars);
					this.currentElement.appendChild(charNode);
				} else {
					var charNode = this.document.createTextNode(chars);
					this.currentElement.appendChild(charNode);
				}
				this.locator && position(this.locator,charNode)
			}
		},
		skippedEntity:function(name) {
		},
		endDocument:function() {
			this.document.normalize();
		},
		setDocumentLocator:function (locator) {
		    if(this.locator = locator){// && !('lineNumber' in locator)){
		    	locator.lineNumber = 0;
		    }
		},
		//LexicalHandler
		comment:function(chars, start, length) {
			chars = _toString.apply(this,arguments)
		    var comm = this.document.createComment(chars);
		    this.locator && position(this.locator,comm)
		    appendElement(this, comm);
		},
		
		startCDATA:function() {
		    //used in characters() methods
		    this.cdata = true;
		},
		endCDATA:function() {
		    this.cdata = false;
		},
		
		startDTD:function(name, publicId, systemId) {
			var impl = this.document.implementation;
		    if (impl && impl.createDocumentType) {
		        var dt = impl.createDocumentType(name, publicId, systemId);
		        this.locator && position(this.locator,dt)
		        appendElement(this, dt);
		    }
		},
		/**
		 * @see org.xml.sax.ErrorHandler
		 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
		 */
		warning:function(error) {
			console.warn('[xmldom warning]\t'+error,_locator(this.locator));
		},
		error:function(error) {
			console.error('[xmldom error]\t'+error,_locator(this.locator));
		},
		fatalError:function(error) {
			console.error('[xmldom fatalError]\t'+error,_locator(this.locator));
		    throw error;
		}
	}
	function _locator(l){
		if(l){
			return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
		}
	}
	function _toString(chars,start,length){
		if(typeof chars == 'string'){
			return chars.substr(start,length)
		}else{//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
			if(chars.length >= start+length || start){
				return new java.lang.String(chars,start,length)+'';
			}
			return chars;
		}
	}

	/*
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
	 * used method of org.xml.sax.ext.LexicalHandler:
	 *  #comment(chars, start, length)
	 *  #startCDATA()
	 *  #endCDATA()
	 *  #startDTD(name, publicId, systemId)
	 *
	 *
	 * IGNORED method of org.xml.sax.ext.LexicalHandler:
	 *  #endDTD()
	 *  #startEntity(name)
	 *  #endEntity(name)
	 *
	 *
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
	 * IGNORED method of org.xml.sax.ext.DeclHandler
	 * 	#attributeDecl(eName, aName, type, mode, value)
	 *  #elementDecl(name, model)
	 *  #externalEntityDecl(name, publicId, systemId)
	 *  #internalEntityDecl(name, value)
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
	 * IGNORED method of org.xml.sax.EntityResolver2
	 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
	 *  #resolveEntity(publicId, systemId)
	 *  #getExternalSubset(name, baseURI)
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
	 * IGNORED method of org.xml.sax.DTDHandler
	 *  #notationDecl(name, publicId, systemId) {};
	 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
	 */
	"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
		DOMHandler.prototype[key] = function(){return null}
	})

	/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
	function appendElement (hander,node) {
	    if (!hander.currentElement) {
	        hander.document.appendChild(node);
	    } else {
	        hander.currentElement.appendChild(node);
	    }
	}//appendChild and setAttributeNS are preformance key

	if(true){
		var XMLReader = __webpack_require__(85).XMLReader;
		var DOMImplementation = exports.DOMImplementation = __webpack_require__(86).DOMImplementation;
		exports.XMLSerializer = __webpack_require__(86).XMLSerializer ;
		exports.DOMParser = DOMParser;
	}


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/main.d.ts" />
	"use strict";
	function isEmpty(value) {
	    return value == null;
	}
	function toString(value) {
	    return isEmpty(value) ? '' : String(value);
	}
	function toBoolean(value) {
	    return [0, false, '', '0', 'false'].indexOf(value) === -1;
	}
	function toNumber(value) {
	    return isFinite(value) ? Number(value) : null;
	}
	function toInteger(value) {
	    return value % 1 === 0 ? Number(value) : null;
	}
	function toDate(value) {
	    return !isNaN(Date.parse(value)) ? new Date(value) : null;
	}
	function toSanitization(parameter, rules, types) {
	    var parameters = Array.isArray(parameter) ? parameter : [parameter];
	    var sanitizations = parameters.map(function (parameter) {
	        var fns = [];
	        var typeSanitization = types[parameter.type];
	        if (typeof typeSanitization === 'function') {
	            fns.push(typeSanitization);
	        }
	        Object.keys(parameter)
	            .filter(function (key) {
	            return key !== 'type' && key !== 'repeat' && key !== 'default';
	        })
	            .forEach(function (key) {
	            var fn = rules[key];
	            if (typeof fn === 'function') {
	                fns.push(fn(parameter[key], key));
	            }
	        });
	        function sanitize(value, key, src) {
	            for (var i = 0; i < fns.length; i++) {
	                var fn = fns[i];
	                var value = fn(value, key, src);
	                if (value != null) {
	                    return value;
	                }
	            }
	            return null;
	        }
	        return function (value, key, src) {
	            if (isEmpty(value)) {
	                if (parameter.default != null) {
	                    return sanitize(parameter.default, key, src);
	                }
	                return parameter.repeat && !parameter.required ? [] : value;
	            }
	            if (parameter.repeat) {
	                var values = Array.isArray(value) ? value : [value];
	                values = values.map(function (value) {
	                    return sanitize(value, key, src);
	                });
	                return values.some(isEmpty) ? null : value;
	            }
	            if (Array.isArray(value)) {
	                if (value.length > 1) {
	                    return null;
	                }
	                value = value[0];
	            }
	            return sanitize(value, key, src);
	        };
	    });
	    return function (value, key, src) {
	        for (var i = 0; i < sanitizations.length; i++) {
	            var sanitization = sanitizations[i];
	            var result = sanitization(value, key, src);
	            if (result != null) {
	                return result;
	            }
	        }
	        return value;
	    };
	}
	function sanitize() {
	    var RULES = {};
	    var TYPES = {
	        string: toString,
	        number: toNumber,
	        integer: toInteger,
	        boolean: toBoolean,
	        date: toDate
	    };
	    function rule(parameter) {
	        return toSanitization(parameter, RULES, TYPES);
	    }
	    var sanitize = function (parameterMap) {
	        if (!parameterMap) {
	            return function () {
	                return {};
	            };
	        }
	        var sanitizations = {};
	        Object.keys(parameterMap).forEach(function (key) {
	            sanitizations[key] = sanitize.rule(parameterMap[key]);
	        });
	        return function (src) {
	            src = src || {};
	            var dest = {};
	            // Iterate the sanitized parameters to get a clean model.
	            Object.keys(sanitizations).forEach(function (key) {
	                var value = src[key];
	                var fn = sanitizations[key];
	                if (Object.prototype.hasOwnProperty.call(src, key)) {
	                    dest[key] = fn(value, key, src);
	                }
	            });
	            return dest;
	        };
	    };
	    var s;
	    s = sanitize;
	    s.rule = rule;
	    s.TYPES = TYPES;
	    s.RULES = RULES;
	    return s;
	}
	exports.sanitize = sanitize;
	// export = sanitize 
	//# sourceMappingURL=raml-sanitize.js.map

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/// <reference path="../../typings/main.d.ts" />
	"use strict";
	var _toString = Object.prototype.toString;
	function isDateType(check) {
	    return _toString.call(check) === '[object Date]' && !isNaN(check.getTime());
	}
	function isBooleanType(check) {
	    return typeof check === 'boolean';
	}
	function isStringType(check) {
	    return typeof check === 'string';
	}
	function isIntegerType(check) {
	    return typeof check === 'number' && check % 1 === 0;
	}
	function isNumberType(check) {
	    return typeof check === 'number' && isFinite(check);
	}
	function isMinimum(min) {
	    return function (check) {
	        return check >= min;
	    };
	}
	function isMaximum(max) {
	    return function (check) {
	        return check <= max;
	    };
	}
	function isMinimumLength(min) {
	    return function (check) {
	        return Buffer.byteLength(check) >= min;
	    };
	}
	function isMaximumLength(max) {
	    return function (check) {
	        return Buffer.byteLength(check) <= max;
	    };
	}
	function isEnum(values) {
	    if (values && values.length != 0) {
	        return function (check) {
	            return values.indexOf(check) > -1;
	        };
	    }
	    else {
	        return function (check) {
	            return true;
	        };
	    }
	}
	function isPattern(pattern) {
	    var regexp = (typeof pattern === 'string') ? new RegExp(pattern) : pattern;
	    return regexp.test.bind(regexp);
	}
	function toValidationResult(valid, key, value, rule, attr) {
	    return {
	        valid: valid,
	        rule: rule,
	        attr: attr,
	        value: value,
	        key: key
	    };
	}
	function toValidationFunction(parameter, rules) {
	    var validations = [];
	    Object.keys(parameter).forEach(function (name) {
	        var rule = rules[name];
	        if (!rule) {
	            return;
	        }
	        var value = parameter[name];
	        validations.push([name, rule(value, name), value]);
	    });
	    return function (value, key, src) {
	        for (var i = 0; i < validations.length; i++) {
	            var validation = validations[i];
	            var name = validation[0];
	            var fn = validation[1];
	            var attr = validation[2];
	            var valid = fn(value, key, src);
	            if (!valid) {
	                return toValidationResult(false, key, value, name, attr);
	            }
	        }
	        return toValidationResult(true, key, value);
	    };
	}
	function toValidation(parameter, rules, types) {
	    var parameters = Array.isArray(parameter) ? parameter : [parameter];
	    var isOptional = !parameters.length;
	    var simpleValidations = [];
	    var repeatValidations = [];
	    parameters.forEach(function (parameter) {
	        var validation = [parameter.type || 'string', toValidationFunction(parameter, rules)];
	        if (!parameter.required) {
	            isOptional = true;
	        }
	        if (parameter.repeat) {
	            repeatValidations.push(validation);
	        }
	        else {
	            simpleValidations.push(validation);
	        }
	    });
	    return function (value, key, src) {
	        if (value == null) {
	            return toValidationResult(isOptional, key, value, 'required', !isOptional);
	        }
	        var isArray = Array.isArray(value);
	        var values = isArray ? value : [value];
	        var validations = isArray ? repeatValidations : simpleValidations;
	        if (!validations.length) {
	            return toValidationResult(false, key, value, 'repeat', !isArray);
	        }
	        var response = null;
	        var originalValue = value;
	        validations.some(function (validation) {
	            var isValidType = values.every(function (value) {
	                var paramType = validation[0];
	                var isValidType = types[paramType] && types[paramType](value, key, src);
	                if (!isValidType) {
	                    response = toValidationResult(false, key, originalValue, 'type', paramType);
	                }
	                return isValidType;
	            });
	            if (!isValidType) {
	                return false;
	            }
	            values.every(function (value) {
	                var fn = validation[1];
	                response = fn(value, key);
	                return response.valid;
	            });
	            return true;
	        });
	        return response;
	    };
	}
	function validate() {
	    var TYPES = {
	        date: isDateType,
	        number: isNumberType,
	        integer: isIntegerType,
	        boolean: isBooleanType,
	        string: isStringType
	    };
	    var RULES = {
	        minimum: isMinimum,
	        maximum: isMaximum,
	        minLength: isMinimumLength,
	        maxLength: isMaximumLength,
	        'enum': isEnum,
	        pattern: isPattern
	    };
	    function rule(parameter) {
	        return toValidation(parameter, RULES, TYPES);
	    }
	    var v;
	    var validate = function (parameterMap) {
	        if (!parameterMap) {
	            return function (check) {
	                return { valid: true, errors: [] };
	            };
	        }
	        var validations = {};
	        Object.keys(parameterMap).forEach(function (key) {
	            validations[key] = rule(parameterMap[key]);
	        });
	        return function (src) {
	            src = src || {};
	            var errors = Object.keys(validations)
	                .map(function (param) {
	                var value = src[param];
	                var fn = validations[param];
	                return fn(value, param, src);
	            })
	                .filter(function (result) {
	                return !result.valid;
	            });
	            return {
	                valid: errors.length === 0,
	                errors: errors
	            };
	        };
	    };
	    v = validate;
	    v.rule = rule;
	    v.TYPES = TYPES;
	    v.RULES = RULES;
	    return v;
	}
	exports.validate = validate;
	// export = validate
	//# sourceMappingURL=raml-validate.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(92).Buffer))

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {(function() {
	  var vm,
	    __slice = [].slice;

	  vm = __webpack_require__(108);

	  exports.allowUnsafeEval = function(fn) {
	    var previousEval;
	    previousEval = global["eval"];
	    try {
	      global["eval"] = function(source) {
	        return vm.runInThisContext(source);
	      };
	      return fn();
	    } finally {
	      global["eval"] = previousEval;
	    }
	  };

	  exports.allowUnsafeNewFunction = function(fn) {
	    var previousFunction;
	    previousFunction = global.Function;
	    try {
	      global.Function = exports.Function;
	      return fn();
	    } finally {
	      global.Function = previousFunction;
	    }
	  };

	  exports.Function = function() {
	    var body, paramList, paramLists, params, _i, _j, _len;
	    paramLists = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), body = arguments[_i++];
	    params = [];
	    for (_j = 0, _len = paramLists.length; _j < _len; _j++) {
	      paramList = paramLists[_j];
	      if (typeof paramList === 'string') {
	        paramList = paramList.split(/\s*,\s*/);
	      }
	      params.push.apply(params, paramList);
	    }
	    return vm.runInThisContext("(function(" + (params.join(', ')) + ") {\n  " + body + "\n})");
	  };

	  exports.Function.prototype = global.Function.prototype;

	}).call(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var def = __webpack_require__(36);
	var khttp = __webpack_require__(136);
	var _ = __webpack_require__(87);
	var services = def;
	function handleTypeAnnotation(a, rangeType) {
	    if (a.name == 'MetaModel.declaresSubTypeOf') {
	        rangeType.getAdapter(services.RAMLService).setExtendedTypeName(a.arguments[0]);
	    }
	    if (a.name == 'MetaModel.nameAtRuntime') {
	        rangeType.setNameAtRuntime(a.arguments[0]);
	    }
	    if (a.name == 'MetaModel.description') {
	        rangeType.withDescription(a.arguments[0]);
	    }
	    if (a.name == 'MetaModel.inlinedTemplates') {
	        rangeType.getAdapter(services.RAMLService).setInlinedTemplates(true);
	    }
	    if (a.name == 'MetaModel.requireValue') {
	        rangeType.getAdapter(services.RAMLService).withContextRequirement("" + a.arguments[0], "" + a.arguments[1]);
	    }
	    if (a.name == 'MetaModel.referenceIs') {
	        rangeType.getAdapter(services.RAMLService).withReferenceIs("" + a.arguments[0]);
	    }
	    //MetaModel.referenceIs
	    if (a.name == 'MetaModel.actuallyExports') {
	        rangeType.getAdapter(services.RAMLService).withActuallyExports("" + a.arguments[0]);
	    }
	    if (a.name == 'MetaModel.convertsToGlobalOfType') {
	        rangeType.getAdapter(services.RAMLService).withConvertsToGlobal("" + a.arguments[0]);
	    }
	    if (a.name == 'MetaModel.allowAny') {
	        rangeType.getAdapter(services.RAMLService).withAllowAny();
	    }
	    if (a.name == 'MetaModel.allowQuestion') {
	        rangeType.getAdapter(services.RAMLService).withAllowQuestion();
	    }
	    if (a.name == 'MetaModel.alias') {
	        rangeType.getAdapter(services.RAMLService).addAlias("" + a.arguments[0]);
	    }
	    if (a.name == 'MetaModel.consumesRefs') {
	        rangeType.getAdapter(services.RAMLService).setConsumesRefs(true);
	    }
	    if (a.name == 'MetaModel.canInherit') {
	        rangeType.getAdapter(services.RAMLService).withCanInherit("" + a.arguments[0]);
	    }
	    if (a.name == 'MetaModel.definingPropertyIsEnough') {
	        rangeType.getAdapter(services.RAMLService).definingPropertyIsEnough("" + a.arguments[0]);
	    }
	    if (a.name == 'MetaModel.customHandling') {
	        rangeType.setCustom(true);
	    }
	    if (a.name == 'MetaModel.superclasses') {
	        rangeType.getAdapter(services.RAMLService).registerSupertypes(a.arguments[0]);
	    }
	    if (a.name == 'MetaModel.possibleInterfaces') {
	        rangeType.getAdapter(services.RAMLService).registerPossibleInterfaces(a.arguments[0]);
	    }
	}
	exports.handleTypeAnnotation = handleTypeAnnotation;
	exports.annotationHandlers = {
	    key: function (a, f) {
	        f.withFromParentKey();
	        f.withKey(true);
	    },
	    value: function (a, f) {
	        f.withFromParentValue();
	    },
	    canBeValue: function (a, f) {
	        f.withCanBeValue();
	    },
	    unmerged: function (a, f) {
	        f.unmerge();
	    },
	    startFrom: function (a, f) {
	        f.withKeyRestriction(a.arguments[0]);
	        f.merge();
	    },
	    oneOf: function (a, f) {
	        f.withEnumOptions(a.arguments[0]);
	    },
	    oftenKeys: function (a, f) {
	        f.withOftenKeys(a.arguments[0]);
	    },
	    embeddedInMaps: function (a, f) {
	        f.getAdapter(services.RAMLPropertyParserService).withEmbedMap();
	    },
	    system: function (a, f) {
	        f.getAdapter(services.RAMLPropertyParserService).withSystem(true);
	    },
	    required: function (a, f) {
	        if (a.arguments[0] != 'false' && a.arguments[0] !== false) {
	            f.withRequired(true);
	        }
	    },
	    noDirectParse: function (a, f) {
	        if (a.arguments[0] != 'false' && a.arguments[0] !== false) {
	            f.withNoDirectParse();
	        }
	    },
	    setsContextValue: function (a, f) {
	        f.addChildValueConstraint(new def.ChildValueConstraint("" + a.arguments[0], "" + a.arguments[1]));
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    defaultValue: function (a, f) {
	        f.setDefaultVal("" + a.arguments[0]);
	    },
	    defaultIntegerValue: function (a, f) {
	        f.setDefaultIntegerVal(a.arguments[0]);
	    },
	    defaultBooleanValue: function (a, f) {
	        f.setDefaultBooleanVal(a.arguments[0]);
	    },
	    facetId: function (a, f) {
	        if (a.arguments[0] == "minItems") {
	            f.setFacetValidator(function (x, f) {
	                if (x instanceof Array) {
	                    var length = Number.parseInt("" + f.value());
	                    if (length > x.length) {
	                        return "array should contain at least " + f.value() + " items";
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "enum") {
	            f.setFacetValidator(function (x, f) {
	                var validateAgainst = x + "";
	                var array = f;
	                try {
	                    if (!array.some(function (x) { return x == validateAgainst; })) {
	                        return "value should be one of :" + array.join(",");
	                    }
	                }
	                catch (e) {
	                    return;
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "maxItems") {
	            f.setFacetValidator(function (x, f) {
	                if (x instanceof Array) {
	                    var length = Number.parseInt("" + f);
	                    if (length < x.length) {
	                        return "array should contain not more then " + f.value() + " items";
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "minProperties") {
	            f.setFacetValidator(function (x, f) {
	                if (x instanceof Object) {
	                    var length = Number.parseInt("" + f);
	                    if (length > Object.keys(x).length) {
	                        return "object should contain at least " + f.value() + " properties";
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "maxProperties") {
	            f.setFacetValidator(function (x, f) {
	                if (x instanceof Object) {
	                    var length = Number.parseInt("" + f);
	                    if (length < Object.keys(x).length) {
	                        return "object should contain not more then " + f.value() + " properties";
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "uniqueItems") {
	            f.setFacetValidator(function (x, f) {
	                if (f instanceof Array) {
	                    var length = _.unique(f).length;
	                    if (length < f.length) {
	                        return "array should contain only unique items";
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "minLength") {
	            f.setFacetValidator(function (x, f) {
	                if (typeof x == 'number' || typeof x == 'boolean') {
	                    x = "" + x;
	                }
	                if (typeof x == 'string') {
	                    var length = Number.parseInt("" + f);
	                    if (length > x.length) {
	                        return "string length should be at least " + length;
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "maxLength") {
	            f.setFacetValidator(function (x, f) {
	                if (typeof x == 'number' || typeof x == 'boolean') {
	                    x = "" + x;
	                }
	                if (typeof x == 'string') {
	                    var length = Number.parseInt("" + f);
	                    if (length < x.length) {
	                        return "string length should be not more then " + length;
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "minimum") {
	            f.setFacetValidator(function (x, f) {
	                if (typeof x == 'string') {
	                    x = parseFloat(x);
	                }
	                if (typeof x == 'number') {
	                    var length = parseFloat(f);
	                    if (length > x) {
	                        return "value should be not less then " + length;
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "maximum") {
	            f.setFacetValidator(function (x, f) {
	                if (typeof x == 'string') {
	                    x = parseFloat(x);
	                }
	                if (typeof x == 'number') {
	                    var length = parseFloat(f);
	                    if (length < x) {
	                        return "value should be not more then " + length;
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "pattern") {
	            f.setFacetValidator(function (x, f) {
	                if (typeof x == 'number' || typeof x == 'boolean') {
	                    x = "" + x;
	                }
	                if (typeof x == 'string') {
	                    var regExp = new RegExp(f);
	                    if (!regExp.test(x)) {
	                        return "string should match to " + f;
	                    }
	                }
	                return null;
	            });
	        }
	    },
	    extraMetaKey: function (a, f) {
	        if (a.arguments[0] == "statusCodes") {
	            f.withOftenKeys(khttp.statusCodes.filter(function (statusCode) { return statusCode.code.indexOf("x") < 0; }).map(function (x) { return x.code; }));
	            f.setValueDocProvider(function (name) {
	                var s = _.find(khttp.statusCodes, function (x) { return x.code == name; });
	                if (s) {
	                    return (name + ":" + s.description);
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "headers") {
	            f.setValueSuggester(function (x) {
	                if (x.property()) {
	                    var c = x.property().getChildValueConstraints();
	                    if (_.find(c, function (x) {
	                        return x.name == "location" && x.value == "Params.ParameterLocation.HEADERS";
	                    })) {
	                        return khttp.headers.map(function (x) { return x.header; });
	                    }
	                    if (x.property()) {
	                        if (x.property().nameId() == "headers") {
	                            return khttp.headers.map(function (x) { return x.header; });
	                        }
	                    }
	                }
	                return null;
	            });
	            f.setValueDocProvider(function (name) {
	                var s = _.find(khttp.headers, function (x) { return x.header == name; });
	                if (s) {
	                    return (name + ":" + s.description);
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "methods") {
	            f.setValueDocProvider(function (name) {
	                var s = _.find(khttp.methods, function (x) { return x.method == name.toUpperCase(); });
	                if (s) {
	                    return (name + ":" + s.description);
	                }
	                return null;
	            });
	        }
	    },
	    requireValue: function (a, f) {
	        f.withContextRequirement("" + a.arguments[0], "" + a.arguments[1]);
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    allowMultiple: function (a, f) {
	        f.withMultiValue(true);
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    constraint: function (a, f) {
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    newInstanceName: function (a, f) {
	        f.withNewInstanceName("" + a.arguments[0]);
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    declaringFields: function (a, f) {
	        f.withThisPropertyDeclaresFields();
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    describesAnnotation: function (a, f) {
	        //f.withReferenceParameters();
	        f.withDescribes(a.arguments[0]);
	    },
	    allowNull: function (a, f) {
	        f.withAllowNull();
	    },
	    descriminatingProperty: function (a, f) {
	        //f.withReferenceParameters();
	        f.withDescriminating(true);
	    },
	    description: function (a, f) {
	        f.withDescription("" + a.arguments[0]);
	        //f.withReferenceParameters();
	        //f.withDescriminating(true)
	    },
	    inherited: function (a, f) {
	        f.withInherited(true);
	    },
	    selfNode: function (a, f) {
	        f.withSelfNode();
	    },
	    grammarTokenKind: function (a, f) {
	        f.getAdapter(services.RAMLPropertyService).withPropertyGrammarType("" + a.arguments[0]);
	    },
	    canInherit: function (a, f) {
	        f.withInheritedContextValue("" + a.arguments[0]);
	    },
	    canBeDuplicator: function (a, f) {
	        f.setCanBeDuplicator();
	    },
	    example: function (a, f) {
	        f.getAdapter(services.RAMLPropertyService).setExample(true);
	    },
	    typeExpression: function (a, f) {
	        f.getAdapter(services.RAMLPropertyService).setTypeExpression(true);
	    },
	    hide: function (a, f) {
	        if (a.arguments.length == 0) {
	            f.getAdapter(services.RAMLPropertyDocumentationService).setHidden(true);
	        }
	        else {
	            f.getAdapter(services.RAMLPropertyDocumentationService).setHidden(a.arguments[0]);
	        }
	    },
	    documentationTableLabel: function (a, f) {
	        f.getAdapter(services.RAMLPropertyDocumentationService).setDocTableName("" + a.arguments[0]);
	    },
	    markdownDescription: function (a, f) {
	        f.getAdapter(services.RAMLPropertyDocumentationService).setMarkdownDescription("" + a.arguments[0]);
	    },
	    valueDescription: function (a, f) {
	        f.getAdapter(services.RAMLPropertyDocumentationService).setValueDescription(a.arguments[0] != null ? ("" + a.arguments[0]) : null);
	    },
	    customHandling: function (a, f) {
	    }
	};
	function recordAnnotation(p, a) {
	    exports.annotationHandlers[a.name](a, p);
	}
	exports.recordAnnotation = recordAnnotation;
	//# sourceMappingURL=annotationHandlers.js.map

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ts = __webpack_require__(96);
	exports.tsInterfaces = __webpack_require__(97);
	var tc = __webpack_require__(98);
	var fr = __webpack_require__(99);
	var restrictions_1 = __webpack_require__(100);
	var metainfo_1 = __webpack_require__(101);
	var metainfo_2 = __webpack_require__(101);
	var metainfo_3 = __webpack_require__(101);
	var nm = __webpack_require__(102);
	exports.nominalTypes = __webpack_require__(103);
	exports.nominalInterfaces = __webpack_require__(104);
	exports.typeExpressions = __webpack_require__(105);
	var schemaUtil = __webpack_require__(106);
	exports.TOP_LEVEL_EXTRA = exports.tsInterfaces.TOP_LEVEL_EXTRA;
	exports.DEFINED_IN_TYPES_EXTRA = exports.tsInterfaces.DEFINED_IN_TYPES_EXTRA;
	exports.USER_DEFINED_EXTRA = exports.tsInterfaces.USER_DEFINED_EXTRA;
	exports.SOURCE_EXTRA = exports.tsInterfaces.SOURCE_EXTRA;
	// export function instanceOfHasExtra(instance : nominalTypes.ITypeDefinition) : instance is IHasExtra {
	//     returninstance instanceof ts.AbstractType || instance instanceof nominalTypes.AbstractType;
	// }
	function getSchemaUtils() {
	    return schemaUtil;
	}
	exports.getSchemaUtils = getSchemaUtils;
	function isParsedType(object) {
	    return object instanceof ts.AbstractType;
	}
	exports.isParsedType = isParsedType;
	/**
	 * loads type collection from JSON type definition
	 * @param data
	 * @param registry - optional registry of types which ar already known (does not modified during parse)
	 * @returns {TypeCollection} returns a new instance of type collection with a parsed types
	 */
	function loadTypeCollection(data, registry) {
	    if (registry === void 0) { registry = ts.builtInRegistry(); }
	    return tc.parseJSONTypeCollection(data, registry);
	}
	exports.loadTypeCollection = loadTypeCollection;
	/**
	 * loads type  from JSON type definition
	 * @param data
	 * @returns {ts.AbstractType}
	 */
	function loadType(data) {
	    return tc.parseJSON(null, data, ts.builtInRegistry());
	}
	exports.loadType = loadType;
	/**
	 * parses a type or type collection definition from a JSON structure
	 * @param data
	 * @returns {any}
	 */
	function parse(data) {
	    if (data['types'] || data['annotationTypes']) {
	        return tc.parseJSONTypeCollection(data);
	    }
	    else {
	        return tc.parseJSON(null, data);
	    }
	}
	exports.parse = parse;
	/**
	 * parses a type  from a JSON structure, uses second argument to resolve types
	 * @param data
	 * @returns {any}
	 */
	function parseType(data, collection) {
	    return tc.parseJSON(null, data, collection ? collection.getTypeRegistry() : ts.builtInRegistry());
	}
	exports.parseType = parseType;
	/**
	 * kind of the node
	 */
	(function (NodeKind) {
	    NodeKind[NodeKind["SCALAR"] = 0] = "SCALAR";
	    NodeKind[NodeKind["ARRAY"] = 1] = "ARRAY";
	    NodeKind[NodeKind["MAP"] = 2] = "MAP";
	})(exports.NodeKind || (exports.NodeKind = {}));
	var NodeKind = exports.NodeKind;
	/**
	 * parses type collection definition from a JSON structure
	 * @param data
	 * @returns {any}
	 */
	function parseFromAST(data) {
	    return tc.parseTypeCollection(data, ts.builtInRegistry());
	}
	exports.parseFromAST = parseFromAST;
	/**
	 * parses type collection definition from a JSON structure
	 * @param data
	 * @returns {any}
	 */
	function parseTypeFromAST(name, data, collection, defaultsToAny, annotation, global, ignoreTypeAttr) {
	    if (defaultsToAny === void 0) { defaultsToAny = false; }
	    if (annotation === void 0) { annotation = false; }
	    if (global === void 0) { global = true; }
	    if (ignoreTypeAttr === void 0) { ignoreTypeAttr = false; }
	    return tc.parse(name, data, collection ? collection.getTypeRegistry() : ts.builtInRegistry(), defaultsToAny, annotation, global, ignoreTypeAttr);
	}
	exports.parseTypeFromAST = parseTypeFromAST;
	/**
	 * dumps type or type collection to JSON
	 * @param ts
	 * @returns {IType|ITypeCollection}
	 */
	function dump(ts) {
	    return tc.storeAsJSON(ts);
	}
	exports.dump = dump;
	/**
	 * validates intance against the type definition
	 * @param i - instance to validate
	 * @param t - type definition
	 * @returns {IStatus}
	 */
	function validate(i, t, autoClose) {
	    if (autoClose === void 0) { autoClose = false; }
	    ts.autoCloseFlag = autoClose;
	    try {
	        return t.validate(i, autoClose);
	    }
	    finally {
	        ts.autoCloseFlag = false;
	    }
	}
	exports.validate = validate;
	/***
	 * validates type definition
	 * @param t
	 * @param collection - collection of the types
	 * @returns {IStatus}
	 */
	function validateTypeDefinition(t, collection) {
	    return t.validateType(collection.getAnnotationTypeRegistry());
	}
	exports.validateTypeDefinition = validateTypeDefinition;
	/**
	 * performs automatic classification of instance against a given type
	 * @param i
	 * @param t
	 * @returns {IParsedType}
	 */
	function performAC(i, t) {
	    return t.ac(i);
	}
	exports.performAC = performAC;
	/**
	 * checks if the given type is suitable for automatic classification
	 * @param t
	 * @returns {Status}
	 */
	function checkACStatus(t) {
	    return t.canDoAc();
	}
	exports.checkACStatus = checkACStatus;
	/**
	 * this function allow you to get a list of all built-in facets
	 * @returns {FacetPrototype[]}
	 */
	function builtInFacets() {
	    return fr.getInstance().allPrototypes();
	}
	exports.builtInFacets = builtInFacets;
	/**
	 * returns type registry returning all built in types
	 * @returns {TypeRegistry}
	 */
	function builtInTypes() {
	    return ts.builtInRegistry();
	}
	exports.builtInTypes = builtInTypes;
	/**
	 * creates a new type by deriving it from a list of super types
	 * @returns {IParsedType}
	 */
	function derive(name) {
	    var types = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        types[_i - 1] = arguments[_i];
	    }
	    return ts.derive(name, types);
	}
	exports.derive = derive;
	/**
	 * creates a new type by unifying it from a list of possible options
	 * @returns {IParsedType}
	 */
	function unify(name) {
	    var types = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        types[_i - 1] = arguments[_i];
	    }
	    return ts.union(name, types);
	}
	exports.unify = unify;
	var TypeConstructor = (function () {
	    function TypeConstructor(target) {
	        this.target = target;
	    }
	    /**
	     * adds property declaration to the type
	     * @param name
	     * @param type
	     * @param optional
	     * @returns {TypeConstructor}
	     */
	    TypeConstructor.prototype.addProperty = function (name, type, optional) {
	        this.target.declareProperty(name, type, optional);
	        return this;
	    };
	    /**
	     * closes type
	     * @returns {TypeConstructor}
	     */
	    TypeConstructor.prototype.closeType = function () {
	        this.target.addMeta(new restrictions_1.KnownPropertyRestriction(false));
	        return this;
	    };
	    /**
	     * adds annotation to the type
	     * @returns {TypeConstructor}
	     */
	    TypeConstructor.prototype.annotate = function (name, value) {
	        this.target.addMeta(new metainfo_1.Annotation(name, value));
	        return this;
	    };
	    /**
	     * adds custom facet to the type
	     * @returns {TypeConstructor}
	     */
	    TypeConstructor.prototype.customFacet = function (name, value) {
	        this.target.addMeta(new metainfo_2.CustomFacet(name, value));
	        return this;
	    };
	    /**
	     * adds custom facet declaration to the type
	     * @returns {TypeConstructor}
	     */
	    TypeConstructor.prototype.customFacetDeclaration = function (name, value, optional) {
	        if (optional === void 0) { optional = true; }
	        this.target.addMeta(new metainfo_3.FacetDeclaration(name, value, optional));
	        return this;
	    };
	    /**
	     * adds a built-in facet with a given name and value
	     * @param name
	     * @param value
	     * @returns {TypeConstructor}
	     */
	    TypeConstructor.prototype.addSimpleFacet = function (name, value) {
	        this.target.addMeta(fr.getInstance().buildFacet(name, value));
	        return this;
	    };
	    /**
	     * returns a constructed type instance
	     * @returns {IParsedType}
	     */
	    TypeConstructor.prototype.getResult = function () {
	        return this.target;
	    };
	    return TypeConstructor;
	}());
	exports.TypeConstructor = TypeConstructor;
	function setPropertyConstructor(c) {
	    nm.setPropertyConstructor(c);
	}
	exports.setPropertyConstructor = setPropertyConstructor;
	function toNominal(t, bt) {
	    return nm.toNominal(t, bt);
	}
	exports.toNominal = toNominal;
	//# sourceMappingURL=index.js.map

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.decode = exports.parse = __webpack_require__(94);
	exports.encode = exports.stringify = __webpack_require__(95);


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {

		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}

		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,

		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},

		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,

		/** Temporary variable */
		key;

		/*--------------------------------------------------------------------------*/

		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}

		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}

		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}

		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}

		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}

		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

					if (index >= inputLength) {
						error('invalid-input');
					}

					digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}

					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

					if (digit < t) {
						break;
					}

					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}

					w *= baseMinusT;

				}

				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);

			}

			return ucs2encode(output);
		}

		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;

			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);

			// Cache the length
			inputLength = input.length;

			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;

			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}

			handledCPCount = basicLength = output.length;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];

					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}

					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}

				++delta;
				++n;

			}
			return output.join('');
		}

		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}

		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}

	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(145)(module), (function() { return this; }())))

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ast = __webpack_require__(113);
	'use strict';
	var common = __webpack_require__(110);
	var YAMLException = __webpack_require__(111);
	var Mark = __webpack_require__(114);
	var DEFAULT_SAFE_SCHEMA = __webpack_require__(133);
	var DEFAULT_FULL_SCHEMA = __webpack_require__(132);
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	var CONTEXT_FLOW_IN = 1;
	var CONTEXT_FLOW_OUT = 2;
	var CONTEXT_BLOCK_IN = 3;
	var CONTEXT_BLOCK_OUT = 4;
	var CHOMPING_CLIP = 1;
	var CHOMPING_STRIP = 2;
	var CHOMPING_KEEP = 3;
	var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uD800-\uDFFF\uFFFE\uFFFF]/;
	var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
	var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
	var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
	var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
	function is_EOL(c) {
	    return (c === 0x0A) || (c === 0x0D);
	}
	function is_WHITE_SPACE(c) {
	    return (c === 0x09) || (c === 0x20);
	}
	function is_WS_OR_EOL(c) {
	    return (c === 0x09) ||
	        (c === 0x20) ||
	        (c === 0x0A) ||
	        (c === 0x0D);
	}
	function is_FLOW_INDICATOR(c) {
	    return 0x2C === c ||
	        0x5B === c ||
	        0x5D === c ||
	        0x7B === c ||
	        0x7D === c;
	}
	function fromHexCode(c) {
	    var lc;
	    if ((0x30 <= c) && (c <= 0x39)) {
	        return c - 0x30;
	    }
	    lc = c | 0x20;
	    if ((0x61 <= lc) && (lc <= 0x66)) {
	        return lc - 0x61 + 10;
	    }
	    return -1;
	}
	function escapedHexLen(c) {
	    if (c === 0x78) {
	        return 2;
	    }
	    if (c === 0x75) {
	        return 4;
	    }
	    if (c === 0x55) {
	        return 8;
	    }
	    return 0;
	}
	function fromDecimalCode(c) {
	    if ((0x30 <= c) && (c <= 0x39)) {
	        return c - 0x30;
	    }
	    return -1;
	}
	function simpleEscapeSequence(c) {
	    return (c === 0x30) ? '\x00' :
	        (c === 0x61) ? '\x07' :
	            (c === 0x62) ? '\x08' :
	                (c === 0x74) ? '\x09' :
	                    (c === 0x09) ? '\x09' :
	                        (c === 0x6E) ? '\x0A' :
	                            (c === 0x76) ? '\x0B' :
	                                (c === 0x66) ? '\x0C' :
	                                    (c === 0x72) ? '\x0D' :
	                                        (c === 0x65) ? '\x1B' :
	                                            (c === 0x20) ? ' ' :
	                                                (c === 0x22) ? '\x22' :
	                                                    (c === 0x2F) ? '/' :
	                                                        (c === 0x5C) ? '\x5C' :
	                                                            (c === 0x4E) ? '\x85' :
	                                                                (c === 0x5F) ? '\xA0' :
	                                                                    (c === 0x4C) ? '\u2028' :
	                                                                        (c === 0x50) ? '\u2029' : '';
	}
	function charFromCodepoint(c) {
	    if (c <= 0xFFFF) {
	        return String.fromCharCode(c);
	    }
	    return String.fromCharCode(((c - 0x010000) >> 10) + 0xD800, ((c - 0x010000) & 0x03FF) + 0xDC00);
	}
	var simpleEscapeCheck = new Array(256);
	var simpleEscapeMap = new Array(256);
	for (var i = 0; i < 256; i++) {
	    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
	    simpleEscapeMap[i] = simpleEscapeSequence(i);
	}
	var State = (function () {
	    function State(input, options) {
	        this.errorMap = {};
	        this.errors = [];
	        this.input = input;
	        this.filename = options['filename'] || null;
	        this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
	        this.onWarning = options['onWarning'] || null;
	        this.legacy = options['legacy'] || false;
	        this.implicitTypes = this.schema.compiledImplicit;
	        this.typeMap = this.schema.compiledTypeMap;
	        this.length = input.length;
	        this.position = 0;
	        this.line = 0;
	        this.lineStart = 0;
	        this.lineIndent = 0;
	        this.documents = [];
	    }
	    return State;
	}());
	function generateError(state, message) {
	    return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line - 1, (state.position - state.lineStart)));
	}
	function throwError(state, message) {
	    var error = generateError(state, message);
	    var hash = error.message + error.mark.position;
	    if (!state.errorMap[hash]) {
	        state.errors.push(error);
	        state.errorMap[hash] = 1;
	    }
	    var or = state.position;
	    while (true) {
	        if (state.position >= state.input.length - 1) {
	            return;
	        }
	        var c = state.input.charAt(state.position);
	        if (c == '\n') {
	            state.position--;
	            if (state.position == or) {
	                state.position += 1;
	            }
	            return;
	        }
	        if (c == '\r') {
	            state.position--;
	            if (state.position == or) {
	                state.position += 1;
	            }
	            return;
	        }
	        state.position++;
	    }
	}
	function throwWarning(state, message) {
	    var error = generateError(state, message);
	    if (state.onWarning) {
	        state.onWarning.call(null, error);
	    }
	    else {
	    }
	}
	var directiveHandlers = {
	    YAML: function handleYamlDirective(state, name, args) {
	        var match, major, minor;
	        if (null !== state.version) {
	            throwError(state, 'duplication of %YAML directive');
	        }
	        if (1 !== args.length) {
	            throwError(state, 'YAML directive accepts exactly one argument');
	        }
	        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
	        if (null === match) {
	            throwError(state, 'ill-formed argument of the YAML directive');
	        }
	        major = parseInt(match[1], 10);
	        minor = parseInt(match[2], 10);
	        if (1 !== major) {
	            throwError(state, 'found incompatible YAML document (version 1.2 is required)');
	        }
	        state.version = args[0];
	        state.checkLineBreaks = (minor < 2);
	        if (2 !== minor) {
	            throwError(state, 'found incompatible YAML document (version 1.2 is required)');
	        }
	    },
	    TAG: function handleTagDirective(state, name, args) {
	        var handle, prefix;
	        if (2 !== args.length) {
	            throwError(state, 'TAG directive accepts exactly two arguments');
	        }
	        handle = args[0];
	        prefix = args[1];
	        if (!PATTERN_TAG_HANDLE.test(handle)) {
	            throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
	        }
	        if (_hasOwnProperty.call(state.tagMap, handle)) {
	            throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
	        }
	        if (!PATTERN_TAG_URI.test(prefix)) {
	            throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
	        }
	        state.tagMap[handle] = prefix;
	    }
	};
	function captureSegment(state, start, end, checkJson) {
	    var _position, _length, _character, _result;
	    var scalar = state.result;
	    if (scalar.startPosition == -1) {
	        scalar.startPosition = start;
	    }
	    if (start <= end) {
	        _result = state.input.slice(start, end);
	        if (checkJson) {
	            for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
	                _character = _result.charCodeAt(_position);
	                if (!(0x09 === _character ||
	                    0x20 <= _character && _character <= 0x10FFFF)) {
	                    throwError(state, 'expected valid JSON character');
	                }
	            }
	        }
	        scalar.value += _result;
	        scalar.endPosition = end;
	    }
	}
	function mergeMappings(state, destination, source) {
	    var sourceKeys, key, index, quantity;
	    if (!common.isObject(source)) {
	        throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
	    }
	    sourceKeys = Object.keys(source);
	    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
	        key = sourceKeys[index];
	        if (!_hasOwnProperty.call(destination, key)) {
	            destination[key] = source[key];
	        }
	    }
	}
	function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {
	    var index, quantity;
	    if (keyNode == null) {
	        return;
	    }
	    if (null === _result) {
	        _result = {
	            startPosition: keyNode.startPosition,
	            endPosition: valueNode.endPosition,
	            parent: null,
	            errors: [],
	            mappings: [], kind: ast.Kind.MAP };
	    }
	    var mapping = ast.newMapping(keyNode, valueNode);
	    mapping.parent = _result;
	    keyNode.parent = mapping;
	    if (valueNode != null) {
	        valueNode.parent = mapping;
	    }
	    _result.mappings.push(mapping);
	    _result.endPosition = valueNode ? valueNode.endPosition : keyNode.endPosition + 1;
	    return _result;
	}
	function readLineBreak(state) {
	    var ch;
	    ch = state.input.charCodeAt(state.position);
	    if (0x0A === ch) {
	        state.position++;
	    }
	    else if (0x0D === ch) {
	        state.position++;
	        if (0x0A === state.input.charCodeAt(state.position)) {
	            state.position++;
	        }
	    }
	    else {
	        throwError(state, 'a line break is expected');
	    }
	    state.line += 1;
	    state.lineStart = state.position;
	}
	function skipSeparationSpace(state, allowComments, checkIndent) {
	    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
	    while (0 !== ch) {
	        while (is_WHITE_SPACE(ch)) {
	            ch = state.input.charCodeAt(++state.position);
	        }
	        if (allowComments && 0x23 === ch) {
	            do {
	                ch = state.input.charCodeAt(++state.position);
	            } while (ch !== 0x0A && ch !== 0x0D && 0 !== ch);
	        }
	        if (is_EOL(ch)) {
	            readLineBreak(state);
	            ch = state.input.charCodeAt(state.position);
	            lineBreaks++;
	            state.lineIndent = 0;
	            while (0x20 === ch) {
	                state.lineIndent++;
	                ch = state.input.charCodeAt(++state.position);
	            }
	        }
	        else {
	            break;
	        }
	    }
	    if (-1 !== checkIndent && 0 !== lineBreaks && state.lineIndent < checkIndent) {
	        throwWarning(state, 'deficient indentation');
	    }
	    return lineBreaks;
	}
	function testDocumentSeparator(state) {
	    var _position = state.position, ch;
	    ch = state.input.charCodeAt(_position);
	    if ((0x2D === ch || 0x2E === ch) &&
	        state.input.charCodeAt(_position + 1) === ch &&
	        state.input.charCodeAt(_position + 2) === ch) {
	        _position += 3;
	        ch = state.input.charCodeAt(_position);
	        if (ch === 0 || is_WS_OR_EOL(ch)) {
	            return true;
	        }
	    }
	    return false;
	}
	function writeFoldedLines(state, scalar, count) {
	    if (1 === count) {
	        scalar.value += ' ';
	    }
	    else if (count > 1) {
	        scalar.value += common.repeat('\n', count - 1);
	    }
	}
	function readPlainScalar(state, nodeIndent, withinFlowCollection) {
	    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
	    var state_result = ast.newScalar();
	    state_result.plainScalar = true;
	    state.result = state_result;
	    ch = state.input.charCodeAt(state.position);
	    if (is_WS_OR_EOL(ch) ||
	        is_FLOW_INDICATOR(ch) ||
	        0x23 === ch ||
	        0x26 === ch ||
	        0x2A === ch ||
	        0x21 === ch ||
	        0x7C === ch ||
	        0x3E === ch ||
	        0x27 === ch ||
	        0x22 === ch ||
	        0x25 === ch ||
	        0x40 === ch ||
	        0x60 === ch) {
	        return false;
	    }
	    if (0x3F === ch || 0x2D === ch) {
	        following = state.input.charCodeAt(state.position + 1);
	        if (is_WS_OR_EOL(following) ||
	            withinFlowCollection && is_FLOW_INDICATOR(following)) {
	            return false;
	        }
	    }
	    state.kind = 'scalar';
	    captureStart = captureEnd = state.position;
	    hasPendingContent = false;
	    while (0 !== ch) {
	        if (0x3A === ch) {
	            following = state.input.charCodeAt(state.position + 1);
	            if (is_WS_OR_EOL(following) ||
	                withinFlowCollection && is_FLOW_INDICATOR(following)) {
	                break;
	            }
	        }
	        else if (0x23 === ch) {
	            preceding = state.input.charCodeAt(state.position - 1);
	            if (is_WS_OR_EOL(preceding)) {
	                break;
	            }
	        }
	        else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
	            withinFlowCollection && is_FLOW_INDICATOR(ch)) {
	            break;
	        }
	        else if (is_EOL(ch)) {
	            _line = state.line;
	            _lineStart = state.lineStart;
	            _lineIndent = state.lineIndent;
	            skipSeparationSpace(state, false, -1);
	            if (state.lineIndent >= nodeIndent) {
	                hasPendingContent = true;
	                ch = state.input.charCodeAt(state.position);
	                continue;
	            }
	            else {
	                state.position = captureEnd;
	                state.line = _line;
	                state.lineStart = _lineStart;
	                state.lineIndent = _lineIndent;
	                break;
	            }
	        }
	        if (hasPendingContent) {
	            captureSegment(state, captureStart, captureEnd, false);
	            writeFoldedLines(state, state_result, state.line - _line);
	            captureStart = captureEnd = state.position;
	            hasPendingContent = false;
	        }
	        if (!is_WHITE_SPACE(ch)) {
	            captureEnd = state.position + 1;
	        }
	        ch = state.input.charCodeAt(++state.position);
	        if (state.position >= state.input.length) {
	            return false;
	        }
	    }
	    captureSegment(state, captureStart, captureEnd, false);
	    if (state.result.startPosition != -1) {
	        return true;
	    }
	    state.kind = _kind;
	    state.result = _result;
	    return false;
	}
	function readSingleQuotedScalar(state, nodeIndent) {
	    var ch, captureStart, captureEnd;
	    ch = state.input.charCodeAt(state.position);
	    if (0x27 !== ch) {
	        return false;
	    }
	    var scalar = ast.newScalar();
	    state.kind = 'scalar';
	    state.result = scalar;
	    scalar.startPosition = state.position;
	    state.position++;
	    captureStart = captureEnd = state.position;
	    while (0 !== (ch = state.input.charCodeAt(state.position))) {
	        if (0x27 === ch) {
	            captureSegment(state, captureStart, state.position, true);
	            ch = state.input.charCodeAt(++state.position);
	            scalar.endPosition = state.position;
	            if (0x27 === ch) {
	                captureStart = captureEnd = state.position;
	                state.position++;
	            }
	            else {
	                return true;
	            }
	        }
	        else if (is_EOL(ch)) {
	            captureSegment(state, captureStart, captureEnd, true);
	            writeFoldedLines(state, scalar, skipSeparationSpace(state, false, nodeIndent));
	            captureStart = captureEnd = state.position;
	        }
	        else if (state.position === state.lineStart && testDocumentSeparator(state)) {
	            throwError(state, 'unexpected end of the document within a single quoted scalar');
	        }
	        else {
	            state.position++;
	            captureEnd = state.position;
	            scalar.endPosition = state.position;
	        }
	    }
	    throwError(state, 'unexpected end of the stream within a single quoted scalar');
	}
	function readDoubleQuotedScalar(state, nodeIndent) {
	    var captureStart, captureEnd, hexLength, hexResult, tmp, tmpEsc, ch;
	    ch = state.input.charCodeAt(state.position);
	    if (0x22 !== ch) {
	        return false;
	    }
	    state.kind = 'scalar';
	    var scalar = ast.newScalar();
	    scalar.doubleQuoted = true;
	    state.result = scalar;
	    scalar.startPosition = state.position;
	    state.position++;
	    captureStart = captureEnd = state.position;
	    while (0 !== (ch = state.input.charCodeAt(state.position))) {
	        if (0x22 === ch) {
	            captureSegment(state, captureStart, state.position, true);
	            state.position++;
	            scalar.endPosition = state.position;
	            return true;
	        }
	        else if (0x5C === ch) {
	            captureSegment(state, captureStart, state.position, true);
	            ch = state.input.charCodeAt(++state.position);
	            if (is_EOL(ch)) {
	                skipSeparationSpace(state, false, nodeIndent);
	            }
	            else if (ch < 256 && simpleEscapeCheck[ch]) {
	                scalar.value += simpleEscapeMap[ch];
	                state.position++;
	            }
	            else if ((tmp = escapedHexLen(ch)) > 0) {
	                hexLength = tmp;
	                hexResult = 0;
	                for (; hexLength > 0; hexLength--) {
	                    ch = state.input.charCodeAt(++state.position);
	                    if ((tmp = fromHexCode(ch)) >= 0) {
	                        hexResult = (hexResult << 4) + tmp;
	                    }
	                    else {
	                        throwError(state, 'expected hexadecimal character');
	                    }
	                }
	                scalar.value += charFromCodepoint(hexResult);
	                state.position++;
	            }
	            else {
	                throwError(state, 'unknown escape sequence');
	            }
	            captureStart = captureEnd = state.position;
	        }
	        else if (is_EOL(ch)) {
	            captureSegment(state, captureStart, captureEnd, true);
	            writeFoldedLines(state, scalar, skipSeparationSpace(state, false, nodeIndent));
	            captureStart = captureEnd = state.position;
	        }
	        else if (state.position === state.lineStart && testDocumentSeparator(state)) {
	            throwError(state, 'unexpected end of the document within a double quoted scalar');
	        }
	        else {
	            state.position++;
	            captureEnd = state.position;
	        }
	    }
	    throwError(state, 'unexpected end of the stream within a double quoted scalar');
	}
	function readFlowCollection(state, nodeIndent) {
	    var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, keyNode, keyTag, valueNode, ch;
	    ch = state.input.charCodeAt(state.position);
	    if (ch === 0x5B) {
	        terminator = 0x5D;
	        isMapping = false;
	        _result = ast.newItems();
	        _result.startPosition = state.position;
	    }
	    else if (ch === 0x7B) {
	        terminator = 0x7D;
	        isMapping = true;
	        _result = ast.newMap();
	        _result.startPosition = state.position;
	    }
	    else {
	        return false;
	    }
	    if (null !== state.anchor) {
	        _result.anchorId = state.anchor;
	        state.anchorMap[state.anchor] = _result;
	    }
	    ch = state.input.charCodeAt(++state.position);
	    while (0 !== ch) {
	        skipSeparationSpace(state, true, nodeIndent);
	        ch = state.input.charCodeAt(state.position);
	        if (ch === terminator) {
	            state.position++;
	            state.tag = _tag;
	            state.anchor = _anchor;
	            state.kind = isMapping ? 'mapping' : 'sequence';
	            state.result = _result;
	            _result.endPosition = state.position;
	            return true;
	        }
	        else if (!readNext) {
	            var p = state.position;
	            throwError(state, 'missed comma between flow collection entries');
	            state.position = p + 1;
	        }
	        keyTag = keyNode = valueNode = null;
	        isPair = isExplicitPair = false;
	        if (0x3F === ch) {
	            following = state.input.charCodeAt(state.position + 1);
	            if (is_WS_OR_EOL(following)) {
	                isPair = isExplicitPair = true;
	                state.position++;
	                skipSeparationSpace(state, true, nodeIndent);
	            }
	        }
	        _line = state.line;
	        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
	        keyTag = state.tag;
	        keyNode = state.result;
	        skipSeparationSpace(state, true, nodeIndent);
	        ch = state.input.charCodeAt(state.position);
	        if ((isExplicitPair || state.line === _line) && 0x3A === ch) {
	            isPair = true;
	            ch = state.input.charCodeAt(++state.position);
	            skipSeparationSpace(state, true, nodeIndent);
	            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
	            valueNode = state.result;
	        }
	        if (isMapping) {
	            storeMappingPair(state, _result, keyTag, keyNode, valueNode);
	        }
	        else if (isPair) {
	            var mp = storeMappingPair(state, null, keyTag, keyNode, valueNode);
	            mp.parent = _result;
	            _result.items.push(mp);
	        }
	        else {
	            keyNode.parent = _result;
	            _result.items.push(keyNode);
	        }
	        _result.endPosition = state.position + 1;
	        skipSeparationSpace(state, true, nodeIndent);
	        ch = state.input.charCodeAt(state.position);
	        if (0x2C === ch) {
	            readNext = true;
	            ch = state.input.charCodeAt(++state.position);
	        }
	        else {
	            readNext = false;
	        }
	    }
	    throwError(state, 'unexpected end of the stream within a flow collection');
	}
	function readBlockScalar(state, nodeIndent) {
	    var captureStart, folding, chomping = CHOMPING_CLIP, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
	    ch = state.input.charCodeAt(state.position);
	    if (ch === 0x7C) {
	        folding = false;
	    }
	    else if (ch === 0x3E) {
	        folding = true;
	    }
	    else {
	        return false;
	    }
	    var sc = ast.newScalar();
	    state.kind = 'scalar';
	    state.result = sc;
	    sc.startPosition = state.position;
	    while (0 !== ch) {
	        ch = state.input.charCodeAt(++state.position);
	        if (0x2B === ch || 0x2D === ch) {
	            if (CHOMPING_CLIP === chomping) {
	                chomping = (0x2B === ch) ? CHOMPING_KEEP : CHOMPING_STRIP;
	            }
	            else {
	                throwError(state, 'repeat of a chomping mode identifier');
	            }
	        }
	        else if ((tmp = fromDecimalCode(ch)) >= 0) {
	            if (tmp === 0) {
	                throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
	            }
	            else if (!detectedIndent) {
	                textIndent = nodeIndent + tmp - 1;
	                detectedIndent = true;
	            }
	            else {
	                throwError(state, 'repeat of an indentation width identifier');
	            }
	        }
	        else {
	            break;
	        }
	    }
	    if (is_WHITE_SPACE(ch)) {
	        do {
	            ch = state.input.charCodeAt(++state.position);
	        } while (is_WHITE_SPACE(ch));
	        if (0x23 === ch) {
	            do {
	                ch = state.input.charCodeAt(++state.position);
	            } while (!is_EOL(ch) && (0 !== ch));
	        }
	    }
	    while (0 !== ch) {
	        readLineBreak(state);
	        state.lineIndent = 0;
	        ch = state.input.charCodeAt(state.position);
	        while ((!detectedIndent || state.lineIndent < textIndent) &&
	            (0x20 === ch)) {
	            state.lineIndent++;
	            ch = state.input.charCodeAt(++state.position);
	        }
	        if (!detectedIndent && state.lineIndent > textIndent) {
	            textIndent = state.lineIndent;
	        }
	        if (is_EOL(ch)) {
	            emptyLines++;
	            continue;
	        }
	        if (state.lineIndent < textIndent) {
	            if (chomping === CHOMPING_KEEP) {
	                sc.value += common.repeat('\n', emptyLines);
	            }
	            else if (chomping === CHOMPING_CLIP) {
	                if (detectedIndent) {
	                    sc.value += '\n';
	                }
	            }
	            break;
	        }
	        if (folding) {
	            if (is_WHITE_SPACE(ch)) {
	                atMoreIndented = true;
	                sc.value += common.repeat('\n', emptyLines + 1);
	            }
	            else if (atMoreIndented) {
	                atMoreIndented = false;
	                sc.value += common.repeat('\n', emptyLines + 1);
	            }
	            else if (0 === emptyLines) {
	                if (detectedIndent) {
	                    sc.value += ' ';
	                }
	            }
	            else {
	                sc.value += common.repeat('\n', emptyLines);
	            }
	        }
	        else if (detectedIndent) {
	            sc.value += common.repeat('\n', emptyLines + 1);
	        }
	        else {
	        }
	        detectedIndent = true;
	        emptyLines = 0;
	        captureStart = state.position;
	        while (!is_EOL(ch) && (0 !== ch)) {
	            ch = state.input.charCodeAt(++state.position);
	        }
	        captureSegment(state, captureStart, state.position, false);
	    }
	    sc.endPosition = state.position;
	    var i = state.position - 1;
	    var needMinus = false;
	    while (true) {
	        var c = state.input[i];
	        if (c == '\r' || c == '\n') {
	            if (needMinus) {
	                i--;
	            }
	            break;
	        }
	        if (c != ' ' && c != '\t') {
	            break;
	        }
	        i--;
	    }
	    sc.endPosition = i;
	    return true;
	}
	function readBlockSequence(state, nodeIndent) {
	    var _line, _tag = state.tag, _anchor = state.anchor, _result = ast.newItems(), following, detected = false, ch;
	    if (null !== state.anchor) {
	        _result.anchorId = state.anchor;
	        state.anchorMap[state.anchor] = _result;
	    }
	    _result.startPosition = state.position;
	    ch = state.input.charCodeAt(state.position);
	    while (0 !== ch) {
	        if (0x2D !== ch) {
	            break;
	        }
	        following = state.input.charCodeAt(state.position + 1);
	        if (!is_WS_OR_EOL(following)) {
	            break;
	        }
	        detected = true;
	        state.position++;
	        if (skipSeparationSpace(state, true, -1)) {
	            if (state.lineIndent <= nodeIndent) {
	                _result.items.push(null);
	                ch = state.input.charCodeAt(state.position);
	                continue;
	            }
	        }
	        _line = state.line;
	        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
	        state.result.parent = _result;
	        _result.items.push(state.result);
	        skipSeparationSpace(state, true, -1);
	        ch = state.input.charCodeAt(state.position);
	        if ((state.line === _line || state.lineIndent > nodeIndent) && (0 !== ch)) {
	            throwError(state, 'bad indentation of a sequence entry');
	        }
	        else if (state.lineIndent < nodeIndent) {
	            break;
	        }
	    }
	    _result.endPosition = state.position;
	    if (detected) {
	        state.tag = _tag;
	        state.anchor = _anchor;
	        state.kind = 'sequence';
	        state.result = _result;
	        _result.endPosition = state.position;
	        return true;
	    }
	    return false;
	}
	function readBlockMapping(state, nodeIndent, flowIndent) {
	    var following, allowCompact, _line, _tag = state.tag, _anchor = state.anchor, _result = ast.newMap(), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
	    _result.startPosition = state.position;
	    if (null !== state.anchor) {
	        _result.anchorId = state.anchor;
	        state.anchorMap[state.anchor] = _result;
	    }
	    ch = state.input.charCodeAt(state.position);
	    while (0 !== ch) {
	        following = state.input.charCodeAt(state.position + 1);
	        _line = state.line;
	        if ((0x3F === ch || 0x3A === ch) && is_WS_OR_EOL(following)) {
	            if (0x3F === ch) {
	                if (atExplicitKey) {
	                    storeMappingPair(state, _result, keyTag, keyNode, null);
	                    keyTag = keyNode = valueNode = null;
	                }
	                detected = true;
	                atExplicitKey = true;
	                allowCompact = true;
	            }
	            else if (atExplicitKey) {
	                atExplicitKey = false;
	                allowCompact = true;
	            }
	            else {
	                throwError(state, 'incomplete explicit mapping pair; a key node is missed');
	            }
	            state.position += 1;
	            ch = following;
	        }
	        else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
	            if (state.line === _line) {
	                ch = state.input.charCodeAt(state.position);
	                while (is_WHITE_SPACE(ch)) {
	                    ch = state.input.charCodeAt(++state.position);
	                }
	                if (0x3A === ch) {
	                    ch = state.input.charCodeAt(++state.position);
	                    if (!is_WS_OR_EOL(ch)) {
	                        throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
	                    }
	                    if (atExplicitKey) {
	                        storeMappingPair(state, _result, keyTag, keyNode, null);
	                        keyTag = keyNode = valueNode = null;
	                    }
	                    detected = true;
	                    atExplicitKey = false;
	                    allowCompact = false;
	                    keyTag = state.tag;
	                    keyNode = state.result;
	                }
	                else if (detected) {
	                    throwError(state, 'can not read an implicit mapping pair; a colon is missed');
	                }
	                else {
	                    state.tag = _tag;
	                    state.anchor = _anchor;
	                    return true;
	                }
	            }
	            else if (detected) {
	                throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
	                while (state.position > 0) {
	                    ch = state.input.charCodeAt(--state.position);
	                    if (is_EOL(ch)) {
	                        state.position++;
	                        break;
	                    }
	                }
	            }
	            else {
	                state.tag = _tag;
	                state.anchor = _anchor;
	                return true;
	            }
	        }
	        else {
	            break;
	        }
	        if (state.line === _line || state.lineIndent > nodeIndent) {
	            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
	                if (atExplicitKey) {
	                    keyNode = state.result;
	                }
	                else {
	                    valueNode = state.result;
	                }
	            }
	            if (!atExplicitKey) {
	                storeMappingPair(state, _result, keyTag, keyNode, valueNode);
	                keyTag = keyNode = valueNode = null;
	            }
	            skipSeparationSpace(state, true, -1);
	            ch = state.input.charCodeAt(state.position);
	        }
	        if (state.lineIndent > nodeIndent && (0 !== ch)) {
	            throwError(state, 'bad indentation of a mapping entry');
	        }
	        else if (state.lineIndent < nodeIndent) {
	            break;
	        }
	    }
	    if (atExplicitKey) {
	        storeMappingPair(state, _result, keyTag, keyNode, null);
	    }
	    if (detected) {
	        state.tag = _tag;
	        state.anchor = _anchor;
	        state.kind = 'mapping';
	        state.result = _result;
	    }
	    return detected;
	}
	function readTagProperty(state) {
	    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
	    ch = state.input.charCodeAt(state.position);
	    if (0x21 !== ch) {
	        return false;
	    }
	    if (null !== state.tag) {
	        throwError(state, 'duplication of a tag property');
	    }
	    ch = state.input.charCodeAt(++state.position);
	    if (0x3C === ch) {
	        isVerbatim = true;
	        ch = state.input.charCodeAt(++state.position);
	    }
	    else if (0x21 === ch) {
	        isNamed = true;
	        tagHandle = '!!';
	        ch = state.input.charCodeAt(++state.position);
	    }
	    else {
	        tagHandle = '!';
	    }
	    _position = state.position;
	    if (isVerbatim) {
	        do {
	            ch = state.input.charCodeAt(++state.position);
	        } while (0 !== ch && 0x3E !== ch);
	        if (state.position < state.length) {
	            tagName = state.input.slice(_position, state.position);
	            ch = state.input.charCodeAt(++state.position);
	        }
	        else {
	            throwError(state, 'unexpected end of the stream within a verbatim tag');
	        }
	    }
	    else {
	        while (0 !== ch && !is_WS_OR_EOL(ch)) {
	            if (0x21 === ch) {
	                if (!isNamed) {
	                    tagHandle = state.input.slice(_position - 1, state.position + 1);
	                    if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
	                        throwError(state, 'named tag handle cannot contain such characters');
	                    }
	                    isNamed = true;
	                    _position = state.position + 1;
	                }
	                else {
	                    throwError(state, 'tag suffix cannot contain exclamation marks');
	                }
	            }
	            ch = state.input.charCodeAt(++state.position);
	        }
	        tagName = state.input.slice(_position, state.position);
	        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
	            throwError(state, 'tag suffix cannot contain flow indicator characters');
	        }
	    }
	    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
	        throwError(state, 'tag name cannot contain such characters: ' + tagName);
	    }
	    if (isVerbatim) {
	        state.tag = tagName;
	    }
	    else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
	        state.tag = state.tagMap[tagHandle] + tagName;
	    }
	    else if ('!' === tagHandle) {
	        state.tag = '!' + tagName;
	    }
	    else if ('!!' === tagHandle) {
	        state.tag = 'tag:yaml.org,2002:' + tagName;
	    }
	    else {
	        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
	    }
	    return true;
	}
	function readAnchorProperty(state) {
	    var _position, ch;
	    ch = state.input.charCodeAt(state.position);
	    if (0x26 !== ch) {
	        return false;
	    }
	    if (null !== state.anchor) {
	        throwError(state, 'duplication of an anchor property');
	    }
	    ch = state.input.charCodeAt(++state.position);
	    _position = state.position;
	    while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
	        ch = state.input.charCodeAt(++state.position);
	    }
	    if (state.position === _position) {
	        throwError(state, 'name of an anchor node must contain at least one character');
	    }
	    state.anchor = state.input.slice(_position, state.position);
	    return true;
	}
	function readAlias(state) {
	    var _position, alias, len = state.length, input = state.input, ch;
	    ch = state.input.charCodeAt(state.position);
	    if (0x2A !== ch) {
	        return false;
	    }
	    ch = state.input.charCodeAt(++state.position);
	    _position = state.position;
	    while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
	        ch = state.input.charCodeAt(++state.position);
	    }
	    if (state.position <= _position) {
	        throwError(state, 'name of an alias node must contain at least one character');
	        state.position = _position + 1;
	    }
	    alias = state.input.slice(_position, state.position);
	    if (!state.anchorMap.hasOwnProperty(alias)) {
	        throwError(state, 'unidentified alias "' + alias + '"');
	        if (state.position <= _position) {
	            state.position = _position + 1;
	        }
	    }
	    state.result = ast.newAnchorRef(alias, _position, state.position, state.anchorMap[alias]);
	    skipSeparationSpace(state, true, -1);
	    return true;
	}
	function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
	    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent, _result;
	    state.tag = null;
	    state.anchor = null;
	    state.kind = null;
	    state.result = null;
	    allowBlockStyles = allowBlockScalars = allowBlockCollections =
	        CONTEXT_BLOCK_OUT === nodeContext ||
	            CONTEXT_BLOCK_IN === nodeContext;
	    if (allowToSeek) {
	        if (skipSeparationSpace(state, true, -1)) {
	            atNewLine = true;
	            if (state.lineIndent > parentIndent) {
	                indentStatus = 1;
	            }
	            else if (state.lineIndent === parentIndent) {
	                indentStatus = 0;
	            }
	            else if (state.lineIndent < parentIndent) {
	                indentStatus = -1;
	            }
	        }
	    }
	    if (1 === indentStatus) {
	        while (readTagProperty(state) || readAnchorProperty(state)) {
	            if (skipSeparationSpace(state, true, -1)) {
	                atNewLine = true;
	                allowBlockCollections = allowBlockStyles;
	                if (state.lineIndent > parentIndent) {
	                    indentStatus = 1;
	                }
	                else if (state.lineIndent === parentIndent) {
	                    indentStatus = 0;
	                }
	                else if (state.lineIndent < parentIndent) {
	                    indentStatus = -1;
	                }
	            }
	            else {
	                allowBlockCollections = false;
	            }
	        }
	    }
	    if (allowBlockCollections) {
	        allowBlockCollections = atNewLine || allowCompact;
	    }
	    if (1 === indentStatus || CONTEXT_BLOCK_OUT === nodeContext) {
	        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
	            flowIndent = parentIndent;
	        }
	        else {
	            flowIndent = parentIndent + 1;
	        }
	        blockIndent = state.position - state.lineStart;
	        if (1 === indentStatus) {
	            if (allowBlockCollections &&
	                (readBlockSequence(state, blockIndent) ||
	                    readBlockMapping(state, blockIndent, flowIndent)) ||
	                readFlowCollection(state, flowIndent)) {
	                hasContent = true;
	            }
	            else {
	                if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
	                    readSingleQuotedScalar(state, flowIndent) ||
	                    readDoubleQuotedScalar(state, flowIndent)) {
	                    hasContent = true;
	                }
	                else if (readAlias(state)) {
	                    hasContent = true;
	                    if (null !== state.tag || null !== state.anchor) {
	                        throwError(state, 'alias node should not have any properties');
	                    }
	                }
	                else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
	                    hasContent = true;
	                    if (null === state.tag) {
	                        state.tag = '?';
	                    }
	                }
	                if (null !== state.anchor) {
	                    state.anchorMap[state.anchor] = state.result;
	                    state.result.anchorId = state.anchor;
	                }
	            }
	        }
	        else if (0 === indentStatus) {
	            hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
	        }
	    }
	    if (null !== state.tag && '!' !== state.tag) {
	        if (state.tag == "!include") {
	            if (!state.result) {
	                state.result = ast.newScalar();
	                state.result.startPosition = state.position;
	                state.result.endPosition = state.position;
	                throwError(state, "!include without value");
	            }
	            state.result.kind = ast.Kind.INCLUDE_REF;
	        }
	        else if ('?' === state.tag) {
	            for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
	                type = state.implicitTypes[typeIndex];
	                var vl = state.result['value'];
	                if (type.resolve(vl)) {
	                    state.result.valueObject = type.construct(state.result['value']);
	                    state.tag = type.tag;
	                    if (null !== state.anchor) {
	                        state.result.anchorId = state.anchor;
	                        state.anchorMap[state.anchor] = state.result;
	                    }
	                    break;
	                }
	            }
	        }
	        else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
	            type = state.typeMap[state.tag];
	            if (null !== state.result && type.kind !== state.kind) {
	                throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
	            }
	            if (!type.resolve(state.result)) {
	                throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
	            }
	            else {
	                state.result = type.construct(state.result);
	                if (null !== state.anchor) {
	                    state.result.anchorId = state.anchor;
	                    state.anchorMap[state.anchor] = state.result;
	                }
	            }
	        }
	        else {
	            throwWarning(state, 'unknown tag !<' + state.tag + '>');
	        }
	    }
	    return null !== state.tag || null !== state.anchor || hasContent;
	}
	function readDocument(state) {
	    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
	    state.version = null;
	    state.checkLineBreaks = state.legacy;
	    state.tagMap = {};
	    state.anchorMap = {};
	    while (0 !== (ch = state.input.charCodeAt(state.position))) {
	        skipSeparationSpace(state, true, -1);
	        ch = state.input.charCodeAt(state.position);
	        if (state.lineIndent > 0 || 0x25 !== ch) {
	            break;
	        }
	        hasDirectives = true;
	        ch = state.input.charCodeAt(++state.position);
	        _position = state.position;
	        while (0 !== ch && !is_WS_OR_EOL(ch)) {
	            ch = state.input.charCodeAt(++state.position);
	        }
	        directiveName = state.input.slice(_position, state.position);
	        directiveArgs = [];
	        if (directiveName.length < 1) {
	            throwError(state, 'directive name must not be less than one character in length');
	        }
	        while (0 !== ch) {
	            while (is_WHITE_SPACE(ch)) {
	                ch = state.input.charCodeAt(++state.position);
	            }
	            if (0x23 === ch) {
	                do {
	                    ch = state.input.charCodeAt(++state.position);
	                } while (0 !== ch && !is_EOL(ch));
	                break;
	            }
	            if (is_EOL(ch)) {
	                break;
	            }
	            _position = state.position;
	            while (0 !== ch && !is_WS_OR_EOL(ch)) {
	                ch = state.input.charCodeAt(++state.position);
	            }
	            directiveArgs.push(state.input.slice(_position, state.position));
	        }
	        if (0 !== ch) {
	            readLineBreak(state);
	        }
	        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
	            directiveHandlers[directiveName](state, directiveName, directiveArgs);
	        }
	        else {
	            throwWarning(state, 'unknown document directive "' + directiveName + '"');
	            state.position++;
	        }
	    }
	    skipSeparationSpace(state, true, -1);
	    if (0 === state.lineIndent &&
	        0x2D === state.input.charCodeAt(state.position) &&
	        0x2D === state.input.charCodeAt(state.position + 1) &&
	        0x2D === state.input.charCodeAt(state.position + 2)) {
	        state.position += 3;
	        skipSeparationSpace(state, true, -1);
	    }
	    else if (hasDirectives) {
	        throwError(state, 'directives end mark is expected');
	    }
	    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
	    skipSeparationSpace(state, true, -1);
	    if (state.checkLineBreaks &&
	        PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
	        throwWarning(state, 'non-ASCII line breaks are interpreted as content');
	    }
	    state.documents.push(state.result);
	    if (state.position === state.lineStart && testDocumentSeparator(state)) {
	        if (0x2E === state.input.charCodeAt(state.position)) {
	            state.position += 3;
	            skipSeparationSpace(state, true, -1);
	        }
	        return;
	    }
	    if (state.position < (state.length - 1)) {
	        throwError(state, 'end of the stream or a document separator is expected');
	    }
	    else {
	        return;
	    }
	}
	function loadDocuments(input, options) {
	    input = String(input);
	    options = options || {};
	    if (input.length !== 0) {
	        if (0x0A !== input.charCodeAt(input.length - 1) &&
	            0x0D !== input.charCodeAt(input.length - 1)) {
	            input += '\n';
	        }
	        if (input.charCodeAt(0) === 0xFEFF) {
	            input = input.slice(1);
	        }
	    }
	    var state = new State(input, options);
	    if (PATTERN_NON_PRINTABLE.test(state.input)) {
	        throwError(state, 'the stream contains non-printable characters');
	    }
	    state.input += '\0';
	    while (0x20 === state.input.charCodeAt(state.position)) {
	        state.lineIndent += 1;
	        state.position += 1;
	    }
	    while (state.position < (state.length - 1)) {
	        var q = state.position;
	        readDocument(state);
	        if (state.position <= q) {
	            for (; state.position < state.length - 1; state.position++) {
	                var c = state.input.charAt(state.position);
	                if (c == '\n') {
	                    break;
	                }
	            }
	        }
	    }
	    state.documents.forEach(function (x) { return x.errors = state.errors; });
	    return state.documents;
	}
	function loadAll(input, iterator, options) {
	    var documents = loadDocuments(input, options), index, length;
	    for (index = 0, length = documents.length; index < length; index += 1) {
	        iterator(documents[index]);
	    }
	}
	exports.loadAll = loadAll;
	function load(input, options) {
	    var documents = loadDocuments(input, options), index, length;
	    if (0 === documents.length) {
	        return undefined;
	    }
	    else if (1 === documents.length) {
	        var result = documents[0];
	        result.endPosition = input.length;
	        if (result.startPosition > result.endPosition) {
	            result.startPosition = result.endPosition;
	        }
	        return result;
	    }
	    var e = new YAMLException('expected a single document in the stream, but found more');
	    e.mark = new Mark("", "", 0, 0, 0);
	    e.mark.position = documents[0].endPosition;
	    documents[0].errors.push(e);
	    return documents[0];
	}
	exports.load = load;
	function safeLoadAll(input, output, options) {
	    loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}
	exports.safeLoadAll = safeLoadAll;
	function safeLoad(input, options) {
	    return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}
	exports.safeLoad = safeLoad;
	module.exports.loadAll = loadAll;
	module.exports.load = load;
	module.exports.safeLoadAll = safeLoadAll;
	module.exports.safeLoad = safeLoad;
	//# sourceMappingURL=loader.js.map

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var common = __webpack_require__(110);
	var YAMLException = __webpack_require__(111);
	var DEFAULT_FULL_SCHEMA = __webpack_require__(132);
	var DEFAULT_SAFE_SCHEMA = __webpack_require__(133);
	var _toString = Object.prototype.toString;
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	var CHAR_TAB = 0x09;
	var CHAR_LINE_FEED = 0x0A;
	var CHAR_CARRIAGE_RETURN = 0x0D;
	var CHAR_SPACE = 0x20;
	var CHAR_EXCLAMATION = 0x21;
	var CHAR_DOUBLE_QUOTE = 0x22;
	var CHAR_SHARP = 0x23;
	var CHAR_PERCENT = 0x25;
	var CHAR_AMPERSAND = 0x26;
	var CHAR_SINGLE_QUOTE = 0x27;
	var CHAR_ASTERISK = 0x2A;
	var CHAR_COMMA = 0x2C;
	var CHAR_MINUS = 0x2D;
	var CHAR_COLON = 0x3A;
	var CHAR_GREATER_THAN = 0x3E;
	var CHAR_QUESTION = 0x3F;
	var CHAR_COMMERCIAL_AT = 0x40;
	var CHAR_LEFT_SQUARE_BRACKET = 0x5B;
	var CHAR_RIGHT_SQUARE_BRACKET = 0x5D;
	var CHAR_GRAVE_ACCENT = 0x60;
	var CHAR_LEFT_CURLY_BRACKET = 0x7B;
	var CHAR_VERTICAL_LINE = 0x7C;
	var CHAR_RIGHT_CURLY_BRACKET = 0x7D;
	var ESCAPE_SEQUENCES = {};
	ESCAPE_SEQUENCES[0x00] = '\\0';
	ESCAPE_SEQUENCES[0x07] = '\\a';
	ESCAPE_SEQUENCES[0x08] = '\\b';
	ESCAPE_SEQUENCES[0x09] = '\\t';
	ESCAPE_SEQUENCES[0x0A] = '\\n';
	ESCAPE_SEQUENCES[0x0B] = '\\v';
	ESCAPE_SEQUENCES[0x0C] = '\\f';
	ESCAPE_SEQUENCES[0x0D] = '\\r';
	ESCAPE_SEQUENCES[0x1B] = '\\e';
	ESCAPE_SEQUENCES[0x22] = '\\"';
	ESCAPE_SEQUENCES[0x5C] = '\\\\';
	ESCAPE_SEQUENCES[0x85] = '\\N';
	ESCAPE_SEQUENCES[0xA0] = '\\_';
	ESCAPE_SEQUENCES[0x2028] = '\\L';
	ESCAPE_SEQUENCES[0x2029] = '\\P';
	var DEPRECATED_BOOLEANS_SYNTAX = [
	    'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
	    'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
	];
	function compileStyleMap(schema, map) {
	    var result, keys, index, length, tag, style, type;
	    if (null === map) {
	        return {};
	    }
	    result = {};
	    keys = Object.keys(map);
	    for (index = 0, length = keys.length; index < length; index += 1) {
	        tag = keys[index];
	        style = String(map[tag]);
	        if ('!!' === tag.slice(0, 2)) {
	            tag = 'tag:yaml.org,2002:' + tag.slice(2);
	        }
	        type = schema.compiledTypeMap[tag];
	        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
	            style = type.styleAliases[style];
	        }
	        result[tag] = style;
	    }
	    return result;
	}
	function encodeHex(character) {
	    var string, handle, length;
	    string = character.toString(16).toUpperCase();
	    if (character <= 0xFF) {
	        handle = 'x';
	        length = 2;
	    }
	    else if (character <= 0xFFFF) {
	        handle = 'u';
	        length = 4;
	    }
	    else if (character <= 0xFFFFFFFF) {
	        handle = 'U';
	        length = 8;
	    }
	    else {
	        throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
	    }
	    return '\\' + handle + common.repeat('0', length - string.length) + string;
	}
	function State(options) {
	    this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
	    this.indent = Math.max(1, (options['indent'] || 2));
	    this.skipInvalid = options['skipInvalid'] || false;
	    this.flowLevel = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
	    this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
	    this.implicitTypes = this.schema.compiledImplicit;
	    this.explicitTypes = this.schema.compiledExplicit;
	    this.tag = null;
	    this.result = '';
	    this.duplicates = [];
	    this.usedDuplicates = null;
	}
	function indentString(string, spaces) {
	    var ind = common.repeat(' ', spaces), position = 0, next = -1, result = '', line, length = string.length;
	    while (position < length) {
	        next = string.indexOf('\n', position);
	        if (next === -1) {
	            line = string.slice(position);
	            position = length;
	        }
	        else {
	            line = string.slice(position, next + 1);
	            position = next + 1;
	        }
	        if (line.length && line !== '\n') {
	            result += ind;
	        }
	        result += line;
	    }
	    return result;
	}
	function generateNextLine(state, level) {
	    return '\n' + common.repeat(' ', state.indent * level);
	}
	function testImplicitResolving(state, str) {
	    var index, length, type;
	    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
	        type = state.implicitTypes[index];
	        if (type.resolve(str)) {
	            return true;
	        }
	    }
	    return false;
	}
	function StringBuilder(source) {
	    this.source = source;
	    this.result = '';
	    this.checkpoint = 0;
	}
	StringBuilder.prototype.takeUpTo = function (position) {
	    var er;
	    if (position < this.checkpoint) {
	        er = new Error('position should be > checkpoint');
	        er.position = position;
	        er.checkpoint = this.checkpoint;
	        throw er;
	    }
	    this.result += this.source.slice(this.checkpoint, position);
	    this.checkpoint = position;
	    return this;
	};
	StringBuilder.prototype.escapeChar = function () {
	    var character, esc;
	    character = this.source.charCodeAt(this.checkpoint);
	    esc = ESCAPE_SEQUENCES[character] || encodeHex(character);
	    this.result += esc;
	    this.checkpoint += 1;
	    return this;
	};
	StringBuilder.prototype.finish = function () {
	    if (this.source.length > this.checkpoint) {
	        this.takeUpTo(this.source.length);
	    }
	};
	function writeScalar(state, object, level) {
	    var simple, first, spaceWrap, folded, literal, single, double, sawLineFeed, linePosition, longestLine, indent, max, character, position, escapeSeq, hexEsc, previous, lineLength, modifier, trailingLineBreaks, result;
	    if (0 === object.length) {
	        state.dump = "''";
	        return;
	    }
	    if (object.indexOf("!include") == 0) {
	        state.dump = "" + object;
	        return;
	    }
	    if (object.indexOf("!$$$novalue") == 0) {
	        state.dump = "";
	        return;
	    }
	    if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {
	        state.dump = "'" + object + "'";
	        return;
	    }
	    simple = true;
	    first = object.length ? object.charCodeAt(0) : 0;
	    spaceWrap = (CHAR_SPACE === first ||
	        CHAR_SPACE === object.charCodeAt(object.length - 1));
	    if (CHAR_MINUS === first ||
	        CHAR_QUESTION === first ||
	        CHAR_COMMERCIAL_AT === first ||
	        CHAR_GRAVE_ACCENT === first) {
	        simple = false;
	    }
	    if (spaceWrap) {
	        simple = false;
	        folded = false;
	        literal = false;
	    }
	    else {
	        folded = true;
	        literal = true;
	    }
	    single = true;
	    double = new StringBuilder(object);
	    sawLineFeed = false;
	    linePosition = 0;
	    longestLine = 0;
	    indent = state.indent * level;
	    max = 80;
	    if (indent < 40) {
	        max -= indent;
	    }
	    else {
	        max = 40;
	    }
	    for (position = 0; position < object.length; position++) {
	        character = object.charCodeAt(position);
	        if (simple) {
	            if (!simpleChar(character)) {
	                simple = false;
	            }
	            else {
	                continue;
	            }
	        }
	        if (single && character === CHAR_SINGLE_QUOTE) {
	            single = false;
	        }
	        escapeSeq = ESCAPE_SEQUENCES[character];
	        hexEsc = needsHexEscape(character);
	        if (!escapeSeq && !hexEsc) {
	            continue;
	        }
	        if (character !== CHAR_LINE_FEED &&
	            character !== CHAR_DOUBLE_QUOTE &&
	            character !== CHAR_SINGLE_QUOTE) {
	            folded = false;
	            literal = false;
	        }
	        else if (character === CHAR_LINE_FEED) {
	            sawLineFeed = true;
	            single = false;
	            if (position > 0) {
	                previous = object.charCodeAt(position - 1);
	                if (previous === CHAR_SPACE) {
	                    literal = false;
	                    folded = false;
	                }
	            }
	            if (folded) {
	                lineLength = position - linePosition;
	                linePosition = position;
	                if (lineLength > longestLine) {
	                    longestLine = lineLength;
	                }
	            }
	        }
	        if (character !== CHAR_DOUBLE_QUOTE) {
	            single = false;
	        }
	        double.takeUpTo(position);
	        double.escapeChar();
	    }
	    if (simple && testImplicitResolving(state, object)) {
	        simple = false;
	    }
	    modifier = '';
	    if (folded || literal) {
	        trailingLineBreaks = 0;
	        if (object.charCodeAt(object.length - 1) === CHAR_LINE_FEED) {
	            trailingLineBreaks += 1;
	            if (object.charCodeAt(object.length - 2) === CHAR_LINE_FEED) {
	                trailingLineBreaks += 1;
	            }
	        }
	        if (trailingLineBreaks === 0) {
	            modifier = '-';
	        }
	        else if (trailingLineBreaks === 2) {
	            modifier = '+';
	        }
	    }
	    if (literal && longestLine < max) {
	        folded = false;
	    }
	    if (!sawLineFeed) {
	        literal = false;
	    }
	    if (simple) {
	        state.dump = object;
	    }
	    else if (single) {
	        state.dump = '\'' + object + '\'';
	    }
	    else if (folded) {
	        result = fold(object, max);
	        state.dump = '>' + modifier + '\n' + indentString(result, indent);
	    }
	    else if (literal) {
	        if (!modifier) {
	            object = object.replace(/\n$/, '');
	        }
	        state.dump = '|' + modifier + '\n' + indentString(object, indent);
	    }
	    else if (double) {
	        double.finish();
	        state.dump = '"' + double.result + '"';
	    }
	    else {
	        throw new Error('Failed to dump scalar value');
	    }
	    return;
	}
	function fold(object, max) {
	    var result = '', position = 0, length = object.length, trailing = /\n+$/.exec(object), newLine;
	    if (trailing) {
	        length = trailing.index + 1;
	    }
	    while (position < length) {
	        newLine = object.indexOf('\n', position);
	        if (newLine > length || newLine === -1) {
	            if (result) {
	                result += '\n\n';
	            }
	            result += foldLine(object.slice(position, length), max);
	            position = length;
	        }
	        else {
	            if (result) {
	                result += '\n\n';
	            }
	            result += foldLine(object.slice(position, newLine), max);
	            position = newLine + 1;
	        }
	    }
	    if (trailing && trailing[0] !== '\n') {
	        result += trailing[0];
	    }
	    return result;
	}
	function foldLine(line, max) {
	    if (line === '') {
	        return line;
	    }
	    var foldRe = /[^\s] [^\s]/g, result = '', prevMatch = 0, foldStart = 0, match = foldRe.exec(line), index, foldEnd, folded;
	    while (match) {
	        index = match.index;
	        if (index - foldStart > max) {
	            if (prevMatch !== foldStart) {
	                foldEnd = prevMatch;
	            }
	            else {
	                foldEnd = index;
	            }
	            if (result) {
	                result += '\n';
	            }
	            folded = line.slice(foldStart, foldEnd);
	            result += folded;
	            foldStart = foldEnd + 1;
	        }
	        prevMatch = index + 1;
	        match = foldRe.exec(line);
	    }
	    if (result) {
	        result += '\n';
	    }
	    if (foldStart !== prevMatch && line.length - foldStart > max) {
	        result += line.slice(foldStart, prevMatch) + '\n' +
	            line.slice(prevMatch + 1);
	    }
	    else {
	        result += line.slice(foldStart);
	    }
	    return result;
	}
	function simpleChar(character) {
	    return CHAR_TAB !== character &&
	        CHAR_LINE_FEED !== character &&
	        CHAR_CARRIAGE_RETURN !== character &&
	        CHAR_COMMA !== character &&
	        CHAR_LEFT_SQUARE_BRACKET !== character &&
	        CHAR_RIGHT_SQUARE_BRACKET !== character &&
	        CHAR_LEFT_CURLY_BRACKET !== character &&
	        CHAR_RIGHT_CURLY_BRACKET !== character &&
	        CHAR_SHARP !== character &&
	        CHAR_AMPERSAND !== character &&
	        CHAR_ASTERISK !== character &&
	        CHAR_EXCLAMATION !== character &&
	        CHAR_VERTICAL_LINE !== character &&
	        CHAR_GREATER_THAN !== character &&
	        CHAR_SINGLE_QUOTE !== character &&
	        CHAR_DOUBLE_QUOTE !== character &&
	        CHAR_PERCENT !== character &&
	        CHAR_COLON !== character &&
	        !ESCAPE_SEQUENCES[character] &&
	        !needsHexEscape(character);
	}
	function needsHexEscape(character) {
	    return !((0x00020 <= character && character <= 0x00007E) ||
	        (0x00085 === character) ||
	        (0x000A0 <= character && character <= 0x00D7FF) ||
	        (0x0E000 <= character && character <= 0x00FFFD) ||
	        (0x10000 <= character && character <= 0x10FFFF));
	}
	function writeFlowSequence(state, level, object) {
	    var _result = '', _tag = state.tag, index, length;
	    for (index = 0, length = object.length; index < length; index += 1) {
	        if (writeNode(state, level, object[index], false, false)) {
	            if (0 !== index) {
	                _result += ', ';
	            }
	            _result += state.dump;
	        }
	    }
	    state.tag = _tag;
	    state.dump = '[' + _result + ']';
	}
	function writeBlockSequence(state, level, object, compact) {
	    var _result = '', _tag = state.tag, index, length;
	    for (index = 0, length = object.length; index < length; index += 1) {
	        if (writeNode(state, level + 1, object[index], true, true)) {
	            if (!compact || 0 !== index) {
	                _result += generateNextLine(state, level);
	            }
	            _result += '- ' + state.dump;
	        }
	    }
	    state.tag = _tag;
	    state.dump = _result || '[]';
	}
	function writeFlowMapping(state, level, object) {
	    var _result = '', _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
	    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	        pairBuffer = '';
	        if (0 !== index) {
	            pairBuffer += ', ';
	        }
	        objectKey = objectKeyList[index];
	        objectValue = object[objectKey];
	        if (!writeNode(state, level, objectKey, false, false)) {
	            continue;
	        }
	        if (state.dump.length > 1024) {
	            pairBuffer += '? ';
	        }
	        pairBuffer += state.dump + ': ';
	        if (!writeNode(state, level, objectValue, false, false)) {
	            continue;
	        }
	        pairBuffer += state.dump;
	        _result += pairBuffer;
	    }
	    state.tag = _tag;
	    state.dump = '{' + _result + '}';
	}
	function writeBlockMapping(state, level, object, compact) {
	    var _result = '', _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
	    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	        pairBuffer = '';
	        if (!compact || 0 !== index) {
	            pairBuffer += generateNextLine(state, level);
	        }
	        objectKey = objectKeyList[index];
	        objectValue = object[objectKey];
	        if (!writeNode(state, level + 1, objectKey, true, true)) {
	            continue;
	        }
	        explicitPair = (null !== state.tag && '?' !== state.tag) ||
	            (state.dump && state.dump.length > 1024);
	        if (explicitPair) {
	            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
	                pairBuffer += '?';
	            }
	            else {
	                pairBuffer += '? ';
	            }
	        }
	        pairBuffer += state.dump;
	        if (explicitPair) {
	            pairBuffer += generateNextLine(state, level);
	        }
	        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
	            continue;
	        }
	        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
	            pairBuffer += ':';
	        }
	        else {
	            pairBuffer += ': ';
	        }
	        pairBuffer += state.dump;
	        _result += pairBuffer;
	    }
	    state.tag = _tag;
	    state.dump = _result || '{}';
	}
	function detectType(state, object, explicit) {
	    var _result, typeList, index, length, type, style;
	    typeList = explicit ? state.explicitTypes : state.implicitTypes;
	    for (index = 0, length = typeList.length; index < length; index += 1) {
	        type = typeList[index];
	        if ((type.instanceOf || type.predicate) &&
	            (!type.instanceOf || (('object' === typeof object) && (object instanceof type.instanceOf))) &&
	            (!type.predicate || type.predicate(object))) {
	            state.tag = explicit ? type.tag : '?';
	            if (type.represent) {
	                style = state.styleMap[type.tag] || type.defaultStyle;
	                if ('[object Function]' === _toString.call(type.represent)) {
	                    _result = type.represent(object, style);
	                }
	                else if (_hasOwnProperty.call(type.represent, style)) {
	                    _result = type.represent[style](object, style);
	                }
	                else {
	                    throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
	                }
	                state.dump = _result;
	            }
	            return true;
	        }
	    }
	    return false;
	}
	function writeNode(state, level, object, block, compact) {
	    state.tag = null;
	    state.dump = object;
	    if (!detectType(state, object, false)) {
	        detectType(state, object, true);
	    }
	    var type = _toString.call(state.dump);
	    if (block) {
	        block = (0 > state.flowLevel || state.flowLevel > level);
	    }
	    if ((null !== state.tag && '?' !== state.tag) || (2 !== state.indent && level > 0)) {
	        compact = false;
	    }
	    var objectOrArray = '[object Object]' === type || '[object Array]' === type, duplicateIndex, duplicate;
	    if (objectOrArray) {
	        duplicateIndex = state.duplicates.indexOf(object);
	        duplicate = duplicateIndex !== -1;
	    }
	    if (duplicate && state.usedDuplicates[duplicateIndex]) {
	        state.dump = '*ref_' + duplicateIndex;
	    }
	    else {
	        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
	            state.usedDuplicates[duplicateIndex] = true;
	        }
	        if ('[object Object]' === type) {
	            if (block && (0 !== Object.keys(state.dump).length)) {
	                writeBlockMapping(state, level, state.dump, compact);
	                if (duplicate) {
	                    state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
	                }
	            }
	            else {
	                writeFlowMapping(state, level, state.dump);
	                if (duplicate) {
	                    state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
	                }
	            }
	        }
	        else if ('[object Array]' === type) {
	            if (block && (0 !== state.dump.length)) {
	                writeBlockSequence(state, level, state.dump, compact);
	                if (duplicate) {
	                    state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
	                }
	            }
	            else {
	                writeFlowSequence(state, level, state.dump);
	                if (duplicate) {
	                    state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
	                }
	            }
	        }
	        else if ('[object String]' === type) {
	            if ('?' !== state.tag) {
	                writeScalar(state, state.dump, level);
	            }
	        }
	        else {
	            if (state.skipInvalid) {
	                return false;
	            }
	            throw new YAMLException('unacceptable kind of an object to dump ' + type);
	        }
	        if (null !== state.tag && '?' !== state.tag) {
	            state.dump = '!<' + state.tag + '> ' + state.dump;
	        }
	    }
	    return true;
	}
	function getDuplicateReferences(object, state) {
	    var objects = [], duplicatesIndexes = [], index, length;
	    inspectNode(object, objects, duplicatesIndexes);
	    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
	        state.duplicates.push(objects[duplicatesIndexes[index]]);
	    }
	    state.usedDuplicates = new Array(length);
	}
	function inspectNode(object, objects, duplicatesIndexes) {
	    var type = _toString.call(object), objectKeyList, index, length;
	    if (null !== object && 'object' === typeof object) {
	        index = objects.indexOf(object);
	        if (-1 !== index) {
	            if (-1 === duplicatesIndexes.indexOf(index)) {
	                duplicatesIndexes.push(index);
	            }
	        }
	        else {
	            objects.push(object);
	            if (Array.isArray(object)) {
	                for (index = 0, length = object.length; index < length; index += 1) {
	                    inspectNode(object[index], objects, duplicatesIndexes);
	                }
	            }
	            else {
	                objectKeyList = Object.keys(object);
	                for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	                    inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
	                }
	            }
	        }
	    }
	}
	function dump(input, options) {
	    options = options || {};
	    var state = new State(options);
	    getDuplicateReferences(input, state);
	    if (writeNode(state, 0, input, true, true)) {
	        return state.dump + '\n';
	    }
	    return '';
	}
	exports.dump = dump;
	function safeDump(input, options) {
	    return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}
	exports.safeDump = safeDump;
	//# sourceMappingURL=dumper.js.map

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
	//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
	//[5]   	Name	   ::=   	NameStartChar (NameChar)*
	var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]///\u10000-\uEFFFF
	var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\u00B7\u0300-\u036F\\u203F-\u2040]");
	var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
	//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
	//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

	//S_TAG,	S_ATTR,	S_EQ,	S_V
	//S_ATTR_S,	S_E,	S_S,	S_C
	var S_TAG = 0;//tag name offerring
	var S_ATTR = 1;//attr name offerring 
	var S_ATTR_S=2;//attr name end and space offer
	var S_EQ = 3;//=space?
	var S_V = 4;//attr value(no quot value only)
	var S_E = 5;//attr value end and no space(quot end)
	var S_S = 6;//(attr value end || tag end ) && (space offer)
	var S_C = 7;//closed el<el />

	function XMLReader(){
		
	}

	XMLReader.prototype = {
		parse:function(source,defaultNSMap,entityMap){
			var domBuilder = this.domBuilder;
			domBuilder.startDocument();
			_copy(defaultNSMap ,defaultNSMap = {})
			parse(source,defaultNSMap,entityMap,
					domBuilder,this.errorHandler);
			domBuilder.endDocument();
		}
	}
	function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
	  function fixedFromCharCode(code) {
			// String.prototype.fromCharCode does not supports
			// > 2 bytes unicode chars directly
			if (code > 0xffff) {
				code -= 0x10000;
				var surrogate1 = 0xd800 + (code >> 10)
					, surrogate2 = 0xdc00 + (code & 0x3ff);

				return String.fromCharCode(surrogate1, surrogate2);
			} else {
				return String.fromCharCode(code);
			}
		}
		function entityReplacer(a){
			var k = a.slice(1,-1);
			if(k in entityMap){
				return entityMap[k]; 
			}else if(k.charAt(0) === '#'){
				return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
			}else{
				errorHandler.error('entity not found:'+a);
				return a;
			}
		}
		function appendText(end){//has some bugs
			if(end>start){
				var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
				locator&&position(start);
				domBuilder.characters(xt,0,end-start);
				start = end
			}
		}
		function position(p,m){
			while(p>=lineEnd && (m = linePattern.exec(source))){
				lineStart = m.index;
				lineEnd = lineStart + m[0].length;
				locator.lineNumber++;
				//console.log('line++:',locator,startPos,endPos)
			}
			locator.columnNumber = p-lineStart+1;
		}
		var lineStart = 0;
		var lineEnd = 0;
		var linePattern = /.+(?:\r\n?|\n)|.*$/g
		var locator = domBuilder.locator;
		
		var parseStack = [{currentNSMap:defaultNSMapCopy}]
		var closeMap = {};
		var start = 0;
		while(true){
			try{
				var tagStart = source.indexOf('<',start);
				if(tagStart<0){
					if(!source.substr(start).match(/^\s*$/)){
						var doc = domBuilder.document;
		    			var text = doc.createTextNode(source.substr(start));
		    			doc.appendChild(text);
		    			domBuilder.currentElement = text;
					}
					return;
				}
				if(tagStart>start){
					appendText(tagStart);
				}
				switch(source.charAt(tagStart+1)){
				case '/':
					var end = source.indexOf('>',tagStart+3);
					var tagName = source.substring(tagStart+2,end);
					var config = parseStack.pop();
					var localNSMap = config.localNSMap;
			        if(config.tagName != tagName){
			            errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName );
			        }
					domBuilder.endElement(config.uri,config.localName,tagName);
					if(localNSMap){
						for(var prefix in localNSMap){
							domBuilder.endPrefixMapping(prefix) ;
						}
					}
					end++;
					break;
					// end elment
				case '?':// <?...?>
					locator&&position(tagStart);
					end = parseInstruction(source,tagStart,domBuilder);
					break;
				case '!':// <!doctype,<![CDATA,<!--
					locator&&position(tagStart);
					end = parseDCC(source,tagStart,domBuilder,errorHandler);
					break;
				default:
				
					locator&&position(tagStart);
					
					var el = new ElementAttributes();
					
					//elStartEnd
					var end = parseElementStartPart(source,tagStart,el,entityReplacer,errorHandler);
					var len = el.length;
					
					if(locator){
						if(len){
							//attribute position fixed
							for(var i = 0;i<len;i++){
								var a = el[i];
								position(a.offset);
								a.offset = copyLocator(locator,{});
							}
						}
						position(end);
					}
					if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
						el.closed = true;
						if(!entityMap.nbsp){
							errorHandler.warning('unclosed xml attribute');
						}
					}
					appendElement(el,domBuilder,parseStack);
					
					
					if(el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed){
						end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)
					}else{
						end++;
					}
				}
			}catch(e){
				errorHandler.error('element parse error: '+e);
				end = -1;
			}
			if(end>start){
				start = end;
			}else{
				//TODO: sax
				appendText(Math.max(tagStart,start)+1);
			}
		}
	}
	function copyLocator(f,t){
		t.lineNumber = f.lineNumber;
		t.columnNumber = f.columnNumber;
		return t;
	}

	/**
	 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
	 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
	 */
	function parseElementStartPart(source,start,el,entityReplacer,errorHandler){
		var attrName;
		var value;
		var p = ++start;
		var s = S_TAG;//status
		while(true){
			var c = source.charAt(p);
			switch(c){
			case '=':
				if(s === S_ATTR){//attrName
					attrName = source.slice(start,p);
					s = S_EQ;
				}else if(s === S_ATTR_S){
					s = S_EQ;
				}else{
					//fatalError: equal must after attrName or space after attrName
					throw new Error('attribute equal must after attrName');
				}
				break;
			case '\'':
			case '"':
				if(s === S_EQ){//equal
					start = p+1;
					p = source.indexOf(c,start)
					if(p>0){
						value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
						el.add(attrName,value,start-1);
						s = S_E;
					}else{
						//fatalError: no end quot match
						throw new Error('attribute value no end \''+c+'\' match');
					}
				}else if(s == S_V){
					value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					//console.log(attrName,value,start,p)
					el.add(attrName,value,start);
					//console.dir(el)
					errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
					start = p+1;
					s = S_E
				}else{
					//fatalError: no equal before
					throw new Error('attribute value must after "="');
				}
				break;
			case '/':
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));
				case S_E:
				case S_S:
				case S_C:
					s = S_C;
					el.closed = true;
				case S_V:
				case S_ATTR:
				case S_ATTR_S:
					break;
				//case S_EQ:
				default:
					throw new Error("attribute invalid close char('/')")
				}
				break;
			case ''://end document
				//throw new Error('unexpected end of input')
				errorHandler.error('unexpected end of input');
			case '>':
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));
				case S_E:
				case S_S:
				case S_C:
					break;//normal
				case S_V://Compatible state
				case S_ATTR:
					value = source.slice(start,p);
					if(value.slice(-1) === '/'){
						el.closed  = true;
						value = value.slice(0,-1)
					}
				case S_ATTR_S:
					if(s === S_ATTR_S){
						value = attrName;
					}
					if(s == S_V){
						errorHandler.warning('attribute "'+value+'" missed quot(")!!');
						el.add(attrName,value.replace(/&#?\w+;/g,entityReplacer),start)
					}else{
						errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')
						el.add(value,value,start)
					}
					break;
				case S_EQ:
					throw new Error('attribute value missed!!');
				}
	//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
				return p;
			/*xml space '\x20' | #x9 | #xD | #xA; */
			case '\u0080':
				c = ' ';
			default:
				if(c<= ' '){//space
					switch(s){
					case S_TAG:
						el.setTagName(source.slice(start,p));//tagName
						s = S_S;
						break;
					case S_ATTR:
						attrName = source.slice(start,p)
						s = S_ATTR_S;
						break;
					case S_V:
						var value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
						errorHandler.warning('attribute "'+value+'" missed quot(")!!');
						el.add(attrName,value,start)
					case S_E:
						s = S_S;
						break;
					//case S_S:
					//case S_EQ:
					//case S_ATTR_S:
					//	void();break;
					//case S_C:
						//ignore warning
					}
				}else{//not space
	//S_TAG,	S_ATTR,	S_EQ,	S_V
	//S_ATTR_S,	S_E,	S_S,	S_C
					switch(s){
					//case S_TAG:void();break;
					//case S_ATTR:void();break;
					//case S_V:void();break;
					case S_ATTR_S:
						errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead!!')
						el.add(attrName,attrName,start);
						start = p;
						s = S_ATTR;
						break;
					case S_E:
						errorHandler.warning('attribute space is required"'+attrName+'"!!')
					case S_S:
						s = S_ATTR;
						start = p;
						break;
					case S_EQ:
						s = S_V;
						start = p;
						break;
					case S_C:
						throw new Error("elements closed character '/' and '>' must be connected to");
					}
				}
			}
			p++;
		}
	}
	/**
	 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
	 */
	function appendElement(el,domBuilder,parseStack){
		var tagName = el.tagName;
		var localNSMap = null;
		var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
		var i = el.length;
		while(i--){
			var a = el[i];
			var qName = a.qName;
			var value = a.value;
			var nsp = qName.indexOf(':');
			if(nsp>0){
				var prefix = a.prefix = qName.slice(0,nsp);
				var localName = qName.slice(nsp+1);
				var nsPrefix = prefix === 'xmlns' && localName
			}else{
				localName = qName;
				prefix = null
				nsPrefix = qName === 'xmlns' && ''
			}
			//can not set prefix,because prefix !== ''
			a.localName = localName ;
			//prefix == null for no ns prefix attribute 
			if(nsPrefix !== false){//hack!!
				if(localNSMap == null){
					localNSMap = {}
					//console.log(currentNSMap,0)
					_copy(currentNSMap,currentNSMap={})
					//console.log(currentNSMap,1)
				}
				currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
				a.uri = 'http://www.w3.org/2000/xmlns/'
				domBuilder.startPrefixMapping(nsPrefix, value) 
			}
		}
		var i = el.length;
		while(i--){
			a = el[i];
			var prefix = a.prefix;
			if(prefix){//no prefix attribute has no namespace
				if(prefix === 'xml'){
					a.uri = 'http://www.w3.org/XML/1998/namespace';
				}if(prefix !== 'xmlns'){
					a.uri = currentNSMap[prefix]
					
					//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
				}
			}
		}
		var nsp = tagName.indexOf(':');
		if(nsp>0){
			prefix = el.prefix = tagName.slice(0,nsp);
			localName = el.localName = tagName.slice(nsp+1);
		}else{
			prefix = null;//important!!
			localName = el.localName = tagName;
		}
		//no prefix element has default namespace
		var ns = el.uri = currentNSMap[prefix || ''];
		domBuilder.startElement(ns,localName,tagName,el);
		//endPrefixMapping and startPrefixMapping have not any help for dom builder
		//localNSMap = null
		if(el.closed){
			domBuilder.endElement(ns,localName,tagName);
			if(localNSMap){
				for(prefix in localNSMap){
					domBuilder.endPrefixMapping(prefix) 
				}
			}
		}else{
			el.currentNSMap = currentNSMap;
			el.localNSMap = localNSMap;
			parseStack.push(el);
		}
	}
	function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
		if(/^(?:script|textarea)$/i.test(tagName)){
			var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
			var text = source.substring(elStartEnd+1,elEndStart);
			if(/[&<]/.test(text)){
				if(/^script$/i.test(tagName)){
					//if(!/\]\]>/.test(text)){
						//lexHandler.startCDATA();
						domBuilder.characters(text,0,text.length);
						//lexHandler.endCDATA();
						return elEndStart;
					//}
				}//}else{//text area
					text = text.replace(/&#?\w+;/g,entityReplacer);
					domBuilder.characters(text,0,text.length);
					return elEndStart;
				//}
				
			}
		}
		return elStartEnd+1;
	}
	function fixSelfClosed(source,elStartEnd,tagName,closeMap){
		//if(tagName in closeMap){
		var pos = closeMap[tagName];
		if(pos == null){
			//console.log(tagName)
			pos = closeMap[tagName] = source.lastIndexOf('</'+tagName+'>')
		}
		return pos<elStartEnd;
		//} 
	}
	function _copy(source,target){
		for(var n in source){target[n] = source[n]}
	}
	function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
		var next= source.charAt(start+2)
		switch(next){
		case '-':
			if(source.charAt(start + 3) === '-'){
				var end = source.indexOf('-->',start+4);
				//append comment source.substring(4,end)//<!--
				if(end>start){
					domBuilder.comment(source,start+4,end-start-4);
					return end+3;
				}else{
					errorHandler.error("Unclosed comment");
					return -1;
				}
			}else{
				//error
				return -1;
			}
		default:
			if(source.substr(start+3,6) == 'CDATA['){
				var end = source.indexOf(']]>',start+9);
				domBuilder.startCDATA();
				domBuilder.characters(source,start+9,end-start-9);
				domBuilder.endCDATA() 
				return end+3;
			}
			//<!DOCTYPE
			//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) 
			var matchs = split(source,start);
			var len = matchs.length;
			if(len>1 && /!doctype/i.test(matchs[0][0])){
				var name = matchs[1][0];
				var pubid = len>3 && /^public$/i.test(matchs[2][0]) && matchs[3][0]
				var sysid = len>4 && matchs[4][0];
				var lastMatch = matchs[len-1]
				domBuilder.startDTD(name,pubid && pubid.replace(/^(['"])(.*?)\1$/,'$2'),
						sysid && sysid.replace(/^(['"])(.*?)\1$/,'$2'));
				domBuilder.endDTD();
				
				return lastMatch.index+lastMatch[0].length
			}
		}
		return -1;
	}



	function parseInstruction(source,start,domBuilder){
		var end = source.indexOf('?>',start);
		if(end){
			var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
			if(match){
				var len = match[0].length;
				domBuilder.processingInstruction(match[1], match[2]) ;
				return end+2;
			}else{//error
				return -1;
			}
		}
		return -1;
	}

	/**
	 * @param source
	 */
	function ElementAttributes(source){
		
	}
	ElementAttributes.prototype = {
		setTagName:function(tagName){
			if(!tagNamePattern.test(tagName)){
				throw new Error('invalid tagName:'+tagName)
			}
			this.tagName = tagName
		},
		add:function(qName,value,offset){
			if(!tagNamePattern.test(qName)){
				throw new Error('invalid attribute:'+qName)
			}
			this[this.length++] = {qName:qName,value:value,offset:offset}
		},
		length:0,
		getLocalName:function(i){return this[i].localName},
		getOffset:function(i){return this[i].offset},
		getQName:function(i){return this[i].qName},
		getURI:function(i){return this[i].uri},
		getValue:function(i){return this[i].value}
	//	,getIndex:function(uri, localName)){
	//		if(localName){
	//			
	//		}else{
	//			var qName = uri
	//		}
	//	},
	//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
	//	getType:function(uri,localName){}
	//	getType:function(i){},
	}




	function _set_proto_(thiz,parent){
		thiz.__proto__ = parent;
		return thiz;
	}
	if(!(_set_proto_({},_set_proto_.prototype) instanceof _set_proto_)){
		_set_proto_ = function(thiz,parent){
			function p(){};
			p.prototype = parent;
			p = new p();
			for(parent in thiz){
				p[parent] = thiz[parent];
			}
			return p;
		}
	}

	function split(source,start){
		var match;
		var buf = [];
		var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
		reg.lastIndex = start;
		reg.exec(source);//skip <
		while(match = reg.exec(source)){
			buf.push(match);
			if(match[1])return buf;
		}
	}

	if(true){
		exports.XMLReader = XMLReader;
	}



/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * DOM Level 2
	 * Object DOMException
	 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
	 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
	 */

	function copy(src,dest){
		for(var p in src){
			dest[p] = src[p];
		}
	}
	/**
	^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
	^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
	 */
	function _extends(Class,Super){
		var pt = Class.prototype;
		if(Object.create){
			var ppt = Object.create(Super.prototype)
			pt.__proto__ = ppt;
		}
		if(!(pt instanceof Super)){
			function t(){};
			t.prototype = Super.prototype;
			t = new t();
			copy(pt,t);
			Class.prototype = pt = t;
		}
		if(pt.constructor != Class){
			if(typeof Class != 'function'){
				console.error("unknow Class:"+Class)
			}
			pt.constructor = Class
		}
	}
	var htmlns = 'http://www.w3.org/1999/xhtml' ;
	// Node Types
	var NodeType = {}
	var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
	var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
	var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
	var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
	var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
	var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
	var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
	var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
	var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
	var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
	var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
	var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

	// ExceptionCode
	var ExceptionCode = {}
	var ExceptionMessage = {};
	var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
	var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
	var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
	var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
	var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
	var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
	var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
	var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
	var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
	var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
	//level2
	var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
	var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
	var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
	var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
	var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);


	function DOMException(code, message) {
		if(message instanceof Error){
			var error = message;
		}else{
			error = this;
			Error.call(this, ExceptionMessage[code]);
			this.message = ExceptionMessage[code];
			if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
		}
		error.code = code;
		if(message) this.message = this.message + ": " + message;
		return error;
	};
	DOMException.prototype = Error.prototype;
	copy(ExceptionCode,DOMException)
	/**
	 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
	 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
	 * The items in the NodeList are accessible via an integral index, starting from 0.
	 */
	function NodeList() {
	};
	NodeList.prototype = {
		/**
		 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
		 * @standard level1
		 */
		length:0, 
		/**
		 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
		 * @standard level1
		 * @param index  unsigned long 
		 *   Index into the collection.
		 * @return Node
		 * 	The node at the indexth position in the NodeList, or null if that is not a valid index. 
		 */
		item: function(index) {
			return this[index] || null;
		},
		toString:function(){
			for(var buf = [], i = 0;i<this.length;i++){
				serializeToString(this[i],buf);
			}
			return buf.join('');
		}
	};
	function LiveNodeList(node,refresh){
		this._node = node;
		this._refresh = refresh
		_updateLiveList(this);
	}
	function _updateLiveList(list){
		var inc = list._node._inc || list._node.ownerDocument._inc;
		if(list._inc != inc){
			var ls = list._refresh(list._node);
			//console.log(ls.length)
			__set__(list,'length',ls.length);
			copy(ls,list);
			list._inc = inc;
		}
	}
	LiveNodeList.prototype.item = function(i){
		_updateLiveList(this);
		return this[i];
	}

	_extends(LiveNodeList,NodeList);
	/**
	 * 
	 * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.
	 * NamedNodeMap objects in the DOM are live.
	 * used for attributes or DocumentType entities 
	 */
	function NamedNodeMap() {
	};

	function _findNodeIndex(list,node){
		var i = list.length;
		while(i--){
			if(list[i] === node){return i}
		}
	}

	function _addNamedNode(el,list,newAttr,oldAttr){
		if(oldAttr){
			list[_findNodeIndex(list,oldAttr)] = newAttr;
		}else{
			list[list.length++] = newAttr;
		}
		if(el){
			newAttr.ownerElement = el;
			var doc = el.ownerDocument;
			if(doc){
				oldAttr && _onRemoveAttribute(doc,el,oldAttr);
				_onAddAttribute(doc,el,newAttr);
			}
		}
	}
	function _removeNamedNode(el,list,attr){
		var i = _findNodeIndex(list,attr);
		if(i>=0){
			var lastIndex = list.length-1
			while(i<lastIndex){
				list[i] = list[++i]
			}
			list.length = lastIndex;
			if(el){
				var doc = el.ownerDocument;
				if(doc){
					_onRemoveAttribute(doc,el,attr);
					attr.ownerElement = null;
				}
			}
		}else{
			throw DOMException(NOT_FOUND_ERR,new Error())
		}
	}
	NamedNodeMap.prototype = {
		length:0,
		item:NodeList.prototype.item,
		getNamedItem: function(key) {
	//		if(key.indexOf(':')>0 || key == 'xmlns'){
	//			return null;
	//		}
			var i = this.length;
			while(i--){
				var attr = this[i];
				if(attr.nodeName == key){
					return attr;
				}
			}
		},
		setNamedItem: function(attr) {
			var el = attr.ownerElement;
			if(el && el!=this._ownerElement){
				throw new DOMException(INUSE_ATTRIBUTE_ERR);
			}
			var oldAttr = this.getNamedItem(attr.nodeName);
			_addNamedNode(this._ownerElement,this,attr,oldAttr);
			return oldAttr;
		},
		/* returns Node */
		setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
			var el = attr.ownerElement, oldAttr;
			if(el && el!=this._ownerElement){
				throw new DOMException(INUSE_ATTRIBUTE_ERR);
			}
			oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
			_addNamedNode(this._ownerElement,this,attr,oldAttr);
			return oldAttr;
		},

		/* returns Node */
		removeNamedItem: function(key) {
			var attr = this.getNamedItem(key);
			_removeNamedNode(this._ownerElement,this,attr);
			return attr;
			
			
		},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
		
		//for level2
		removeNamedItemNS:function(namespaceURI,localName){
			var attr = this.getNamedItemNS(namespaceURI,localName);
			_removeNamedNode(this._ownerElement,this,attr);
			return attr;
		},
		getNamedItemNS: function(namespaceURI, localName) {
			var i = this.length;
			while(i--){
				var node = this[i];
				if(node.localName == localName && node.namespaceURI == namespaceURI){
					return node;
				}
			}
			return null;
		}
	};
	/**
	 * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490
	 */
	function DOMImplementation(/* Object */ features) {
		this._features = {};
		if (features) {
			for (var feature in features) {
				 this._features = features[feature];
			}
		}
	};

	DOMImplementation.prototype = {
		hasFeature: function(/* string */ feature, /* string */ version) {
			var versions = this._features[feature.toLowerCase()];
			if (versions && (!version || version in versions)) {
				return true;
			} else {
				return false;
			}
		},
		// Introduced in DOM Level 2:
		createDocument:function(namespaceURI,  qualifiedName, doctype){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
			var doc = new Document();
			doc.implementation = this;
			doc.childNodes = new NodeList();
			doc.doctype = doctype;
			if(doctype){
				doc.appendChild(doctype);
			}
			if(qualifiedName){
				var root = doc.createElementNS(namespaceURI,qualifiedName);
				doc.appendChild(root);
			}
			return doc;
		},
		// Introduced in DOM Level 2:
		createDocumentType:function(qualifiedName, publicId, systemId){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
			var node = new DocumentType();
			node.name = qualifiedName;
			node.nodeName = qualifiedName;
			node.publicId = publicId;
			node.systemId = systemId;
			// Introduced in DOM Level 2:
			//readonly attribute DOMString        internalSubset;
			
			//TODO:..
			//  readonly attribute NamedNodeMap     entities;
			//  readonly attribute NamedNodeMap     notations;
			return node;
		}
	};


	/**
	 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
	 */

	function Node() {
	};

	Node.prototype = {
		firstChild : null,
		lastChild : null,
		previousSibling : null,
		nextSibling : null,
		attributes : null,
		parentNode : null,
		childNodes : null,
		ownerDocument : null,
		nodeValue : null,
		namespaceURI : null,
		prefix : null,
		localName : null,
		// Modified in DOM Level 2:
		insertBefore:function(newChild, refChild){//raises 
			return _insertBefore(this,newChild,refChild);
		},
		replaceChild:function(newChild, oldChild){//raises 
			this.insertBefore(newChild,oldChild);
			if(oldChild){
				this.removeChild(oldChild);
			}
		},
		removeChild:function(oldChild){
			return _removeChild(this,oldChild);
		},
		appendChild:function(newChild){
			return this.insertBefore(newChild,null);
		},
		hasChildNodes:function(){
			return this.firstChild != null;
		},
		cloneNode:function(deep){
			return cloneNode(this.ownerDocument||this,this,deep);
		},
		// Modified in DOM Level 2:
		normalize:function(){
			var child = this.firstChild;
			while(child){
				var next = child.nextSibling;
				if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
					this.removeChild(next);
					child.appendData(next.data);
				}else{
					child.normalize();
					child = next;
				}
			}
		},
	  	// Introduced in DOM Level 2:
		isSupported:function(feature, version){
			return this.ownerDocument.implementation.hasFeature(feature,version);
		},
	    // Introduced in DOM Level 2:
	    hasAttributes:function(){
	    	return this.attributes.length>0;
	    },
	    lookupPrefix:function(namespaceURI){
	    	var el = this;
	    	while(el){
	    		var map = el._nsMap;
	    		//console.dir(map)
	    		if(map){
	    			for(var n in map){
	    				if(map[n] == namespaceURI){
	    					return n;
	    				}
	    			}
	    		}
	    		el = el.nodeType == 2?el.ownerDocument : el.parentNode;
	    	}
	    	return null;
	    },
	    // Introduced in DOM Level 3:
	    lookupNamespaceURI:function(prefix){
	    	var el = this;
	    	while(el){
	    		var map = el._nsMap;
	    		//console.dir(map)
	    		if(map){
	    			if(prefix in map){
	    				return map[prefix] ;
	    			}
	    		}
	    		el = el.nodeType == 2?el.ownerDocument : el.parentNode;
	    	}
	    	return null;
	    },
	    // Introduced in DOM Level 3:
	    isDefaultNamespace:function(namespaceURI){
	    	var prefix = this.lookupPrefix(namespaceURI);
	    	return prefix == null;
	    }
	};


	function _xmlEncoder(c){
		return c == '<' && '&lt;' ||
	         c == '>' && '&gt;' ||
	         c == '&' && '&amp;' ||
	         c == '"' && '&quot;' ||
	         '&#'+c.charCodeAt()+';'
	}


	copy(NodeType,Node);
	copy(NodeType,Node.prototype);

	/**
	 * @param callback return true for continue,false for break
	 * @return boolean true: break visit;
	 */
	function _visitNode(node,callback){
		if(callback(node)){
			return true;
		}
		if(node = node.firstChild){
			do{
				if(_visitNode(node,callback)){return true}
	        }while(node=node.nextSibling)
	    }
	}



	function Document(){
	}
	function _onAddAttribute(doc,el,newAttr){
		doc && doc._inc++;
		var ns = newAttr.namespaceURI ;
		if(ns == 'http://www.w3.org/2000/xmlns/'){
			//update namespace
			el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value
		}
	}
	function _onRemoveAttribute(doc,el,newAttr,remove){
		doc && doc._inc++;
		var ns = newAttr.namespaceURI ;
		if(ns == 'http://www.w3.org/2000/xmlns/'){
			//update namespace
			delete el._nsMap[newAttr.prefix?newAttr.localName:'']
		}
	}
	function _onUpdateChild(doc,el,newChild){
		if(doc && doc._inc){
			doc._inc++;
			//update childNodes
			var cs = el.childNodes;
			if(newChild){
				cs[cs.length++] = newChild;
			}else{
				//console.log(1)
				var child = el.firstChild;
				var i = 0;
				while(child){
					cs[i++] = child;
					child =child.nextSibling;
				}
				cs.length = i;
			}
		}
	}

	/**
	 * attributes;
	 * children;
	 * 
	 * writeable properties:
	 * nodeValue,Attr:value,CharacterData:data
	 * prefix
	 */
	function _removeChild(parentNode,child){
		var previous = child.previousSibling;
		var next = child.nextSibling;
		if(previous){
			previous.nextSibling = next;
		}else{
			parentNode.firstChild = next
		}
		if(next){
			next.previousSibling = previous;
		}else{
			parentNode.lastChild = previous;
		}
		_onUpdateChild(parentNode.ownerDocument,parentNode);
		return child;
	}
	/**
	 * preformance key(refChild == null)
	 */
	function _insertBefore(parentNode,newChild,nextChild){
		var cp = newChild.parentNode;
		if(cp){
			cp.removeChild(newChild);//remove and update
		}
		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
			var newFirst = newChild.firstChild;
			if (newFirst == null) {
				return newChild;
			}
			var newLast = newChild.lastChild;
		}else{
			newFirst = newLast = newChild;
		}
		var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;

		newFirst.previousSibling = pre;
		newLast.nextSibling = nextChild;
		
		
		if(pre){
			pre.nextSibling = newFirst;
		}else{
			parentNode.firstChild = newFirst;
		}
		if(nextChild == null){
			parentNode.lastChild = newLast;
		}else{
			nextChild.previousSibling = newLast;
		}
		do{
			newFirst.parentNode = parentNode;
		}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
		_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);
		//console.log(parentNode.lastChild.nextSibling == null)
		if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
			newChild.firstChild = newChild.lastChild = null;
		}
		return newChild;
	}
	function _appendSingleChild(parentNode,newChild){
		var cp = newChild.parentNode;
		if(cp){
			var pre = parentNode.lastChild;
			cp.removeChild(newChild);//remove and update
			var pre = parentNode.lastChild;
		}
		var pre = parentNode.lastChild;
		newChild.parentNode = parentNode;
		newChild.previousSibling = pre;
		newChild.nextSibling = null;
		if(pre){
			pre.nextSibling = newChild;
		}else{
			parentNode.firstChild = newChild;
		}
		parentNode.lastChild = newChild;
		_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);
		return newChild;
		//console.log("__aa",parentNode.lastChild.nextSibling == null)
	}
	Document.prototype = {
		//implementation : null,
		nodeName :  '#document',
		nodeType :  DOCUMENT_NODE,
		doctype :  null,
		documentElement :  null,
		_inc : 1,
		
		insertBefore :  function(newChild, refChild){//raises 
			if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
				var child = newChild.firstChild;
				while(child){
					var next = child.nextSibling;
					this.insertBefore(child,refChild);
					child = next;
				}
				return newChild;
			}
			if(this.documentElement == null && newChild.nodeType == 1){
				this.documentElement = newChild;
			}
			
			return _insertBefore(this,newChild,refChild),(newChild.ownerDocument = this),newChild;
		},
		removeChild :  function(oldChild){
			if(this.documentElement == oldChild){
				this.documentElement = null;
			}
			return _removeChild(this,oldChild);
		},
		// Introduced in DOM Level 2:
		importNode : function(importedNode,deep){
			return importNode(this,importedNode,deep);
		},
		// Introduced in DOM Level 2:
		getElementById :	function(id){
			var rtv = null;
			_visitNode(this.documentElement,function(node){
				if(node.nodeType == 1){
					if(node.getAttribute('id') == id){
						rtv = node;
						return true;
					}
				}
			})
			return rtv;
		},
		
		//document factory method:
		createElement :	function(tagName){
			var node = new Element();
			node.ownerDocument = this;
			node.nodeName = tagName;
			node.tagName = tagName;
			node.childNodes = new NodeList();
			var attrs	= node.attributes = new NamedNodeMap();
			attrs._ownerElement = node;
			return node;
		},
		createDocumentFragment :	function(){
			var node = new DocumentFragment();
			node.ownerDocument = this;
			node.childNodes = new NodeList();
			return node;
		},
		createTextNode :	function(data){
			var node = new Text();
			node.ownerDocument = this;
			node.appendData(data)
			return node;
		},
		createComment :	function(data){
			var node = new Comment();
			node.ownerDocument = this;
			node.appendData(data)
			return node;
		},
		createCDATASection :	function(data){
			var node = new CDATASection();
			node.ownerDocument = this;
			node.appendData(data)
			return node;
		},
		createProcessingInstruction :	function(target,data){
			var node = new ProcessingInstruction();
			node.ownerDocument = this;
			node.tagName = node.target = target;
			node.nodeValue= node.data = data;
			return node;
		},
		createAttribute :	function(name){
			var node = new Attr();
			node.ownerDocument	= this;
			node.name = name;
			node.nodeName	= name;
			node.localName = name;
			node.specified = true;
			return node;
		},
		createEntityReference :	function(name){
			var node = new EntityReference();
			node.ownerDocument	= this;
			node.nodeName	= name;
			return node;
		},
		// Introduced in DOM Level 2:
		createElementNS :	function(namespaceURI,qualifiedName){
			var node = new Element();
			var pl = qualifiedName.split(':');
			var attrs	= node.attributes = new NamedNodeMap();
			node.childNodes = new NodeList();
			node.ownerDocument = this;
			node.nodeName = qualifiedName;
			node.tagName = qualifiedName;
			node.namespaceURI = namespaceURI;
			if(pl.length == 2){
				node.prefix = pl[0];
				node.localName = pl[1];
			}else{
				//el.prefix = null;
				node.localName = qualifiedName;
			}
			attrs._ownerElement = node;
			return node;
		},
		// Introduced in DOM Level 2:
		createAttributeNS :	function(namespaceURI,qualifiedName){
			var node = new Attr();
			var pl = qualifiedName.split(':');
			node.ownerDocument = this;
			node.nodeName = qualifiedName;
			node.name = qualifiedName;
			node.namespaceURI = namespaceURI;
			node.specified = true;
			if(pl.length == 2){
				node.prefix = pl[0];
				node.localName = pl[1];
			}else{
				//el.prefix = null;
				node.localName = qualifiedName;
			}
			return node;
		}
	};
	_extends(Document,Node);


	function Element() {
		this._nsMap = {};
	};
	Element.prototype = {
		nodeType : ELEMENT_NODE,
		hasAttribute : function(name){
			return this.getAttributeNode(name)!=null;
		},
		getAttribute : function(name){
			var attr = this.getAttributeNode(name);
			return attr && attr.value || '';
		},
		getAttributeNode : function(name){
			return this.attributes.getNamedItem(name);
		},
		setAttribute : function(name, value){
			var attr = this.ownerDocument.createAttribute(name);
			attr.value = attr.nodeValue = "" + value;
			this.setAttributeNode(attr)
		},
		removeAttribute : function(name){
			var attr = this.getAttributeNode(name)
			attr && this.removeAttributeNode(attr);
		},
		
		//four real opeartion method
		appendChild:function(newChild){
			if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
				return this.insertBefore(newChild,null);
			}else{
				return _appendSingleChild(this,newChild);
			}
		},
		setAttributeNode : function(newAttr){
			return this.attributes.setNamedItem(newAttr);
		},
		setAttributeNodeNS : function(newAttr){
			return this.attributes.setNamedItemNS(newAttr);
		},
		removeAttributeNode : function(oldAttr){
			return this.attributes.removeNamedItem(oldAttr.nodeName);
		},
		//get real attribute name,and remove it by removeAttributeNode
		removeAttributeNS : function(namespaceURI, localName){
			var old = this.getAttributeNodeNS(namespaceURI, localName);
			old && this.removeAttributeNode(old);
		},
		
		hasAttributeNS : function(namespaceURI, localName){
			return this.getAttributeNodeNS(namespaceURI, localName)!=null;
		},
		getAttributeNS : function(namespaceURI, localName){
			var attr = this.getAttributeNodeNS(namespaceURI, localName);
			return attr && attr.value || '';
		},
		setAttributeNS : function(namespaceURI, qualifiedName, value){
			var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
			attr.value = attr.nodeValue = "" + value;
			this.setAttributeNode(attr)
		},
		getAttributeNodeNS : function(namespaceURI, localName){
			return this.attributes.getNamedItemNS(namespaceURI, localName);
		},
		
		getElementsByTagName : function(tagName){
			return new LiveNodeList(this,function(base){
				var ls = [];
				_visitNode(base,function(node){
					if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
						ls.push(node);
					}
				});
				return ls;
			});
		},
		getElementsByTagNameNS : function(namespaceURI, localName){
			return new LiveNodeList(this,function(base){
				var ls = [];
				_visitNode(base,function(node){
					if(node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)){
						ls.push(node);
					}
				});
				return ls;
			});
		}
	};
	Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
	Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


	_extends(Element,Node);
	function Attr() {
	};
	Attr.prototype.nodeType = ATTRIBUTE_NODE;
	_extends(Attr,Node);


	function CharacterData() {
	};
	CharacterData.prototype = {
		data : '',
		substringData : function(offset, count) {
			return this.data.substring(offset, offset+count);
		},
		appendData: function(text) {
			text = this.data+text;
			this.nodeValue = this.data = text;
			this.length = text.length;
		},
		insertData: function(offset,text) {
			this.replaceData(offset,0,text);
		
		},
		appendChild:function(newChild){
			//if(!(newChild instanceof CharacterData)){
				throw new Error(ExceptionMessage[3])
			//}
			return Node.prototype.appendChild.apply(this,arguments)
		},
		deleteData: function(offset, count) {
			this.replaceData(offset,count,"");
		},
		replaceData: function(offset, count, text) {
			var start = this.data.substring(0,offset);
			var end = this.data.substring(offset+count);
			text = start + text + end;
			this.nodeValue = this.data = text;
			this.length = text.length;
		}
	}
	_extends(CharacterData,Node);
	function Text() {
	};
	Text.prototype = {
		nodeName : "#text",
		nodeType : TEXT_NODE,
		splitText : function(offset) {
			var text = this.data;
			var newText = text.substring(offset);
			text = text.substring(0, offset);
			this.data = this.nodeValue = text;
			this.length = text.length;
			var newNode = this.ownerDocument.createTextNode(newText);
			if(this.parentNode){
				this.parentNode.insertBefore(newNode, this.nextSibling);
			}
			return newNode;
		}
	}
	_extends(Text,CharacterData);
	function Comment() {
	};
	Comment.prototype = {
		nodeName : "#comment",
		nodeType : COMMENT_NODE
	}
	_extends(Comment,CharacterData);

	function CDATASection() {
	};
	CDATASection.prototype = {
		nodeName : "#cdata-section",
		nodeType : CDATA_SECTION_NODE
	}
	_extends(CDATASection,CharacterData);


	function DocumentType() {
	};
	DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
	_extends(DocumentType,Node);

	function Notation() {
	};
	Notation.prototype.nodeType = NOTATION_NODE;
	_extends(Notation,Node);

	function Entity() {
	};
	Entity.prototype.nodeType = ENTITY_NODE;
	_extends(Entity,Node);

	function EntityReference() {
	};
	EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
	_extends(EntityReference,Node);

	function DocumentFragment() {
	};
	DocumentFragment.prototype.nodeName =	"#document-fragment";
	DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
	_extends(DocumentFragment,Node);


	function ProcessingInstruction() {
	}
	ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
	_extends(ProcessingInstruction,Node);
	function XMLSerializer(){}
	XMLSerializer.prototype.serializeToString = function(node,attributeSorter){
		return node.toString(attributeSorter);
	}
	Node.prototype.toString =function(attributeSorter){
		var buf = [];
		serializeToString(this,buf,attributeSorter);
		return buf.join('');
	}
	function serializeToString(node,buf,attributeSorter,isHTML){
		switch(node.nodeType){
		case ELEMENT_NODE:
			var attrs = node.attributes;
			var len = attrs.length;
			var child = node.firstChild;
			var nodeName = node.tagName;
			isHTML =  (htmlns === node.namespaceURI) ||isHTML 
			buf.push('<',nodeName);
			if(attributeSorter){
				buf.sort.apply(attrs, attributeSorter);
			}
			for(var i=0;i<len;i++){
				serializeToString(attrs.item(i),buf,attributeSorter,isHTML);
			}
			if(child || isHTML && !/^(?:meta|link|img|br|hr|input|button)$/i.test(nodeName)){
				buf.push('>');
				//if is cdata child node
				if(isHTML && /^script$/i.test(nodeName)){
					if(child){
						buf.push(child.data);
					}
				}else{
					while(child){
						serializeToString(child,buf,attributeSorter,isHTML);
						child = child.nextSibling;
					}
				}
				buf.push('</',nodeName,'>');
			}else{
				buf.push('/>');
			}
			return;
		case DOCUMENT_NODE:
		case DOCUMENT_FRAGMENT_NODE:
			var child = node.firstChild;
			while(child){
				serializeToString(child,buf,attributeSorter,isHTML);
				child = child.nextSibling;
			}
			return;
		case ATTRIBUTE_NODE:
			return buf.push(' ',node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');
		case TEXT_NODE:
			return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));
		case CDATA_SECTION_NODE:
			return buf.push( '<![CDATA[',node.data,']]>');
		case COMMENT_NODE:
			return buf.push( "<!--",node.data,"-->");
		case DOCUMENT_TYPE_NODE:
			var pubid = node.publicId;
			var sysid = node.systemId;
			buf.push('<!DOCTYPE ',node.name);
			if(pubid){
				buf.push(' PUBLIC "',pubid);
				if (sysid && sysid!='.') {
					buf.push( '" "',sysid);
				}
				buf.push('">');
			}else if(sysid && sysid!='.'){
				buf.push(' SYSTEM "',sysid,'">');
			}else{
				var sub = node.internalSubset;
				if(sub){
					buf.push(" [",sub,"]");
				}
				buf.push(">");
			}
			return;
		case PROCESSING_INSTRUCTION_NODE:
			return buf.push( "<?",node.target," ",node.data,"?>");
		case ENTITY_REFERENCE_NODE:
			return buf.push( '&',node.nodeName,';');
		//case ENTITY_NODE:
		//case NOTATION_NODE:
		default:
			buf.push('??',node.nodeName);
		}
	}
	function importNode(doc,node,deep){
		var node2;
		switch (node.nodeType) {
		case ELEMENT_NODE:
			node2 = node.cloneNode(false);
			node2.ownerDocument = doc;
			//var attrs = node2.attributes;
			//var len = attrs.length;
			//for(var i=0;i<len;i++){
				//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
			//}
		case DOCUMENT_FRAGMENT_NODE:
			break;
		case ATTRIBUTE_NODE:
			deep = true;
			break;
		//case ENTITY_REFERENCE_NODE:
		//case PROCESSING_INSTRUCTION_NODE:
		////case TEXT_NODE:
		//case CDATA_SECTION_NODE:
		//case COMMENT_NODE:
		//	deep = false;
		//	break;
		//case DOCUMENT_NODE:
		//case DOCUMENT_TYPE_NODE:
		//cannot be imported.
		//case ENTITY_NODE:
		//case NOTATION_NODE
		//can not hit in level3
		//default:throw e;
		}
		if(!node2){
			node2 = node.cloneNode(false);//false
		}
		node2.ownerDocument = doc;
		node2.parentNode = null;
		if(deep){
			var child = node.firstChild;
			while(child){
				node2.appendChild(importNode(doc,child,deep));
				child = child.nextSibling;
			}
		}
		return node2;
	}
	//
	//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
	//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
	function cloneNode(doc,node,deep){
		var node2 = new node.constructor();
		for(var n in node){
			var v = node[n];
			if(typeof v != 'object' ){
				if(v != node2[n]){
					node2[n] = v;
				}
			}
		}
		if(node.childNodes){
			node2.childNodes = new NodeList();
		}
		node2.ownerDocument = doc;
		switch (node2.nodeType) {
		case ELEMENT_NODE:
			var attrs	= node.attributes;
			var attrs2	= node2.attributes = new NamedNodeMap();
			var len = attrs.length
			attrs2._ownerElement = node2;
			for(var i=0;i<len;i++){
				node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
			}
			break;;
		case ATTRIBUTE_NODE:
			deep = true;
		}
		if(deep){
			var child = node.firstChild;
			while(child){
				node2.appendChild(cloneNode(doc,child,deep));
				child = child.nextSibling;
			}
		}
		return node2;
	}

	function __set__(object,key,value){
		object[key] = value
	}
	//do dynamic
	try{
		if(Object.defineProperty){
			Object.defineProperty(LiveNodeList.prototype,'length',{
				get:function(){
					_updateLiveList(this);
					return this.$$length;
				}
			});
			Object.defineProperty(Node.prototype,'textContent',{
				get:function(){
					return getTextContent(this);
				},
				set:function(data){
					switch(this.nodeType){
					case 1:
					case 11:
						while(this.firstChild){
							this.removeChild(this.firstChild);
						}
						if(data || String(data)){
							this.appendChild(this.ownerDocument.createTextNode(data));
						}
						break;
					default:
						//TODO:
						this.data = data;
						this.value = value;
						this.nodeValue = data;
					}
				}
			})
			
			function getTextContent(node){
				switch(node.nodeType){
				case 1:
				case 11:
					var buf = [];
					node = node.firstChild;
					while(node){
						if(node.nodeType!==7 && node.nodeType !==8){
							buf.push(getTextContent(node));
						}
						node = node.nextSibling;
					}
					return buf.join('');
				default:
					return node.nodeValue;
				}
			}
			__set__ = function(object,key,value){
				//console.log(value)
				object['$$'+key] = value
			}
		}
	}catch(e){//ie8
	}

	if(true){
		exports.DOMImplementation = DOMImplementation;
		exports.XMLSerializer = XMLSerializer;
	}


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
	//     http://underscorejs.org
	//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind,
	    nativeCreate       = Object.create;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.8.3';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      case 2: return function(value, other) {
	        return func.call(context, value, other);
	      };
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };

	  // A mostly-internal function to generate callbacks that can be applied
	  // to each element in a collection, returning the desired result  either
	  // identity, an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value)) return _.matcher(value);
	    return _.property(value);
	  };
	  _.iteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };

	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, undefinedOnly) {
	    return function(obj) {
	      var length = arguments.length;
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };

	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };

	  var property = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = property('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };

	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Optimized iterator function as using arguments.length
	    // in the main function will deoptimize the, see #1991.
	    function iterator(obj, iteratee, memo, keys, index, length) {
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    }

	    return function(obj, iteratee, memo, context) {
	      iteratee = optimizeCb(iteratee, context, 4);
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      // Determine the initial value if none is provided.
	      if (arguments.length < 3) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      return iterator(obj, iteratee, memo, keys, index, length);
	    };
	  }

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var key;
	    if (isArrayLike(obj)) {
	      key = _.findIndex(obj, predicate, context);
	    } else {
	      key = _.findKey(obj, predicate, context);
	    }
	    if (key !== void 0 && key !== -1) return obj[key];
	  };

	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };

	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      var func = isFunc ? method : value[method];
	      return func == null ? func : func.apply(value, args);
	    });
	  };

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };

	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Shuffle a collection, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
	  _.shuffle = function(obj) {
	    var set = isArrayLike(obj) ? obj : _.values(obj);
	    var length = set.length;
	    var shuffled = Array(length);
	    for (var index = 0, rand; index < length; index++) {
	      rand = _.random(0, index);
	      if (rand !== index) shuffled[index] = shuffled[rand];
	      shuffled[rand] = set[index];
	    }
	    return shuffled;
	  };

	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };

	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iteratee(value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iteratee, context) {
	      var result = {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key]++; else result[key] = 1;
	  });

	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var pass = [], fail = [];
	    _.each(obj, function(value, key, obj) {
	      (predicate(value, key, obj) ? pass : fail).push(value);
	    });
	    return [pass, fail];
	  };

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, startIndex) {
	    var output = [], idx = 0;
	    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        //flatten current level of array or arguments object
	        if (!shallow) value = flatten(value, shallow, strict);
	        var j = 0, len = value.length;
	        output.length += len;
	        while (j < len) {
	          output[idx++] = value[j++];
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(flatten(arguments, true, true));
	  };

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      for (var j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = flatten(arguments, true, true, 1);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    return _.unzip(arguments);
	  };

	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // Generator function to create the findIndex and findLastIndex functions
	  function createPredicateIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }

	  // Returns the first index on an array-like that passes a predicate test
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };

	  // Generator function to create the indexOf and lastIndexOf functions
	  function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	            i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  }

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = step || 1;

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var args = slice.call(arguments, 2);
	    var bound = function() {
	      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
	    };
	    return bound;
	  };

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  };

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var i, length = arguments.length, key;
	    if (length <= 1) throw new Error('bindAll must be passed function names');
	    for (i = 1; i < length; i++) {
	      key = arguments[i];
	      obj[key] = _.bind(obj[key], obj);
	    }
	    return obj;
	  };

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){
	      return func.apply(null, args);
	    }, wait);
	  };

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    if (!options) options = {};
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;

	    var later = function() {
	      var last = _.now() - timestamp;

	      if (last < wait && last >= 0) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          if (!timeout) context = args = null;
	        }
	      }
	    };

	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) timeout = setTimeout(later, wait);
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }

	      return result;
	    };
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };

	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };

	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  function collectNonEnumProps(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  }

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Returns the results of applying the iteratee to each element of the object
	  // In contrast to _.map it returns an object
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys =  _.keys(obj),
	          length = keys.length,
	          results = {},
	          currentKey;
	      for (var index = 0; index < length; index++) {
	        currentKey = keys[index];
	        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	      }
	      return results;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s)
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);

	  // Returns the first key on an object that passes a predicate test
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(object, oiteratee, context) {
	    var result = {}, obj = object, iteratee, keys;
	    if (obj == null) return result;
	    if (_.isFunction(oiteratee)) {
	      keys = _.allKeys(obj);
	      iteratee = optimizeCb(oiteratee, context);
	    } else {
	      keys = flatten(arguments, false, false, 1);
	      iteratee = function(value, key, obj) { return key in obj; };
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  };

	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj, iteratee, context) {
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	    } else {
	      var keys = _.map(flatten(arguments, false, false, 1), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  };

	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };


	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return _.has(obj, 'callee');
	    };
	  }

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), and in Safari 8 (#1929).
	  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj !== +obj;
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return obj != null && hasOwnProperty.call(obj, key);
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };

	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };

	  _.noop = function(){};

	  _.property = property;

	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    return obj == null ? function(){} : function(key) {
	      return obj[key];
	    };
	  };

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };

	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };

	   // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);

	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property, fallback) {
	    var value = object == null ? void 0 : object[property];
	    if (value === void 0) {
	      value = fallback;
	    }
	    return _.isFunction(value) ? value.call(object) : value;
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escaper, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offest.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    try {
	      var render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var result = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result(this, func.apply(_, args));
	      };
	    });
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return result(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return '' + this._wrapped;
	  };

	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}.call(this));


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [
		{
			"classes": [
				{
					"name": "GlobalSchema",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Referencable",
							"nameSpace": "",
							"basicName": "Referencable",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "Sys.SchemaString",
									"nameSpace": "Sys",
									"basicName": "SchemaString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/api.ts"
								}
							],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/api.ts"
						}
					],
					"fields": [
						{
							"name": "key",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the global schema, used to refer on schema content"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "value",
							"type": {
								"typeName": "Sys.SchemaString",
								"nameSpace": "Sys",
								"basicName": "SchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Content of the schema"
									]
								},
								{
									"name": "MetaModel.value",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"value"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"Content of the schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "RAMLSimpleElement",
							"nameSpace": "",
							"basicName": "RAMLSimpleElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/api.ts"
						}
					],
					"moduleName": "RAMLSpec",
					"annotationOverridings": {}
				},
				{
					"name": "Api",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The title property is a short plain text description of the RESTful API. The value SHOULD be suitable for use as a title for the contained user documentation."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "version",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"If the RAML API definition is targeted to a specific API version, the API definition MUST contain a version property. The version property is OPTIONAL and should not be used if: The API itself is not versioned. The API definition does not change between versions. The API architect can decide whether a change to user documentation elements, but no change to the API's resources, constitutes a version change. The API architect MAY use any versioning scheme so long as version numbers retain the same format. For example, 'v3', 'v3.0', and 'V3' are all allowed, but are not considered to be equal."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "baseUri",
							"type": {
								"typeName": "Sys.FullUriTemplateString",
								"nameSpace": "Sys",
								"basicName": "FullUriTemplateString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional during development; Required after implementation) A RESTful API's resources are defined relative to the API's base URI. The use of the baseUri field is OPTIONAL to allow describing APIs that have not yet been implemented. After the API is implemented (even a mock implementation) and can be accessed at a service endpoint, the API definition MUST contain a baseUri property. The baseUri property's value MUST conform to the URI specification RFC2396 or a Level 1 Template URI as defined in RFC6570. The baseUri property SHOULD only be used as a reference value."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "baseUriParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.BURI"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Base uri parameters are named parameters which described template parameters in the base uri"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uriParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.BURI"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"URI parameters can be further defined by using the uriParameters property. The use of uriParameters is OPTIONAL. The uriParameters property MUST be a map in which each key MUST be the name of the URI parameter as defined in the baseUri property. The uriParameters CANNOT contain a key named version because it is a reserved URI parameter name. The value of the uriParameters property is itself a map that specifies  the property's attributes as named parameters"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "protocols",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"HTTP",
											"HTTPS"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A RESTful API can be reached HTTP, HTTPS, or both. The protocols property MAY be used to specify the protocols that an API supports. If the protocols property is not specified, the protocol specified at the baseUri property is used. The protocols property MUST be an array of strings, of values `HTTP` and/or `HTTPS`."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "mediaType",
							"type": {
								"typeName": "Bodies.MimeType",
								"nameSpace": "Bodies",
								"basicName": "MimeType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.oftenKeys",
									"arguments": [
										[
											"application/json",
											"application/xml",
											"application/x-www-form-urlencoded",
											"multipart/formdata"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional) The media types returned by API responses, and expected from API requests that accept a body, MAY be defaulted by specifying the mediaType property. This property is specified at the root level of the API definition. The property's value MAY be a single string with a valid media type described in the specification."
									]
								},
								{
									"name": "MetaModel.inherited",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "schemas",
							"type": {
								"base": {
									"typeName": "GlobalSchema",
									"nameSpace": "",
									"basicName": "GlobalSchema",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"To better achieve consistency and simplicity, the API definition SHOULD include an OPTIONAL schemas property in the root section. The schemas property specifies collections of schemas that could be used anywhere in the API definition. The value of the schemas property is an array of maps; in each map, the keys are the schema name, and the values are schema definitions. The schema definitions MAY be included inline or by using the RAML !include user-defined data type."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "traits",
							"type": {
								"base": {
									"typeName": "Methods.Trait",
									"nameSpace": "Methods",
									"basicName": "Trait",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of traits used in this API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "Security.SecuritySchemeRef",
									"nameSpace": "Security",
									"basicName": "SecuritySchemeRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.allowNull",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of the security schemes to apply to all methods, these must be defined in the securitySchemes declaration."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securitySchemes",
							"type": {
								"base": {
									"typeName": "Security.AbstractSecurityScheme",
									"nameSpace": "Security",
									"basicName": "AbstractSecurityScheme",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Security schemes that can be applied using securedBy"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "resourceTypes",
							"type": {
								"base": {
									"typeName": "Resources.ResourceType",
									"nameSpace": "Resources",
									"basicName": "ResourceType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declaration of resource types used in this API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "resources",
							"type": {
								"base": {
									"typeName": "Resources.Resource",
									"nameSpace": "Resources",
									"basicName": "Resource",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Resource"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Resources are identified by their relative URI, which MUST begin with a slash (/). A resource defined as a root-level property is called a top-level resource. Its property's key is the resource's URI relative to the baseUri. A resource defined as a child property of another resource is called a nested resource, and its property's key is its URI relative to its parent resource's URI. Every property whose key begins with a slash (/), and is either at the root of the API definition or is the child property of a resource property, is a resource property. The key of a resource, i.e. its relative URI, MAY consist of multiple URI path fragments separated by slashes; e.g. `/bom/items` may indicate the collection of items in a bill of materials as a single resource. However, if the individual URI path fragments are themselves resources, the API definition SHOULD use nested resources to describe this structure; e.g. if `/bom` is itself a resource then `/items` should be a nested resource of `/bom`, while `/bom/items` should not be used."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "documentation",
							"type": {
								"base": {
									"typeName": "DocumentationItem",
									"nameSpace": "",
									"basicName": "DocumentationItem",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The API definition can include a variety of documents that serve as a user guides and reference documentation for the API. Such documents can clarify how the API works or provide business context. Documentation-generators MUST include all the sections in an API definition's documentation property in the documentation output, and they MUST preserve the order in which the documentation is declared. To add user documentation to the API, include the documentation property at the root of the API definition. The documentation property MUST be an array of documents. Each document MUST contain title and content attributes, both of which are REQUIRED. If the documentation property is specified, it MUST include at least one document. Documentation-generators MUST process the content field as if it was defined using Markdown."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "RAMLVersion",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns AST node of security scheme, this reference refers to, or null."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": "RAMLSpec",
					"annotationOverridings": {}
				},
				{
					"name": "DocumentationItem",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"title of documentation section"
									]
								},
								{
									"name": "MetaModel.required",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "content",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Content of documentation section"
									]
								},
								{
									"name": "MetaModel.required",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "RAMLSimpleElement",
							"nameSpace": "",
							"basicName": "RAMLSimpleElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/api.ts"
						}
					],
					"moduleName": "RAMLSpec",
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts",
				"Sys": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts",
				"Params": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/parameters.ts",
				"Common": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/common.ts",
				"Bodies": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/bodies.ts",
				"Resources": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts",
				"Methods": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts",
				"Security": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
			},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/api.ts"
		},
		{
			"classes": [
				{
					"name": "SpecPartMetaData",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts"
		},
		{
			"classes": [
				{
					"name": "ValueType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "StringType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"string"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "AnyType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"any"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "NumberType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"number"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "BooleanType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"boolean"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Referencable",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Reference",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [
						{
							"name": "structuredValue",
							"type": {
								"typeName": "TypeInstance",
								"nameSpace": "",
								"basicName": "TypeInstance",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns a structured object if the reference point to one."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns name of referenced object"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DeclaresDynamicType",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [
						{
							"typeName": "Referencable",
							"nameSpace": "",
							"basicName": "Referencable",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "T",
									"nameSpace": "",
									"basicName": "T",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
								}
							],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "UriTemplate",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This type currently serves both for absolute and relative urls"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RelativeUriString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This  type describes relative uri templates"
							]
						}
					],
					"extends": [
						{
							"typeName": "UriTemplate",
							"nameSpace": "",
							"basicName": "UriTemplate",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "FullUriTemplateString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This  type describes absolute uri templates"
							]
						}
					],
					"extends": [
						{
							"typeName": "UriTemplate",
							"nameSpace": "",
							"basicName": "UriTemplate",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "FixedUri",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This  type describes fixed uris"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "MarkdownString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.innerType",
							"arguments": [
								"markdown"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"Mardown string is a string which can contain markdown as an extension this markdown should support links with RAML Pointers since 1.0"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SchemaString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Schema at this moment only two subtypes are supported (json schema and xsd)"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "JSonSchemaString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"this.mediaType&&this.mediaType.isJSON()"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"JSON schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "SchemaString",
							"nameSpace": "",
							"basicName": "SchemaString",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "XMLSchemaString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.innerType",
							"arguments": [
								"xml"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"XSD schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "SchemaString",
							"nameSpace": "",
							"basicName": "SchemaString",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ExampleString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "StatusCodeString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "JSONExample",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"this.mediaType.isJSON()"
							]
						}
					],
					"extends": [
						{
							"typeName": "ExampleString",
							"nameSpace": "",
							"basicName": "ExampleString",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "XMLExample",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"this.mediaType.isXML()"
							]
						}
					],
					"extends": [
						{
							"typeName": "ExampleString",
							"nameSpace": "",
							"basicName": "ExampleString",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "TypeInstance",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "properties",
							"type": {
								"base": {
									"typeName": "TypeInstanceProperty",
									"nameSpace": "",
									"basicName": "TypeInstanceProperty",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Array of instance properties"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "isScalar",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Whether the type is scalar"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "value",
							"type": {
								"typeName": "any",
								"nameSpace": "",
								"basicName": "any",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"For instances of scalar types returns scalar value"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.customHandling",
							"arguments": []
						}
					],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "TypeInstanceProperty",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Property name"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "value",
							"type": {
								"typeName": "TypeInstance",
								"nameSpace": "",
								"basicName": "TypeInstance",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Property value"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "values",
							"type": {
								"base": {
									"typeName": "TypeInstance",
									"nameSpace": "",
									"basicName": "TypeInstance",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Array of values if property value is array"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "isArray",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Whether property has array as value"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.customHandling",
							"arguments": []
						}
					],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts",
				"Common": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/common.ts"
			},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
		},
		{
			"classes": [
				{
					"name": "RAMLSimpleElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts",
				"Sys": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts"
			},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/common.ts"
		},
		{
			"classes": [
				{
					"name": "Parameter",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"name of the parameter"
									]
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"headers"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "displayName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"An alternate, human-friendly name for the parameter"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.defaultValue",
									"arguments": [
										"string"
									]
								},
								{
									"name": "MetaModel.descriminatingProperty",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The type attribute specifies the primitive type of the parameter's resolved value. API clients MUST return/throw an error if the parameter's resolved value does not match the specified type. If type is not specified, it defaults to string."
									]
								},
								{
									"name": "MetaModel.canBeDuplicator",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "location",
							"type": {
								"typeName": "ParameterLocation",
								"nameSpace": "",
								"basicName": "ParameterLocation",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/parameters.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.system",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Location of the parameter (can not be edited by user)"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "required",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Set to true if parameter is required"
									]
								},
								{
									"name": "MetaModel.defaultBooleanValue",
									"arguments": [
										true
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "default",
							"type": {
								"typeName": "any",
								"nameSpace": "",
								"basicName": "any",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The default attribute specifies the default value to use for the property if the property is omitted or its value is not specified. This SHOULD NOT be interpreted as a requirement for the client to send the default attribute's value if there is no other value to send. Instead, the default attribute's value is the value the server uses if the client does not send a value."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "example",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional) The example attribute shows an example value for the property. This can be used, e.g., by documentation generators to generate sample values for the property."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "repeat",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The repeat attribute specifies that the parameter can be repeated. If the parameter can be used multiple times, the repeat parameter value MUST be set to 'true'. Otherwise, the default value is 'false' and the parameter may not be repeated."
									]
								},
								{
									"name": "MetaModel.defaultBooleanValue",
									"arguments": [
										false
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/parameters.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The description attribute describes the intended use or meaning of the $self. This value MAY be formatted using Markdown."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "StringTypeDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "string"
							},
							"optional": false
						},
						{
							"name": "pattern",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type string) The pattern attribute is a regular expression that a parameter of type string MUST match. Regular expressions MUST follow the regular expression specification from ECMA 262/Perl 5. The pattern MAY be enclosed in double quotes for readability and clarity."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "enum",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "minLength",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type string) The minLength attribute specifies the parameter value's minimum number of characters."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maxLength",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type string) The maxLength attribute specifies the parameter value's maximum number of characters."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value must be a string"
							]
						}
					],
					"extends": [
						{
							"typeName": "Parameter",
							"nameSpace": "",
							"basicName": "Parameter",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "BooleanTypeDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "boolean"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value must be a boolean"
							]
						}
					],
					"extends": [
						{
							"typeName": "Parameter",
							"nameSpace": "",
							"basicName": "Parameter",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "NumberTypeDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "number"
							},
							"optional": false
						},
						{
							"name": "minimum",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type number or integer) The minimum attribute specifies the parameter's minimum value."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maximum",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type number or integer) The maximum attribute specifies the parameter's maximum value."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value MUST be a number. Indicate floating point numbers as defined by YAML."
							]
						}
					],
					"extends": [
						{
							"typeName": "Parameter",
							"nameSpace": "",
							"basicName": "Parameter",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "IntegerTypeDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "integer"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value MUST be a integer."
							]
						}
					],
					"extends": [
						{
							"typeName": "NumberTypeDeclaration",
							"nameSpace": "",
							"basicName": "NumberTypeDeclaration",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DateTypeDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "date"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value MUST be a string representation of a date as defined in RFC2616 Section 3.3. "
							]
						}
					],
					"extends": [
						{
							"typeName": "Parameter",
							"nameSpace": "",
							"basicName": "Parameter",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "FileTypeDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "file"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.requireValue",
							"arguments": [
								"location",
								"ParameterLocation.FORM"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"(Applicable only to Form properties) Value is a file. Client generators SHOULD use this type to handle file uploads correctly."
							]
						}
					],
					"extends": [
						{
							"typeName": "Parameter",
							"nameSpace": "",
							"basicName": "Parameter",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [
				{
					"name": "ParameterLocation",
					"members": [
						"QUERY",
						"HEADERS",
						"URI",
						"FORM",
						"BURI"
					]
				}
			],
			"imports": {
				"MetaModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts",
				"Sys": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts",
				"Common": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/common.ts"
			},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/parameters.ts"
		},
		{
			"classes": [
				{
					"name": "MimeType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This sub type of the string represents mime types"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/bodies.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "BodyLike",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Mime type of the request or response body"
									]
								},
								{
									"name": "MetaModel.canInherit",
									"arguments": [
										"mediaType"
									]
								},
								{
									"name": "MetaModel.oftenKeys",
									"arguments": [
										[
											"application/json",
											"application/xml",
											"application/x-www-form-urlencoded",
											"multipart/form-data"
										]
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "schema",
							"type": {
								"typeName": "Sys.SchemaString",
								"nameSpace": "Sys",
								"basicName": "SchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.requireValue",
									"arguments": [
										"this.name.isForm()",
										"false"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The structure of a request or response body MAY be further specified by the schema property under the appropriate media type. The schema key CANNOT be specified if a body's media type is application/x-www-form-urlencoded or multipart/form-data. All parsers of RAML MUST be able to interpret JSON Schema and XML Schema. Schema MAY be declared inline or in an external file. However, if the schema is sufficiently large so as to make it difficult for a person to read the API definition, or the schema is reused across multiple APIs or across multiple miles in the same API, the !include user-defined data type SHOULD be used instead of including the content inline. Alternatively, the value of the schema field MAY be the name of a schema specified in the root-level schemas property, or it MAY be declared in an external file and included by using the by using the RAML !include user-defined data type."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "example",
							"type": {
								"typeName": "Sys.ExampleString",
								"nameSpace": "Sys",
								"basicName": "ExampleString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Documentation generators MUST use body properties' example attributes to generate example invocations."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "formParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/bodies.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.FORM"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Web forms REQUIRE special encoding and custom declaration. If the API's media type is either application/x-www-form-urlencoded or multipart/form-data, the formParameters property MUST specify the name-value pairs that the API is expecting. The formParameters property is a map in which the key is the name of the web form parameter, and the value is itself a map the specifies the web form parameter's attributes."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "schemaContent",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns schema content for the cases when schema is inlined, when schema is included, and when schema is a reference."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Human readable description of the body"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.canInherit",
							"arguments": [
								"mediaType"
							]
						}
					],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "XMLBody",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "schema",
							"type": {
								"typeName": "Sys.XMLSchemaString",
								"nameSpace": "Sys",
								"basicName": "XMLSchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"XSD Schema"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"this.mime.isXML()"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"Needed to set connection between xml related mime types and xsd schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "BodyLike",
							"nameSpace": "",
							"basicName": "BodyLike",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/bodies.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "JSONBody",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "schema",
							"type": {
								"typeName": "Sys.JSonSchemaString",
								"nameSpace": "Sys",
								"basicName": "JSonSchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"JSON Schema"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"this.mime.isJSON()"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"Needed to set connection between json related mime types and json schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "BodyLike",
							"nameSpace": "",
							"basicName": "BodyLike",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/bodies.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Response",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "code",
							"type": {
								"typeName": "Sys.StatusCodeString",
								"nameSpace": "Sys",
								"basicName": "StatusCodeString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"statusCodes"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Responses MUST be a map of one or more HTTP status codes, where each status code itself is a map that describes that status code."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "headers",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/bodies.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.HEADERS"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Header"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"An API's methods may support custom header values in responses. The custom, non-standard HTTP headers MUST be specified by the headers property. API's may include the the placeholder token {?} in a header name to indicate that any number of headers that conform to the specified format can be sent in responses. This is particularly useful for APIs that allow HTTP headers that conform to some naming convention to send arbitrary, custom data."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "body",
							"type": {
								"base": {
									"typeName": "BodyLike",
									"nameSpace": "",
									"basicName": "BodyLike",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/bodies.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Body"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Each response MAY contain a body property, which conforms to the same structure as request body properties (see Body). Responses that can return more than one response code MAY therefore have multiple bodies defined. For APIs without a priori knowledge of the response types for their responses, `*/*` MAY be used to indicate that responses that do not matching other defined data types MUST be accepted. Processing applications MUST match the most descriptive media type first if `*/*` is used."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The description attribute describes the intended use or meaning of the $self. This value MAY be formatted using Markdown."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts",
				"Sys": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts",
				"Params": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/parameters.ts",
				"Common": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/common.ts"
			},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/bodies.ts"
		},
		{
			"classes": [
				{
					"name": "Resource",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "relativeUri",
							"type": {
								"typeName": "Sys.RelativeUriString",
								"nameSpace": "Sys",
								"basicName": "RelativeUriString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.startFrom",
									"arguments": [
										"/"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Relative URL of this resource from the parent resource"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "ResourceTypeRef",
								"nameSpace": "",
								"basicName": "ResourceTypeRef",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instantiation of applyed resource type"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "is",
							"type": {
								"base": {
									"typeName": "TraitRef",
									"nameSpace": "",
									"basicName": "TraitRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instantiation of applyed traits"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "SecuritySchemeRef",
									"nameSpace": "",
									"basicName": "SecuritySchemeRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.allowNull",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource. To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uriParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.URI"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Uri parameters of this resource"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "methods",
							"type": {
								"base": {
									"typeName": "Methods.Method",
									"nameSpace": "Methods",
									"basicName": "Method",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Method"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Methods that can be called on this resource"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "resources",
							"type": {
								"base": {
									"typeName": "Resource",
									"nameSpace": "",
									"basicName": "Resource",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Resource"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Children resources"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "displayName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"An alternate, human-friendly name for the resource"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "baseUriParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.BURI"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A resource or a method can override a base URI template's values. This is useful to restrict or change the default or parameter selection in the base URI. The baseUriParameters property MAY be used to override any or all parameters defined at the root level baseUriParameters property, as well as base URI parameters not specified at the root level."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The description attribute describes the intended use or meaning of the $self. This value MAY be formatted using Markdown."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ResourceTypeRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "resourceType",
							"type": {
								"typeName": "ResourceType",
								"nameSpace": "",
								"basicName": "ResourceType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns referenced resource type"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Reference",
							"nameSpace": "",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "ResourceType",
									"nameSpace": "",
									"basicName": "ResourceType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
								}
							],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ResourceType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "DeclaresDynamicType",
							"nameSpace": "",
							"basicName": "DeclaresDynamicType",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "ResourceType",
									"nameSpace": "",
									"basicName": "ResourceType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
								}
							],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
						}
					],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the resource type"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instructions on how and when the resource type should be used."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "methods",
							"type": {
								"base": {
									"typeName": "Methods.Method",
									"nameSpace": "Methods",
									"basicName": "Method",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Methods that are part of this resource type definition"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "is",
							"type": {
								"base": {
									"typeName": "Security.TraitRef",
									"nameSpace": "Security",
									"basicName": "TraitRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instantiation of applyed traits"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "ResourceTypeRef",
								"nameSpace": "",
								"basicName": "ResourceTypeRef",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instantiation of applyed resource type"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "Security.SecuritySchemeRef",
									"nameSpace": "Security",
									"basicName": "SecuritySchemeRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.allowNull",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource. To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uriParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.URI"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Uri parameters of this resource"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "displayName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"An alternate, human-friendly name for the resource type"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "baseUriParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.BURI"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A resource or a method can override a base URI template's values. This is useful to restrict or change the default or parameter selection in the base URI. The baseUriParameters property MAY be used to override any or all parameters defined at the root level baseUriParameters property, as well as base URI parameters not specified at the root level."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "parametrizedProperties",
							"type": {
								"typeName": "Sys.TypeInstance",
								"nameSpace": "Sys",
								"basicName": "TypeInstance",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns object representation of parametrized properties of the resource type"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The description attribute describes the intended use or meaning of the $self. This value MAY be formatted using Markdown."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.inlinedTemplates",
							"arguments": []
						},
						{
							"name": "MetaModel.allowQuestion",
							"arguments": []
						}
					],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts",
				"Sys": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts",
				"Params": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/parameters.ts",
				"Bodies": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/bodies.ts",
				"Common": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/common.ts",
				"Methods": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts",
				"Security": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
			},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/resources.ts"
		},
		{
			"classes": [
				{
					"name": "MethodBase",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "responses",
							"type": {
								"base": {
									"typeName": "Bodies.Response",
									"nameSpace": "Bodies",
									"basicName": "Response",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Response"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Resource methods MAY have one or more responses. Responses MAY be described using the description property, and MAY include example attributes or schema properties."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "body",
							"type": {
								"base": {
									"typeName": "Bodies.BodyLike",
									"nameSpace": "Bodies",
									"basicName": "BodyLike",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Body"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Some method verbs expect the resource to be sent as a request body. For example, to create a resource, the request must include the details of the resource to create. Resources CAN have alternate representations. For example, an API might support both JSON and XML representations. A method's body is defined in the body property as a hashmap, in which the key MUST be a valid media type."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "protocols",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"HTTP",
											"HTTPS"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A method can override an API's protocols value for that single method by setting a different value for the fields."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "SecuritySchemeRef",
									"nameSpace": "",
									"basicName": "SecuritySchemeRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.allowNull",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of the security schemas to apply, these must be defined in the securitySchemes declaration. To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme. Security schemas may also be applied to a resource with securedBy, which is equivalent to applying the security schemas to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "baseUriParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.BURI"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A resource or a method can override a base URI template's values. This is useful to restrict or change the default or parameter selection in the base URI. The baseUriParameters property MAY be used to override any or all parameters defined at the root level baseUriParameters property, as well as base URI parameters not specified at the root level."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "queryParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"ParameterLocation.QUERY"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New query parameter"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"An APIs resources MAY be filtered (to return a subset of results) or altered (such as transforming a response body from JSON to XML format) by the use of query strings. If the resource or its method supports a query string, the query string MUST be defined by the queryParameters property"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "headers",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"ParameterLocation.HEADERS"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Headers that allowed at this position"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Header"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Method object allows description of http methods"
							]
						}
					],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Method",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "method",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"methods"
									]
								},
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"get",
											"put",
											"post",
											"delete",
											"patch",
											"options",
											"head",
											"trace",
											"connect"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Method that can be called"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "is",
							"type": {
								"base": {
									"typeName": "TraitRef",
									"nameSpace": "",
									"basicName": "TraitRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instantiation of applyed traits"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "MethodBase",
							"nameSpace": "",
							"basicName": "MethodBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Trait",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "DeclaresDynamicType",
							"nameSpace": "",
							"basicName": "DeclaresDynamicType",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "Trait",
									"nameSpace": "",
									"basicName": "Trait",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts"
								}
							],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts"
						}
					],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the trait"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instructions on how and when the trait should be used."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "parametrizedProperties",
							"type": {
								"typeName": "Sys.TypeInstance",
								"nameSpace": "Sys",
								"basicName": "TypeInstance",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns object representation of parametrized properties of the trait"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "displayName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"An alternate, human-friendly name for the trait"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.inlinedTemplates",
							"arguments": []
						},
						{
							"name": "MetaModel.allowQuestion",
							"arguments": []
						}
					],
					"extends": [
						{
							"typeName": "MethodBase",
							"nameSpace": "",
							"basicName": "MethodBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "TraitRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "trait",
							"type": {
								"typeName": "Trait",
								"nameSpace": "",
								"basicName": "Trait",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns referenced trait"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Reference",
							"nameSpace": "",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "Trait",
									"nameSpace": "",
									"basicName": "Trait",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts"
								}
							],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts",
				"Sys": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts",
				"Params": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/parameters.ts",
				"Bodies": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/bodies.ts",
				"Common": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/common.ts",
				"Security": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
			},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts"
		},
		{
			"classes": [
				{
					"name": "SecuritySchemePart",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "displayName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"An alternate, human-friendly name for the security scheme part"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "is",
							"type": {
								"base": {
									"typeName": "TraitRef",
									"nameSpace": "",
									"basicName": "TraitRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instantiation of applyed traits"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "MethodBase",
							"nameSpace": "",
							"basicName": "MethodBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"headers": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Optional array of headers, documenting the possible headers that could be accepted."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Object whose property names are the request header names and whose values describe the values."
								]
							}
						],
						"queryParameters": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Query parameters, used by the schema in order to authorize the request. Mutually exclusive with queryString."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Object whose property names are the query parameter names and whose values describe the values."
								]
							}
						],
						"queryString": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Specifies the query string, used by the schema in order to authorize the request. Mutually exclusive with queryParameters."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Type name or type declaration"
								]
							}
						],
						"responses": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Optional array of responses, describing the possible responses that could be sent."
								]
							}
						],
						"description": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A longer, human-friendly description of the security scheme part"
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Markdown string"
								]
							}
						]
					}
				},
				{
					"name": "SecuritySchemeSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.allowAny",
							"arguments": []
						}
					],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "AbstractSecurityScheme",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Referencable",
							"nameSpace": "",
							"basicName": "Referencable",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "AbstractSecurityScheme",
									"nameSpace": "",
									"basicName": "AbstractSecurityScheme",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
								}
							],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
						}
					],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.startFrom",
									"arguments": [
										""
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the security scheme"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"OAuth 1.0",
											"OAuth 2.0",
											"Basic Authentication",
											"DigestSecurityScheme Authentication",
											"x-{other}"
										]
									]
								},
								{
									"name": "MetaModel.descriminatingProperty",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The securitySchemes property MUST be used to specify an API's security mechanisms, including the required settings and the authentication methods that the API supports. one authentication method is allowed if the API supports them."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"string<br><br>The value MUST be one of<br>* OAuth 1.0,<br>* OAuth 2.0, <br>* BasicSecurityScheme Authentication<br>* DigestSecurityScheme Authentication<br>* x-&lt;other&gt;"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The description attribute MAY be used to describe a security schemes property."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "describedBy",
							"type": {
								"typeName": "SecuritySchemePart",
								"nameSpace": "",
								"basicName": "SecuritySchemePart",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A description of the request components related to Security that are determined by the scheme: the headers, query parameters or responses. As a best practice, even for standard security schemes, API designers SHOULD describe these properties of security schemes. Including the security scheme description completes an API documentation."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "settings",
							"type": {
								"typeName": "SecuritySchemeSettings",
								"nameSpace": "",
								"basicName": "SecuritySchemeSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The settings attribute MAY be used to provide security scheme-specific information. The required attributes vary depending on the type of security scheme is being declared. It describes the minimum set of properties which any processing application MUST provide and validate if it chooses to implement the security scheme. Processing applications MAY choose to recognize other properties for things such as token lifetime, preferred cryptographic algorithms, and more."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemeRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "securitySchemeName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns the name of security scheme, this reference refers to."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securityScheme",
							"type": {
								"typeName": "AbstractSecurityScheme",
								"nameSpace": "",
								"basicName": "AbstractSecurityScheme",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns AST node of security scheme, this reference refers to, or null."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.allowAny",
							"arguments": []
						}
					],
					"extends": [
						{
							"typeName": "Reference",
							"nameSpace": "",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "AbstractSecurityScheme",
									"nameSpace": "",
									"basicName": "AbstractSecurityScheme",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
								}
							],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "OAuth1SecuritySchemeSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "requestTokenUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Temporary Credential Request endpoint as defined in RFC5849 Section 2.1"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUriString"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "authorizationUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Resource Owner Authorization endpoint as defined in RFC5849 Section 2.2"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUriString"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "tokenCredentialsUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Token Request endpoint as defined in RFC5849 Section 2.3"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUriString"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.allowAny",
							"arguments": []
						},
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"$parent.type=='OAuth 1.0'"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchemeSettings",
							"nameSpace": "",
							"basicName": "SecuritySchemeSettings",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "OAuth2SecuritySchemeSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "accessTokenUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Token Endpoint as defined in RFC6749 Section 3.2. Not required forby implicit grant type."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUriString"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "authorizationUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Authorization Endpoint as defined in RFC6749 Section 3.1. Required forby authorization_code and implicit grant types."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUriString"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "authorizationGrants",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of the Authorization grants supported by the API as defined in RFC6749 Sections 4.1, 4.2, 4.3 and 4.4, can be any of: authorization_code, password, client_credentials, implicit, or refresh_token."
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"A list of the Authorization grants supported by the API as defined in RFC6749 Sections 4.1, 4.2, 4.3 and 4.4, can be any of:<br>* authorization_code<br>* password<br>* client_credentials <br>* implicit<br>* refresh_token."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "scopes",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of scopes supported by the security scheme as defined in RFC6749 Section 3.3"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.allowAny",
							"arguments": []
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchemeSettings",
							"nameSpace": "",
							"basicName": "SecuritySchemeSettings",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "OAuth2SecurityScheme",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "OAuth 2.0"
							},
							"optional": false
						},
						{
							"name": "settings",
							"type": {
								"typeName": "OAuth2SecuritySchemeSettings",
								"nameSpace": "",
								"basicName": "OAuth2SecuritySchemeSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "AbstractSecurityScheme",
							"nameSpace": "",
							"basicName": "AbstractSecurityScheme",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "OAuth1SecurityScheme",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "OAuth 1.0"
							},
							"optional": false
						},
						{
							"name": "settings",
							"type": {
								"typeName": "OAuth1SecuritySchemeSettings",
								"nameSpace": "",
								"basicName": "OAuth1SecuritySchemeSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "AbstractSecurityScheme",
							"nameSpace": "",
							"basicName": "AbstractSecurityScheme",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "BasicSecurityScheme",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "Basic Authentication"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "AbstractSecurityScheme",
							"nameSpace": "",
							"basicName": "AbstractSecurityScheme",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DigestSecurityScheme",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "Digest Authentication"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "AbstractSecurityScheme",
							"nameSpace": "",
							"basicName": "AbstractSecurityScheme",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "CustomSecurityScheme",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "x-{other}"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "AbstractSecurityScheme",
							"nameSpace": "",
							"basicName": "AbstractSecurityScheme",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts",
				"Sys": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/systemTypes.ts",
				"Params": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/parameters.ts",
				"Bodies": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/bodies.ts",
				"Common": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/common.ts",
				"Methods": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/methods.ts"
			},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-0.8/security.ts"
		}
	];

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [
		{
			"classes": [
				{
					"name": "Library",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"contains description of why library exist"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Namespace which the library is imported under"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "LibraryBase",
							"nameSpace": "",
							"basicName": "LibraryBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "LibraryBase",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "schemas",
							"type": {
								"base": {
									"typeName": "TypeDeclaration",
									"nameSpace": "",
									"basicName": "TypeDeclaration",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Alias for the equivalent \"types\" property, for compatibility with RAML 0.8. Deprecated - API definitions should use the \"types\" property, as the \"schemas\" alias for that property name may be removed in a future RAML version. The \"types\" property allows for XML and JSON schemas."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "types",
							"type": {
								"base": {
									"typeName": "DataModel.TypeDeclaration",
									"nameSpace": "DataModel",
									"basicName": "TypeDeclaration",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"DataModel.LocationKind.MODELS"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of (data) types for use within this API"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of (data) types for use within this API."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map type names to type declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "traits",
							"type": {
								"base": {
									"typeName": "Methods.Trait",
									"nameSpace": "Methods",
									"basicName": "Trait",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of traits used in this API"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of traits for use within this API"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of traits for use within this API."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map trait names to trait declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "resourceTypes",
							"type": {
								"base": {
									"typeName": "Resources.ResourceType",
									"nameSpace": "Resources",
									"basicName": "ResourceType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declaration of resource types used in this API"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of resource types for use within this API"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of resource types for use within this API."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map resource type names to resource type declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "annotationTypes",
							"type": {
								"base": {
									"typeName": "DataModel.TypeDeclaration",
									"nameSpace": "DataModel",
									"basicName": "TypeDeclaration",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"decls",
										"true"
									]
								},
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of annotation types for use by annotations"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of annotation types for use by annotations."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map annotation type names to annotation type declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securitySchemes",
							"type": {
								"base": {
									"typeName": "Security.AbstractSecurityScheme",
									"nameSpace": "Security",
									"basicName": "AbstractSecurityScheme",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Security schemas declarations"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of security schemes for use within this API."
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of security schemes for use within this API."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map security scheme names to security scheme declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.internalClass",
							"arguments": []
						}
					],
					"extends": [
						{
							"typeName": "FragmentDeclaration",
							"nameSpace": "",
							"basicName": "FragmentDeclaration",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Api",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Short plain-text label for the API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A longer, human-friendly description of the API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "version",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The version of the API, e.g. 'v1'"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "baseUri",
							"type": {
								"typeName": "Sys.FullUriTemplateString",
								"nameSpace": "Sys",
								"basicName": "FullUriTemplateString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A URI that's to be used as the base of all the resources' URIs. Often used as the base of the URL of each resource, containing the location of the API. Can be a template URI."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "baseUriParameters",
							"type": {
								"base": {
									"typeName": "DataModel.TypeDeclaration",
									"nameSpace": "DataModel",
									"basicName": "TypeDeclaration",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"DataModel.ModelLocation.BURI"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"DataModel.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Named parameters used in the baseUri (template)"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "protocols",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"HTTP",
											"HTTPS"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The protocols supported by the API"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Array of strings, with each being \"HTTP\" or \"HTTPS\", case-insensitive"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "mediaType",
							"type": {
								"base": {
									"typeName": "Bodies.MimeType",
									"nameSpace": "Bodies",
									"basicName": "MimeType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.oftenKeys",
									"arguments": [
										[
											"application/json",
											"application/xml",
											"application/x-www-form-urlencoded",
											"multipart/form-data"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The default media type to use for request and response bodies (payloads), e.g. \"application/json\""
									]
								},
								{
									"name": "MetaModel.inherited",
									"arguments": []
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Media type string"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "Security.SecuritySchemeRef",
									"nameSpace": "Security",
									"basicName": "SecuritySchemeRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The security schemes that apply to every resource and method in the API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "resources",
							"type": {
								"base": {
									"typeName": "Resources.Resource",
									"nameSpace": "Resources",
									"basicName": "Resource",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.documentationTableLabel",
									"arguments": [
										"/&lt;relativeUri&gt;"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Resource"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The resources of the API, identified as relative URIs that begin with a slash (/). Every property whose key begins with a slash (/), and is either at the root of the API definition or is the child property of a resource property, is a resource property, e.g.: /users, /{groupId}, etc"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "documentation",
							"type": {
								"base": {
									"typeName": "DocumentationItem",
									"nameSpace": "",
									"basicName": "DocumentationItem",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Additional overall documentation for the API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "RAMLVersion",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns RAML version. \"RAML10\" string is returned for RAML 1.0. \"RAML08\" string is returned for RAML 0.8."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "LibraryBase",
							"nameSpace": "",
							"basicName": "LibraryBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"annotations": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Annotations to be applied to this API. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name."
								]
							}
						]
					}
				},
				{
					"name": "Overlay",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"contains description of why overlay exist"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "extends",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Location of a valid RAML API definition (or overlay or extension), the overlay is applied to."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Short plain-text label for the API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Api",
							"nameSpace": "",
							"basicName": "Api",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Extension",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"contains description of why extension exist"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "extends",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Location of a valid RAML API definition (or overlay or extension), the extension is applied to"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Short plain-text label for the API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Api",
							"nameSpace": "",
							"basicName": "Api",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "UsesDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "key",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name prefix (without dot) used to refer imported declarations"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "value",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Content of the schema"
									]
								},
								{
									"name": "MetaModel.canBeValue",
									"arguments": []
								},
								{
									"name": "MetaModel.value",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Annotable",
							"nameSpace": "",
							"basicName": "Annotable",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "FragmentDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "uses",
							"type": {
								"base": {
									"typeName": "UsesDeclaration",
									"nameSpace": "",
									"basicName": "UsesDeclaration",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Annotable",
							"nameSpace": "",
							"basicName": "Annotable",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DocumentationItem",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Title of documentation section"
									]
								},
								{
									"name": "MetaModel.required",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "content",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Content of documentation section"
									]
								},
								{
									"name": "MetaModel.required",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.possibleInterfaces",
							"arguments": [
								[
									"FragmentDeclaration"
								]
							]
						}
					],
					"extends": [
						{
							"typeName": "Annotable",
							"nameSpace": "",
							"basicName": "Annotable",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts",
				"Sys": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts",
				"Methods": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts",
				"Resources": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/resources.ts",
				"Decls": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/declarations.ts",
				"Params": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/parameters.ts",
				"Common": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/common.ts",
				"Bodies": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/bodies.ts",
				"DataModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts",
				"Security": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
			},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/api.ts"
		},
		{
			"classes": [
				{
					"name": "SpecPartMetaData",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts"
		},
		{
			"classes": [
				{
					"name": "ValueType",
					"methods": [
						{
							"returnType": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"name": "value",
							"start": 170,
							"end": 210,
							"text": "\n\n  value():string {\n    return null\n  }",
							"arguments": []
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Annotable",
							"nameSpace": "",
							"basicName": "Annotable",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "StringType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"string"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"string"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "AnyType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"any"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"any"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "NumberType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"number"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"number"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "IntegerType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"integer"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"integer"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "NullType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"null"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"null"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "TimeOnlyType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"time-only"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"time-only"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DateOnlyType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"date-only"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"date-only"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DateTimeOnlyType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"datetime-only"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"datetime-only"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DateTimeType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"datetime"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"datetime"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "FileType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"file"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"file"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "BooleanType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"boolean"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"boolean"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Reference",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [
						{
							"name": "structuredValue",
							"type": {
								"typeName": "DataModel.TypeInstance",
								"nameSpace": "DataModel",
								"basicName": "TypeInstance",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns a structured object if the reference point to one."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns name of referenced object"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "UriTemplate",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This type currently serves both for absolute and relative urls"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "StatusCodeString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RelativeUriString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This  type describes relative uri templates"
							]
						}
					],
					"extends": [
						{
							"typeName": "UriTemplate",
							"nameSpace": "",
							"basicName": "UriTemplate",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "FullUriTemplateString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This  type describes absolute uri templates"
							]
						}
					],
					"extends": [
						{
							"typeName": "UriTemplate",
							"nameSpace": "",
							"basicName": "UriTemplate",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "FixedUriString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This  type describes fixed uris"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ContentType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "MarkdownString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.innerType",
							"arguments": [
								"markdown"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"[GitHub Flavored Markdown](https://help.github.com/articles/github-flavored-markdown/)"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SchemaString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Schema at this moment only two subtypes are supported (json schema and xsd)"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts",
				"DataModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts",
				"Common": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/common.ts"
			},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts"
		},
		{
			"classes": [
				{
					"name": "ExampleSpec",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "value",
							"type": {
								"typeName": "any",
								"nameSpace": "",
								"basicName": "any",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.example",
									"arguments": []
								},
								{
									"name": "MetaModel.selfNode",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"String representation of example"
									]
								},
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"* Valid value for this type<br>* String representing the serialized version of a valid value"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "structuredValue",
							"type": {
								"typeName": "TypeInstance",
								"nameSpace": "",
								"basicName": "TypeInstance",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns object representation of example, if possible"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "strict",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"By default, examples are validated against any type declaration. Set this to false to allow examples that need not validate."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Example identifier, if specified"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "displayName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"An alternate, human-friendly name for the example"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A longer, human-friendly description of the example"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"markdown string"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.customHandling",
							"arguments": []
						},
						{
							"name": "MetaModel.possibleInterfaces",
							"arguments": [
								[
									"FragmentDeclaration"
								]
							]
						}
					],
					"extends": [
						{
							"typeName": "Annotable",
							"nameSpace": "",
							"basicName": "Annotable",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"annotations": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Annotations to be applied to this example. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name."
								]
							}
						]
					}
				},
				{
					"name": "TypeDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"name of the parameter"
									]
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"headers"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "displayName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The displayName attribute specifies the type display name. It is a friendly name used only for  display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself)."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "facets",
							"type": {
								"base": {
									"typeName": "TypeDeclaration",
									"nameSpace": "",
									"basicName": "TypeDeclaration",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.declaringFields",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"When extending from a type you can define new facets (which can then be set to concrete values by subtypes)."
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "fixedFacets",
							"type": {
								"typeName": "TypeInstance",
								"nameSpace": "",
								"basicName": "TypeInstance",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns facets fixed by the type. Value is an object with properties named after facets fixed. Value of each property is a value of the corresponding facet."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "schema",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.typeExpression",
									"arguments": []
								},
								{
									"name": "MetaModel.allowMultiple",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Alias for the equivalent \"type\" property, for compatibility with RAML 0.8. Deprecated - API definitions should use the \"type\" property, as the \"schema\" alias for that property name may be removed in a future RAML version. The \"type\" property allows for XML and JSON schemas."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Single string denoting the base type or type expression"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.typeExpression",
									"arguments": []
								},
								{
									"name": "MetaModel.allowMultiple",
									"arguments": []
								},
								{
									"name": "MetaModel.canBeValue",
									"arguments": []
								},
								{
									"name": "MetaModel.defaultValue",
									"arguments": [
										"string"
									]
								},
								{
									"name": "MetaModel.descriminatingProperty",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A base type which the current type extends, or more generally a type expression."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"string denoting the base type or type expression"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "structuredType",
							"type": {
								"typeName": "TypeInstance",
								"nameSpace": "",
								"basicName": "TypeInstance",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.typeExpression",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Inlined supertype definition."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Inlined supertype definition"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "location",
							"type": {
								"typeName": "ModelLocation",
								"nameSpace": "",
								"basicName": "ModelLocation",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.system",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Location of the parameter (can not be edited by user)"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "locationKind",
							"type": {
								"typeName": "LocationKind",
								"nameSpace": "",
								"basicName": "LocationKind",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.system",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Kind of location"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "default",
							"type": {
								"typeName": "any",
								"nameSpace": "",
								"basicName": "any",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Provides default value for a property"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "example",
							"type": {
								"typeName": "ExampleSpec",
								"nameSpace": "",
								"basicName": "ExampleSpec",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.example",
									"arguments": []
								},
								{
									"name": "MetaModel.selfNode",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"An example of this type instance represented as string or yaml map/sequence. This can be used, e.g., by documentation generators to generate sample values for an object of this type. Cannot be present if the examples property is present."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"* Valid value for this type<br>* String representing the serialized version of a valid value"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "examples",
							"type": {
								"base": {
									"typeName": "ExampleSpec",
									"nameSpace": "",
									"basicName": "ExampleSpec",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.example",
									"arguments": []
								},
								{
									"name": "MetaModel.selfNode",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"An example of this type instance represented as string. This can be used, e.g., by documentation generators to generate sample values for an object of this type. Cannot be present if the example property is present."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"* Valid value for this type<br>* String representing the serialized version of a valid value"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "required",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.requireValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Sets if property is optional or not"
									]
								},
								{
									"name": "MetaModel.describesAnnotation",
									"arguments": [
										"required"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								},
								{
									"name": "MetaModel.defaultBooleanValue",
									"arguments": [
										true
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A longer, human-friendly description of the type"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"markdown string"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "xml",
							"type": {
								"typeName": "XMLFacetInfo",
								"nameSpace": "",
								"basicName": "XMLFacetInfo",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "allowedTargets",
							"type": {
								"base": {
									"typeName": "AnnotationTarget",
									"nameSpace": "",
									"basicName": "AnnotationTarget",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"API",
											"DocumentationItem",
											"Resource",
											"Method",
											"Response",
											"RequestBody",
											"ResponseBody",
											"TypeDeclaration",
											"NamedExample",
											"ResourceType",
											"Trait",
											"SecurityScheme",
											"SecuritySchemeSettings",
											"AnnotationTypeDeclaration",
											"Library",
											"Overlay",
											"Extension",
											"Scalar"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Restrictions on where annotations of this type can be applied. If this property is specified, annotations of this type may only be applied on a property corresponding to one of the target names specified as the value of this property."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An array, or single, of names allowed target nodes."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "isAnnotation",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Whether the type represents annotation"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "parametrizedProperties",
							"type": {
								"typeName": "TypeInstance",
								"nameSpace": "",
								"basicName": "TypeInstance",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"For types defined in traits or resource types returns object representation of parametrized properties"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.convertsToGlobalOfType",
							"arguments": [
								"SchemaString"
							]
						},
						{
							"name": "MetaModel.canInherit",
							"arguments": [
								"mediaType"
							]
						},
						{
							"name": "MetaModel.possibleInterfaces",
							"arguments": [
								[
									"FragmentDeclaration"
								]
							]
						}
					],
					"extends": [
						{
							"typeName": "Annotable",
							"nameSpace": "",
							"basicName": "Annotable",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"annotations": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Annotations to be applied to this type. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name."
								]
							}
						]
					}
				},
				{
					"name": "XMLFacetInfo",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "attribute",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"If attribute is set to true, a type instance should be serialized as an XML attribute. It can only be true for scalar types."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "wrapped",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"If wrapped is set to true, a type instance should be wrapped in its own XML element. It can not be true for scalar types and it can not be true at the same moment when attribute is true."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Allows to override the name of the XML element or XML attribute in it's XML representation."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "namespace",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Allows to configure the name of the XML namespace."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "prefix",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Allows to configure the prefix which will be used during serialization to XML."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Annotable",
							"nameSpace": "",
							"basicName": "Annotable",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ArrayTypeDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "array"
							},
							"optional": false
						},
						{
							"name": "uniqueItems",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"uniqueItems"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Should items in array be unique"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "items",
							"type": {
								"typeName": "TypeDeclaration",
								"nameSpace": "",
								"basicName": "TypeDeclaration",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Array component type."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Inline type declaration or type name."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "minItems",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"minItems"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Minimum amount of items in array"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"integer ( >= 0 ). Defaults to 0"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maxItems",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"maxItems"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Maximum amount of items in array"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"integer ( >= 0 ). Defaults to undefined."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.convertsToGlobalOfType",
							"arguments": [
								"SchemaString"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"array"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"TypeDeclaration"
							]
						}
					],
					"extends": [
						{
							"typeName": "TypeDeclaration",
							"nameSpace": "",
							"basicName": "TypeDeclaration",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "UnionTypeDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "union"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.convertsToGlobalOfType",
							"arguments": [
								"SchemaString"
							]
						},
						{
							"name": "MetaModel.requireValue",
							"arguments": [
								"locationKind",
								"LocationKind.MODELS"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"TypeDeclaration"
							]
						}
					],
					"extends": [
						{
							"typeName": "TypeDeclaration",
							"nameSpace": "",
							"basicName": "TypeDeclaration",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ObjectTypeDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "object"
							},
							"optional": false
						},
						{
							"name": "properties",
							"type": {
								"base": {
									"typeName": "TypeDeclaration",
									"nameSpace": "",
									"basicName": "TypeDeclaration",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The properties that instances of this type may or must have."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose keys are the properties' names and whose values are property declarations."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "minProperties",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"minProperties"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The minimum number of properties allowed for instances of this type."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maxProperties",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"maxProperties"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The maximum number of properties allowed for instances of this type."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "additionalProperties",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A Boolean that indicates if an object instance has additional properties."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "discriminator",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Type property name to be used as discriminator, or boolean"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "discriminatorValue",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The value of discriminator for the type."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.definingPropertyIsEnough",
							"arguments": [
								"properties"
							]
						},
						{
							"name": "MetaModel.setsContextValue",
							"arguments": [
								"field",
								"true"
							]
						},
						{
							"name": "MetaModel.convertsToGlobalOfType",
							"arguments": [
								"SchemaString"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"TypeDeclaration"
							]
						}
					],
					"extends": [
						{
							"typeName": "TypeDeclaration",
							"nameSpace": "",
							"basicName": "TypeDeclaration",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "StringTypeDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "string"
							},
							"optional": false
						},
						{
							"name": "pattern",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"pattern"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Regular expression that this string should path"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"regexp"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "minLength",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"minLength"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Minimum length of the string"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maxLength",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"maxLength"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Maximum length of the string"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "enum",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"enum"
									]
								},
								{
									"name": "MetaModel.describesAnnotation",
									"arguments": [
										"oneOf"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error."
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value must be a string"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"TypeDeclaration"
							]
						}
					],
					"extends": [
						{
							"typeName": "TypeDeclaration",
							"nameSpace": "",
							"basicName": "TypeDeclaration",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "BooleanTypeDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "boolean"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value must be a boolean"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"TypeDeclaration"
							]
						}
					],
					"extends": [
						{
							"typeName": "TypeDeclaration",
							"nameSpace": "",
							"basicName": "TypeDeclaration",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "NumberTypeDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "number"
							},
							"optional": false
						},
						{
							"name": "minimum",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"minimum"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type number or integer) The minimum attribute specifies the parameter's minimum value."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maximum",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"maximum"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type number or integer) The maximum attribute specifies the parameter's maximum value."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "enum",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"enum"
									]
								},
								{
									"name": "MetaModel.describesAnnotation",
									"arguments": [
										"oneOf"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error."
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "format",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"int32",
											"int64",
											"int",
											"long",
											"float",
											"double",
											"int16",
											"int8"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Value format"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "multipleOf",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A numeric instance is valid against \"multipleOf\" if the result of the division of the instance by this keyword's value is an integer."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value MUST be a number. Indicate floating point numbers as defined by YAML."
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"TypeDeclaration"
							]
						}
					],
					"extends": [
						{
							"typeName": "TypeDeclaration",
							"nameSpace": "",
							"basicName": "TypeDeclaration",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "IntegerTypeDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "integer"
							},
							"optional": false
						},
						{
							"name": "format",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"int32",
											"int64",
											"int",
											"long",
											"int16",
											"int8"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Value format"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value MUST be a integer."
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"TypeDeclaration"
							]
						}
					],
					"extends": [
						{
							"typeName": "NumberTypeDeclaration",
							"nameSpace": "",
							"basicName": "NumberTypeDeclaration",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DateOnlyTypeDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "date-only"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"the \"full-date\" notation of RFC3339, namely yyyy-mm-dd (no implications about time or timezone-offset)"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"TypeDeclaration"
							]
						}
					],
					"extends": [
						{
							"typeName": "TypeDeclaration",
							"nameSpace": "",
							"basicName": "TypeDeclaration",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "TimeOnlyTypeDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "time-only"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"the \"partial-time\" notation of RFC3339, namely hh:mm:ss[.ff...] (no implications about date or timezone-offset)"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"TypeDeclaration"
							]
						}
					],
					"extends": [
						{
							"typeName": "TypeDeclaration",
							"nameSpace": "",
							"basicName": "TypeDeclaration",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DateTimeOnlyTypeDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "datetime-only"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"combined date-only and time-only with a separator of \"T\", namely yyyy-mm-ddThh:mm:ss[.ff...] (no implications about timezone-offset)"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"TypeDeclaration"
							]
						}
					],
					"extends": [
						{
							"typeName": "TypeDeclaration",
							"nameSpace": "",
							"basicName": "TypeDeclaration",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DateTimeTypeDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "datetime"
							},
							"optional": false
						},
						{
							"name": "format",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"rfc3339",
											"rfc2616"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Format used for this date time rfc3339 or rfc2616"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"a timestamp, either in the \"date-time\" notation of RFC3339, if format is omitted or is set to rfc3339, or in the format defined in RFC2616, if format is set to rfc2616."
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"TypeDeclaration"
							]
						}
					],
					"extends": [
						{
							"typeName": "TypeDeclaration",
							"nameSpace": "",
							"basicName": "TypeDeclaration",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "TypeInstance",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "properties",
							"type": {
								"base": {
									"typeName": "TypeInstanceProperty",
									"nameSpace": "",
									"basicName": "TypeInstanceProperty",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Array of instance properties"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "isScalar",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Whether the type is scalar"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "value",
							"type": {
								"typeName": "any",
								"nameSpace": "",
								"basicName": "any",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"For instances of scalar types returns scalar value"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "isArray",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Indicates whether the instance is array"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "items",
							"type": {
								"base": {
									"typeName": "TypeInstance",
									"nameSpace": "",
									"basicName": "TypeInstance",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns components of array instances"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.customHandling",
							"arguments": []
						}
					],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "TypeInstanceProperty",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Property name"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "value",
							"type": {
								"typeName": "TypeInstance",
								"nameSpace": "",
								"basicName": "TypeInstance",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Property value"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "values",
							"type": {
								"base": {
									"typeName": "TypeInstance",
									"nameSpace": "",
									"basicName": "TypeInstance",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Array of values if property value is array"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "isArray",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Whether property has array as value"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.customHandling",
							"arguments": []
						}
					],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [
				{
					"name": "ModelLocation",
					"members": [
						"QUERY",
						"HEADERS",
						"URI",
						"FORM",
						"BURI",
						"ANNOTATION",
						"MODEL",
						"SECURITYSCHEMATYPE"
					]
				},
				{
					"name": "LocationKind",
					"members": [
						"APISTRUCTURE",
						"DECLARATIONS",
						"MODELS"
					]
				}
			],
			"imports": {
				"MetaModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts",
				"Sys": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts",
				"Bodies": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/bodies.ts",
				"Common": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/common.ts",
				"Declarations": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/declarations.ts"
			},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
		},
		{
			"classes": [
				{
					"name": "MimeType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This sub type of the string represents mime types"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/bodies.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Response",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "code",
							"type": {
								"typeName": "Sys.StatusCodeString",
								"nameSpace": "Sys",
								"basicName": "StatusCodeString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"statusCodes"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Responses MUST be a map of one or more HTTP status codes, where each status code itself is a map that describes that status code."
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "headers",
							"type": {
								"base": {
									"typeName": "DataModel.TypeDeclaration",
									"nameSpace": "DataModel",
									"basicName": "TypeDeclaration",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/bodies.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"DataModel.ModelLocation.HEADERS"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"DataModel.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Header"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Detailed information about any response headers returned by this method"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Object whose property names are the response header names and whose values describe the values."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "body",
							"type": {
								"base": {
									"typeName": "DataModel.TypeDeclaration",
									"nameSpace": "DataModel",
									"basicName": "TypeDeclaration",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/bodies.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Body"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The body of the response: a body declaration"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Object whose properties are either<br>* Media types and whose values are type objects describing the request body for that media type, or<br>* a type object describing the request body for the default media type specified in the root mediaType property."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A longer, human-friendly description of the response"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Markdown string"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Annotable",
							"nameSpace": "",
							"basicName": "Annotable",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/bodies.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"An alternate, human-friendly name for the response"
								]
							}
						],
						"annotations": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Annotations to be applied to this response. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name."
								]
							}
						]
					}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts",
				"Sys": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts",
				"DataModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts",
				"Common": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/common.ts"
			},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/bodies.ts"
		},
		{
			"classes": [
				{
					"name": "Annotable",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "annotations",
							"type": {
								"base": {
									"typeName": "Decls.AnnotationRef",
									"nameSpace": "Decls",
									"basicName": "AnnotationRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/common.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.noDirectParse",
									"arguments": []
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"datamodel.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"datamodel.ModelLocation.ANNOTATION"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Most of RAML model elements may have attached annotations decribing additional meta data about this element"
									]
								},
								{
									"name": "MetaModel.documentationTableLabel",
									"arguments": [
										"(&lt;annotationName&gt;)"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"A value corresponding to the declared type of this annotation."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts",
				"Sys": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts",
				"Decls": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/declarations.ts"
			},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/common.ts"
		},
		{
			"classes": [
				{
					"name": "AnnotationRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "annotation",
							"type": {
								"typeName": "DataModel.TypeDeclaration",
								"nameSpace": "DataModel",
								"basicName": "TypeDeclaration",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/declarations.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns referenced annotation"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Annotations allow you to attach information to your API"
							]
						},
						{
							"name": "MetaModel.tags",
							"arguments": [
								[
									"annotations"
								]
							]
						}
					],
					"extends": [
						{
							"typeName": "Reference",
							"nameSpace": "",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "DataModel.TypeDeclaration",
									"nameSpace": "DataModel",
									"basicName": "TypeDeclaration",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/declarations.ts"
								}
							],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/declarations.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "AnnotationTarget",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Elements to which this Annotation can be applied (enum)"
							]
						},
						{
							"name": "MetaModel.tags",
							"arguments": [
								[
									"annotations"
								]
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/declarations.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts",
				"Sys": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts",
				"DataModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts",
				"Common": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/common.ts"
			},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/declarations.ts"
		},
		{
			"classes": [
				{
					"name": "TraitRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "trait",
							"type": {
								"typeName": "Trait",
								"nameSpace": "",
								"basicName": "Trait",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns referenced trait"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Reference",
							"nameSpace": "",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "Trait",
									"nameSpace": "",
									"basicName": "Trait",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
								}
							],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Trait",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the trait"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instructions on how and when the trait should be used."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "parametrizedProperties",
							"type": {
								"typeName": "DataModel.TypeInstance",
								"nameSpace": "DataModel",
								"basicName": "TypeInstance",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns object representation of parametrized properties of the trait"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.inlinedTemplates",
							"arguments": []
						},
						{
							"name": "MetaModel.allowQuestion",
							"arguments": []
						},
						{
							"name": "MetaModel.possibleInterfaces",
							"arguments": [
								[
									"FragmentDeclaration"
								]
							]
						}
					],
					"extends": [
						{
							"typeName": "MethodBase",
							"nameSpace": "",
							"basicName": "MethodBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"The displayName attribute specifies the trait display name. It is a friendly name used only for  display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself)."
								]
							}
						]
					}
				},
				{
					"name": "MethodBase",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "body",
							"type": {
								"base": {
									"typeName": "DataModel.TypeDeclaration",
									"nameSpace": "DataModel",
									"basicName": "TypeDeclaration",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Body"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Some method verbs expect the resource to be sent as a request body. For example, to create a resource, the request must include the details of the resource to create. Resources CAN have alternate representations. For example, an API might support both JSON and XML representations. A method's body is defined in the body property as a hashmap, in which the key MUST be a valid media type."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "protocols",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"HTTP",
											"HTTPS"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A method can override the protocols specified in the resource or at the API root, by employing this property."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"array of strings of value HTTP or HTTPS, or a single string of such kind, case-insensitive"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "is",
							"type": {
								"base": {
									"typeName": "TraitRef",
									"nameSpace": "",
									"basicName": "TraitRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instantiation of applyed traits"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "Security.SecuritySchemeRef",
									"nameSpace": "Security",
									"basicName": "SecuritySchemeRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.allowNull",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource. To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "displayName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Operation",
							"nameSpace": "",
							"basicName": "Operation",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Method",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "method",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"methods"
									]
								},
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"get",
											"put",
											"post",
											"delete",
											"options",
											"head",
											"patch"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Method that can be called"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "parametrizedProperties",
							"type": {
								"typeName": "DataModel.TypeInstance",
								"nameSpace": "DataModel",
								"basicName": "TypeInstance",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"For types defined in resource types returns object representation of parametrized properties"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "MethodBase",
							"nameSpace": "",
							"basicName": "MethodBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"The displayName attribute specifies the method display name. It is a friendly name used only for  display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself)."
								]
							}
						]
					}
				},
				{
					"name": "Operation",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "queryParameters",
							"type": {
								"base": {
									"typeName": "DataModel.TypeDeclaration",
									"nameSpace": "DataModel",
									"basicName": "TypeDeclaration",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"DataModel.ModelLocation.QUERY"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"DataModel.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New query parameter"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"An APIs resources MAY be filtered (to return a subset of results) or altered (such as transforming  a response body from JSON to XML format) by the use of query strings. If the resource or its method supports a query string, the query string MUST be defined by the queryParameters property"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "headers",
							"type": {
								"base": {
									"typeName": "DataModel.TypeDeclaration",
									"nameSpace": "DataModel",
									"basicName": "TypeDeclaration",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"DataModel.ModelLocation.HEADERS"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"DataModel.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Headers that allowed at this position"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Header"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "queryString",
							"type": {
								"typeName": "DataModel.TypeDeclaration",
								"nameSpace": "DataModel",
								"basicName": "TypeDeclaration",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Specifies the query string needed by this method. Mutually exclusive with queryParameters."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "responses",
							"type": {
								"base": {
									"typeName": "Bodies.Response",
									"nameSpace": "Bodies",
									"basicName": "Response",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"response",
										"true"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Response"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Information about the expected responses to a request"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose keys are the HTTP status codes of the responses and whose values describe the responses."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Annotable",
							"nameSpace": "",
							"basicName": "Annotable",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts",
				"Sys": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts",
				"Bodies": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/bodies.ts",
				"DataModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts",
				"Security": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
			},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
		},
		{
			"classes": [
				{
					"name": "SecuritySchemePart",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Operation",
							"nameSpace": "",
							"basicName": "Operation",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Annotations to be applied to this security scheme part. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name."
								]
							}
						]
					}
				},
				{
					"name": "SecuritySchemeSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.allowAny",
							"arguments": []
						}
					],
					"extends": [
						{
							"typeName": "Annotable",
							"nameSpace": "",
							"basicName": "Annotable",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "OAuth1SecuritySchemeSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "requestTokenUri",
							"type": {
								"typeName": "Sys.FixedUriString",
								"nameSpace": "Sys",
								"basicName": "FixedUriString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Temporary Credential Request endpoint as defined in RFC5849 Section 2.1"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUriString"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "authorizationUri",
							"type": {
								"typeName": "Sys.FixedUriString",
								"nameSpace": "Sys",
								"basicName": "FixedUriString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Resource Owner Authorization endpoint as defined in RFC5849 Section 2.2"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUriString"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "tokenCredentialsUri",
							"type": {
								"typeName": "Sys.FixedUriString",
								"nameSpace": "Sys",
								"basicName": "FixedUriString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Token Request endpoint as defined in RFC5849 Section 2.3"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUriString"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "signatures",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"HMAC-SHA1",
											"RSA-SHA1",
											"PLAINTEXT"
										]
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"List of the signature methods used by the server. Available methods: HMAC-SHA1, RSA-SHA1, PLAINTEXT"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.allowAny",
							"arguments": []
						},
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"$parent.type=='OAuth 1.0'"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchemeSettings",
							"nameSpace": "",
							"basicName": "SecuritySchemeSettings",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "OAuth2SecuritySchemeSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "accessTokenUri",
							"type": {
								"typeName": "Sys.FixedUriString",
								"nameSpace": "Sys",
								"basicName": "FixedUriString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Token Endpoint as defined in RFC6749 Section 3.2. Not required forby implicit grant type."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUriString"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "authorizationUri",
							"type": {
								"typeName": "Sys.FixedUriString",
								"nameSpace": "Sys",
								"basicName": "FixedUriString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Authorization Endpoint as defined in RFC6749 Section 3.1. Required forby authorization_code and implicit grant types."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUriString"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "authorizationGrants",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.oftenKeys",
									"arguments": [
										[
											"authorization_code",
											"password",
											"client_credentials",
											"implicit"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of the Authorization grants supported by the API as defined in RFC6749 Sections 4.1, 4.2, 4.3 and 4.4, can be any of: authorization_code, password, client_credentials, implicit, or any absolute url."
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"A list of the Authorization grants supported by the API as defined in RFC6749 Sections 4.1, 4.2, 4.3 and 4.4, can be any of:<br>* authorization_code<br>* password<br>* client_credentials<br>* implicit <br>*  or any absolute url."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "scopes",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of scopes supported by the security scheme as defined in RFC6749 Section 3.3"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.allowAny",
							"arguments": []
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchemeSettings",
							"nameSpace": "",
							"basicName": "SecuritySchemeSettings",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemeRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "securitySchemeName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns the name of security scheme, this reference refers to."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securityScheme",
							"type": {
								"typeName": "AbstractSecurityScheme",
								"nameSpace": "",
								"basicName": "AbstractSecurityScheme",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns AST node of security scheme, this reference refers to, or null."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Reference",
							"nameSpace": "",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "AbstractSecurityScheme",
									"nameSpace": "",
									"basicName": "AbstractSecurityScheme",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
								}
							],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "AbstractSecurityScheme",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.startFrom",
									"arguments": [
										""
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the security scheme"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"OAuth 1.0",
											"OAuth 2.0",
											"Basic Authentication",
											"Digest Authentication",
											"Pass Through",
											"x-{other}"
										]
									]
								},
								{
									"name": "MetaModel.descriminatingProperty",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The securitySchemes property MUST be used to specify an API's security mechanisms, including the required settings and the authentication methods that the API supports. one authentication method is allowed if the API supports them."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"string<br><br>The value MUST be one of<br>* OAuth 1.0,<br>* OAuth 2.0,<br>* BasicSecurityScheme Authentication<br>* DigestSecurityScheme Authentication<br>* Pass Through<br>* x-&lt;other&gt;"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The description attribute MAY be used to describe a security schemes property."
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The description MAY be used to describe a securityScheme."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "describedBy",
							"type": {
								"typeName": "SecuritySchemePart",
								"nameSpace": "",
								"basicName": "SecuritySchemePart",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A description of the request components related to Security that are determined by the scheme: the headers, query parameters or responses. As a best practice, even for standard security schemes, API designers SHOULD describe these properties of security schemes. Including the security scheme description completes an API documentation."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "displayName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The displayName attribute specifies the security scheme display name. It is a friendly name used only for  display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself)."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "settings",
							"type": {
								"typeName": "SecuritySchemeSettings",
								"nameSpace": "",
								"basicName": "SecuritySchemeSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The settings attribute MAY be used to provide security scheme-specific information. The required attributes vary depending on the type of security scheme is being declared. It describes the minimum set of properties which any processing application MUST provide and validate if it chooses to implement the security scheme. Processing applications MAY choose to recognize other properties for things such as token lifetime, preferred cryptographic algorithms, and more."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security scheme definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "Annotable",
							"nameSpace": "",
							"basicName": "Annotable",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "OAuth2SecurityScheme",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "OAuth 2.0"
							},
							"optional": false
						},
						{
							"name": "settings",
							"type": {
								"typeName": "OAuth2SecuritySchemeSettings",
								"nameSpace": "",
								"basicName": "OAuth2SecuritySchemeSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security scheme definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "AbstractSecurityScheme",
							"nameSpace": "",
							"basicName": "AbstractSecurityScheme",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "OAuth1SecurityScheme",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "OAuth 1.0"
							},
							"optional": false
						},
						{
							"name": "settings",
							"type": {
								"typeName": "OAuth1SecuritySchemeSettings",
								"nameSpace": "",
								"basicName": "OAuth1SecuritySchemeSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security scheme definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "AbstractSecurityScheme",
							"nameSpace": "",
							"basicName": "AbstractSecurityScheme",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "PassThroughSecurityScheme",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "Pass Through"
							},
							"optional": false
						},
						{
							"name": "settings",
							"type": {
								"typeName": "SecuritySchemeSettings",
								"nameSpace": "",
								"basicName": "SecuritySchemeSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security scheme definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "AbstractSecurityScheme",
							"nameSpace": "",
							"basicName": "AbstractSecurityScheme",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "BasicSecurityScheme",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "Basic Authentication"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security scheme definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "AbstractSecurityScheme",
							"nameSpace": "",
							"basicName": "AbstractSecurityScheme",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DigestSecurityScheme",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "Digest Authentication"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security scheme definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "AbstractSecurityScheme",
							"nameSpace": "",
							"basicName": "AbstractSecurityScheme",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "CustomSecurityScheme",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "x-{other}"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security scheme definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "AbstractSecurityScheme",
							"nameSpace": "",
							"basicName": "AbstractSecurityScheme",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts",
				"Sys": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts",
				"Methods": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
			},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts"
		},
		{
			"classes": [
				{
					"name": "ResourceTypeRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "resourceType",
							"type": {
								"typeName": "ResourceType",
								"nameSpace": "",
								"basicName": "ResourceType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/resources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns referenced resource type"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Reference",
							"nameSpace": "",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "ResourceType",
									"nameSpace": "",
									"basicName": "ResourceType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/resources.ts"
								}
							],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/resources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ResourceType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "displayName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The displayName attribute specifies the resource type display name. It is a friendly name used only for  display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself)."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the resource type"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instructions on how and when the resource type should be used."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "parametrizedProperties",
							"type": {
								"typeName": "DataModel.TypeInstance",
								"nameSpace": "DataModel",
								"basicName": "TypeInstance",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/resources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.customHandling",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Returns object representation of parametrized properties of the resource type"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.inlinedTemplates",
							"arguments": []
						},
						{
							"name": "MetaModel.allowQuestion",
							"arguments": []
						},
						{
							"name": "MetaModel.possibleInterfaces",
							"arguments": [
								[
									"FragmentDeclaration"
								]
							]
						}
					],
					"extends": [
						{
							"typeName": "ResourceBase",
							"nameSpace": "",
							"basicName": "ResourceBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/resources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ResourceBase",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "methods",
							"type": {
								"base": {
									"typeName": "Methods.Method",
									"nameSpace": "Methods",
									"basicName": "Method",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/resources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Methods that are part of this resource type definition"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"The methods available on this resource."
									]
								},
								{
									"name": "MetaModel.documentationTableLabel",
									"arguments": [
										"get?<br>patch?<br>put?<br>post?<br>delete?<br>options?<br>head?"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Object describing the method"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "is",
							"type": {
								"base": {
									"typeName": "Methods.TraitRef",
									"nameSpace": "Methods",
									"basicName": "TraitRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/resources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of the traits to apply to all methods declared (implicitly or explicitly) for this resource. Individual methods may override this declaration"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"array, which can contain each of the following elements:<br>* name of unparametrized trait <br>* a key-value pair with trait name as key and a map of trait parameters as value<br>* inline trait declaration <br><br>(or a single element of any above kind)"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "ResourceTypeRef",
								"nameSpace": "",
								"basicName": "ResourceTypeRef",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/resources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The resource type which this resource inherits."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"one of the following elements:<br>* name of unparametrized resource type<br>* a key-value pair with resource type name as key and a map of its parameters as value<br>* inline resource type declaration"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/resources.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "Security.SecuritySchemeRef",
									"nameSpace": "Security",
									"basicName": "SecuritySchemeRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/resources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.allowNull",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The security schemes that apply to all methods declared (implicitly or explicitly) for this resource."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"array of security scheme names or a single security scheme name"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uriParameters",
							"type": {
								"base": {
									"typeName": "DataModel.TypeDeclaration",
									"nameSpace": "DataModel",
									"basicName": "TypeDeclaration",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/resources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"DataModel.ModelLocation.URI"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"DataModel.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Detailed information about any URI parameters of this resource"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"object whose property names are the URI parameter names and whose values describe the values"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Annotable",
							"nameSpace": "",
							"basicName": "Annotable",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/resources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Resource",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "relativeUri",
							"type": {
								"typeName": "Sys.RelativeUriString",
								"nameSpace": "Sys",
								"basicName": "RelativeUriString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/resources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.startFrom",
									"arguments": [
										"/"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Relative URL of this resource from the parent resource"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "displayName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The displayName attribute specifies the resource display name. It is a friendly name used only for  display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself)."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "resources",
							"type": {
								"base": {
									"typeName": "Resource",
									"nameSpace": "",
									"basicName": "Resource",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/resources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Resource"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A nested resource is identified as any property whose name begins with a slash (\"/\") and is therefore treated as a relative URI."
									]
								},
								{
									"name": "MetaModel.documentationTableLabel",
									"arguments": [
										"/&lt;relativeUri&gt;"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"object describing the nested resource"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "ResourceBase",
							"nameSpace": "",
							"basicName": "ResourceBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/resources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"description": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A longer, human-friendly description of the resource."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Markdown string"
								]
							}
						],
						"annotations": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Annotations to be applied to this resource. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name."
								]
							}
						]
					}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts",
				"Sys": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts",
				"DataModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts",
				"Security": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/security.ts",
				"Methods": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/methods.ts"
			},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/resources.ts"
		},
		{
			"classes": [
				{
					"name": "FileTypeDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "file"
							},
							"optional": false
						},
						{
							"name": "fileTypes",
							"type": {
								"base": {
									"typeName": "Sys.ContentType",
									"nameSpace": "Sys",
									"basicName": "ContentType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/parameters.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"It should also include a new property: fileTypes, which should be a list of valid content-type strings for the file. The file type */* should be a valid value."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "minLength",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The minLength attribute specifies the parameter value's minimum number of bytes."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maxLength",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The maxLength attribute specifies the parameter value's maximum number of bytes."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"(Applicable only to Form properties) Value is a file. Client generators SHOULD use this type to handle file uploads correctly."
							]
						}
					],
					"extends": [
						{
							"typeName": "TypeDeclaration",
							"nameSpace": "",
							"basicName": "TypeDeclaration",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/metamodel.ts",
				"Sys": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/systemTypes.ts",
				"DataModel": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/datamodel.ts"
			},
			"name": "/Users/munch/work/repositories_official/raml-definition-system/raml-definition/spec-1.0/parameters.ts"
		}
	];

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var parse = __webpack_require__(169).parse;
	var stringify = __webpack_require__(169).stringify;

	module.exports = handleQs;
	function handleQs(url, query) {
	  url = url.split('?');
	  var start = url[0];
	  var qs = (url[1] || '').split('#')[0];
	  var end = url[1] && url[1].split('#').length > 1 ? '#' + url[1].split('#')[1] : '';

	  var baseQs = parse(qs);
	  for (var i in query) {
	    baseQs[i] = query[i];
	  }
	  qs = stringify(baseQs);
	  if (qs !== '') {
	    qs = '?' + qs;
	  }
	  return start + qs + end;
	}


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.helpers = __webpack_require__(134);
	var tsStructureParser = __webpack_require__(135);
	var EnumDeclaration = (function () {
	    function EnumDeclaration() {
	    }
	    return EnumDeclaration;
	}());
	exports.EnumDeclaration = EnumDeclaration;
	(function (TypeKind) {
	    TypeKind[TypeKind["BASIC"] = 0] = "BASIC";
	    TypeKind[TypeKind["ARRAY"] = 1] = "ARRAY";
	    TypeKind[TypeKind["UNION"] = 2] = "UNION";
	})(exports.TypeKind || (exports.TypeKind = {}));
	var TypeKind = exports.TypeKind;
	function classDecl(name, isInteface) {
	    return {
	        name: name,
	        methods: [],
	        typeParameters: [],
	        typeParameterConstraint: [],
	        implements: [],
	        fields: [],
	        isInterface: isInteface,
	        annotations: [],
	        extends: [],
	        moduleName: null,
	        annotationOverridings: {}
	    };
	}
	exports.classDecl = classDecl;
	function parseStruct(content, modules, mpth) {
	    return tsStructureParser.parseStruct(content, modules, mpth);
	}
	exports.parseStruct = parseStruct;
	//# sourceMappingURL=index.js.map

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	'use strict'

	var base64 = __webpack_require__(177)
	var ieee754 = __webpack_require__(170)
	var isArray = __webpack_require__(171)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation

	var rootParent = {}

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }

	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }

	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }

	  // Unusual.
	  return fromObject(this, arg)
	}

	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)

	  that.write(string, encoding)
	  return that
	}

	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

	  if (isArray(object)) return fromArray(that, object)

	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }

	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }

	  if (object.length) return fromArrayLike(that, object)

	  return fromJsonObject(that, object)
	}

	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}

	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}

	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0

	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)

	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}

	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }

	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent

	  return that
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break

	    ++i
	  }

	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

	  if (list.length === 0) {
	    return new Buffer(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }

	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}

	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0

	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'binary':
	        return binarySlice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0

	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1

	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }

	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}

	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'binary':
	        return binaryWrite(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  if (newBuf.length) newBuf.parent = this.parent || this

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }

	  return len
	}

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length

	  if (end < start) throw new RangeError('end < start')

	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return

	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }

	  return this
	}

	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}

	// HELPER FUNCTIONS
	// ================

	var BP = Buffer.prototype

	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true

	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set

	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set

	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer

	  return arr
	}

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(92).Buffer, (function() { return this; }())))

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	exports.parse = __webpack_require__(143);
	exports.stringify = __webpack_require__(144);


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);

	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../typings/main.d.ts" />
	var _ = __webpack_require__(175);
	var su = __webpack_require__(106);
	var tsInterfaces = __webpack_require__(97);
	var Status = (function () {
	    function Status(severity, code, message, source, takeNodeFromSource) {
	        if (takeNodeFromSource === void 0) { takeNodeFromSource = false; }
	        this.takeNodeFromSource = takeNodeFromSource;
	        this.subStatus = [];
	        this.severity = severity;
	        this.code = code;
	        this.message = message;
	        this.source = source;
	    }
	    Status.prototype.getValidationPath = function () {
	        return this.vp;
	    };
	    Status.prototype.getValidationPathAsString = function () {
	        if (!this.vp) {
	            return "";
	        }
	        var s = "";
	        var c = this.vp;
	        while (c) {
	            s += c.name;
	            if (c.child) {
	                s += '/';
	            }
	            c = c.child;
	        }
	        return s;
	    };
	    Status.prototype.patchPath = function (p) {
	        if (!p) {
	            return null;
	        }
	        else {
	            var c = p;
	            var r = null;
	            var cp = null;
	            while (c) {
	                if (!r) {
	                    r = { name: c.name };
	                    cp = r;
	                    c = c.child;
	                    cp = r;
	                }
	                else {
	                    var news = { name: c.name };
	                    cp.child = news;
	                    c = c.child;
	                    cp = news;
	                }
	            }
	            return r;
	        }
	    };
	    Status.prototype.setValidationPath = function (c) {
	        var _this = this;
	        if (this.vp) {
	            c = this.patchPath(c);
	            var m = c;
	            while (m.child) {
	                m = m.child;
	            }
	            m.child = this.vp;
	            this.vp = c;
	        }
	        else {
	            this.vp = c;
	        }
	        this.subStatus.forEach(function (x) {
	            x.setValidationPath(_this.vp);
	        });
	    };
	    Status.prototype.addSubStatus = function (st, pathName) {
	        if (pathName === void 0) { pathName = null; }
	        if (pathName) {
	            st.setValidationPath({ name: pathName });
	        }
	        this.subStatus.push(st);
	        if (this.severity < st.severity) {
	            this.severity = st.severity;
	            this.message = st.message;
	        }
	    };
	    Status.prototype.getErrors = function () {
	        if (this.isError() || this.isWarning()) {
	            if (this.subStatus.length > 0) {
	                var rs = [];
	                this.subStatus.forEach(function (x) { return rs = rs.concat(x.getErrors()); });
	                return rs;
	            }
	            return [this];
	        }
	        return [];
	    };
	    Status.prototype.getSubStatuses = function () {
	        return this.subStatus;
	    };
	    Status.prototype.getSeverity = function () {
	        return this.severity;
	    };
	    Status.prototype.getMessage = function () {
	        return this.message;
	    };
	    Status.prototype.setMessage = function (message) {
	        this.message = message;
	    };
	    Status.prototype.getSource = function () {
	        return this.source;
	    };
	    Status.prototype.isWarning = function () {
	        return this.severity == Status.WARNING;
	    };
	    Status.prototype.isError = function () {
	        return this.severity == Status.ERROR;
	    };
	    Status.prototype.isOk = function () {
	        return this.severity === Status.OK;
	    };
	    Status.prototype.setSource = function (s) {
	        this.source = s;
	    };
	    Status.prototype.toString = function () {
	        if (this.isOk()) {
	            return "OK";
	        }
	        return this.message;
	    };
	    Status.prototype.getExtra = function (name) {
	        if (this.takeNodeFromSource && name == tsInterfaces.SOURCE_EXTRA) {
	            if (this.source instanceof TypeInformation) {
	                return this.source.node();
	            }
	        }
	        return null;
	    };
	    Status.prototype.putExtra = function (name, value) { };
	    Status.CODE_CONFLICTING_TYPE_KIND = 4;
	    Status.ERROR = 3;
	    Status.INFO = 1;
	    Status.OK = 0;
	    Status.WARNING = 2;
	    return Status;
	}());
	exports.Status = Status;
	function ok() { return new Status(Status.OK, Status.OK, "", null); }
	exports.ok = ok;
	;
	exports.SCHEMA_AND_TYPE = tsInterfaces.SCHEMA_AND_TYPE_EXTRA;
	exports.GLOBAL = tsInterfaces.GLOBAL_EXTRA;
	exports.TOPLEVEL = tsInterfaces.TOP_LEVEL_EXTRA;
	exports.SOURCE_EXTRA = tsInterfaces.SOURCE_EXTRA;
	function error(message, source, takeNodeFromSource) {
	    if (takeNodeFromSource === void 0) { takeNodeFromSource = false; }
	    return new Status(Status.ERROR, 0, message, source, takeNodeFromSource);
	}
	exports.error = error;
	var TypeInformation = (function () {
	    function TypeInformation(_inheritable) {
	        this._inheritable = _inheritable;
	    }
	    TypeInformation.prototype.node = function () {
	        return this._node;
	    };
	    TypeInformation.prototype.setNode = function (node) {
	        this._node = node;
	    };
	    TypeInformation.prototype.owner = function () {
	        return this._owner;
	    };
	    TypeInformation.prototype.isInheritable = function () {
	        return this._inheritable;
	    };
	    TypeInformation.prototype.validateSelf = function (registry) {
	        return ok();
	    };
	    /**
	     * Extension of requiredType() method for the case when there are more than a single type
	     * hierarchy roots to cover.
	     * requiredType() should return the common superclass for the list.
	     *
	     * @returns {Array} of types or empty list of there is only a single type set by requiredType() method
	     */
	    TypeInformation.prototype.requiredTypes = function () {
	        return [];
	    };
	    return TypeInformation;
	}());
	exports.TypeInformation = TypeInformation;
	var stack = null;
	var Constraint = (function (_super) {
	    __extends(Constraint, _super);
	    function Constraint() {
	        _super.call(this, true);
	    }
	    Constraint.prototype.intersect = function (t0, t1) {
	        var nm = t0.id() + "" + t1.id();
	        if (Constraint.intersections.hasOwnProperty(nm)) {
	            return Constraint.intersections[nm];
	        }
	        var is = intersect(nm, [t0, t1]);
	        Constraint.intersections[nm] = is;
	        return is;
	    };
	    Constraint.prototype.release = function (t) {
	        delete Constraint.intersections[t.name()];
	    };
	    Constraint.prototype.nothing = function (c, message) {
	        if (message === void 0) { message = "Conflicting restrictions"; }
	        return new NothingRestrictionWithLocation(stack, message, c);
	    };
	    /**
	     * inner implementation of  compute composed restriction from this and parameter restriction
	     * @param restriction
	     * @return  composed restriction or null;
	     */
	    Constraint.prototype.composeWith = function (r) { return null; };
	    /**
	     * returns optimized restiction or this
	     * @returns {Constraint}
	     */
	    Constraint.prototype.preoptimize = function () {
	        if (stack === null) {
	            stack = new RestrictionStackEntry(null, null, "top");
	        }
	        stack = stack.push(this);
	        try {
	            return this.innerOptimize();
	        }
	        finally {
	            stack = stack.pop();
	        }
	    };
	    Constraint.prototype.innerOptimize = function () {
	        return this;
	    };
	    /**
	     * performs attempt to compute composed restriction from this and parameter restriction
	     * @param restriction
	     * @return  composed restriction or null;
	     */
	    Constraint.prototype.tryCompose = function (r) {
	        if (stack === null) {
	            stack = new RestrictionStackEntry(null, null, "top");
	        }
	        stack = stack.push(this);
	        try {
	            return this.composeWith(r);
	        }
	        finally {
	            stack = stack.pop();
	        }
	    };
	    Constraint.prototype.kind = function () {
	        return tsInterfaces.MetaInformationKind.Constraint;
	    };
	    Constraint.prototype.conflictMessage = function (otherPath, otherValue) { return null; };
	    Constraint.intersections = {};
	    return Constraint;
	}(TypeInformation));
	exports.Constraint = Constraint;
	var restr = __webpack_require__(100);
	var metaInfo = __webpack_require__(101);
	var fr = __webpack_require__(99);
	var restrictions_1 = __webpack_require__(100);
	var metainfo_1 = __webpack_require__(101);
	var metainfo_2 = __webpack_require__(101);
	var restrictions_2 = __webpack_require__(100);
	var restrictions_3 = __webpack_require__(100);
	var exO = __webpack_require__(137);
	var metainfo_3 = __webpack_require__(101);
	var restrictions_4 = __webpack_require__(100);
	var restrictions_5 = __webpack_require__(100);
	exports.autoCloseFlag = false;
	/**
	 * Registry of the types
	 */
	var TypeRegistry = (function () {
	    function TypeRegistry(_parent) {
	        if (_parent === void 0) { _parent = null; }
	        this._parent = _parent;
	        this._types = {};
	        this.typeList = [];
	    }
	    TypeRegistry.prototype.put = function (alias, t) {
	        this._types[alias] = t;
	    };
	    TypeRegistry.prototype.addType = function (t) {
	        if (t.isAnonymous()) {
	            return;
	        }
	        this._types[t.name()] = t;
	        this.typeList.push(t);
	    };
	    TypeRegistry.prototype.get = function (name) {
	        if (this._types.hasOwnProperty(name)) {
	            return this._types[name];
	        }
	        if (this._parent != null) {
	            return this._parent.get(name);
	        }
	        return null;
	    };
	    TypeRegistry.prototype.types = function () {
	        return this.typeList;
	    };
	    return TypeRegistry;
	}());
	exports.TypeRegistry = TypeRegistry;
	var PropertyCyclesValidator = (function () {
	    function PropertyCyclesValidator() {
	    }
	    PropertyCyclesValidator.prototype.getInfos = function (t) {
	        if (t.getExtra("PInfos")) {
	            return t.getExtra("PInfos");
	        }
	        var m = {};
	        t.meta().forEach(function (x) {
	            if (x instanceof restr.HasProperty) {
	                var id = x.value();
	                m[id] = { name: id, type: null };
	            }
	        });
	        t.meta().forEach(function (x) {
	            if (x instanceof restr.PropertyIs) {
	                var id = x.propertyName();
	                if (m[id]) {
	                    m[id].type = x.value();
	                }
	            }
	        });
	        t.putExtra("PInfos", m);
	        return m;
	    };
	    PropertyCyclesValidator.prototype.validate = function (t, visited) {
	        var _this = this;
	        var i = this.getInfos(t);
	        var result = false;
	        Object.keys(i).forEach(function (x) {
	            result = result || _this.validateInfo(i[x], visited);
	        });
	        return result;
	    };
	    PropertyCyclesValidator.prototype.validateInfo = function (t, visited) {
	        var _this = this;
	        if (visited.some(function (y) { return y == t; })) {
	            return true;
	        }
	        else {
	            if (t.type instanceof UnionType) {
	                var ut = t.type;
	                var passing = true;
	                ut.options().forEach(function (o) {
	                    if (!_this.validate(o, [t].concat(visited))) {
	                        passing = false;
	                    }
	                });
	                return passing;
	            }
	            if (t.type.isArray()) {
	            }
	            else {
	                return this.validate(t.type, [t].concat(visited));
	            }
	        }
	    };
	    PropertyCyclesValidator.prototype.validateType = function (t) {
	        var _this = this;
	        var i = this.getInfos(t);
	        var result = [];
	        Object.keys(i).forEach(function (x) {
	            if (_this.validateInfo(i[x], [])) {
	                result.push(x);
	            }
	        });
	        return result;
	    };
	    return PropertyCyclesValidator;
	}());
	var RestrictionsConflict = (function (_super) {
	    __extends(RestrictionsConflict, _super);
	    function RestrictionsConflict(_conflicting, _stack, source) {
	        _super.call(this, Status.ERROR, 0, null, source);
	        this._conflicting = _conflicting;
	        this._stack = _stack;
	        var conflictingMessage = null;
	        if (_stack != null) {
	            if (_stack.getRestriction() instanceof restr.MinMaxRestriction) {
	                var mmr = _stack.getRestriction();
	                conflictingMessage = _conflicting.conflictMessage(mmr.facetPath(), mmr.value());
	            }
	        }
	        if (conflictingMessage == null) {
	            conflictingMessage = _conflicting + " and " + (_stack != null ? _stack.getRestriction().toString() : "");
	        }
	        var typeInfo = "";
	        if (source instanceof AbstractType) {
	            typeInfo = "in type '" + typePath(source) + "'";
	        }
	        this.message = ("Restrictions conflict " + typeInfo + ": ") + conflictingMessage;
	    }
	    RestrictionsConflict.prototype.getConflictDescription = function () {
	        var rs = "";
	        rs += "Restrictions coflict:\n";
	        rs += this._stack.getRestriction() + " conflicts with " + this._conflicting + "\n";
	        rs += "at\n";
	        rs += this._stack.pop();
	        return rs;
	    };
	    RestrictionsConflict.prototype.getConflicting = function () {
	        return this._conflicting;
	    };
	    RestrictionsConflict.prototype.getStack = function () {
	        return this._stack;
	    };
	    RestrictionsConflict.prototype.toRestriction = function () {
	        return new NothingRestrictionWithLocation(this._stack, this.message, this._conflicting);
	    };
	    return RestrictionsConflict;
	}(Status));
	exports.RestrictionsConflict = RestrictionsConflict;
	var globalId = 0;
	exports.VALIDATED_TYPE = null;
	var AbstractType = (function () {
	    function AbstractType(_name) {
	        this._name = _name;
	        this.metaInfo = [];
	        this._subTypes = [];
	        this.innerid = globalId++;
	        this.extras = {};
	        this._locked = false;
	    }
	    AbstractType.prototype.getExtra = function (name) {
	        return this.extras[name];
	    };
	    AbstractType.prototype.putExtra = function (name, v) {
	        this.extras[name] = v;
	    };
	    AbstractType.prototype.id = function () {
	        return this.innerid;
	    };
	    AbstractType.prototype.knownProperties = function () {
	        return this.metaOfType(restrictions_5.MatchesProperty);
	    };
	    AbstractType.prototype.lock = function () {
	        this._locked = true;
	    };
	    AbstractType.prototype.isLocked = function () {
	        return this._locked;
	    };
	    AbstractType.prototype.allFacets = function () {
	        return this.meta();
	    };
	    AbstractType.prototype.declaredFacets = function () {
	        return this.declaredMeta();
	    };
	    AbstractType.prototype.isSubTypeOf = function (t) {
	        return t === exports.ANY || this === t || this.superTypes().some(function (x) { return x.isSubTypeOf(t); });
	    };
	    AbstractType.prototype.isSuperTypeOf = function (t) {
	        return this === t || this.allSubTypes().indexOf(t) != -1;
	    };
	    AbstractType.prototype.addMeta = function (info) {
	        this.metaInfo.push(info);
	        info._owner = this;
	    };
	    AbstractType.prototype.name = function () {
	        return this._name;
	    };
	    AbstractType.prototype.label = function () {
	        return this._name;
	    };
	    /**
	     * @return directly known sub types of a given type
	     */
	    AbstractType.prototype.subTypes = function () {
	        return this._subTypes;
	    };
	    /**
	     * @return directly known super types of a given type
	     */
	    AbstractType.prototype.superTypes = function () {
	        return [];
	    };
	    AbstractType.prototype.validateType = function (tr) {
	        var _this = this;
	        if (tr === void 0) { tr = builtInRegistry(); }
	        var rs = new Status(Status.OK, 0, "", this);
	        this.validateHierarchy(rs);
	        if (this.getExtra(tsInterfaces.PARSE_ERROR)) {
	            rs.addSubStatus(this.getExtra(tsInterfaces.PARSE_ERROR));
	        }
	        if (rs.isOk()) {
	            rs.addSubStatus(this.checkConfluent());
	            if (this.isExternal()) {
	                var allS = this.allSuperTypes();
	                var mma = allS.filter(function (x) { return x instanceof ExternalType; });
	                if (this instanceof ExternalType) {
	                    mma.push(this);
	                }
	                mma.forEach(function (x) {
	                    if (x.isJSON()) {
	                        try {
	                            su.getJSONSchema(x.schema(), x.getContentProvider && x.getContentProvider());
	                        }
	                        catch (e) {
	                            rs.addSubStatus(new Status(Status.ERROR, 0, e.message, _this));
	                        }
	                    }
	                });
	            }
	            if (rs.isOk()) {
	                this.superTypes().forEach(function (x) {
	                    if (x.isAnonymous()) {
	                        rs.addSubStatus(x.validateType(tr));
	                    }
	                });
	            }
	        }
	        if (this.getExtra(exports.SCHEMA_AND_TYPE)) {
	            rs.addSubStatus(new Status(Status.ERROR, 0, "schema and type are mutually exclusive", this));
	        }
	        if (rs.isOk()) {
	            this.validateMeta(tr).getErrors().forEach(function (x) { return rs.addSubStatus(x); });
	        }
	        //if (this.isPolymorphic()||(this.isUnion())) {
	        //    rs.addSubStatus(this.canDoAc());
	        //}
	        if (this.isObject()) {
	            var required = {};
	            this.restrictions().forEach(function (x) {
	                if (x.owner() != _this) {
	                    if (x instanceof restr.HasProperty) {
	                        required[x.value()] = true;
	                    }
	                }
	            });
	            this.declaredMeta().forEach(function (x) {
	                if (x instanceof restr.HasProperty) {
	                    delete required[x.value()];
	                }
	            });
	            this.declaredMeta().forEach(function (x) {
	                if (x instanceof restr.PropertyIs) {
	                    var pr = x;
	                    if (required.hasOwnProperty(pr.propertyName())) {
	                        rs.addSubStatus(new Status(Status.ERROR, 0, "Can not override required property:" + pr.propertyName() + " to be optional", _this));
	                    }
	                }
	            });
	            var propertyCycles = new PropertyCyclesValidator().validateType(this);
	            if (propertyCycles.length > 0) {
	                propertyCycles.forEach(function (p) {
	                    var st = new Status(Status.ERROR, 0, p + "has cyclic dependency", _this);
	                    st.setValidationPath({ name: p });
	                    rs.addSubStatus(st);
	                });
	            }
	        }
	        return rs;
	    };
	    AbstractType.prototype.validateHierarchy = function (rs) {
	        var _this = this;
	        if (!this.isAnonymous()) {
	            if (this.getExtra(tsInterfaces.TOP_LEVEL_EXTRA) && builtInRegistry().get(this.name())) {
	                rs.addSubStatus(new Status(Status.ERROR, 0, "redefining builtin type:" + this.name(), this));
	            }
	        }
	        if (this.isSubTypeOf(exports.RECURRENT)) {
	            rs.addSubStatus(new Status(Status.ERROR, 0, "recurrent type definition", this), "type");
	        }
	        if (this.isSubTypeOf(exports.UNKNOWN)) {
	            rs.addSubStatus(new Status(Status.ERROR, 0, "inheriting from unknown type", this), "type");
	        }
	        if (this.isUnion()) {
	            var tf = this.typeFamily();
	            if (tf.some(function (x) { return x.isSubTypeOf(exports.RECURRENT); })) {
	                rs.addSubStatus(new Status(Status.ERROR, 0, "recurrent type as an option of union type", this), "type");
	            }
	            if (tf.some(function (x) { return x.isSubTypeOf(exports.UNKNOWN); })) {
	                rs.addSubStatus(new Status(Status.ERROR, 0, "unknown type as an option of union type", this), "type");
	            }
	        }
	        if (this.isArray()) {
	            var fs_1 = this.familyWithArray();
	            var ps = this.getExtra(tsInterfaces.HAS_ITEMS) ? "items" : "type";
	            if ((fs_1.indexOf(this) != -1) || fs_1.some(function (x) { return x === exports.RECURRENT; })) {
	                rs.addSubStatus(new Status(Status.ERROR, 0, "recurrent array type definition", this), ps);
	            }
	            else if (fs_1.some(function (x) { return x === exports.UNKNOWN; })) {
	                rs.addSubStatus(new Status(Status.ERROR, 0, "referring to unknown type " + this.oneMeta(restrictions_3.ComponentShouldBeOfType).value().name() + " as an array component type", this), ps);
	            }
	        }
	        var supers = this.superTypes();
	        var hasExternal = false;
	        var hasNotExternal = false;
	        if (supers.length > 1) {
	            supers.forEach(function (x) {
	                if (x.isExternal()) {
	                    hasExternal = true;
	                }
	                else {
	                    hasNotExternal = true;
	                }
	            });
	        }
	        if (hasExternal && hasNotExternal) {
	            rs.addSubStatus(new Status(Status.ERROR, 0, "It is not allowed to mix RAML types with externals", this), "type");
	        }
	        if (this instanceof UnionType) {
	            var ut = this;
	            ut.options().forEach(function (x) {
	                if (x.isExternal()) {
	                    rs.addSubStatus(new Status(Status.ERROR, 0, "It is not allowed to mix RAML types with externals", _this), "type");
	                }
	            });
	        }
	        if (this.isExternal()) {
	            if (this.getExtra(tsInterfaces.HAS_FACETS)) {
	                var fs = new Status(Status.ERROR, 0, "External types can not declare facet '" + this.getExtra(tsInterfaces.HAS_FACETS) + "'", this);
	                fs.setValidationPath({ name: this.getExtra(tsInterfaces.HAS_FACETS) });
	                rs.addSubStatus(fs);
	            }
	        }
	    };
	    ;
	    AbstractType.prototype.familyWithArray = function () {
	        var ts = this.allSuperTypes();
	        var mn = this.oneMeta(restrictions_3.ComponentShouldBeOfType);
	        if (mn) {
	            var at = mn.value();
	            ts = ts.concat(at.familyWithArray());
	        }
	        return ts;
	    };
	    AbstractType.prototype.validateMeta = function (tr) {
	        var rs = new Status(Status.OK, 0, "", this);
	        this.declaredMeta().forEach(function (x) {
	            x.validateSelf(tr).getErrors().forEach(function (y) { return rs.addSubStatus(y); });
	        });
	        this.validateFacets(rs);
	        return rs;
	    };
	    AbstractType.prototype.validateFacets = function (rs) {
	        var _this = this;
	        var fds = {};
	        var super_facets = {};
	        var rfds = {};
	        this.meta().forEach(function (x) {
	            if (x instanceof metainfo_1.FacetDeclaration) {
	                var fd = x;
	                fds[fd.actualName()] = fd;
	                if (!fd.isOptional()) {
	                    if (fd.owner() !== _this) {
	                        rfds[fd.actualName()] = fd;
	                    }
	                }
	                if (fd.owner() != _this) {
	                    super_facets[fd.actualName()] = fd;
	                }
	            }
	        });
	        this.declaredMeta().forEach(function (x) {
	            if (x instanceof metainfo_1.FacetDeclaration) {
	                var fd = x;
	                if (fd.owner() == _this) {
	                    var an = fd.actualName();
	                    if (super_facets.hasOwnProperty(an)) {
	                        rs.addSubStatus(new Status(Status.ERROR, 0, "facet :" + an + " can not be overriden", _this));
	                    }
	                    var fp = fr.getInstance().facetPrototypeWithName(an);
	                    if (fp && fp.isApplicable(_this) || an == "type" || fd.facetName() == "properties" || an == "schema" || an == "facets" || an == "uses") {
	                        rs.addSubStatus(new Status(Status.ERROR, 0, "built-in facet :" + an + " can not be overriden", _this));
	                    }
	                    if (an.charAt(0) == '(') {
	                        rs.addSubStatus(new Status(Status.ERROR, 0, "facet :" + an + " can not start from '('", _this));
	                    }
	                }
	            }
	        });
	        var knownPropertySet = {};
	        this.meta().forEach(function (x) {
	            if (x instanceof restrictions_2.PropertyIs) {
	                knownPropertySet[x.propId()] = true;
	            }
	        });
	        this.meta().forEach(function (x) {
	            if (x instanceof metainfo_2.CustomFacet) {
	                var cd = x;
	                if (fds.hasOwnProperty(cd.facetName())) {
	                    var ft = fds[cd.facetName()].value();
	                    rs.addSubStatus(ft.validateDirect(cd.value(), false, false));
	                    delete rfds[cd.facetName()];
	                }
	                else {
	                    var msg = _this.isExternal() ? "'" + cd.facetName() + "' facet is prohibited for external types"
	                        : "specifying unknown facet:" + cd.facetName();
	                    rs.addSubStatus(new Status(Status.ERROR, 0, msg, cd, true));
	                }
	            }
	            if (x instanceof restrictions_4.MapPropertyIs) {
	                var mm = x;
	                Object.keys(knownPropertySet).forEach(function (c) {
	                    try {
	                        if (c.match(mm.regexpValue())) {
	                            var regexpText = '/' + mm.regexpValue().toString() + '/';
	                            rs.addSubStatus(new Status(Status.WARNING, 0, "pattern property '" + regexpText + "' conflicts with property: " + c, _this));
	                        }
	                    }
	                    catch (e) {
	                    }
	                });
	            }
	        });
	        if (Object.getOwnPropertyNames(rfds).length > 0) {
	            rs.addSubStatus(new Status(Status.ERROR, 0, "missing required facets:" + Object.keys(rfds).join(","), this));
	        }
	    };
	    ;
	    AbstractType.prototype.allSuperTypes = function () {
	        var rs = [];
	        this.fillSuperTypes(rs);
	        return rs;
	    };
	    AbstractType.prototype.fillSuperTypes = function (r) {
	        this.superTypes().forEach(function (x) {
	            if (!_.contains(r, x)) {
	                r.push(x);
	                x.fillSuperTypes(r);
	            }
	        });
	    };
	    AbstractType.prototype.allSubTypes = function () {
	        var rs = [];
	        this.fillSubTypes(rs);
	        return rs;
	    };
	    AbstractType.prototype.fillSubTypes = function (r) {
	        this.subTypes().forEach(function (x) {
	            if (!_.contains(r, x)) {
	                r.push(x);
	                x.fillSubTypes(r);
	            }
	        });
	    };
	    AbstractType.prototype.inherit = function (name) {
	        var rs = new InheritedType(name);
	        rs.addSuper(this);
	        return rs;
	    };
	    /**
	     *
	     * @return true if type is an inplace type and has no name
	     */
	    AbstractType.prototype.isAnonymous = function () {
	        return (!this._name) || this._name.length === 0;
	    };
	    /**
	     *
	     * @return true if type has no associated meta information of restrictions
	     */
	    AbstractType.prototype.isEmpty = function () {
	        if (this.metaInfo.length > 1) {
	            return false;
	        }
	        return this.metaInfo.filter(function (x) { return !(x instanceof metainfo_3.NotScalar); }).length == 0;
	    };
	    /**
	     *
	     * @return true if type is an array or extends from an array
	     */
	    AbstractType.prototype.isArray = function () {
	        return this === exports.ARRAY || this.allSuperTypes().indexOf(exports.ARRAY) != -1;
	    };
	    AbstractType.prototype.propertySet = function () {
	        var rs = [];
	        this.meta().forEach(function (x) {
	            if (x instanceof restrictions_2.PropertyIs) {
	                var p = x;
	                rs.push(p.propertyName());
	            }
	        });
	        return _.uniq(rs);
	    };
	    AbstractType.prototype.checkConfluent = function () {
	        if (this.computeConfluent) {
	            return ok();
	        }
	        this.computeConfluent = true;
	        try {
	            var os = restr.optimize(this.restrictions());
	            var ns = _.find(os, function (x) { return x instanceof NothingRestriction; });
	            if (ns) {
	                var lstack = null;
	                var another = null;
	                if (ns instanceof NothingRestrictionWithLocation) {
	                    var nswl = ns;
	                    lstack = nswl.getStack();
	                    another = nswl.another();
	                }
	                var status = new RestrictionsConflict(another, lstack, this);
	                return status;
	            }
	            return ok();
	        }
	        finally {
	            this.computeConfluent = false;
	        }
	    };
	    /**
	     *
	     * @return true if type is object or inherited from object
	     */
	    AbstractType.prototype.isObject = function () {
	        return this == exports.OBJECT || this.allSuperTypes().indexOf(exports.OBJECT) != -1;
	    };
	    /**
	     *
	     * @return true if type is object or inherited from object
	     */
	    AbstractType.prototype.isExternal = function () {
	        return this == exports.EXTERNAL || this.allSuperTypes().indexOf(exports.EXTERNAL) != -1;
	    };
	    /**
	     *
	     * @return true if type is an boolean type or extends from boolean
	     */
	    AbstractType.prototype.isBoolean = function () {
	        return this == exports.BOOLEAN || this.allSuperTypes().indexOf(exports.BOOLEAN) != -1;
	    };
	    /**
	     *
	     * @return true if type is string or inherited from string
	     */
	    AbstractType.prototype.isString = function () {
	        return this == exports.STRING || this.allSuperTypes().indexOf(exports.STRING) != -1;
	    };
	    /**
	     *
	     * @return true if type is number or inherited from number
	     */
	    AbstractType.prototype.isNumber = function () {
	        return this == exports.NUMBER || this.allSuperTypes().indexOf(exports.NUMBER) != -1;
	    };
	    /**
	     *
	     * @return true if type is number or inherited from number
	     */
	    AbstractType.prototype.isFile = function () {
	        return this == exports.FILE || this.allSuperTypes().indexOf(exports.FILE) != -1;
	    };
	    /**
	     *
	     * @return true if type is scalar or inherited from scalar
	     */
	    AbstractType.prototype.isScalar = function () {
	        return this == exports.SCALAR || this.allSuperTypes().indexOf(exports.SCALAR) != -1;
	    };
	    /**
	     * returns true if this type inherits from one of date related types
	     */
	    AbstractType.prototype.isDateTime = function () {
	        return this == exports.DATETIME || this.allSuperTypes().indexOf(exports.DATETIME) != -1;
	    };
	    /**
	     * returns true if this type inherits from one of date related types
	     */
	    AbstractType.prototype.isDateOnly = function () {
	        return this == exports.DATE_ONLY || this.allSuperTypes().indexOf(exports.DATE_ONLY) != -1;
	    };
	    /**
	     * returns true if this type inherits from one of date related types
	     */
	    AbstractType.prototype.isTimeOnly = function () {
	        return this == exports.TIME_ONLY || this.allSuperTypes().indexOf(exports.TIME_ONLY) != -1;
	    };
	    /**
	     * returns true if this type inherits from one of date related types
	     */
	    AbstractType.prototype.isInteger = function () {
	        return this == exports.INTEGER || this.allSuperTypes().indexOf(exports.INTEGER) != -1;
	    };
	    /**
	     * returns true if this type inherits from one of date related types
	     */
	    AbstractType.prototype.isDateTimeOnly = function () {
	        return this == exports.DATETIME_ONLY || this.allSuperTypes().indexOf(exports.DATETIME_ONLY) != -1;
	    };
	    /**
	     *
	     * @return true if type is scalar or inherited from scalar
	     */
	    AbstractType.prototype.isUnknown = function () {
	        return this == exports.UNKNOWN || this.allSuperTypes().indexOf(exports.UNKNOWN) != -1;
	    };
	    /**
	     *
	     * @return true if type is scalar or inherited from scalar
	     */
	    AbstractType.prototype.isRecurrent = function () {
	        return this == exports.RECURRENT || this.allSuperTypes().indexOf(exports.RECURRENT) != -1;
	    };
	    /**
	     *
	     * @return true if type is an built-in type
	     */
	    AbstractType.prototype.isBuiltin = function () {
	        return this.metaInfo.indexOf(BUILT_IN) != -1;
	    };
	    AbstractType.prototype.exampleObject = function () {
	        return exO.example(this);
	    };
	    /**
	     *
	     * @return true if type is an polymorphic type
	     */
	    AbstractType.prototype.isPolymorphic = function () {
	        return this.meta().some(function (x) { return x instanceof Polymorphic; });
	    };
	    /**
	     * @return all restrictions associated with type
	     */
	    AbstractType.prototype.restrictions = function (forValidation) {
	        if (forValidation === void 0) { forValidation = false; }
	        if (this.isUnion()) {
	            var rs = [];
	            this.superTypes().forEach(function (x) {
	                rs = rs.concat(x.restrictions());
	            });
	            rs = rs.concat(this.meta().filter(function (x) { return x instanceof Constraint; }));
	            return rs;
	        }
	        var result = [];
	        var generic = null;
	        this.meta().forEach(function (x) {
	            if (x instanceof Constraint) {
	                if (x instanceof GenericTypeOf && forValidation) {
	                    if (generic) {
	                        return;
	                    }
	                    generic = x;
	                }
	                result.push(x);
	            }
	        });
	        return result;
	    };
	    AbstractType.prototype.customFacets = function () {
	        return this.declaredMeta().filter(function (x) { return x instanceof metaInfo.CustomFacet; });
	    };
	    AbstractType.prototype.allCustomFacets = function () {
	        return this.meta().filter(function (x) { return x instanceof metaInfo.CustomFacet; });
	    };
	    AbstractType.prototype.isUnion = function () {
	        var rs = false;
	        if (this.isBuiltin()) {
	            return false;
	        }
	        this.allSuperTypes().forEach(function (x) { return rs = rs || x instanceof UnionType; });
	        return rs;
	    };
	    /**
	     * return all type information associated with type
	     */
	    AbstractType.prototype.meta = function () {
	        return [].concat(this.metaInfo);
	    };
	    /**
	     * validates object against this type without performing AC
	     */
	    AbstractType.prototype.validateDirect = function (i, autoClose, nullAllowed, path) {
	        var _this = this;
	        if (autoClose === void 0) { autoClose = false; }
	        if (nullAllowed === void 0) { nullAllowed = true; }
	        if (path === void 0) { path = null; }
	        var prevValidated = exports.VALIDATED_TYPE;
	        try {
	            var g = exports.autoCloseFlag;
	            if (autoClose) {
	                exports.autoCloseFlag = true;
	            }
	            exports.VALIDATED_TYPE = this;
	            var result = new Status(Status.OK, 0, "", this);
	            if (!nullAllowed && (i === null || i === undefined)) {
	                if (!this.nullable) {
	                    return error("object is expected", this);
	                }
	            }
	            this.restrictions(true).forEach(function (x) { return result.addSubStatus(x.check(i, path)); });
	            if ((autoClose || exports.autoCloseFlag) && this.isObject() && (!this.oneMeta(restrictions_1.KnownPropertyRestriction))) {
	                var cp = new restrictions_1.KnownPropertyRestriction(false);
	                cp.patchOwner(this);
	                cp.check(i).getErrors().forEach(function (x) {
	                    var rs = new Status(Status.WARNING, 0, x.getMessage(), _this);
	                    rs.setValidationPath(x.getValidationPath());
	                    result.addSubStatus(rs);
	                });
	            }
	        }
	        finally {
	            exports.autoCloseFlag = g;
	            exports.VALIDATED_TYPE = prevValidated;
	        }
	        return result;
	    };
	    AbstractType.prototype.validate = function (i, autoClose, nullAllowed) {
	        if (autoClose === void 0) { autoClose = false; }
	        if (nullAllowed === void 0) { nullAllowed = true; }
	        var g = exports.autoCloseFlag;
	        if (!nullAllowed && (i === null || i === undefined)) {
	            if (!this.nullable) {
	                return error("Null or undefined value is not allowed", this);
	            }
	        }
	        if (autoClose) {
	            exports.autoCloseFlag = true;
	        }
	        try {
	            for (var _i = 0, _a = this.subTypes(); _i < _a.length; _i++) {
	                var subType = _a[_i];
	                var vr = subType.validateDirect(i, autoClose || g);
	                if (vr.isOk()) {
	                    return vr;
	                }
	            }
	            return this.validateDirect(i, autoClose || g);
	        }
	        finally {
	            exports.autoCloseFlag = g;
	        }
	    };
	    /**
	     * declares a pattern property on this type,
	     * note if type is not inherited from an object type this will move
	     * type to inconsistent state
	     * @param name - regexp
	     * @param type - type of the property
	     * @return
	     */
	    AbstractType.prototype.declareMapProperty = function (name, type) {
	        if (type != null) {
	            this.addMeta(new restr.MapPropertyIs(name, type));
	        }
	        return type;
	    };
	    /**
	     * make this type closed type (no unknown properties any more)
	     */
	    AbstractType.prototype.closeUnknownProperties = function () {
	        this.addMeta(new restrictions_1.KnownPropertyRestriction(false));
	    };
	    AbstractType.prototype.canDoAc = function () {
	        var tf = _.uniq(this.typeFamily());
	        var s = new Status(Status.OK, 0, "", this);
	        for (var i = 0; i < tf.length; i++) {
	            for (var j = 0; j < tf.length; j++) {
	                if (i != j) {
	                    var t0 = tf[i];
	                    var t1 = tf[j];
	                    var ed = this.emptyIntersectionOrDiscriminator(t0, t1);
	                    s.addSubStatus(ed);
	                }
	            }
	        }
	        return s;
	    };
	    AbstractType.prototype.emptyIntersectionOrDiscriminator = function (t0, t1) {
	        if (t1 === t0) {
	            return ok();
	        }
	        if (t1.isScalar() && t0.isScalar()) {
	            return ok();
	        }
	        var it = intersect("", [t0, t1]);
	        var innerCheckConfluent = it.checkConfluent();
	        if (innerCheckConfluent.isOk()) {
	            return this.checkDiscriminator(t0, t1);
	        }
	        return ok();
	    };
	    AbstractType.prototype.checkDiscriminator = function (t1, t2) {
	        var found = new Status(Status.ERROR, 0, "can not discriminate types " + t1.name() + " and " + t2.name() + " without discriminator", this);
	        var oneMeta = t1.oneMeta(metaInfo.Discriminator);
	        var anotherMeta = t2.oneMeta(metaInfo.Discriminator);
	        if (oneMeta != null && anotherMeta != null && oneMeta.value() === (anotherMeta.value())) {
	            var d1 = t1.name();
	            var d2 = t2.name();
	            var dv1 = t1.oneMeta(metaInfo.DiscriminatorValue);
	            if (dv1 != null) {
	                d1 = dv1.value();
	            }
	            var dv2 = t2.oneMeta(metaInfo.DiscriminatorValue);
	            if (dv2 != null) {
	                d2 = dv2.value();
	            }
	            if (d1 !== d2) {
	                return ok();
	            }
	            found = new Status(Status.ERROR, 0, "types" + t1.name() + " and " + t2.name() + " have same discriminator value", this);
	        }
	        return found;
	    };
	    /**
	     * performs automatic classification of the instance
	     * @param obj
	     * @returns {AbstractType}
	     */
	    AbstractType.prototype.ac = function (obj) {
	        if (!this.isPolymorphic() && !this.isUnion()) {
	            return this;
	        }
	        if (this.isBuiltin()) {
	            return this;
	        }
	        var tf = _.uniq(this.typeFamily());
	        if (tf.length == 0) {
	            return exports.NOTHING;
	        }
	        if (this.isScalar()) {
	            if (this.isNumber()) {
	                if (typeof obj == "number") {
	                    return this;
	                }
	                return exports.NOTHING;
	            }
	            if (this.isString()) {
	                if (typeof obj == "string") {
	                    return this;
	                }
	                return exports.NOTHING;
	            }
	            if (this.isBoolean()) {
	                if (typeof obj == "boolean") {
	                    return this;
	                }
	                return exports.NOTHING;
	            }
	            return this;
	        }
	        if (tf.length === 1) {
	            return tf[0];
	        }
	        var options = [];
	        tf.forEach(function (x) {
	            var ds = x.validateDirect(obj, true);
	            if (ds.isOk()) {
	                options.push(x);
	            }
	        });
	        var t = this.discriminate(obj, options);
	        if (!t) {
	            return exports.NOTHING;
	        }
	        return t;
	    };
	    /**
	     * adds new property declaration to this type, note if type is not inherited from an object type this will move
	     * type to inconsistent state
	     * @param name - name of the property
	     * @param type - type of the property
	     * @param optional true if property is optinal
	     * @return the type with property (this)
	     */
	    AbstractType.prototype.declareProperty = function (name, t, optional) {
	        if (!optional) {
	            this.addMeta(new restr.HasProperty(name));
	        }
	        if (t != null) {
	            this.addMeta(new restr.PropertyIs(name, t));
	        }
	        return this;
	    };
	    AbstractType.prototype.discriminate = function (obj, opt) {
	        var newOpts = [].concat(opt);
	        var opts = [].concat(opt);
	        while (newOpts.length > 1) {
	            var found = false;
	            l2: for (var i = 0; i < opts.length; i++) {
	                for (var j = 0; j < opts.length; j++) {
	                    var t0 = opts[i];
	                    var t1 = opts[j];
	                    if (t0 != t1) {
	                        var nt = select(obj, t0, t1);
	                        if (nt === t0) {
	                            opts = opts.filter(function (x) { return x != t1; });
	                            found = true;
	                            break l2;
	                        }
	                        else if (nt === t1) {
	                            opts = opts.filter(function (x) { return x != t0; });
	                            found = true;
	                            break l2;
	                        }
	                        else {
	                            opts = opts.filter(function (x) { return x != t0 && x != t1; });
	                            found = true;
	                            break l2;
	                        }
	                    }
	                }
	            }
	            newOpts = opts;
	        }
	        if (newOpts.length == 1) {
	            return newOpts[0];
	        }
	        return null;
	    };
	    /**
	     * return instance of type information of particular class
	     * @param clazz
	     * @returns {any}
	     */
	    AbstractType.prototype.oneMeta = function (clazz) {
	        return _.find(this.meta(), function (x) { return x instanceof clazz; });
	    };
	    /**
	     * return all instances of meta information of particular class
	     * @param clazz
	     * @returns {any}
	     */
	    AbstractType.prototype.metaOfType = function (clazz) {
	        return this.meta().filter(function (x) { return x instanceof clazz; });
	    };
	    AbstractType.prototype.declaredMeta = function () {
	        return this.metaInfo;
	    };
	    AbstractType.prototype.descValue = function () {
	        var dv = this.oneMeta(metaInfo.DiscriminatorValue);
	        if (dv) {
	            return dv.value();
	        }
	        return this.name();
	    };
	    AbstractType.prototype.isAbstractOrInternal = function () {
	        return this.metaInfo.some(function (x) { return x instanceof Abstract || x instanceof Internal; });
	    };
	    AbstractType.prototype.typeFamily = function () {
	        if (this.isUnion()) {
	            var res = [];
	            this.allSuperTypes().forEach(function (x) {
	                if (x instanceof UnionType) {
	                    var opts = x.allOptions();
	                    for (var i = 0; i < opts.length; i++) {
	                        res = res.concat(opts[i].typeFamily());
	                    }
	                }
	            });
	            return _.unique(res);
	        }
	        var rs = [];
	        if (!this.isAbstractOrInternal()) {
	            rs.push(this);
	        }
	        this.allSubTypes().forEach(function (x) {
	            if (!x.isAbstractOrInternal()) {
	                rs.push(x);
	            }
	        });
	        return _.unique(rs);
	    };
	    AbstractType.prototype.hasPropertiesFacet = function () {
	        return this.metaInfo.some(function (x) { return x instanceof metaInfo.HasPropertiesFacet; });
	    };
	    return AbstractType;
	}());
	exports.AbstractType = AbstractType;
	var Modifier = (function (_super) {
	    __extends(Modifier, _super);
	    function Modifier() {
	        _super.apply(this, arguments);
	    }
	    Modifier.prototype.requiredType = function () {
	        return exports.ANY;
	    };
	    Modifier.prototype.kind = function () {
	        return tsInterfaces.MetaInformationKind.Modifier;
	    };
	    return Modifier;
	}(TypeInformation));
	exports.Modifier = Modifier;
	var Polymorphic = (function (_super) {
	    __extends(Polymorphic, _super);
	    function Polymorphic() {
	        _super.call(this, true);
	    }
	    Polymorphic.prototype.facetName = function () {
	        return "polymorphic";
	    };
	    Polymorphic.prototype.value = function () {
	        return true;
	    };
	    return Polymorphic;
	}(Modifier));
	exports.Polymorphic = Polymorphic;
	var Abstract = (function (_super) {
	    __extends(Abstract, _super);
	    function Abstract() {
	        _super.call(this, false);
	    }
	    Abstract.prototype.value = function () {
	        return true;
	    };
	    Abstract.prototype.facetName = function () {
	        return "abstract";
	    };
	    return Abstract;
	}(Modifier));
	exports.Abstract = Abstract;
	var Internal = (function (_super) {
	    __extends(Internal, _super);
	    function Internal() {
	        _super.call(this, false);
	    }
	    Internal.prototype.facetName = function () {
	        return "abstract";
	    };
	    Internal.prototype.value = function () {
	        return true;
	    };
	    return Internal;
	}(Modifier));
	exports.Internal = Internal;
	var BuiltIn = (function (_super) {
	    __extends(BuiltIn, _super);
	    function BuiltIn() {
	        _super.call(this, false);
	    }
	    BuiltIn.prototype.facetName = function () {
	        return "builtIn";
	    };
	    BuiltIn.prototype.value = function () {
	        return true;
	    };
	    return BuiltIn;
	}(Modifier));
	var BUILT_IN = new BuiltIn();
	var RootType = (function (_super) {
	    __extends(RootType, _super);
	    function RootType() {
	        _super.apply(this, arguments);
	    }
	    RootType.prototype.kind = function () {
	        return "root";
	    };
	    return RootType;
	}(AbstractType));
	exports.RootType = RootType;
	var InheritedType = (function (_super) {
	    __extends(InheritedType, _super);
	    function InheritedType() {
	        _super.apply(this, arguments);
	        this._superTypes = [];
	    }
	    InheritedType.prototype.superTypes = function () {
	        return this._superTypes;
	    };
	    InheritedType.prototype.knownProperties = function () {
	        var vs = this.metaOfType(restrictions_5.MatchesProperty);
	        this.superTypes().forEach(function (x) {
	            vs = vs.concat(x.knownProperties());
	        });
	        return vs;
	    };
	    InheritedType.prototype.kind = function () {
	        return "inherited";
	    };
	    InheritedType.prototype.meta = function () {
	        var _this = this;
	        var rs = _super.prototype.meta.call(this);
	        var hasKp = false;
	        this.superTypes().forEach(function (x) {
	            x.meta().forEach(function (m) {
	                if (m instanceof restrictions_1.KnownPropertyRestriction) {
	                    if (hasKp) {
	                        return;
	                    }
	                    var kp = new restrictions_1.KnownPropertyRestriction(false);
	                    kp.patchOwner(_this);
	                    rs.push(kp);
	                    return;
	                }
	                if (m.isInheritable()) {
	                    rs.push(m);
	                }
	            });
	        });
	        return rs;
	    };
	    InheritedType.prototype.addSuper = function (t) {
	        this._superTypes.push(t);
	        if (!t.isLocked()) {
	            t._subTypes.push(this);
	        }
	        if (t.nullable) {
	            this.nullable = true;
	        }
	    };
	    InheritedType.prototype.label = function () {
	        var cmp = this.metaOfType(restrictions_3.ComponentShouldBeOfType);
	        if (cmp.length > 0) {
	            return cmp[0].value().label() + "[]";
	        }
	        return _super.prototype.label.call(this);
	    };
	    InheritedType.prototype.contextMeta = function () {
	        return this._contextMeta;
	    };
	    InheritedType.prototype.setContextMeta = function (contextMeta) {
	        this._contextMeta = contextMeta;
	    };
	    InheritedType.prototype.patch = function (another) {
	        for (var prop in another) {
	            if (another.hasOwnProperty(prop)) {
	                this[prop] = another[prop];
	            }
	        }
	    };
	    return InheritedType;
	}(AbstractType));
	exports.InheritedType = InheritedType;
	var DerivedType = (function (_super) {
	    __extends(DerivedType, _super);
	    function DerivedType(name, _options) {
	        _super.call(this, name);
	        this._options = _options;
	    }
	    /**
	     *
	     * @returns all possible options
	     */
	    DerivedType.prototype.allOptions = function () {
	        var _this = this;
	        var rs = [];
	        this._options.forEach(function (x) {
	            if (x.kind() == _this.kind()) {
	                rs = rs.concat(x.allOptions());
	            }
	            else {
	                rs.push(x);
	            }
	        });
	        return _.unique(rs);
	    };
	    DerivedType.prototype.options = function () {
	        return this._options;
	    };
	    return DerivedType;
	}(AbstractType));
	exports.DerivedType = DerivedType;
	var UnionType = (function (_super) {
	    __extends(UnionType, _super);
	    function UnionType(name, _options) {
	        var _this = this;
	        _super.call(this, name, _options);
	        this.options().forEach(function (x) {
	            if (x.nullable) {
	                _this.nullable = true;
	            }
	        });
	    }
	    UnionType.prototype.kind = function () {
	        return "union";
	    };
	    UnionType.prototype.isSubTypeOf = function (t) {
	        var isSubType = true;
	        this.allOptions().forEach(function (x) {
	            if (!x.isSubTypeOf(t)) {
	                isSubType = false;
	            }
	        });
	        return isSubType;
	        //return t===ANY||this===t|| this.superTypes().some(x=>x.isSubTypeOf(t));
	    };
	    UnionType.prototype.validate = function (i) {
	        return this.validateDirect(i);
	    };
	    UnionType.prototype.typeFamily = function () {
	        var res = [];
	        this.allOptions().forEach(function (x) {
	            res = res.concat(x.typeFamily());
	        });
	        return res;
	    };
	    UnionType.prototype.knownProperties = function () {
	        var vs = this.metaOfType(restrictions_5.MatchesProperty);
	        this.options().forEach(function (x) {
	            vs = vs.concat(x.knownProperties());
	        });
	        return vs;
	    };
	    UnionType.prototype.validateDirect = function (i, autoClose) {
	        if (autoClose === void 0) { autoClose = false; }
	        var result = new Status(Status.OK, 0, "", this);
	        this.restrictions().forEach(function (x) { return result.addSubStatus(x.check(i, null)); });
	        return result;
	    };
	    UnionType.prototype.isUnion = function () {
	        return true;
	    };
	    UnionType.prototype.restrictions = function () {
	        return [new OrRestriction(this.allOptions().map(function (x) { return new AndRestriction(x.restrictions()); }), "Union type options do not pass validation", "Union type option does not pass validation")];
	    };
	    UnionType.prototype.label = function () {
	        return this.options().map(function (x) { return x.label(); }).join("|");
	    };
	    return UnionType;
	}(DerivedType));
	exports.UnionType = UnionType;
	var IntersectionType = (function (_super) {
	    __extends(IntersectionType, _super);
	    function IntersectionType() {
	        _super.apply(this, arguments);
	    }
	    IntersectionType.prototype.kind = function () {
	        return "intersection";
	    };
	    IntersectionType.prototype.restrictions = function () {
	        var rs = [];
	        this.allOptions().forEach(function (x) { return rs = rs.concat(x.restrictions()); });
	        return [new AndRestriction(rs)];
	    };
	    IntersectionType.prototype.label = function () {
	        return this.options().map(function (x) { return x.label(); }).join("&");
	    };
	    return IntersectionType;
	}(DerivedType));
	exports.IntersectionType = IntersectionType;
	var registry = new TypeRegistry();
	function builtInRegistry() {
	    return registry;
	}
	exports.builtInRegistry = builtInRegistry;
	function union(name, t) {
	    return new UnionType(name, t);
	}
	exports.union = union;
	function intersect(name, t) {
	    return new IntersectionType(name, t);
	}
	exports.intersect = intersect;
	/**
	 * allows you to extend a type from other types
	 * @param name
	 * @param t
	 * @returns {InheritedType}
	 */
	function derive(name, t) {
	    var r = new InheritedType(name);
	    t.forEach(function (x) { return r.addSuper(x); });
	    if (r.isSubTypeOf(exports.NIL)) {
	        r.nullable = true;
	    }
	    return r;
	}
	exports.derive = derive;
	/**
	 * this function allows you to quickly derive a new type from object;
	 * @param name
	 * @returns {InheritedType}
	 */
	function deriveObjectType(name) {
	    return derive(name, [exports.OBJECT]);
	}
	exports.deriveObjectType = deriveObjectType;
	function select(obj, t0, t1) {
	    if (t0.isScalar() && t1.isScalar()) {
	        if (t0.allSubTypes().indexOf(t1) != -1) {
	            return t0;
	        }
	        if (t1.allSubTypes().indexOf(t0) != -1) {
	            return t1;
	        }
	    }
	    var d0 = t0.oneMeta(metaInfo.Discriminator);
	    var d1 = t1.oneMeta(metaInfo.Discriminator);
	    if (d0 && d1) {
	        if (d0.property === d1.property) {
	            var v0 = t0.descValue();
	            var v1 = t1.descValue();
	            if (v0 !== v1) {
	                var val = obj[d0.property];
	                if (val === v0) {
	                    return t0;
	                }
	                if (val === v1) {
	                    return t1;
	                }
	            }
	        }
	    }
	    return null;
	}
	var NothingRestriction = (function (_super) {
	    __extends(NothingRestriction, _super);
	    function NothingRestriction() {
	        _super.apply(this, arguments);
	    }
	    NothingRestriction.prototype.check = function (i) {
	        if (i === null || i === undefined) {
	            return ok();
	        }
	        return error("nothing ", this);
	    };
	    NothingRestriction.prototype.requiredType = function () {
	        return exports.ANY;
	    };
	    NothingRestriction.prototype.facetName = function () {
	        return "nothing";
	    };
	    NothingRestriction.prototype.value = function () {
	        return "!!!";
	    };
	    return NothingRestriction;
	}(Constraint));
	exports.NothingRestriction = NothingRestriction;
	var RestrictionStackEntry = (function () {
	    function RestrictionStackEntry(_previous, _restriction, id) {
	        this._previous = _previous;
	        this._restriction = _restriction;
	        this.id = id;
	    }
	    RestrictionStackEntry.prototype.getRestriction = function () { return this._restriction; };
	    RestrictionStackEntry.prototype.pop = function () { return this._previous; };
	    RestrictionStackEntry.prototype.push = function (r) {
	        return new RestrictionStackEntry(this, r, r.toString());
	    };
	    return RestrictionStackEntry;
	}());
	exports.RestrictionStackEntry = RestrictionStackEntry;
	var NothingRestrictionWithLocation = (function (_super) {
	    __extends(NothingRestrictionWithLocation, _super);
	    function NothingRestrictionWithLocation(_entry, _message, _another) {
	        _super.call(this);
	        this._entry = _entry;
	        this._message = _message;
	        this._another = _another;
	    }
	    NothingRestrictionWithLocation.prototype.getMessage = function () { return this._message; };
	    NothingRestrictionWithLocation.prototype.getStack = function () { return this._entry; };
	    NothingRestrictionWithLocation.prototype.another = function () { return this._another; };
	    return NothingRestrictionWithLocation;
	}(NothingRestriction));
	exports.NothingRestrictionWithLocation = NothingRestrictionWithLocation;
	var GenericTypeOf = (function (_super) {
	    __extends(GenericTypeOf, _super);
	    function GenericTypeOf() {
	        _super.apply(this, arguments);
	    }
	    return GenericTypeOf;
	}(Constraint));
	exports.GenericTypeOf = GenericTypeOf;
	var TypeOfRestriction = (function (_super) {
	    __extends(TypeOfRestriction, _super);
	    function TypeOfRestriction(val) {
	        _super.call(this);
	        this.val = val;
	    }
	    TypeOfRestriction.prototype.check = function (i) {
	        var to = typeof i;
	        if (i === null || i === undefined) {
	            return ok();
	        }
	        if (Array.isArray(i)) {
	            to = "array";
	        }
	        if (to === this.val) {
	            return ok();
	        }
	        return error(this.val + " is expected", this);
	    };
	    TypeOfRestriction.prototype.value = function () {
	        return this.val;
	    };
	    TypeOfRestriction.prototype.requiredType = function () {
	        return exports.ANY;
	    };
	    TypeOfRestriction.prototype.facetName = function () {
	        return "typeOf";
	    };
	    TypeOfRestriction.prototype.composeWith = function (r) {
	        if (r instanceof TypeOfRestriction) {
	            var to = r;
	            if (to.val == this.val) {
	                return this;
	            }
	            return this.nothing(r);
	        }
	        return null;
	    };
	    TypeOfRestriction.prototype.toString = function () {
	        return "should be of type " + this.val;
	    };
	    return TypeOfRestriction;
	}(GenericTypeOf));
	exports.TypeOfRestriction = TypeOfRestriction;
	function is_int(value) {
	    if ((parseFloat(value) == parseInt(value)) && !isNaN(value)) {
	        return true;
	    }
	    else {
	        return false;
	    }
	}
	var IntegerRestriction = (function (_super) {
	    __extends(IntegerRestriction, _super);
	    function IntegerRestriction() {
	        _super.call(this);
	    }
	    IntegerRestriction.prototype.check = function (i) {
	        if (typeof i == "number" && is_int(i)) {
	            return ok();
	        }
	        return error("integer is expected", this);
	    };
	    IntegerRestriction.prototype.requiredType = function () {
	        return exports.ANY;
	    };
	    IntegerRestriction.prototype.value = function () {
	        return true;
	    };
	    IntegerRestriction.prototype.facetName = function () {
	        return "should be integer";
	    };
	    return IntegerRestriction;
	}(GenericTypeOf));
	exports.IntegerRestriction = IntegerRestriction;
	var NullRestriction = (function (_super) {
	    __extends(NullRestriction, _super);
	    function NullRestriction() {
	        _super.call(this);
	    }
	    NullRestriction.prototype.check = function (i) {
	        if (i === null || i == undefined || i === "null") {
	            return ok();
	        }
	        return error("null is expected", this);
	    };
	    NullRestriction.prototype.requiredType = function () {
	        return exports.ANY;
	    };
	    NullRestriction.prototype.value = function () {
	        return true;
	    };
	    NullRestriction.prototype.facetName = function () {
	        return "should be null";
	    };
	    return NullRestriction;
	}(GenericTypeOf));
	exports.NullRestriction = NullRestriction;
	var ScalarRestriction = (function (_super) {
	    __extends(ScalarRestriction, _super);
	    function ScalarRestriction() {
	        _super.call(this);
	    }
	    ScalarRestriction.prototype.check = function (i) {
	        if (!i) {
	            return ok();
	        }
	        if (typeof i === 'number' || typeof i === 'boolean' || typeof i === 'string') {
	            return ok();
	        }
	        return error("scalar is expected", this);
	    };
	    ScalarRestriction.prototype.requiredType = function () {
	        return exports.ANY;
	    };
	    ScalarRestriction.prototype.facetName = function () {
	        return "should be scalar";
	    };
	    ScalarRestriction.prototype.value = function () {
	        return true;
	    };
	    return ScalarRestriction;
	}(GenericTypeOf));
	exports.ScalarRestriction = ScalarRestriction;
	var OrRestriction = (function (_super) {
	    __extends(OrRestriction, _super);
	    function OrRestriction(val, _extraMessage, _extraOptionMessage) {
	        _super.call(this);
	        this.val = val;
	        this._extraMessage = _extraMessage;
	        this._extraOptionMessage = _extraOptionMessage;
	    }
	    OrRestriction.prototype.check = function (i, p) {
	        var _this = this;
	        var cs = new Status(Status.OK, 0, "", this);
	        var results = [];
	        for (var j = 0; j < this.val.length; j++) {
	            var m = this.val[j].check(i, p);
	            if (m.isOk()) {
	                return ok();
	            }
	            results.push(m);
	        }
	        if (results.length > 0) {
	            for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {
	                var r = results_1[_i];
	                var ownerName = null;
	                var src = r.getSource();
	                if (src instanceof TypeInformation) {
	                    var owner = src.owner();
	                    if (owner) {
	                        ownerName = owner.label();
	                    }
	                }
	                r.getErrors().forEach(function (x) {
	                    var msg = x.getMessage();
	                    if (ownerName) {
	                        msg = ownerName + ": " + msg;
	                    }
	                    if (_this._extraOptionMessage) {
	                        msg = _this._extraOptionMessage + " (" + msg + ")";
	                    }
	                    x.setMessage(msg);
	                    cs.addSubStatus(x);
	                });
	            }
	            if (this._extraMessage) {
	                cs.addSubStatus(error(this._extraMessage, this));
	            }
	        }
	        return cs;
	    };
	    OrRestriction.prototype.value = function () {
	        return this.val.map(function (x) { return x.value(); });
	    };
	    OrRestriction.prototype.requiredType = function () {
	        return exports.ANY;
	    };
	    OrRestriction.prototype.facetName = function () {
	        return "or";
	    };
	    return OrRestriction;
	}(Constraint));
	exports.OrRestriction = OrRestriction;
	var AndRestriction = (function (_super) {
	    __extends(AndRestriction, _super);
	    function AndRestriction(val) {
	        _super.call(this);
	        this.val = val;
	    }
	    AndRestriction.prototype.value = function () {
	        return this.val.map(function (x) { return x.value(); });
	    };
	    AndRestriction.prototype.options = function () {
	        return this.val;
	    };
	    AndRestriction.prototype.check = function (i, p) {
	        for (var j = 0; j < this.val.length; j++) {
	            var st = this.val[j].check(i, p);
	            if (!st.isOk()) {
	                return st;
	            }
	        }
	        return ok();
	    };
	    AndRestriction.prototype.requiredType = function () {
	        return exports.ANY;
	    };
	    AndRestriction.prototype.facetName = function () {
	        return "and";
	    };
	    return AndRestriction;
	}(Constraint));
	exports.AndRestriction = AndRestriction;
	/***
	 *
	 * lets declare built in types
	 */
	exports.ANY = new RootType("any");
	exports.SCALAR = exports.ANY.inherit("scalar");
	exports.OBJECT = exports.ANY.inherit("object");
	//export const POLYMORPHIC=OBJECT.inherit("polymorphic");
	exports.ARRAY = exports.ANY.inherit("array");
	exports.NIL = exports.ANY.inherit("nil");
	exports.EXTERNAL = exports.ANY.inherit("external");
	exports.NUMBER = exports.SCALAR.inherit("number");
	exports.INTEGER = exports.NUMBER.inherit("integer");
	exports.BOOLEAN = exports.SCALAR.inherit("boolean");
	exports.STRING = exports.SCALAR.inherit("string");
	//export const DATE=SCALAR.inherit("date");
	exports.DATE_ONLY = exports.SCALAR.inherit("date-only");
	exports.TIME_ONLY = exports.SCALAR.inherit("time-only");
	exports.DATETIME_ONLY = exports.SCALAR.inherit("datetime-only");
	exports.DATETIME = exports.SCALAR.inherit("datetime");
	exports.FILE = exports.SCALAR.inherit("file");
	exports.NOTHING = new RootType("nothing");
	exports.UNION = exports.ANY.inherit("union");
	exports.UNKNOWN = exports.NOTHING.inherit("unknown");
	exports.REFERENCE = exports.NOTHING.inherit("reference");
	exports.RECURRENT = exports.NOTHING.inherit("recurrent");
	///
	//POLYMORPHIC.addMeta(new Polymorphic())
	exports.ANY.addMeta(BUILT_IN);
	exports.NIL.addMeta(BUILT_IN);
	exports.UNION.addMeta(BUILT_IN);
	exports.SCALAR.addMeta(BUILT_IN);
	exports.OBJECT.addMeta(BUILT_IN);
	exports.ARRAY.addMeta(BUILT_IN);
	exports.NUMBER.addMeta(BUILT_IN);
	exports.INTEGER.addMeta(BUILT_IN);
	exports.BOOLEAN.addMeta(BUILT_IN);
	exports.STRING.addMeta(BUILT_IN);
	exports.EXTERNAL.addMeta(BUILT_IN);
	exports.UNKNOWN.addMeta(BUILT_IN);
	exports.RECURRENT.addMeta(BUILT_IN);
	exports.DATE_ONLY.addMeta(BUILT_IN);
	exports.TIME_ONLY.addMeta(BUILT_IN);
	exports.DATETIME_ONLY.addMeta(BUILT_IN);
	exports.DATETIME.addMeta(BUILT_IN);
	exports.FILE.addMeta(BUILT_IN);
	//POLYMORPHIC.addMeta(BUILT_IN);
	exports.UNKNOWN.addMeta(BUILT_IN);
	exports.UNKNOWN.lock();
	exports.RECURRENT.addMeta(BUILT_IN);
	exports.RECURRENT.lock();
	exports.EXTERNAL.lock();
	exports.UNION.lock();
	///lets register all types in registry
	registry.addType(exports.ANY);
	registry.addType(exports.SCALAR);
	registry.addType(exports.OBJECT);
	registry.addType(exports.ARRAY);
	registry.addType(exports.NUMBER);
	registry.addType(exports.INTEGER);
	registry.addType(exports.BOOLEAN);
	registry.addType(exports.NIL);
	registry.addType(exports.STRING);
	registry.addType(exports.DATE_ONLY);
	registry.addType(exports.TIME_ONLY);
	registry.addType(exports.DATETIME_ONLY);
	registry.addType(exports.DATETIME);
	registry.addType(exports.FILE);
	//registry.addType(POLYMORPHIC);
	exports.NOTHING.addMeta(new NothingRestriction());
	exports.NUMBER.addMeta(new TypeOfRestriction("number"));
	exports.NUMBER.addMeta(new metainfo_1.FacetDeclaration("format", exports.STRING, true));
	exports.BOOLEAN.addMeta(new TypeOfRestriction("boolean"));
	exports.OBJECT.addMeta(new TypeOfRestriction("object"));
	exports.ARRAY.addMeta(new TypeOfRestriction("array"));
	exports.STRING.addMeta(new TypeOfRestriction("string"));
	exports.INTEGER.addMeta(new IntegerRestriction());
	exports.NIL.addMeta(new NullRestriction());
	var dt = __webpack_require__(138);
	exports.DATE_ONLY.addMeta(new dt.DateOnlyR());
	exports.TIME_ONLY.addMeta(new dt.TimeOnlyR());
	exports.DATETIME_ONLY.addMeta(new dt.DateTimeOnlyR());
	exports.DATETIME.addMeta(new dt.DateTimeR());
	exports.FILE.addMeta(new TypeOfRestriction("string"));
	var arrayOfString = exports.ARRAY.inherit("");
	arrayOfString.addMeta(new restrictions_3.ComponentShouldBeOfType(exports.STRING));
	exports.FILE.addMeta(new metainfo_1.FacetDeclaration("fileTypes", arrayOfString, true));
	exports.FILE.addMeta(new metainfo_1.FacetDeclaration("minLength", exports.INTEGER, true));
	exports.FILE.addMeta(new metainfo_1.FacetDeclaration("maxLength", exports.INTEGER, true));
	exports.DATETIME.addMeta(new metainfo_1.FacetDeclaration("format", exports.STRING, true));
	exports.NIL.nullable = true;
	exports.SCALAR.addMeta(new ScalarRestriction());
	registry.types().forEach(function (x) { return x.lock(); });
	var ExternalType = (function (_super) {
	    __extends(ExternalType, _super);
	    function ExternalType(name, _content, json, provider) {
	        _super.call(this, name);
	        this._content = _content;
	        this.json = json;
	        this.provider = provider;
	        this.addMeta(new restr.MatchToSchema(_content, provider));
	        this.addSuper(exports.EXTERNAL);
	    }
	    ExternalType.prototype.getContentProvider = function () {
	        return this.provider;
	    };
	    ExternalType.prototype.setContentProvider = function (provider) {
	        this.provider = provider;
	    };
	    ExternalType.prototype.kind = function () {
	        return "external";
	    };
	    ExternalType.prototype.isJSON = function () {
	        return this.json;
	    };
	    ExternalType.prototype.schema = function () {
	        return this._content;
	    };
	    return ExternalType;
	}(InheritedType));
	exports.ExternalType = ExternalType;
	function typePath(t) {
	    var arr = [];
	    while (t != null) {
	        if (t.name() == null) {
	            if (t instanceof InheritedType) {
	                var contextMeta = t.contextMeta();
	                if (contextMeta != null) {
	                    arr.push(contextMeta.path());
	                    t = contextMeta._owner;
	                }
	                else {
	                    break;
	                }
	            }
	            else {
	                break;
	            }
	        }
	        else {
	            arr.push(t.name());
	            break;
	        }
	    }
	    return arr.reverse();
	}
	exports.typePath = typePath;
	//# sourceMappingURL=typesystem.js.map

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.REPEAT = "repeat";
	exports.PARSE_ERROR = "parseError";
	exports.TOP_LEVEL_EXTRA = "topLevel";
	exports.DEFINED_IN_TYPES_EXTRA = "definedInTypes";
	exports.USER_DEFINED_EXTRA = "USER_DEFINED";
	exports.SOURCE_EXTRA = "SOURCE";
	exports.SCHEMA_AND_TYPE_EXTRA = "SCHEMA";
	exports.GLOBAL_EXTRA = "GLOBAL";
	exports.HAS_FACETS = "HAS_FACETS";
	exports.HAS_ITEMS = "HAS_ITEMS";
	(function (MetaInformationKind) {
	    MetaInformationKind[MetaInformationKind["Description"] = 0] = "Description";
	    MetaInformationKind[MetaInformationKind["NotScalar"] = 1] = "NotScalar";
	    MetaInformationKind[MetaInformationKind["DisplayName"] = 2] = "DisplayName";
	    MetaInformationKind[MetaInformationKind["Usage"] = 3] = "Usage";
	    MetaInformationKind[MetaInformationKind["Annotation"] = 4] = "Annotation";
	    MetaInformationKind[MetaInformationKind["FacetDeclaration"] = 5] = "FacetDeclaration";
	    MetaInformationKind[MetaInformationKind["CustomFacet"] = 6] = "CustomFacet";
	    MetaInformationKind[MetaInformationKind["Example"] = 7] = "Example";
	    MetaInformationKind[MetaInformationKind["Required"] = 8] = "Required";
	    MetaInformationKind[MetaInformationKind["HasPropertiesFacet"] = 9] = "HasPropertiesFacet";
	    MetaInformationKind[MetaInformationKind["AllowedTargets"] = 10] = "AllowedTargets";
	    MetaInformationKind[MetaInformationKind["Examples"] = 11] = "Examples";
	    MetaInformationKind[MetaInformationKind["XMLInfo"] = 12] = "XMLInfo";
	    MetaInformationKind[MetaInformationKind["Default"] = 13] = "Default";
	    MetaInformationKind[MetaInformationKind["Constraint"] = 14] = "Constraint";
	    MetaInformationKind[MetaInformationKind["Modifier"] = 15] = "Modifier";
	    MetaInformationKind[MetaInformationKind["Discriminator"] = 16] = "Discriminator";
	    MetaInformationKind[MetaInformationKind["DiscriminatorValue"] = 17] = "DiscriminatorValue";
	})(exports.MetaInformationKind || (exports.MetaInformationKind = {}));
	var MetaInformationKind = exports.MetaInformationKind;
	//# sourceMappingURL=typesystem-interfaces.js.map

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ts = __webpack_require__(96);
	var tsInterfaces = __webpack_require__(97);
	var rs = __webpack_require__(100);
	var typesystem_1 = __webpack_require__(96);
	var typeExpressions = __webpack_require__(139);
	var facetR = __webpack_require__(99);
	var meta = __webpack_require__(101);
	var metainfo_1 = __webpack_require__(101);
	var typesystem_2 = __webpack_require__(96);
	var restrictions_1 = __webpack_require__(100);
	var restrictions_2 = __webpack_require__(100);
	(function (NodeKind) {
	    NodeKind[NodeKind["SCALAR"] = 0] = "SCALAR";
	    NodeKind[NodeKind["ARRAY"] = 1] = "ARRAY";
	    NodeKind[NodeKind["MAP"] = 2] = "MAP";
	})(exports.NodeKind || (exports.NodeKind = {}));
	var NodeKind = exports.NodeKind;
	var JSObjectNode = (function () {
	    function JSObjectNode(_key, obj, inArr, provider) {
	        if (inArr === void 0) { inArr = false; }
	        this._key = _key;
	        this.obj = obj;
	        this.inArr = inArr;
	        this.provider = provider;
	    }
	    JSObjectNode.prototype.value = function () {
	        return this.obj;
	    };
	    JSObjectNode.prototype.key = function () {
	        if (!this._key) {
	            if (this.kind() === NodeKind.MAP && this.inArr) {
	                var l = Object.keys(this.obj);
	                if (l.length === 1) {
	                    return l[0];
	                }
	            }
	        }
	        return this._key;
	    };
	    JSObjectNode.prototype.childWithKey = function (k) {
	        if (this.obj == null) {
	            return null;
	        }
	        if (this.obj.hasOwnProperty(k)) {
	            return new JSObjectNode(k, this.obj[k], false, this.contentProvider());
	        }
	        return null;
	    };
	    JSObjectNode.prototype.children = function () {
	        var _this = this;
	        if (Array.isArray(this.obj)) {
	            return this.obj.map(function (x) { return new JSObjectNode(null, x, true, _this.contentProvider()); });
	        }
	        else if (this.obj && typeof this.obj == "object") {
	            return Object.keys(this.obj).map(function (x) { return new JSObjectNode(x, _this.obj[x], false, _this.provider); });
	        }
	        return [];
	    };
	    JSObjectNode.prototype.kind = function () {
	        if (!this.obj) {
	            return NodeKind.SCALAR;
	        }
	        if (Array.isArray(this.obj)) {
	            return NodeKind.ARRAY;
	        }
	        else if (typeof this.obj === "object") {
	            return NodeKind.MAP;
	        }
	        return NodeKind.SCALAR;
	    };
	    JSObjectNode.prototype.contentProvider = function () {
	        return this.provider;
	    };
	    ;
	    return JSObjectNode;
	}());
	function parseJSON(name, n, r, provider) {
	    if (r === void 0) { r = ts.builtInRegistry(); }
	    return parse(name, new JSObjectNode(null, n, false, provider), r);
	}
	exports.parseJSON = parseJSON;
	function parseJSONTypeCollection(n, r, provider) {
	    if (r === void 0) { r = ts.builtInRegistry(); }
	    return parseTypeCollection(new JSObjectNode(null, n, false, provider), r);
	}
	exports.parseJSONTypeCollection = parseJSONTypeCollection;
	function endsWithQuestionMark(p) {
	    return p.charAt(p.length - 1) == '?';
	}
	var PropertyBean = (function () {
	    function PropertyBean() {
	    }
	    PropertyBean.prototype.add = function (t) {
	        if (!this.optional && !this.additonal && !this.regExp && !this.type.isSubTypeOf(ts.NIL)) {
	            t.addMeta(new rs.HasProperty(this.id));
	        }
	        var matchesPropertyFacet;
	        if (this.additonal) {
	            matchesPropertyFacet = new rs.AdditionalPropertyIs(this.type);
	        }
	        else if (this.regExp) {
	            matchesPropertyFacet = new rs.MapPropertyIs(this.id, this.type);
	        }
	        else {
	            matchesPropertyFacet = new rs.PropertyIs(this.id, this.type, this.optional);
	        }
	        if (matchesPropertyFacet != null) {
	            t.addMeta(matchesPropertyFacet);
	            if (this.type instanceof ts.InheritedType && this.type.name() == null) {
	                //Linking anonymous types with properties declaring them
	                this.type.setContextMeta(matchesPropertyFacet);
	            }
	        }
	    };
	    return PropertyBean;
	}());
	exports.PropertyBean = PropertyBean;
	var TypeCollection = (function () {
	    function TypeCollection() {
	        this._types = [];
	        this._typeMap = {};
	        this.uses = {};
	        this._annotationTypes = [];
	        this._annotationTypeMap = {};
	    }
	    TypeCollection.prototype.library = function (n) {
	        return this.uses[n];
	    };
	    TypeCollection.prototype.addLibrary = function (n, t) {
	        this.uses[n] = t;
	    };
	    TypeCollection.prototype.add = function (t) {
	        this._types.push(t);
	        this._typeMap[t.name()] = t;
	    };
	    TypeCollection.prototype.getType = function (name) {
	        if (this._typeMap.hasOwnProperty(name)) {
	            return this._typeMap[name];
	        }
	        return null;
	    };
	    TypeCollection.prototype.addAnnotationType = function (t) {
	        this._annotationTypes.push(t);
	        this._annotationTypeMap[t.name()] = t;
	    };
	    TypeCollection.prototype.getAnnotationType = function (name) {
	        if (this._annotationTypeMap.hasOwnProperty(name)) {
	            return this._annotationTypeMap[name];
	        }
	        return null;
	    };
	    TypeCollection.prototype.types = function () {
	        return this._types;
	    };
	    TypeCollection.prototype.annotationTypes = function () {
	        return this._annotationTypes;
	    };
	    TypeCollection.prototype.getAnnotationTypeRegistry = function () {
	        var _this = this;
	        var r = new typesystem_2.TypeRegistry(ts.builtInRegistry());
	        this.annotationTypes().forEach(function (x) { return r.addType(x); });
	        Object.keys(this.uses).forEach(function (x) {
	            _this.uses[x].annotationTypes().forEach(function (y) { return r.put(x + "." + y.name(), y); });
	        });
	        return r;
	    };
	    TypeCollection.prototype.getTypeRegistry = function () {
	        var _this = this;
	        var r = new typesystem_2.TypeRegistry(ts.builtInRegistry());
	        this.types().forEach(function (x) { return r.addType(x); });
	        Object.keys(this.uses).forEach(function (x) {
	            _this.uses[x].types().forEach(function (y) { return r.put(x + "." + y.name(), y); });
	        });
	        return r;
	    };
	    return TypeCollection;
	}());
	exports.TypeCollection = TypeCollection;
	var AccumulatingRegistry = (function (_super) {
	    __extends(AccumulatingRegistry, _super);
	    function AccumulatingRegistry(toParse, schemas, ts, _c) {
	        _super.call(this, ts);
	        this.toParse = toParse;
	        this.schemas = schemas;
	        this._c = _c;
	        this.parsing = {};
	    }
	    AccumulatingRegistry.prototype.get = function (name) {
	        var result = _super.prototype.get.call(this, name);
	        if (!result || result.isSubTypeOf(ts.REFERENCE)) {
	            var chld = this.toParse ? this.toParse.childWithKey(name) : null;
	            if (!chld) {
	                chld = this.schemas ? this.schemas.childWithKey(name) : null;
	            }
	            if (chld) {
	                if (this.parsing[name]) {
	                    var recurrent = ts.derive(name, [ts.RECURRENT]);
	                    if (result && result.isSubTypeOf(ts.REFERENCE)) {
	                        result.patch(recurrent);
	                    }
	                    else {
	                        result = recurrent;
	                    }
	                    return result;
	                }
	                this.parsing[name] = true;
	                try {
	                    var tp = parse(name, chld, this);
	                }
	                finally {
	                    delete this.parsing[name];
	                }
	                return tp;
	            }
	            else {
	                var dt = name.indexOf('.');
	                if (dt != -1) {
	                    var ln = name.substring(0, dt);
	                    var tn = name.substr(dt + 1);
	                    var lib = this._c.library(ln);
	                    if (lib) {
	                        var t = lib.getType(tn);
	                        if (t) {
	                            return t;
	                        }
	                    }
	                }
	            }
	        }
	        return result;
	    };
	    return AccumulatingRegistry;
	}(ts.TypeRegistry));
	exports.AccumulatingRegistry = AccumulatingRegistry;
	function parseTypes(n, tr) {
	    if (tr === void 0) { tr = ts.builtInRegistry(); }
	    var provider = n.provider && n.provider();
	    return parseTypeCollection(new JSObjectNode(null, n, false, provider), tr);
	}
	exports.parseTypes = parseTypes;
	var WrapArrayNode = (function () {
	    function WrapArrayNode(n) {
	        this.n = n;
	    }
	    WrapArrayNode.prototype.key = function () {
	        return null;
	    };
	    WrapArrayNode.prototype.value = function () {
	        return null;
	    };
	    WrapArrayNode.prototype.childWithKey = function (k) {
	        var r = this.children();
	        for (var i = 0; i < r.length; i++) {
	            if (r[i].key() == k) {
	                return r[i];
	            }
	        }
	        return null;
	    };
	    WrapArrayNode.prototype.children = function () {
	        return this.n.children().map(function (x) {
	            var c = x.children();
	            if (c.length == 1) {
	                return c[0];
	            }
	            return x;
	        });
	    };
	    WrapArrayNode.prototype.kind = function () {
	        return NodeKind.MAP;
	    };
	    return WrapArrayNode;
	}());
	function transformToArray(n) {
	    return new WrapArrayNode(n);
	}
	function parseTypeCollection(n, tr) {
	    var result = new TypeCollection();
	    if (n.anchor) {
	        if (n.anchor().__$$) {
	            return n.anchor().__$$;
	        }
	        n.anchor().__$$ = result;
	    }
	    var tpes = n.childWithKey("types");
	    if (tpes && tpes.kind() === NodeKind.ARRAY) {
	        tpes = transformToArray(tpes);
	    }
	    var schemas = n.childWithKey("schemas");
	    if (schemas && schemas.kind() === NodeKind.ARRAY) {
	        schemas = transformToArray(schemas);
	    }
	    var reg = new AccumulatingRegistry(tpes, schemas, tr, result);
	    if (tpes && tpes.kind() !== NodeKind.SCALAR) {
	        tpes.children().forEach(function (x) {
	            var t = ts.derive(x.key(), [ts.REFERENCE]);
	            result.add(t);
	            reg.addType(t);
	        });
	    }
	    if (schemas && schemas.kind() !== NodeKind.SCALAR) {
	        schemas.children().forEach(function (x) {
	            var t = ts.derive(x.key(), [ts.REFERENCE]);
	            result.add(t);
	            reg.addType(t);
	        });
	    }
	    var uses = n.childWithKey("uses");
	    if (uses && uses.kind() === NodeKind.ARRAY) {
	        uses = transformToArray(uses);
	    }
	    if (uses && uses.kind() === NodeKind.MAP) {
	        uses.children().forEach(function (c) {
	            result.addLibrary(c.key(), parseTypeCollection(c, tr));
	        });
	    }
	    if (tpes && tpes.kind() !== NodeKind.SCALAR) {
	        tpes.children().forEach(function (x) {
	            reg.get(x.key());
	        });
	    }
	    if (schemas && schemas.kind() !== NodeKind.SCALAR) {
	        schemas.children().forEach(function (x) {
	            reg.get(x.key());
	        });
	    }
	    reg.types().forEach(function (x) { return result.add(x); });
	    var tpes = n.childWithKey("annotationTypes");
	    if (tpes && tpes.kind() === NodeKind.ARRAY) {
	        tpes = transformToArray(tpes);
	    }
	    if (tpes != null && tpes.kind() === NodeKind.MAP) {
	        tpes.children().forEach(function (x) {
	            result.addAnnotationType(parse(x.key(), x, reg, false, true, false));
	        });
	    }
	    return result;
	}
	exports.parseTypeCollection = parseTypeCollection;
	function parsePropertyBean(n, tr) {
	    var result = new PropertyBean();
	    var hasRequiredFacet = false;
	    var rs = n.childWithKey("required");
	    if (rs) {
	        var rsValue = rs.value();
	        if (typeof rsValue == "boolean") {
	            hasRequiredFacet = true;
	        }
	        if (rsValue === false) {
	            result.optional = true;
	            result.id = n.key();
	        }
	    }
	    var name = n.key();
	    if (!hasRequiredFacet && endsWithQuestionMark(n.key())) {
	        name = name.substr(0, name.length - 1);
	        result.optional = true;
	    }
	    if (name.length == 0 || name === '/.*/') {
	        result.additonal = true;
	    }
	    else if (name.charAt(0) == '/' && name.charAt(name.length - 1) == '/') {
	        name = name.substring(1, name.length - 1);
	        result.regExp = true;
	    }
	    result.type = parse(null, n, tr, false, false, false);
	    result.id = name;
	    return result;
	}
	exports.parsePropertyBean = parsePropertyBean;
	var TypeProto = (function () {
	    function TypeProto() {
	    }
	    TypeProto.prototype.toJSON = function () {
	        var result = {};
	        if (this.superTypes && this.superTypes.length > 0) {
	            if (this.superTypes.length == 1) {
	                result['type'] = this.superTypes[0];
	            }
	            else {
	                result['type'] = this.superTypes;
	            }
	        }
	        if (this.customFacets) {
	            this.customFacets.forEach(function (x) { return result[x.facetName()] = x.value(); });
	        }
	        if (this.annotations) {
	            this.annotations.forEach(function (x) { return result["(" + x.facetName() + ")"] = x.value(); });
	        }
	        if (this.facetDeclarations && this.facetDeclarations.length > 0) {
	            var facets = {};
	            this.facetDeclarations.forEach(function (x) {
	                var nm = x.facetName();
	                if (x.isOptional()) {
	                    nm = nm + "?";
	                }
	                var vl = null;
	                if (x.type().isAnonymous()) {
	                    if (x.type().isEmpty()) {
	                        vl = typeToSignature(x.type());
	                    }
	                    else {
	                        vl = toProto(x.type()).toJSON();
	                    }
	                }
	                else {
	                    vl = typeToSignature(x.type());
	                }
	                facets[nm] = vl;
	            });
	            result['facets'] = facets;
	        }
	        if (this.properties && this.properties.length > 0) {
	            var properties = {};
	            this.properties.forEach(function (x) {
	                var nm = x.id;
	                if (x.optional) {
	                    nm = nm + "?";
	                }
	                if (x.additonal) {
	                    nm = "/.*/";
	                }
	                if (x.regExp) {
	                    nm = "/" + nm + "/";
	                }
	                var vl = null;
	                if (x.type.isAnonymous()) {
	                    if (x.type.isEmpty()) {
	                        vl = typeToSignature(x.type);
	                    }
	                    else {
	                        vl = toProto(x.type).toJSON();
	                    }
	                }
	                else {
	                    vl = typeToSignature(x.type);
	                }
	                properties[nm] = vl;
	            });
	            result['properties'] = properties;
	        }
	        if (this.basicFacets) {
	            this.basicFacets.forEach(function (x) {
	                result[x.facetName()] = x.value();
	            });
	        }
	        if (Object.keys(result).length == 1 && !this.notAScalar) {
	            if (result['type']) {
	                return result['type'];
	            }
	        }
	        if (this.additionalProperties !== undefined) {
	            result["additionalProperties"] = this.additionalProperties;
	        }
	        return result;
	    };
	    return TypeProto;
	}());
	exports.TypeProto = TypeProto;
	function toProto(type) {
	    var result = new TypeProto();
	    result.name = type.name();
	    result.superTypes = type.superTypes().map(function (x) { return typeToSignature(x); });
	    result.annotations = [];
	    result.customFacets = [];
	    result.facetDeclarations = [];
	    result.basicFacets = [];
	    result.properties = [];
	    var pmap = {};
	    type.declaredMeta().forEach(function (x) {
	        if (x instanceof meta.Annotation) {
	            result.annotations.push(x);
	        }
	        else if (x instanceof meta.CustomFacet) {
	            result.customFacets.push(x);
	        }
	        else if (x instanceof meta.NotScalar) {
	            result.notAScalar = true;
	        }
	        else if (x instanceof metainfo_1.FacetDeclaration) {
	            result.facetDeclarations.push(x);
	        }
	        else {
	            if (x instanceof rs.HasProperty) {
	                if (pmap.hasOwnProperty(x.value())) {
	                    pmap[x.value()].optional = false;
	                }
	                else {
	                    var pbean = new PropertyBean();
	                    pbean.optional = false;
	                    pbean.id = x.value();
	                    pbean.type = ts.ANY;
	                    pmap[x.value()] = pbean;
	                }
	            }
	            else if (x instanceof rs.AdditionalPropertyIs) {
	                var pbean = new PropertyBean();
	                pbean.optional = false;
	                pbean.id = "/.*/";
	                pbean.additonal = true;
	                pbean.type = x.value();
	                pmap['/.*/'] = pbean;
	            }
	            else if (x instanceof rs.MapPropertyIs) {
	                var pbean = new PropertyBean();
	                pbean.optional = false;
	                pbean.id = x.regexpValue();
	                pbean.regExp = true;
	                pbean.type = x.value();
	                pmap[x.regexpValue()] = pbean;
	            }
	            else if (x instanceof rs.PropertyIs) {
	                if (pmap.hasOwnProperty(x.propertyName())) {
	                    pmap[x.propertyName()].type = x.value();
	                }
	                else {
	                    var pbean = new PropertyBean();
	                    pbean.optional = true;
	                    pbean.id = x.propertyName();
	                    pbean.type = x.value();
	                    pmap[x.propertyName()] = pbean;
	                }
	            }
	            else if (x instanceof rs.KnownPropertyRestriction) {
	                result.additionalProperties = x.value();
	            }
	            else if (!(x instanceof meta.HasPropertiesFacet)) {
	                result.basicFacets.push(x);
	            }
	        }
	    });
	    Object.keys(pmap).forEach(function (x) { return result.properties.push(pmap[x]); });
	    return result;
	}
	exports.toProto = toProto;
	/***
	 * stores a type to JSON structure
	 * @param ts
	 */
	function storeAsJSON(ts) {
	    if (ts instanceof typesystem_1.AbstractType) {
	        return toProto(ts).toJSON();
	    }
	    else {
	        return storeTypeCollection(ts);
	    }
	}
	exports.storeAsJSON = storeAsJSON;
	function storeTypeCollection(tc) {
	    var res = {};
	    var types = {};
	    tc.types().forEach(function (x) {
	        types[x.name()] = storeAsJSON(x);
	    });
	    if (Object.keys(types).length > 0) {
	        res["types"] = types;
	    }
	    var types = {};
	    tc.annotationTypes().forEach(function (x) {
	        types[x.name()] = storeAsJSON(x);
	    });
	    if (Object.keys(types).length > 0) {
	        res["annotationTypes"] = types;
	    }
	    return res;
	}
	function typeToSignature(t) {
	    if (t.isAnonymous()) {
	        if (t.isArray()) {
	            var ci = t.oneMeta(rs.ComponentShouldBeOfType);
	            if (ci) {
	                var vl = ci.value();
	                if (vl.isAnonymous() && vl.isUnion()) {
	                    return "(" + typeToSignature(vl) + ")" + "[]";
	                }
	                return typeToSignature(vl) + "[]";
	            }
	        }
	        if (t.isUnion()) {
	            return t.options().map(function (x) { return typeToSignature(x); }).join(" | ");
	        }
	        return t.superTypes().map(function (x) { return typeToSignature(x); }).join(" , ");
	    }
	    return t.name();
	}
	/**
	 * Analogue of type.isSubTypeOf(), but also checks through unions
	 * @param potentialSubtype
	 * @param potentialSupertype
	 */
	function isSubtypeOf(potentialSubtype, potentialSupertype) {
	    //TODO this algorithm should be moved to type.isSubTypeOf() after release (now leaving it here for safety)
	    if (potentialSupertype === ts.ANY ||
	        potentialSubtype === potentialSupertype ||
	        potentialSubtype.superTypes().some(function (currentSuperType) { return isSubtypeOf(currentSuperType, potentialSupertype); })) {
	        return true;
	    }
	    if (potentialSubtype.isUnion() && potentialSubtype.options) {
	        var options = potentialSubtype.options();
	        if (options.some(function (option) { return isSubtypeOf(option, potentialSupertype); }))
	            return true;
	    }
	    if (potentialSupertype.isUnion() && potentialSupertype.options) {
	        var options = potentialSupertype.options();
	        if (options.some(function (option) { return potentialSubtype == option; }))
	            return true;
	    }
	    return false;
	}
	function testFacetAgainstType(facet, type) {
	    var requiredType = facet.requiredType();
	    var requiredTypes = facet.requiredTypes();
	    if (requiredTypes && requiredTypes.length > 0) {
	        return requiredTypes.some(function (currentRType) { return isSubtypeOf(type, currentRType); });
	    }
	    else {
	        return isSubtypeOf(type, requiredType);
	    }
	}
	/**
	 * parses a type from a JSON structure
	 * @param name
	 * @param n
	 * @param r
	 * @returns {any}
	 */
	function parse(name, n, r, defaultsToAny, annotation, global, ignoreTypeAttr) {
	    if (r === void 0) { r = ts.builtInRegistry(); }
	    if (defaultsToAny === void 0) { defaultsToAny = false; }
	    if (annotation === void 0) { annotation = false; }
	    if (global === void 0) { global = true; }
	    if (ignoreTypeAttr === void 0) { ignoreTypeAttr = false; }
	    //mentioning fragment' uses
	    var uses = n.childWithKey("uses");
	    if (uses) {
	        if (uses.kind() === NodeKind.ARRAY) {
	            uses = transformToArray(uses);
	        }
	        if (uses.kind() === NodeKind.MAP) {
	            var col = new TypeCollection();
	            uses.children().forEach(function (c) {
	                col.addLibrary(c.key(), parseTypeCollection(c, ts.builtInRegistry()));
	            });
	            r = new AccumulatingRegistry(null, null, r, col);
	        }
	    }
	    var provider = n.contentProvider ? n.contentProvider() : null;
	    if (n.kind() == NodeKind.SCALAR) {
	        var valString = n.value();
	        var sp;
	        if (valString == null || valString == "Null" || valString == "NULL") {
	            sp = ts.STRING;
	        }
	        else {
	            sp = typeExpressions.parseToType("" + valString, r, provider);
	        }
	        if (name == null) {
	            return sp;
	        }
	        var res = ts.derive(name, [sp]);
	        if (r instanceof AccumulatingRegistry) {
	            res = contributeToAccumulatingRegistry(res, r);
	        }
	        return res;
	    }
	    if (n.kind() == NodeKind.ARRAY) {
	        var supers = [];
	        n.children().forEach(function (x) {
	            supers.push(typeExpressions.parseToType("" + x.value(), r, provider));
	        });
	        var res = ts.derive(name, supers);
	        if (r instanceof AccumulatingRegistry) {
	            res = contributeToAccumulatingRegistry(res, r);
	        }
	        return res;
	    }
	    var superTypes = [];
	    var tp = n.childWithKey("type");
	    var shAndType = false;
	    if (!tp) {
	        tp = n.childWithKey("schema");
	    }
	    else {
	        if (n.childWithKey("schema")) {
	            shAndType = true;
	        }
	    }
	    if (!tp || ignoreTypeAttr) {
	        if (defaultsToAny) {
	            if (n.childWithKey("properties")) {
	                superTypes = [ts.OBJECT];
	            }
	            else {
	                superTypes = [ts.ANY];
	            }
	        }
	        else {
	            if (n.childWithKey("properties")) {
	                superTypes = [ts.OBJECT];
	            }
	            else {
	                superTypes = [ts.STRING];
	            }
	        }
	    }
	    else {
	        if (tp.kind() == NodeKind.SCALAR) {
	            var valString = tp.value();
	            if (valString == null || valString == "Null" || valString == "NULL") {
	                superTypes = [ts.STRING];
	            }
	            else {
	                superTypes = [typeExpressions.parseToType("" + valString, r, provider)];
	            }
	        }
	        else if (tp.kind() == NodeKind.ARRAY) {
	            superTypes = tp.children().map(function (x) { return x.value(); }).map(function (y) { return typeExpressions.parseToType("" + y, r, provider); });
	        }
	        else if (tp.kind() == NodeKind.MAP) {
	            superTypes = [parse("", tp, r, false, false, false)];
	        }
	    }
	    var result = ts.derive(name, superTypes);
	    if (r instanceof AccumulatingRegistry) {
	        result = contributeToAccumulatingRegistry(result, r);
	    }
	    var actualResult = result;
	    var hasfacetsOrOtherStuffDoesNotAllowedInExternals = null;
	    n.children().forEach(function (x) {
	        var key = x.key();
	        if (!key) {
	            return;
	        }
	        if (key === "type") {
	            return;
	        }
	        if (key === "uses") {
	            //FIXME this should be handled depending from parse level
	            return;
	        }
	        if (key === "schema") {
	            return;
	        }
	        if (key == "properties" || key == "additionalProperties") {
	            if (result.isSubTypeOf(ts.OBJECT)) {
	                return;
	            }
	        }
	        if (key == "items") {
	            if (result.isSubTypeOf(ts.ARRAY)) {
	                var tp = parse(null, x, r, false, false, false);
	                actualResult.addMeta(new restrictions_1.ComponentShouldBeOfType(tp));
	                actualResult.putExtra(tsInterfaces.HAS_ITEMS, true);
	                return;
	            }
	        }
	        if (key === "facets") {
	            hasfacetsOrOtherStuffDoesNotAllowedInExternals = key;
	            return;
	        }
	        if (key == "default" || key == "xml" || key == "required") {
	            hasfacetsOrOtherStuffDoesNotAllowedInExternals = key;
	        }
	        if (key.charAt(0) == '(' && key.charAt(key.length - 1) == ')') {
	            result.addMeta(new meta.Annotation(key.substr(1, key.length - 2), x.value()));
	            return;
	        }
	        var vl = facetR.getInstance().buildFacet(key, x.value());
	        //TODO remove "format" condition and use this check for all facets
	        if (vl && (key != "format" || testFacetAgainstType(vl, result))) {
	            vl.setNode(x);
	            result.addMeta(vl);
	        }
	        else {
	            if (annotation && key === "allowedTargets") {
	                result.addMeta(new meta.AllowedTargets(x.value()));
	            }
	            else {
	                var customFacet = new meta.CustomFacet(key, x.value());
	                customFacet.setNode(x);
	                result.addMeta(customFacet);
	            }
	        }
	    });
	    if (result.isSubTypeOf(ts.OBJECT)) {
	        var props = n.childWithKey("properties");
	        var hasProps = false;
	        if (props) {
	            result.addMeta(new meta.HasPropertiesFacet());
	            if (props.kind() == NodeKind.MAP) {
	                props.children().forEach(function (x) {
	                    hasProps = true;
	                    parsePropertyBean(x, r).add(result);
	                });
	            }
	            else {
	                var err = new ts.Status(ts.Status.ERROR, 2, "properties should be a map", actualResult);
	                err.setValidationPath({ name: "properties" });
	                result.putExtra(tsInterfaces.PARSE_ERROR, err);
	            }
	        }
	        var ap = n.childWithKey("additionalProperties");
	        if (ap) {
	            result.addMeta(new restrictions_2.KnownPropertyRestriction(ap.value()));
	        }
	    }
	    var props = n.childWithKey("facets");
	    if (props) {
	        if (props.kind() == NodeKind.MAP) {
	            props.children().forEach(function (x) {
	                var bean = parsePropertyBean(x, r);
	                result.addMeta(new meta.FacetDeclaration(bean.id, bean.type, bean.optional));
	            });
	        }
	        else {
	            var err = new ts.Status(ts.Status.ERROR, 2, "facets should be a map", actualResult);
	            err.setValidationPath({ name: "facets" });
	            result.putExtra(tsInterfaces.PARSE_ERROR, err);
	        }
	    }
	    if (result.isAnonymous() && result.isEmpty()) {
	        if (result.superTypes().length == 1) {
	            return result.superTypes()[0];
	        }
	    }
	    if (n.kind() != NodeKind.SCALAR) {
	        result.addMeta(new meta.NotScalar());
	    }
	    if (shAndType) {
	        actualResult.putExtra(ts.SCHEMA_AND_TYPE, true);
	    }
	    actualResult.putExtra(ts.GLOBAL, global);
	    actualResult.putExtra(ts.SOURCE_EXTRA, n);
	    actualResult.putExtra(tsInterfaces.HAS_FACETS, hasfacetsOrOtherStuffDoesNotAllowedInExternals);
	    return actualResult;
	}
	exports.parse = parse;
	function contributeToAccumulatingRegistry(result, r) {
	    var existing = ts.TypeRegistry.prototype.get.call(r, result.name());
	    if (existing == null || !existing.isSubTypeOf(ts.REFERENCE)) {
	        r.addType(result);
	    }
	    else if (existing != null && existing.isSubTypeOf(ts.REFERENCE)) {
	        existing.patch(result);
	        result = existing;
	    }
	    result.putExtra(tsInterfaces.TOP_LEVEL_EXTRA, true);
	    return result;
	}
	;
	//# sourceMappingURL=parse.js.map

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ts = __webpack_require__(96);
	var ms = __webpack_require__(101);
	var typesystem_1 = __webpack_require__(96);
	var restrictions_1 = __webpack_require__(100);
	var metainfo_1 = __webpack_require__(101);
	var metainfo_2 = __webpack_require__(101);
	var metainfo_3 = __webpack_require__(101);
	var metainfo_4 = __webpack_require__(101);
	var restrictions_2 = __webpack_require__(100);
	var FacetPrototype = (function () {
	    function FacetPrototype(_construct, _constructWithValue) {
	        this._construct = _construct;
	        this._constructWithValue = _constructWithValue;
	    }
	    FacetPrototype.prototype.isSimple = function () {
	        return this._constructWithValue != null;
	    };
	    FacetPrototype.prototype.newInstance = function () {
	        return this._construct();
	    };
	    FacetPrototype.prototype.createWithValue = function (v) {
	        return this._constructWithValue(v);
	    };
	    FacetPrototype.prototype.isApplicable = function (t) {
	        var instance = this.newInstance();
	        var requiredType = instance.requiredType();
	        var requiredTypes = instance.requiredTypes();
	        if (requiredTypes && requiredTypes.length > 0) {
	            return requiredTypes.some(function (currentRType) { return t.isSubTypeOf(currentRType); });
	        }
	        else {
	            return t.isSubTypeOf(requiredType);
	        }
	    };
	    FacetPrototype.prototype.isInheritable = function () {
	        return this.newInstance().isInheritable();
	    };
	    FacetPrototype.prototype.isConstraint = function () {
	        return this.newInstance() instanceof ts.Constraint;
	    };
	    FacetPrototype.prototype.isMeta = function () {
	        return !this.isConstraint();
	    };
	    FacetPrototype.prototype.name = function () {
	        return this.newInstance().facetName();
	    };
	    return FacetPrototype;
	}());
	exports.FacetPrototype = FacetPrototype;
	var Registry = (function () {
	    function Registry() {
	        var _this = this;
	        this.constraints = [
	            new FacetPrototype(function () { return new restrictions_1.MinProperties(1); }, function (x) { return new restrictions_1.MinProperties(x); }),
	            new FacetPrototype(function () { return new restrictions_1.MaxProperties(1); }, function (x) { return new restrictions_1.MaxProperties(x); }),
	            new FacetPrototype(function () { return new restrictions_1.MinItems(1); }, function (x) { return new restrictions_1.MinItems(x); }),
	            new FacetPrototype(function () { return new restrictions_1.MaxItems(1); }, function (x) { return new restrictions_1.MaxItems(x); }),
	            new FacetPrototype(function () { return new restrictions_1.MinLength(1); }, function (x) { return new restrictions_1.MinLength(x); }),
	            new FacetPrototype(function () { return new restrictions_1.MaxLength(1); }, function (x) { return new restrictions_1.MaxLength(x); }),
	            new FacetPrototype(function () { return new restrictions_1.Minimum(1); }, function (x) { return new restrictions_1.Minimum(x); }),
	            new FacetPrototype(function () { return new restrictions_2.MultipleOf(1); }, function (x) { return new restrictions_2.MultipleOf(x); }),
	            new FacetPrototype(function () { return new restrictions_1.Maximum(1); }, function (x) { return new restrictions_1.Maximum(x); }),
	            new FacetPrototype(function () { return new restrictions_1.Enum([""]); }, function (x) { return new restrictions_1.Enum(x); }),
	            new FacetPrototype(function () { return new restrictions_1.Pattern("."); }, function (x) { return new restrictions_1.Pattern(x); }),
	            new FacetPrototype(function () { return new restrictions_1.Format(""); }, function (x) { return new restrictions_1.Format(x); }),
	            new FacetPrototype(function () { return new restrictions_1.PropertyIs("x", ts.ANY); }, null),
	            new FacetPrototype(function () { return new restrictions_1.AdditionalPropertyIs(ts.ANY); }, null),
	            new FacetPrototype(function () { return new restrictions_1.MapPropertyIs(".", ts.ANY); }, null),
	            new FacetPrototype(function () { return new restrictions_1.HasProperty("x"); }, null),
	            new FacetPrototype(function () { return new restrictions_1.UniqueItems(true); }, function (x) { return new restrictions_1.UniqueItems(x); }),
	            new FacetPrototype(function () { return new restrictions_1.ComponentShouldBeOfType(ts.ANY); }, null),
	            new FacetPrototype(function () { return new restrictions_1.KnownPropertyRestriction(false); }, function (x) { return new restrictions_1.KnownPropertyRestriction(x); })
	        ];
	        this.meta = [
	            new FacetPrototype(function () { return new ms.Discriminator("kind"); }, function (x) { return new ms.Discriminator(x); }),
	            new FacetPrototype(function () { return new ms.DiscriminatorValue("x"); }, function (x) { return new ms.DiscriminatorValue(x); }),
	            new FacetPrototype(function () { return new metainfo_1.Default(""); }, function (x) { return new metainfo_1.Default(x); }),
	            new FacetPrototype(function () { return new metainfo_4.Usage(""); }, function (x) { return new metainfo_4.Usage(x); }),
	            new FacetPrototype(function () { return new metainfo_1.Example(""); }, function (x) { return new metainfo_1.Example(x); }),
	            new FacetPrototype(function () { return new metainfo_3.Required(true); }, function (x) { return new metainfo_3.Required(x); }),
	            new FacetPrototype(function () { return new ms.Examples({}); }, function (x) { return new ms.Examples(x); }),
	            new FacetPrototype(function () { return new metainfo_1.Description(""); }, function (x) { return new metainfo_1.Description(x); }),
	            new FacetPrototype(function () { return new metainfo_1.DisplayName(""); }, function (x) { return new metainfo_1.DisplayName(x); }),
	            new FacetPrototype(function () { return new typesystem_1.Abstract(); }, function (x) { return new typesystem_1.Abstract(); }),
	            new FacetPrototype(function () { return new typesystem_1.Polymorphic(); }, function (x) { return new typesystem_1.Polymorphic(); }),
	            new FacetPrototype(function () { return new metainfo_2.XMLInfo({}); }, function (x) { return new metainfo_2.XMLInfo(x); }),
	        ];
	        this.known = {};
	        this.allPrototypes().forEach(function (x) { return _this.known[x.name()] = x; });
	    }
	    Registry.prototype.allPrototypes = function () {
	        return this.meta.concat(this.constraints);
	    };
	    Registry.prototype.buildFacet = function (n, value) {
	        if (this.known.hasOwnProperty(n) && this.known[n].isSimple()) {
	            return this.known[n].createWithValue(value);
	        }
	        return null;
	    };
	    Registry.prototype.facetPrototypeWithName = function (n) {
	        if (this.known.hasOwnProperty(n)) {
	            return this.known[n];
	        }
	        return null;
	    };
	    Registry.prototype.applyableTo = function (t) {
	        return this.allPrototypes().filter(function (x) { return x.isApplicable(t); });
	    };
	    Registry.prototype.allMeta = function () {
	        return this.allPrototypes().filter(function (x) { return x.isMeta(); });
	    };
	    return Registry;
	}());
	exports.Registry = Registry;
	var instance;
	function getInstance() {
	    if (instance) {
	        return instance;
	    }
	    instance = new Registry();
	    return instance;
	}
	exports.getInstance = getInstance;
	//# sourceMappingURL=facetRegistry.js.map

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../typings/main.d.ts" />
	var ts = __webpack_require__(96);
	var su = __webpack_require__(106);
	var _ = __webpack_require__(175);
	var typesystem_1 = __webpack_require__(96);
	var typesystem_2 = __webpack_require__(96);
	/**
	 * this class is an abstract super type for every constraint that can select properties from objects
	 */
	var MatchesProperty = (function (_super) {
	    __extends(MatchesProperty, _super);
	    function MatchesProperty(_type) {
	        _super.call(this);
	        this._type = _type;
	    }
	    MatchesProperty.prototype.matches = function (s) {
	        return false;
	    };
	    MatchesProperty.prototype.check = function (i, p) {
	        throw new Error("Should be never called");
	    };
	    MatchesProperty.prototype.patchPath = function (p) {
	        if (!p) {
	            return { name: this.propId() };
	        }
	        else {
	            var c = p;
	            var r = null;
	            var cp = null;
	            while (c) {
	                if (!r) {
	                    r = { name: c.name };
	                    cp = r;
	                }
	                else {
	                    var news = { name: c.name };
	                    cp.child = news;
	                    c = c.child;
	                    cp = news;
	                }
	            }
	            r.child = { name: this.propId() };
	            return r;
	        }
	    };
	    MatchesProperty.prototype.validateProp = function (i, n, t, q) {
	        var vl = i[n];
	        var st = t.validate(vl, false, false);
	        if (!st.isOk()) {
	            if (t.isUnknown() || t.isRecurrent()) {
	                var s = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "Validating instance against unknown type:" + t.name(), this);
	                s.setValidationPath(this.patchPath(q));
	                return s;
	            }
	            var s = new typesystem_2.Status(typesystem_2.Status.OK, 0, "", this);
	            st.getErrors().forEach(function (x) { return s.addSubStatus(x); });
	            s.setValidationPath(this.patchPath(q));
	            return s;
	        }
	        return ts.ok();
	    };
	    MatchesProperty.prototype.validateSelf = function (registry) {
	        if (this._type.isExternal()) {
	            var p = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "It is not allowed to use external types in property definitions", this);
	            p.setValidationPath({ name: this.propId() });
	            return p;
	        }
	        if (this._type.isSubTypeOf(ts.UNKNOWN) || this._type.isSubTypeOf(ts.RECURRENT)) {
	            var actualUnknown = actualUnknownType(this._type);
	            var p = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "property " + this.propId() + " refers to unknown type " + actualUnknown.name(), this);
	            p.setValidationPath({ name: this.propId(), child: { name: "type" } });
	            return p;
	        }
	        if (this._type.isAnonymous()) {
	            var st = this._type.validateType(registry);
	            if (!st.isOk()) {
	                var p = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "property " + this.propId() + " range type has error:" + st.getMessage(), this);
	                st.getErrors().forEach(function (y) { p.addSubStatus(y); });
	                p.setValidationPath({ name: this.propId() });
	                return p;
	            }
	            return st;
	        }
	        if (this._type.isUnion()) {
	            var ui = _.find(this._type.typeFamily(), function (x) { return x.isSubTypeOf(ts.UNKNOWN); });
	            if (ui) {
	                var p = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "property " + this.propId() + " refers to unknown type " + ui.name(), this);
	                p.setValidationPath({ name: this.propId() });
	                return p;
	            }
	        }
	        return ts.ok();
	    };
	    return MatchesProperty;
	}(ts.Constraint));
	exports.MatchesProperty = MatchesProperty;
	var MatchToSchema = (function (_super) {
	    __extends(MatchToSchema, _super);
	    function MatchToSchema(_value, provider) {
	        _super.call(this);
	        this._value = _value;
	        this.provider = provider;
	    }
	    MatchToSchema.prototype.value = function () {
	        return this._value;
	    };
	    MatchToSchema.prototype.check = function (i) {
	        var so = null;
	        var strVal = this.value();
	        if (strVal.charAt(0) == "{") {
	            try {
	                so = su.getJSONSchema(strVal, this.provider);
	            }
	            catch (e) {
	                return new ts.Status(ts.Status.ERROR, 0, "Incorrect schema :" + e.message, this);
	            }
	        }
	        if (strVal.charAt(0) == "<") {
	            try {
	                so = su.getXMLSchema(strVal, this.provider);
	            }
	            catch (e) {
	                return ts.ok();
	            }
	        }
	        if (so) {
	            try {
	                so.validateObject(i);
	            }
	            catch (e) {
	                if (e.message == "!_PERF_!") {
	                    return new ts.Status(ts.Status.WARNING, 0, "Unable to validate example against schema (xmllint)", this);
	                }
	                if (e.message == "Cannot assign to read only property '__$validated' of object") {
	                    return ts.ok();
	                }
	                if (e.message == "Object.keys called on non-object") {
	                    return ts.ok();
	                }
	                if (e.message == "Maximum call stack size exceeded") {
	                    return new ts.Status(ts.Status.ERROR, 0, "JSON schema contains circular references", this);
	                }
	                return new ts.Status(ts.Status.ERROR, 0, "Example does not conform to schema:" + e.message, this);
	            }
	        }
	        return ts.ok();
	    };
	    MatchToSchema.prototype.facetName = function () {
	        return "schema";
	    };
	    MatchToSchema.prototype.requiredType = function () {
	        return ts.EXTERNAL;
	    };
	    return MatchToSchema;
	}(ts.Constraint));
	exports.MatchToSchema = MatchToSchema;
	/**
	 * this is a constraint which checks that object has no unknown properties if at has not additional properties
	 */
	var KnownPropertyRestriction = (function (_super) {
	    __extends(KnownPropertyRestriction, _super);
	    function KnownPropertyRestriction(_value) {
	        _super.call(this);
	        this._value = _value;
	    }
	    KnownPropertyRestriction.prototype.facetName = function () {
	        return "closed";
	    };
	    KnownPropertyRestriction.prototype.requiredType = function () {
	        return ts.OBJECT;
	    };
	    KnownPropertyRestriction.prototype.value = function () {
	        return this._value;
	    };
	    KnownPropertyRestriction.prototype.patchOwner = function (t) {
	        this._owner = t;
	    };
	    KnownPropertyRestriction.prototype.check = function (i) {
	        var _this = this;
	        if (this._value === false) {
	            if (i && typeof i == 'object' && !Array.isArray(i)) {
	                var nm = {};
	                Object.getOwnPropertyNames(i).forEach(function (n) { return nm[n] = true; });
	                var mp = this.owner().knownProperties();
	                Object.getOwnPropertyNames(i).forEach(function (p) {
	                    mp.forEach(function (v) {
	                        if (v.matches(p)) {
	                            delete nm[p];
	                        }
	                    });
	                });
	                var unknownPropertyNames = Object.keys(nm);
	                if ((this.owner().hasPropertiesFacet() || mp.length > 0) && unknownPropertyNames.length > 0) {
	                    var s = new ts.Status(ts.Status.OK, 0, "", this);
	                    unknownPropertyNames.forEach(function (x) {
	                        var err = ts.error("Unknown property:" + x, _this);
	                        err.setValidationPath({ name: x });
	                        s.addSubStatus(err);
	                    });
	                    return s;
	                }
	            }
	        }
	        return ts.ok();
	    };
	    KnownPropertyRestriction.prototype.composeWith = function (restriction) {
	        if (!this._value) {
	            return null;
	        }
	        if (restriction instanceof KnownPropertyRestriction) {
	            var mm = restriction;
	            if (_.isEqual(this.owner().propertySet(), mm.owner().propertySet())) {
	                return mm;
	            }
	        }
	        if (restriction instanceof HasProperty) {
	            var ps = restriction;
	            var name = ps.value();
	            var allowedPropertySet = this.owner().propertySet();
	            if (allowedPropertySet.indexOf(name) == -1) {
	                return this.nothing(ps);
	            }
	        }
	    };
	    return KnownPropertyRestriction;
	}(ts.Constraint));
	exports.KnownPropertyRestriction = KnownPropertyRestriction;
	/**
	 * this constaint checks that object has a particular property
	 */
	var HasProperty = (function (_super) {
	    __extends(HasProperty, _super);
	    function HasProperty(name) {
	        _super.call(this);
	        this.name = name;
	    }
	    HasProperty.prototype.check = function (i) {
	        if (i && typeof i == 'object' && !Array.isArray(i)) {
	            if (i.hasOwnProperty(this.name)) {
	                return ts.ok();
	            }
	            return ts.error("Required property: " + this.name + " is missed", this);
	        }
	        return ts.ok();
	    };
	    HasProperty.prototype.requiredType = function () {
	        return ts.OBJECT;
	    };
	    HasProperty.prototype.facetName = function () {
	        return "hasProperty";
	    };
	    HasProperty.prototype.value = function () {
	        return this.name;
	    };
	    HasProperty.prototype.composeWith = function (r) {
	        if (r instanceof HasProperty) {
	            var hp = r;
	            if (hp.name === this.name) {
	                return this;
	            }
	        }
	        return null;
	    };
	    return HasProperty;
	}(ts.Constraint));
	exports.HasProperty = HasProperty;
	/**
	 * this constraint checks that property has a particular tyoe if exists
	 */
	var PropertyIs = (function (_super) {
	    __extends(PropertyIs, _super);
	    function PropertyIs(name, type, optional) {
	        if (optional === void 0) { optional = false; }
	        _super.call(this, type);
	        this.name = name;
	        this.type = type;
	        this.optional = optional;
	    }
	    PropertyIs.prototype.matches = function (s) {
	        return s === this.name;
	    };
	    PropertyIs.prototype.path = function () {
	        return this.name;
	    };
	    PropertyIs.prototype.check = function (i, p) {
	        if (i && typeof i === "object") {
	            if (i.hasOwnProperty(this.name)) {
	                var st = this.validateProp(i, this.name, this.type, p);
	                if (!st.isOk() && this.optional && i[this.name] == null) {
	                    return ts.ok();
	                }
	                return st;
	            }
	        }
	        return ts.ok();
	    };
	    PropertyIs.prototype.requiredType = function () {
	        return ts.OBJECT;
	    };
	    PropertyIs.prototype.propId = function () {
	        return this.name;
	    };
	    PropertyIs.prototype.propertyName = function () {
	        return this.name;
	    };
	    PropertyIs.prototype.facetName = function () {
	        return "propertyIs";
	    };
	    PropertyIs.prototype.value = function () {
	        return this.type;
	    };
	    PropertyIs.prototype.composeWith = function (t) {
	        if (t instanceof PropertyIs) {
	            var pi = t;
	            if (pi.name === this.name) {
	                if (this.type.typeFamily().indexOf(pi.type) != -1) {
	                    return pi;
	                }
	                if (pi.type.typeFamily().indexOf(this.type) != -1) {
	                    return this;
	                }
	                var intersectionType = this.intersect(this.type, pi.type);
	                try {
	                    var is = intersectionType.checkConfluent();
	                    if (!is.isOk()) {
	                        var rc = is;
	                        return rc.toRestriction();
	                    }
	                    return new PropertyIs(this.name, intersectionType);
	                }
	                finally {
	                    this.release(intersectionType);
	                }
	            }
	        }
	        return null;
	    };
	    return PropertyIs;
	}(MatchesProperty));
	exports.PropertyIs = PropertyIs;
	/**
	 * this cosnstraint checks that map property values passes to particular type if exists
	 */
	var MapPropertyIs = (function (_super) {
	    __extends(MapPropertyIs, _super);
	    function MapPropertyIs(regexp, type) {
	        _super.call(this, type);
	        this.regexp = regexp;
	        this.type = type;
	    }
	    MapPropertyIs.prototype.path = function () {
	        return "/" + this.regexp + "/";
	    };
	    MapPropertyIs.prototype.matches = function (s) {
	        if (s.match(this.regexp)) {
	            return true;
	        }
	        return false;
	    };
	    MapPropertyIs.prototype.requiredType = function () {
	        return ts.OBJECT;
	    };
	    MapPropertyIs.prototype.propId = function () {
	        return '[' + this.regexp + ']';
	    };
	    MapPropertyIs.prototype.facetName = function () {
	        return "mapPropertyIs";
	    };
	    MapPropertyIs.prototype.value = function () {
	        return this.type;
	    };
	    MapPropertyIs.prototype.regexpValue = function () {
	        return this.regexp;
	    };
	    MapPropertyIs.prototype.validateSelf = function (t) {
	        var m = this.checkValue();
	        if (m) {
	            return new typesystem_2.Status(typesystem_2.Status.ERROR, 0, m, this);
	        }
	        return _super.prototype.validateSelf.call(this, t);
	    };
	    MapPropertyIs.prototype.checkValue = function () {
	        try {
	            new RegExp(this.regexp);
	        }
	        catch (e) {
	            return e.message;
	        }
	        return null;
	    };
	    MapPropertyIs.prototype.composeWith = function (t) {
	        if (t instanceof MapPropertyIs) {
	            var pi = t;
	            if (pi.regexp === this.regexp) {
	                if (this.type.typeFamily().indexOf(pi.type) != -1) {
	                    return pi;
	                }
	                if (pi.type.typeFamily().indexOf(this.type) != -1) {
	                    return this;
	                }
	                var intersectionType = this.intersect(this.type, pi.type);
	                try {
	                    var is = intersectionType.checkConfluent();
	                    if (!is.isOk()) {
	                        var rc = is;
	                        return rc.toRestriction();
	                    }
	                    return new MapPropertyIs(this.regexp, intersectionType);
	                }
	                finally {
	                    this.release(intersectionType);
	                }
	            }
	        }
	        return null;
	    };
	    MapPropertyIs.prototype.check = function (i, p) {
	        var _this = this;
	        if (i) {
	            if (typeof i == 'object') {
	                var rs = new ts.Status(ts.Status.OK, 0, "", this);
	                Object.getOwnPropertyNames(i).forEach(function (n) {
	                    if (n.match(_this.regexp)) {
	                        var stat = _this.validateProp(i, n, _this.type, p);
	                        if (!stat.isOk()) {
	                            rs.addSubStatus(stat);
	                        }
	                    }
	                });
	                return rs;
	            }
	        }
	        return ts.ok();
	    };
	    return MapPropertyIs;
	}(MatchesProperty));
	exports.MapPropertyIs = MapPropertyIs;
	/**
	 * this constraint tests that additional property
	 */
	var AdditionalPropertyIs = (function (_super) {
	    __extends(AdditionalPropertyIs, _super);
	    function AdditionalPropertyIs(type) {
	        _super.call(this, type);
	        this.type = type;
	    }
	    AdditionalPropertyIs.prototype.path = function () {
	        return this.facetName();
	    };
	    AdditionalPropertyIs.prototype.matches = function (s) {
	        return true;
	    };
	    AdditionalPropertyIs.prototype.requiredType = function () {
	        return ts.OBJECT;
	    };
	    AdditionalPropertyIs.prototype.propId = function () {
	        return '[]';
	    };
	    AdditionalPropertyIs.prototype.facetName = function () {
	        return "additionalProperties";
	    };
	    AdditionalPropertyIs.prototype.value = function () {
	        return this.type;
	    };
	    AdditionalPropertyIs.prototype.match = function (n) {
	        var all = this.owner().metaOfType(PropertyIs);
	        var map = this.owner().metaOfType(MapPropertyIs);
	        for (var i = 0; i < all.length; i++) {
	            if (all[i].matches(n)) {
	                return true;
	            }
	        }
	        for (var i = 0; i < map.length; i++) {
	            if (map[i].matches(n)) {
	                return true;
	            }
	        }
	        return false;
	    };
	    AdditionalPropertyIs.prototype.composeWith = function (t) {
	        if (t instanceof AdditionalPropertyIs) {
	            var pi = t;
	            if (this.type.typeFamily().indexOf(pi.type) != -1) {
	                return pi;
	            }
	            if (pi.type.typeFamily().indexOf(this.type) != -1) {
	                return this;
	            }
	            var intersectionType = this.intersect(this.type, pi.type);
	            try {
	                var is = intersectionType.checkConfluent();
	                if (!is.isOk()) {
	                    var rc = is;
	                    return rc.toRestriction();
	                }
	                return new AdditionalPropertyIs(intersectionType);
	            }
	            finally {
	                this.release(intersectionType);
	            }
	        }
	        return null;
	    };
	    AdditionalPropertyIs.prototype.check = function (i, p) {
	        var _this = this;
	        var t = this.type;
	        var res = new ts.Status(ts.Status.OK, 0, "", this);
	        if (i && typeof i === "object") {
	            Object.getOwnPropertyNames(i).forEach(function (n) {
	                if (!_this.match(n)) {
	                    var stat = _this.validateProp(i, n, t, p);
	                    if (!stat.isOk()) {
	                        res.addSubStatus(stat);
	                    }
	                }
	            });
	        }
	        return res;
	    };
	    return AdditionalPropertyIs;
	}(MatchesProperty));
	exports.AdditionalPropertyIs = AdditionalPropertyIs;
	/**
	 * common super type for a simple restrictions
	 */
	var FacetRestriction = (function (_super) {
	    __extends(FacetRestriction, _super);
	    function FacetRestriction() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Extension of requiredType() method for the case when there are more than a single type
	     * hierarchy roots to cover.
	     * requiredType() should return the common superclass for the list.
	     *
	     * @returns {Array} of types or empty list of there is only a single type set by requiredType() method
	     */
	    FacetRestriction.prototype.requiredTypes = function () {
	        return [];
	    };
	    FacetRestriction.prototype.checkOwner = function (requiredType) {
	        var ownerIsCorrect = false;
	        if (requiredType.isUnion()) {
	            var family = requiredType.typeFamily();
	            for (var _i = 0, family_1 = family; _i < family_1.length; _i++) {
	                var tp = family_1[_i];
	                if (this.owner().isSubTypeOf(tp)) {
	                    ownerIsCorrect = true;
	                    break;
	                }
	            }
	        }
	        else {
	            ownerIsCorrect = this.owner().isSubTypeOf(requiredType);
	        }
	        return ownerIsCorrect;
	    };
	    FacetRestriction.prototype.validateSelf = function (registry) {
	        var _this = this;
	        var ownerIsCorrect = false;
	        if (this.checkOwner(this.requiredType())) {
	            if (this.requiredTypes() && this.requiredTypes().length > 0) {
	                var owner = this.owner();
	                var correctRequiredSuperType = _.find(this.requiredTypes(), function (requiredType) { return _this.checkOwner(requiredType); });
	                if (correctRequiredSuperType) {
	                    ownerIsCorrect = true;
	                }
	            }
	            else {
	                ownerIsCorrect = true;
	            }
	        }
	        if (!ownerIsCorrect) {
	            var typeNames = this.requiredType().name();
	            if (this.requiredTypes() && this.requiredTypes().length > 0) {
	                typeNames = "[" + this.requiredTypes().map(function (requiredType) { return requiredType.name(); }).join() + "]";
	            }
	            var rs = ts.error(this.facetName() + " facet can only be used with " + typeNames + " types", this);
	            rs.setValidationPath({ name: this.facetName() });
	            return rs;
	        }
	        var m = this.checkValue();
	        if (m) {
	            var rs = ts.error(m, this, true);
	            rs.setValidationPath({ name: this.facetName() });
	            return rs;
	        }
	        return ts.ok();
	    };
	    return FacetRestriction;
	}(ts.Constraint));
	exports.FacetRestriction = FacetRestriction;
	function is_int(value) {
	    if ((parseFloat(value) == parseInt(value)) && !isNaN(value)) {
	        return true;
	    }
	    else {
	        return false;
	    }
	}
	/**
	 * abstract super type for every min max restriction
	 */
	var MinMaxRestriction = (function (_super) {
	    __extends(MinMaxRestriction, _super);
	    function MinMaxRestriction(_facetName, _value, _max, _opposite, _requiredType, _isInt) {
	        _super.call(this);
	        this._facetName = _facetName;
	        this._value = _value;
	        this._max = _max;
	        this._opposite = _opposite;
	        this._requiredType = _requiredType;
	        this._isInt = _isInt;
	    }
	    MinMaxRestriction.prototype.facetName = function () {
	        return this._facetName;
	    };
	    MinMaxRestriction.prototype.isIntConstraint = function () {
	        return this._isInt;
	    };
	    MinMaxRestriction.prototype.isMax = function () {
	        return this._max;
	    };
	    MinMaxRestriction.prototype.value = function () {
	        return this._value;
	    };
	    MinMaxRestriction.prototype.check = function (i) {
	        var o = this.extractValue(i);
	        if (typeof o == 'number') {
	            if (this.isMax()) {
	                if (this.value() < o) {
	                    return this.createError();
	                }
	            }
	            else {
	                if (this.value() > o) {
	                    return this.createError();
	                }
	            }
	        }
	        return ts.ok();
	    };
	    MinMaxRestriction.prototype.createError = function () {
	        return ts.error(this.toString(), this);
	    };
	    MinMaxRestriction.prototype.minValue = function () {
	        if (this._isInt) {
	            return 0;
	        }
	        return Number.NEGATIVE_INFINITY;
	    };
	    MinMaxRestriction.prototype.requiredType = function () {
	        return this._requiredType;
	    };
	    MinMaxRestriction.prototype.checkValue = function () {
	        if (typeof this._value != "number") {
	            return this.facetName() + " should be a number";
	        }
	        if (this.isIntConstraint()) {
	            if (!is_int(this.value())) {
	                return this.facetName() + " should be a integer";
	            }
	        }
	        if (this.value() < this.minValue()) {
	            return this.facetName() + " should be at least " + this.minValue();
	        }
	    };
	    MinMaxRestriction.prototype.composeWith = function (t) {
	        if (t instanceof MinMaxRestriction) {
	            var mx = t;
	            if (mx.facetName() == this.facetName()) {
	                if (mx.isMax() == this.isMax()) {
	                    if (this.isMax()) {
	                        if (this.value() < mx.value()) {
	                            return mx;
	                        }
	                        else {
	                            return this;
	                        }
	                    }
	                    else {
	                        if (this.value() > mx.value()) {
	                            return mx;
	                        }
	                        else {
	                            return this;
	                        }
	                    }
	                }
	            }
	            if (mx.facetName() === this._opposite) {
	                if (this.isMax()) {
	                    if (mx.value() > this.value()) {
	                        return this.nothing(t);
	                    }
	                }
	                else {
	                    if (mx.value() < this.value()) {
	                        return this.nothing(t);
	                    }
	                }
	            }
	        }
	        return null;
	    };
	    MinMaxRestriction.prototype.facetPath = function () {
	        var arr = [this.facetName()];
	        var owner = this._owner;
	        if (owner != null) {
	            if (owner instanceof ts.InheritedType) {
	                var it = owner;
	                arr = ts.typePath(it).concat(arr);
	            }
	        }
	        return arr.join(".");
	    };
	    MinMaxRestriction.prototype.toString = function () {
	        return "'" + this.facetPath() + "=" + this.value() + "' i.e. " + this.textMessagePart() + " " + this.value();
	    };
	    MinMaxRestriction.prototype.conflictMessage = function (otherPath, otherValue) {
	        var arr = this.isMax() ? ["less", "higher"] : ["higher", "less"];
	        return "['" + this.facetPath() + "=" + this.value() + "' is " + arr[0] + " than '" + otherPath + "=" + otherValue + "'. The " + this._opposite + " cannot be " + arr[1] + " than the " + this.facetName() + ".]";
	    };
	    return MinMaxRestriction;
	}(FacetRestriction));
	exports.MinMaxRestriction = MinMaxRestriction;
	var MultipleOf = (function (_super) {
	    __extends(MultipleOf, _super);
	    function MultipleOf(_value) {
	        _super.call(this);
	        this._value = _value;
	    }
	    MultipleOf.prototype.value = function () {
	        return this._value;
	    };
	    MultipleOf.prototype.check = function (o) {
	        if (typeof o == 'number') {
	            var q = o / this.value();
	            if (!is_int(q)) {
	                return new ts.Status(ts.Status.ERROR, 0, "result of division of " + o + " on " + this.value() + " should be integer", this);
	            }
	        }
	        return ts.ok();
	    };
	    MultipleOf.prototype.composeWith = function (t) {
	        return null;
	    };
	    MultipleOf.prototype.facetName = function () {
	        return "multipleOf";
	    };
	    MultipleOf.prototype.checkValue = function () {
	        if (typeof this._value != "number") {
	            return this.facetName() + " should be a number";
	        }
	        return null;
	    };
	    MultipleOf.prototype.requiredType = function () {
	        return ts.NUMBER;
	    };
	    return MultipleOf;
	}(FacetRestriction));
	exports.MultipleOf = MultipleOf;
	/**
	 * maximum  constraint
	 */
	var Maximum = (function (_super) {
	    __extends(Maximum, _super);
	    function Maximum(val) {
	        _super.call(this, "maximum", val, true, "minimum", ts.NUMBER, false);
	    }
	    Maximum.prototype.extractValue = function (i) {
	        return i;
	    };
	    Maximum.prototype.textMessagePart = function () {
	        return "value should not be more than";
	    };
	    return Maximum;
	}(MinMaxRestriction));
	exports.Maximum = Maximum;
	/**
	 * minimum constraint
	 */
	var Minimum = (function (_super) {
	    __extends(Minimum, _super);
	    function Minimum(val) {
	        _super.call(this, "minimum", val, false, "maximum", ts.NUMBER, false);
	    }
	    Minimum.prototype.extractValue = function (i) {
	        return i;
	    };
	    Minimum.prototype.textMessagePart = function () {
	        return "value should not be less than";
	    };
	    return Minimum;
	}(MinMaxRestriction));
	exports.Minimum = Minimum;
	/**
	 * max items cosntraint
	 */
	var MaxItems = (function (_super) {
	    __extends(MaxItems, _super);
	    function MaxItems(val) {
	        _super.call(this, "maxItems", val, true, "minItems", ts.ARRAY, true);
	    }
	    MaxItems.prototype.extractValue = function (i) {
	        if (Array.isArray(i)) {
	            return i.length;
	        }
	    };
	    MaxItems.prototype.textMessagePart = function () {
	        return "array items count should not be more than";
	    };
	    return MaxItems;
	}(MinMaxRestriction));
	exports.MaxItems = MaxItems;
	/**
	 * min items cosntraint
	 */
	var MinItems = (function (_super) {
	    __extends(MinItems, _super);
	    function MinItems(val) {
	        _super.call(this, "minItems", val, false, "maxItems", ts.ARRAY, true);
	    }
	    MinItems.prototype.extractValue = function (i) {
	        if (Array.isArray(i)) {
	            return i.length;
	        }
	    };
	    MinItems.prototype.textMessagePart = function () {
	        return "array items count should not be less than";
	    };
	    return MinItems;
	}(MinMaxRestriction));
	exports.MinItems = MinItems;
	/**
	 * max length
	 */
	var MaxLength = (function (_super) {
	    __extends(MaxLength, _super);
	    function MaxLength(val) {
	        _super.call(this, "maxLength", val, true, "minLength", new ts.UnionType("string and file", [ts.STRING, ts.FILE]), true);
	    }
	    MaxLength.prototype.extractValue = function (i) {
	        if (typeof i == 'string') {
	            return i.length;
	        }
	        return 0;
	    };
	    MaxLength.prototype.textMessagePart = function () {
	        return "string length should not be more than";
	    };
	    return MaxLength;
	}(MinMaxRestriction));
	exports.MaxLength = MaxLength;
	/**
	 * min length
	 */
	var MinLength = (function (_super) {
	    __extends(MinLength, _super);
	    function MinLength(val) {
	        _super.call(this, "minLength", val, false, "maxLength", new ts.UnionType("string and file", [ts.STRING, ts.FILE]), true);
	    }
	    MinLength.prototype.extractValue = function (i) {
	        if (typeof i == 'string') {
	            return i.length;
	        }
	        return 0;
	    };
	    MinLength.prototype.textMessagePart = function () {
	        return "string length should not be less than";
	    };
	    return MinLength;
	}(MinMaxRestriction));
	exports.MinLength = MinLength;
	/**
	 * max properties constraint
	 */
	var MaxProperties = (function (_super) {
	    __extends(MaxProperties, _super);
	    function MaxProperties(val) {
	        _super.call(this, "maxProperties", val, true, "minProperties", ts.OBJECT, true);
	    }
	    MaxProperties.prototype.extractValue = function (i) {
	        return Object.keys(i).length;
	    };
	    MaxProperties.prototype.textMessagePart = function () {
	        return "object properties count should not be more than";
	    };
	    return MaxProperties;
	}(MinMaxRestriction));
	exports.MaxProperties = MaxProperties;
	/**
	 * min properties constraint
	 */
	var MinProperties = (function (_super) {
	    __extends(MinProperties, _super);
	    function MinProperties(val) {
	        _super.call(this, "minProperties", val, false, "maxProperties", ts.OBJECT, true);
	    }
	    MinProperties.prototype.extractValue = function (i) {
	        return Object.keys(i).length;
	    };
	    MinProperties.prototype.textMessagePart = function () {
	        return "object properties count should not be less than";
	    };
	    return MinProperties;
	}(MinMaxRestriction));
	exports.MinProperties = MinProperties;
	/**
	 * unique items constraint
	 */
	var UniqueItems = (function (_super) {
	    __extends(UniqueItems, _super);
	    function UniqueItems(_value) {
	        _super.call(this);
	        this._value = _value;
	    }
	    UniqueItems.prototype.facetName = function () { return "uniqueItems"; };
	    UniqueItems.prototype.requiredType = function () { return ts.ARRAY; };
	    UniqueItems.prototype.check = function (i) {
	        if (!this._value) {
	            return ts.ok();
	        }
	        if (Array.isArray(i)) {
	            var r = i;
	            if (_.unique(r).length != r.length) {
	                return ts.error(this.toString(), this);
	            }
	        }
	        return ts.ok();
	    };
	    UniqueItems.prototype.composeWith = function (r) {
	        if (r instanceof UniqueItems) {
	            var mm = r;
	            if (mm._value == this._value) {
	                return this;
	            }
	        }
	        return null;
	    };
	    UniqueItems.prototype.value = function () {
	        return this._value;
	    };
	    UniqueItems.prototype.checkValue = function () {
	        return null;
	    };
	    UniqueItems.prototype.toString = function () {
	        return "items should be unique";
	    };
	    return UniqueItems;
	}(FacetRestriction));
	exports.UniqueItems = UniqueItems;
	/**
	 * components of array should be of type
	 */
	var ComponentShouldBeOfType = (function (_super) {
	    __extends(ComponentShouldBeOfType, _super);
	    function ComponentShouldBeOfType(type) {
	        _super.call(this);
	        this.type = type;
	    }
	    ComponentShouldBeOfType.prototype.facetName = function () { return "items"; };
	    ComponentShouldBeOfType.prototype.requiredType = function () { return ts.ARRAY; };
	    ComponentShouldBeOfType.prototype.toString = function () {
	        return "items should be of type " + this.type;
	    };
	    ComponentShouldBeOfType.prototype.check = function (i) {
	        var rs = new ts.Status(ts.Status.OK, 0, "", this);
	        if (Array.isArray(i)) {
	            var ar = i;
	            for (var j = 0; j < ar.length; j++) {
	                var ss = this.type.validate(ar[j], false, false);
	                if (!ss.isOk()) {
	                    var t = this.type;
	                    if (t.isUnknown() || t.isRecurrent()) {
	                        var s = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "array instance is validated against unknown type:" + t.name(), this);
	                        return s;
	                    }
	                }
	                ss.setValidationPath({ name: "" + j });
	                rs.addSubStatus(ss);
	            }
	        }
	        return rs;
	    };
	    ComponentShouldBeOfType.prototype.validateSelf = function (registry) {
	        if (this.type.isAnonymous()) {
	            var st = this.type.validateType(registry);
	            if (!st.isOk()) {
	                return new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "component type has error:" + st.getMessage(), this);
	            }
	            return st;
	        }
	        if (this.type.isExternal()) {
	            var p = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "It is not allowed to use external types in component type definitions", this);
	            return p;
	        }
	        if (this.type.isSubTypeOf(ts.UNKNOWN) || this.type.isSubTypeOf(ts.RECURRENT)) {
	            return new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "component refers to unknown type " + this.type.name(), this);
	        }
	        if (this.type.isUnion()) {
	            var ui = _.find(this.type.typeFamily(), function (x) { return x.isSubTypeOf(ts.UNKNOWN); });
	            if (ui) {
	                return new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "component refers to unknown type " + ui.name(), this);
	            }
	        }
	        return ts.ok();
	    };
	    ComponentShouldBeOfType.prototype.composeWith = function (t) {
	        if (t instanceof ComponentShouldBeOfType) {
	            var pi = t;
	            if (this.type.typeFamily().indexOf(pi.type) != -1) {
	                return pi;
	            }
	            if (pi.type.typeFamily().indexOf(this.type) != -1) {
	                return this;
	            }
	            var intersectionType = this.intersect(this.type, pi.type);
	            try {
	                var is = intersectionType.checkConfluent();
	                if (!is.isOk()) {
	                    var rc = is;
	                    return rc.toRestriction();
	                }
	                return new ComponentShouldBeOfType(intersectionType);
	            }
	            finally {
	                this.release(intersectionType);
	            }
	        }
	        return null;
	    };
	    ComponentShouldBeOfType.prototype.checkValue = function () {
	        return null;
	    };
	    ComponentShouldBeOfType.prototype.value = function () {
	        return this.type;
	    };
	    return ComponentShouldBeOfType;
	}(FacetRestriction));
	exports.ComponentShouldBeOfType = ComponentShouldBeOfType;
	/**
	 * regular expression (pattern) constraint
	 */
	var Pattern = (function (_super) {
	    __extends(Pattern, _super);
	    function Pattern(_value) {
	        _super.call(this);
	        this._value = _value;
	    }
	    Pattern.prototype.facetName = function () { return "pattern"; };
	    Pattern.prototype.requiredType = function () { return ts.STRING; };
	    Pattern.prototype.check = function (i) {
	        if (typeof i == 'string') {
	            var st = i;
	            try {
	                var matches = st.match(this._value);
	                var gotMatch = false;
	                if (matches) {
	                    for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {
	                        var m = matches_1[_i];
	                        if (m.length == st.length) {
	                            gotMatch = true;
	                            break;
	                        }
	                    }
	                }
	                if (!gotMatch) {
	                    return new ts.Status(ts.Status.ERROR, 0, "string should match to " + this.value(), this);
	                }
	            }
	            catch (e) {
	            }
	        }
	        return ts.ok();
	    };
	    Pattern.prototype.composeWith = function (r) {
	        if (r instanceof Pattern) {
	            var v = r;
	            if (v._value === this._value) {
	                return this;
	            }
	            return this.nothing(r, "pattern restrictions can not be composed at one type");
	        }
	        return null;
	    };
	    Pattern.prototype.value = function () {
	        return this._value;
	    };
	    Pattern.prototype.checkValue = function () {
	        try {
	            new RegExp(this._value);
	        }
	        catch (e) {
	            return e.message;
	        }
	        return null;
	    };
	    Pattern.prototype.toString = function () {
	        return "should pass reg exp:" + this.value;
	    };
	    return Pattern;
	}(FacetRestriction));
	exports.Pattern = Pattern;
	/**
	 * regular expression (pattern) constraint
	 */
	var Format = (function (_super) {
	    __extends(Format, _super);
	    function Format(_value) {
	        _super.call(this);
	        this._value = _value;
	    }
	    Format.prototype.facetName = function () { return "format"; };
	    Format.prototype.requiredType = function () {
	        return ts.SCALAR;
	    };
	    Format.prototype.requiredTypes = function () {
	        return [ts.NUMBER, ts.INTEGER, ts.DATETIME];
	    };
	    Format.prototype.check = function (i) {
	        return ts.ok();
	    };
	    Format.prototype.composeWith = function (r) {
	        if (r instanceof Format) {
	            var v = r;
	            if (v._value === this._value) {
	                return this;
	            }
	            return this.nothing(r, "Format restrictions can not be composed at one type");
	        }
	        return null;
	    };
	    Format.prototype.value = function () {
	        return this._value;
	    };
	    Format.prototype.checkValue = function () {
	        var _this = this;
	        try {
	            var allowedValues = [];
	            if (this.owner().isSubTypeOf(ts.INTEGER)) {
	                allowedValues = ["int32", "int64", "int", "int16", "int8"];
	            }
	            else if (this.owner().isSubTypeOf(ts.NUMBER)) {
	                allowedValues = ["int32", "int64", "int", "long", "float", "double", "int16", "int8"];
	            }
	            else if (this.owner().isSubTypeOf(ts.DATETIME)) {
	                allowedValues = ["rfc3339", "rfc2616"];
	            }
	            else
	                return null;
	            var found = _.find(allowedValues, function (allowedValue) { return allowedValue == _this.value(); });
	            if (!found) {
	                return "Following format values are allowed: " + allowedValues.join();
	            }
	        }
	        catch (e) {
	            return e.message;
	        }
	        return null;
	    };
	    Format.prototype.toString = function () {
	        return "should have format:" + this.value;
	    };
	    return Format;
	}(FacetRestriction));
	exports.Format = Format;
	/**
	 * enum constraint
	 */
	var Enum = (function (_super) {
	    __extends(Enum, _super);
	    function Enum(_value) {
	        _super.call(this);
	        this._value = _value;
	    }
	    Enum.prototype.facetName = function () { return "enum"; };
	    Enum.prototype.requiredType = function () { return ts.SCALAR; };
	    Enum.prototype.check = function (i) {
	        if (!this.checkStatus) {
	            var opts = this.value();
	            if (!Array.isArray(opts)) {
	                opts = [opts];
	            }
	            if (!opts.some(function (x) { return x == i; })) {
	                return ts.error(this.toString(), this);
	            }
	        }
	        return ts.ok();
	    };
	    Enum.prototype.composeWith = function (r) {
	        if (r instanceof Enum) {
	            var v = r;
	            var sss = _.intersection(this._value, v._value);
	            if (sss.length == 0) {
	                return this.nothing(r);
	            }
	            return new Enum(sss);
	        }
	        return null;
	    };
	    Enum.prototype.value = function () {
	        return this._value;
	    };
	    Enum.prototype.checkValue = function () {
	        var _this = this;
	        if (!this.owner().isSubTypeOf(this.requiredType())) {
	            return "enum facet can only be used with: " + this.requiredType().name();
	        }
	        if (this.requiredTypes() && this.requiredTypes().length > 0) {
	            var owner = this.owner();
	            var requiredSuperType = _.find(this.requiredTypes(), function (requiredType) { return owner.isSubTypeOf(requiredType); });
	            if (!requiredSuperType) {
	                var typeNames = "[" + this.requiredTypes().map(function (requiredType) { return requiredType.name(); }).join() + "]";
	                return "enum facet can only be used with: " + typeNames;
	            }
	        }
	        if (!Array.isArray(this._value)) {
	            return "enum facet value must be defined by array";
	        }
	        // if (_.uniq(this._value).length<this._value.length){
	        //     return "enum facet can only contain unique items";
	        // }
	        var result = null;
	        this.checkStatus = true;
	        try {
	            this._value.forEach(function (x) {
	                var res = _this.owner().validate(x);
	                if (!res.isOk()) {
	                    result = res.getMessage();
	                }
	            });
	        }
	        finally {
	            this.checkStatus = false;
	        }
	        return result;
	    };
	    Enum.prototype.toString = function () {
	        return "value should be one of:" + this._value;
	    };
	    return Enum;
	}(FacetRestriction));
	exports.Enum = Enum;
	/**
	 * this function attempts to optimize to set of restrictions
	 * @param r
	 * @returns {ts.Constraint[]}
	 */
	function optimize(r) {
	    r = r.map(function (x) { return x.preoptimize(); });
	    var optimized = [];
	    r.forEach(function (x) {
	        if (x instanceof typesystem_1.AndRestriction) {
	            var ar = x;
	            ar.options().forEach(function (y) { optimized.push(y); });
	        }
	        else {
	            optimized.push(x);
	        }
	    });
	    var transformed = true;
	    while (transformed) {
	        transformed = false;
	        for (var i = 0; i < optimized.length; i++) {
	            for (var j = 0; j < optimized.length; j++) {
	                var rs0 = optimized[i];
	                var rs1 = optimized[j];
	                if (rs0 !== rs1) {
	                    var compose = rs0.tryCompose(rs1);
	                    if (compose) {
	                        var newOptimized = optimized.filter(function (x) { return x !== rs0 && x !== rs1; });
	                        newOptimized.push(compose);
	                        transformed = true;
	                        optimized = newOptimized;
	                        break;
	                    }
	                }
	            }
	            if (transformed) {
	                break;
	            }
	        }
	    }
	    return optimized;
	}
	exports.optimize = optimize;
	function actualUnknownType(t) {
	    if (!t.isSubTypeOf(ts.UNKNOWN)) {
	        return null;
	    }
	    if (t.name() != null) {
	        return t;
	    }
	    for (var _i = 0, _a = t.superTypes(); _i < _a.length; _i++) {
	        var st = _a[_i];
	        var ust = actualUnknownType(st);
	        if (ust != null) {
	            return ust;
	        }
	    }
	    return t;
	}
	//# sourceMappingURL=restrictions.js.map

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/// <reference path="../typings/main.d.ts" />
	var ts = __webpack_require__(96);
	var typesystem_1 = __webpack_require__(96);
	var restrictions_1 = __webpack_require__(100);
	var _ = __webpack_require__(175);
	var xmlio = __webpack_require__(140);
	var tsInterfaces = __webpack_require__(97);
	var MetaInfo = (function (_super) {
	    __extends(MetaInfo, _super);
	    function MetaInfo(_name, _value, inhertitable) {
	        if (inhertitable === void 0) { inhertitable = false; }
	        _super.call(this, inhertitable);
	        this._name = _name;
	        this._value = _value;
	    }
	    MetaInfo.prototype.value = function () {
	        return this._value;
	    };
	    MetaInfo.prototype.requiredType = function () {
	        return ts.ANY;
	    };
	    MetaInfo.prototype.facetName = function () {
	        return this._name;
	    };
	    MetaInfo.prototype.kind = function () {
	        //to be overriden in subtypes
	        return null;
	    };
	    return MetaInfo;
	}(ts.TypeInformation));
	exports.MetaInfo = MetaInfo;
	var Description = (function (_super) {
	    __extends(Description, _super);
	    function Description(value) {
	        _super.call(this, "description", value);
	    }
	    Description.prototype.kind = function () {
	        return tsInterfaces.MetaInformationKind.Description;
	    };
	    return Description;
	}(MetaInfo));
	exports.Description = Description;
	var NotScalar = (function (_super) {
	    __extends(NotScalar, _super);
	    function NotScalar() {
	        _super.call(this, "notScalar", true);
	    }
	    NotScalar.prototype.kind = function () {
	        return tsInterfaces.MetaInformationKind.NotScalar;
	    };
	    return NotScalar;
	}(MetaInfo));
	exports.NotScalar = NotScalar;
	var DisplayName = (function (_super) {
	    __extends(DisplayName, _super);
	    function DisplayName(value) {
	        _super.call(this, "displayName", value);
	    }
	    DisplayName.prototype.kind = function () {
	        return tsInterfaces.MetaInformationKind.DisplayName;
	    };
	    return DisplayName;
	}(MetaInfo));
	exports.DisplayName = DisplayName;
	var Usage = (function (_super) {
	    __extends(Usage, _super);
	    function Usage(value) {
	        _super.call(this, "usage", value);
	    }
	    Usage.prototype.kind = function () {
	        return tsInterfaces.MetaInformationKind.Usage;
	    };
	    return Usage;
	}(MetaInfo));
	exports.Usage = Usage;
	var Annotation = (function (_super) {
	    __extends(Annotation, _super);
	    function Annotation(name, value) {
	        _super.call(this, name, value);
	    }
	    Annotation.prototype.validateSelf = function (registry) {
	        var tp = registry.get(this.facetName());
	        if (!tp) {
	            return new typesystem_1.Status(typesystem_1.Status.ERROR, 0, "using unknown annotation type:" + this.facetName(), this);
	        }
	        var q = this.value();
	        if (!q) {
	            if (tp.isString()) {
	                q = "";
	            }
	        }
	        var valOwner = tp.validateDirect(q, true, false);
	        if (!valOwner.isOk()) {
	            var res = new typesystem_1.Status(typesystem_1.Status.OK, 0, "invalid annotation value" + valOwner.getMessage(), this);
	            res.addSubStatus(valOwner);
	            return res;
	        }
	        return ts.ok();
	    };
	    Annotation.prototype.kind = function () {
	        return tsInterfaces.MetaInformationKind.Annotation;
	    };
	    return Annotation;
	}(MetaInfo));
	exports.Annotation = Annotation;
	var FacetDeclaration = (function (_super) {
	    __extends(FacetDeclaration, _super);
	    function FacetDeclaration(name, _type, optional) {
	        _super.call(this, name, _type, true);
	        this.name = name;
	        this._type = _type;
	        this.optional = optional;
	    }
	    FacetDeclaration.prototype.actualName = function () {
	        if (this.name.charAt(this.name.length - 1) == '?') {
	            return this.name.substr(0, this.name.length - 1);
	        }
	        return this.name;
	    };
	    FacetDeclaration.prototype.isOptional = function () {
	        return this.optional;
	    };
	    FacetDeclaration.prototype.type = function () {
	        return this._type;
	    };
	    FacetDeclaration.prototype.kind = function () {
	        return tsInterfaces.MetaInformationKind.FacetDeclaration;
	    };
	    return FacetDeclaration;
	}(MetaInfo));
	exports.FacetDeclaration = FacetDeclaration;
	var CustomFacet = (function (_super) {
	    __extends(CustomFacet, _super);
	    function CustomFacet(name, value) {
	        _super.call(this, name, value, true);
	    }
	    CustomFacet.prototype.kind = function () {
	        return tsInterfaces.MetaInformationKind.CustomFacet;
	    };
	    return CustomFacet;
	}(MetaInfo));
	exports.CustomFacet = CustomFacet;
	function serializeToXml(value, type) {
	    return xmlio.serializeToXML(value, type);
	}
	function parseExampleIfNeeded(val, type) {
	    if (typeof val === 'string') {
	        if (type.isObject() || type.isArray() || type.isExternal() || type.isUnion()) {
	            var exampleString = val;
	            var firstChar = exampleString.trim().charAt(0);
	            if ((firstChar == "{" || firstChar == "[")) {
	                try {
	                    return JSON.parse(exampleString);
	                }
	                catch (e) {
	                    if (type.isObject() || type.isArray()) {
	                        var c = new typesystem_1.Status(typesystem_1.Status.ERROR, 0, "Can not parse JSON example:" + e.message, this);
	                        return c;
	                    }
	                }
	            }
	            if (firstChar == "<") {
	                try {
	                    var jsonFromXml = xmlio.readObject(exampleString, type);
	                    var errors = xmlio.getXmlErrors(jsonFromXml);
	                    if (errors) {
	                        var error = new typesystem_1.Status(typesystem_1.Status.ERROR, 0, 'Invalid XML.', {});
	                        errors.forEach(function (child) { return error.addSubStatus(child); });
	                        return error;
	                    }
	                    return jsonFromXml;
	                }
	                catch (e) {
	                }
	            }
	        }
	    }
	    if (type.getExtra(tsInterfaces.REPEAT)) {
	        val = [val];
	    }
	    return val;
	}
	var Example = (function (_super) {
	    __extends(Example, _super);
	    function Example(value) {
	        _super.call(this, "example", value);
	    }
	    Example.prototype.validateSelf = function (registry) {
	        var status = ts.ok();
	        status.addSubStatus(this.validateValue(registry));
	        status.addSubStatus(this.validateAnnotations(registry));
	        return status;
	    };
	    Example.prototype.validateValue = function (registry) {
	        var val = this.value();
	        var isVal = false;
	        if (typeof val === "object" && val) {
	            if (val.value) {
	                if (val.strict === false) {
	                    return ts.ok();
	                }
	                if (val.strict && typeof val.strict != "boolean") {
	                    var s = new typesystem_1.Status(typesystem_1.Status.ERROR, 0, "strict should be boolean", this);
	                    s.setValidationPath({ name: "example", child: { name: "strict" } });
	                    return s;
	                }
	                val = val.value;
	                isVal = true;
	            }
	        }
	        var rr = parseExampleIfNeeded(val, this.owner());
	        if (rr instanceof ts.Status) {
	            rr.setValidationPath({ name: "example" });
	            return rr;
	        }
	        var valOwner = this.owner().validateDirect(rr, true, false);
	        if (!valOwner.isOk()) {
	            if (typeof this.value() === "string") {
	            }
	            var c = new typesystem_1.Status(typesystem_1.Status.ERROR, 0, "using invalid `example`:" + valOwner.getMessage(), this);
	            valOwner.getErrors().forEach(function (x) {
	                c.addSubStatus(x);
	                if (isVal) {
	                    x.setValidationPath({ name: "example", child: { name: "value" } });
	                }
	                else {
	                    x.setValidationPath({ name: "example" });
	                }
	            });
	            return c;
	        }
	        return ts.ok();
	    };
	    Example.prototype.validateAnnotations = function (registry) {
	        var status = ts.ok();
	        var val = this.value();
	        if (typeof val === "object" && val) {
	            if (val.value) {
	                var usedAnnotations = Object.keys(val).filter(function (x) {
	                    return x.length > 2 && x.charAt(0) == "(" && x.charAt(x.length - 1) == ")";
	                });
	                for (var _i = 0, usedAnnotations_1 = usedAnnotations; _i < usedAnnotations_1.length; _i++) {
	                    var ua = usedAnnotations_1[_i];
	                    var aValue = val[ua];
	                    var aName = ua.substring(1, ua.length - 1);
	                    var aInstance = new Annotation(aName, aValue);
	                    status.addSubStatus(aInstance.validateSelf(registry));
	                }
	            }
	        }
	        return status;
	    };
	    Example.prototype.example = function () {
	        var val = this.value();
	        if (typeof val === "object" && val) {
	            if (val.value) {
	                val = val.value;
	            }
	        }
	        return parseExampleIfNeeded(val, this.owner());
	    };
	    Example.prototype.asXMLString = function () {
	        var value = this.value();
	        if (typeof value === 'string' && value.trim().indexOf('<') === 0) {
	            return value;
	        }
	        var parsedValue = parseExampleIfNeeded(value, this.owner());
	        return serializeToXml(parsedValue, this.owner());
	    };
	    Example.prototype.kind = function () {
	        return tsInterfaces.MetaInformationKind.Example;
	    };
	    return Example;
	}(MetaInfo));
	exports.Example = Example;
	var Required = (function (_super) {
	    __extends(Required, _super);
	    function Required(value) {
	        _super.call(this, "required", value);
	    }
	    Required.prototype.validateSelf = function (registry) {
	        if (typeof this.value() !== "boolean") {
	            return new typesystem_1.Status(typesystem_1.Status.ERROR, 0, "value of required facet should be boolean", this);
	        }
	        return ts.ok();
	    };
	    Required.prototype.kind = function () {
	        return tsInterfaces.MetaInformationKind.Required;
	    };
	    return Required;
	}(MetaInfo));
	exports.Required = Required;
	var HasPropertiesFacet = (function (_super) {
	    __extends(HasPropertiesFacet, _super);
	    function HasPropertiesFacet() {
	        _super.call(this, "hasPropertiesFacet", null);
	    }
	    HasPropertiesFacet.prototype.validateSelf = function (registry) {
	        return ts.ok();
	    };
	    HasPropertiesFacet.prototype.kind = function () {
	        return tsInterfaces.MetaInformationKind.HasPropertiesFacet;
	    };
	    return HasPropertiesFacet;
	}(MetaInfo));
	exports.HasPropertiesFacet = HasPropertiesFacet;
	var AllowedTargets = (function (_super) {
	    __extends(AllowedTargets, _super);
	    function AllowedTargets(value) {
	        _super.call(this, "allowedTargets", value);
	    }
	    AllowedTargets.prototype.validateSelf = function (registry) {
	        return ts.ok();
	    };
	    AllowedTargets.prototype.kind = function () {
	        return tsInterfaces.MetaInformationKind.AllowedTargets;
	    };
	    return AllowedTargets;
	}(MetaInfo));
	exports.AllowedTargets = AllowedTargets;
	var Examples = (function (_super) {
	    __extends(Examples, _super);
	    function Examples(value) {
	        _super.call(this, "examples", value);
	    }
	    Examples.prototype.examples = function () {
	        var _this = this;
	        var v = this.value();
	        var result = [];
	        Object.keys(v).forEach(function (x) {
	            if (typeof v[x] == 'object' && v[x]) {
	                var val = v[x].value;
	                if (!val) {
	                    val = v[x];
	                }
	                var example = parseExampleIfNeeded(val, _this.owner());
	                result.push(example);
	            }
	        });
	        return result;
	    };
	    Examples.prototype.asXMLStrings = function () {
	        var _this = this;
	        var value = this.value();
	        var result = {};
	        Object.keys(value).forEach(function (key) {
	            var childValue = value[key];
	            if (typeof childValue === 'string' && childValue.trim().indexOf('<') === 0) {
	                result[key] = childValue;
	                return;
	            }
	            var parsedValue = parseExampleIfNeeded(childValue, _this.owner());
	            result[key] = serializeToXml(parsedValue, _this.owner());
	        });
	        return result;
	    };
	    Examples.prototype.validateSelf = function (registry) {
	        var _this = this;
	        if (typeof this.value() === 'object') {
	            var rs = new typesystem_1.Status(typesystem_1.Status.OK, 0, "", this);
	            var v = this.value();
	            if (v) {
	                Object.keys(v).forEach(function (x) {
	                    if (v[x]) {
	                        var val = v[x].value;
	                        var noVal = !val;
	                        if (noVal) {
	                            val = v[x];
	                        }
	                        else {
	                            if (v[x].strict === false) {
	                                return;
	                            }
	                            if (v[x].strict && typeof v[x].strict != "boolean") {
	                                var s = new typesystem_1.Status(typesystem_1.Status.ERROR, 0, "strict should be boolean", _this);
	                                s.setValidationPath({ name: x, child: { name: "strict", child: { name: "strict" } } });
	                                return s;
	                            }
	                        }
	                        var example = parseExampleIfNeeded(val, _this.owner());
	                        if (example instanceof ts.Status) {
	                            examplesPatchPath(example, noVal, x);
	                            rs.addSubStatus(example);
	                            return;
	                        }
	                        var res = _this.owner().validateDirect(example, true, false);
	                        res.getErrors().forEach(function (ex) {
	                            rs.addSubStatus(ex);
	                            examplesPatchPath(ex, noVal, x);
	                        });
	                        if (typeof v[x] == "object" && v[x].value) {
	                            Object.keys(v[x]).forEach(function (key) {
	                                if (key.charAt(0) == '(' && key.charAt(key.length - 1) == ')') {
	                                    var a = new Annotation(key.substring(1, key.length - 1), v[x][key]);
	                                    rs.addSubStatus(a.validateSelf(registry));
	                                }
	                            });
	                        }
	                    }
	                });
	            }
	            return rs;
	        }
	        else {
	            return new typesystem_1.Status(typesystem_1.Status.ERROR, 0, "examples should be a map", this);
	        }
	    };
	    Examples.prototype.kind = function () {
	        return tsInterfaces.MetaInformationKind.Examples;
	    };
	    return Examples;
	}(MetaInfo));
	exports.Examples = Examples;
	function examplesPatchPath(example, noVal, x) {
	    if (noVal) {
	        example.setValidationPath({ name: "examples", child: { name: x } });
	    }
	    else {
	        example.setValidationPath({ name: "examples", child: { name: x, child: { name: "value" } } });
	    }
	}
	var XMLInfo = (function (_super) {
	    __extends(XMLInfo, _super);
	    function XMLInfo(o) {
	        _super.call(this, "xml", o);
	    }
	    XMLInfo.prototype.kind = function () {
	        return tsInterfaces.MetaInformationKind.XMLInfo;
	    };
	    return XMLInfo;
	}(MetaInfo));
	exports.XMLInfo = XMLInfo;
	var Default = (function (_super) {
	    __extends(Default, _super);
	    function Default(value) {
	        _super.call(this, "default", value);
	    }
	    Default.prototype.validateSelf = function (registry) {
	        var valOwner = this.owner().validateDirect(this.value(), true);
	        if (!valOwner.isOk()) {
	            return new typesystem_1.Status(typesystem_1.Status.ERROR, 0, "using invalid `defaultValue`:" + valOwner.getMessage(), this);
	        }
	        return ts.ok();
	    };
	    Default.prototype.kind = function () {
	        return tsInterfaces.MetaInformationKind.Default;
	    };
	    return Default;
	}(MetaInfo));
	exports.Default = Default;
	var Discriminator = (function (_super) {
	    __extends(Discriminator, _super);
	    function Discriminator(property) {
	        _super.call(this, true);
	        this.property = property;
	    }
	    Discriminator.prototype.requiredType = function () {
	        return ts.OBJECT;
	    };
	    Discriminator.prototype.value = function () {
	        return this.property;
	    };
	    Discriminator.prototype.facetName = function () { return "discriminator"; };
	    Discriminator.prototype.validateSelf = function (registry) {
	        var _this = this;
	        if (!this.owner().isSubTypeOf(ts.OBJECT)) {
	            return new typesystem_1.Status(typesystem_1.Status.ERROR, 0, "you only can use `discriminator` with object types", this);
	        }
	        if (this.owner().getExtra(ts.GLOBAL) === false) {
	            return new typesystem_1.Status(typesystem_1.Status.ERROR, 0, "you only can use `discriminator` with top level type definitions", this);
	        }
	        var prop = _.find(this.owner().meta(), function (x) { return x instanceof restrictions_1.PropertyIs && x.propertyName() == _this.value(); });
	        if (!prop) {
	            return new typesystem_1.Status(typesystem_1.Status.ERROR, 0, "Using unknown property '" + this.value() + "' as discriminator", this, true);
	        }
	        if (!prop.value().isScalar()) {
	            return new typesystem_1.Status(typesystem_1.Status.ERROR, 0, "It is only allowed to use scalar properties as discriminators", this);
	        }
	        return ts.ok();
	    };
	    Discriminator.prototype.kind = function () {
	        return tsInterfaces.MetaInformationKind.Discriminator;
	    };
	    return Discriminator;
	}(ts.TypeInformation));
	exports.Discriminator = Discriminator;
	var DiscriminatorValue = (function (_super) {
	    __extends(DiscriminatorValue, _super);
	    function DiscriminatorValue(_value) {
	        _super.call(this, false);
	        this._value = _value;
	    }
	    DiscriminatorValue.prototype.facetName = function () { return "discriminatorValue"; };
	    DiscriminatorValue.prototype.validateSelf = function (registry) {
	        if (!this.owner().isSubTypeOf(ts.OBJECT)) {
	            return new typesystem_1.Status(typesystem_1.Status.ERROR, 0, "you only can use `discriminator` with object types", this);
	        }
	        if (this.owner().getExtra(ts.GLOBAL) === false) {
	            return new typesystem_1.Status(typesystem_1.Status.ERROR, 0, "you only can use `discriminator` with top level type definitions", this);
	        }
	        var ds = this.owner().oneMeta(Discriminator);
	        if (!ds) {
	            return new typesystem_1.Status(typesystem_1.Status.ERROR, 0, "you can not use `discriminatorValue` without declaring `discriminator`", this);
	        }
	        var prop = _.find(this.owner().meta(), function (x) { return x instanceof restrictions_1.PropertyIs && x.propertyName() == ds.value(); });
	        if (prop) {
	            var sm = prop.value().validate(this.value());
	            if (!sm.isOk()) {
	                return new typesystem_1.Status(typesystem_1.Status.ERROR, 0, "using invalid `disciminatorValue`:" + sm.getMessage(), this);
	            }
	        }
	        return ts.ok();
	    };
	    DiscriminatorValue.prototype.requiredType = function () {
	        return ts.OBJECT;
	    };
	    DiscriminatorValue.prototype.value = function () {
	        return this._value;
	    };
	    DiscriminatorValue.prototype.kind = function () {
	        return tsInterfaces.MetaInformationKind.DiscriminatorValue;
	    };
	    return DiscriminatorValue;
	}(ts.TypeInformation));
	exports.DiscriminatorValue = DiscriminatorValue;
	//# sourceMappingURL=metainfo.js.map

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ts = __webpack_require__(96);
	var nt = __webpack_require__(103);
	var parse = __webpack_require__(98);
	var restrictions = __webpack_require__(100);
	var NOMINAL = "nominal";
	var pc;
	function setPropertyConstructor(p) {
	    pc = p;
	}
	exports.setPropertyConstructor = setPropertyConstructor;
	function toNominal(t, callback, customizer) {
	    if (customizer === void 0) { customizer = null; }
	    var vs = null;
	    if (t.getExtra(NOMINAL)) {
	        return t.getExtra(NOMINAL);
	    }
	    //if (t.isEmpty()){
	    //    if (t.superTypes().length==1){
	    //        return toNominal(t.superTypes()[0],callback);
	    //    }
	    //}
	    if (!t) {
	        var res = callback("any");
	        if (!res) {
	            vs = new nt.StructuredType(t.name());
	        }
	    }
	    if (t.isBuiltin()) {
	        var s = (t.name() != "any" && t.name() != "array") ? callback(t.name()) : null;
	        if (!s) {
	            if (t.isScalar()) {
	                vs = new nt.ValueType(t.name(), null);
	            }
	            else {
	                vs = new nt.StructuredType(t.name());
	            }
	        }
	        else {
	            vs = s;
	        }
	    }
	    else {
	        if (t.isObject()) {
	            vs = new nt.StructuredType(t.name(), null);
	        }
	        else if (t.isArray()) {
	            var ar = new nt.Array(t.name(), null);
	            vs = ar;
	            t.putExtra(NOMINAL, vs);
	            var cm = t.oneMeta(restrictions.ComponentShouldBeOfType);
	            var r = cm ? cm.value() : ts.ANY;
	            ar.setComponent(toNominal(r, callback));
	        }
	        else if (t instanceof ts.UnionType) {
	            var ut = new nt.Union(t.name(), null);
	            if (t.superTypes().length == 0) {
	                ut._superTypes.push(toNominal(ts.UNION, callback, customizer));
	            }
	            t.putExtra(NOMINAL, ut);
	            t.options().forEach(function (x) {
	                if (ut.left == null) {
	                    ut.left = toNominal(x, callback);
	                }
	                else if (ut.right == null) {
	                    ut.right = toNominal(x, callback);
	                }
	                else {
	                    var nu = new nt.Union(t.name(), null);
	                    nu.left = ut.right;
	                    nu.right = toNominal(x, callback);
	                    ut.right = nu;
	                }
	            });
	            vs = ut;
	        }
	        else if (t.isScalar()) {
	            vs = new nt.ValueType(t.name(), null);
	        }
	        else if (t instanceof ts.ExternalType) {
	            var e = t;
	            var et = new nt.ExternalType(e.name());
	            et.schemaString = e.schema();
	            vs = et;
	        }
	    }
	    if (!vs) {
	        vs = new nt.StructuredType(t.name());
	    }
	    t.superTypes().forEach(function (x) {
	        var mn = toNominal(x, callback);
	        if (x.isBuiltin()) {
	            vs._superTypes.push(mn);
	        }
	        else {
	            vs.addSuperType(mn);
	        }
	    });
	    if (t.isEmpty()) {
	        if (t.isArray() && t.superTypes().length == 1 && t.superTypes()[0].isAnonymous()) {
	            var q = vs.superTypes()[0];
	            q.setName(t.name());
	            q._subTypes = q._subTypes.filter(function (x) { return x != vs; });
	            vs = q;
	        }
	        if (t.isUnion() && t.superTypes().length == 1 && t.superTypes()[0].isAnonymous()) {
	            var q = vs.superTypes()[0];
	            q.setName(t.name());
	            q._subTypes = q._subTypes.filter(function (x) { return x != vs; });
	            vs = q;
	        }
	    }
	    t.putExtra(NOMINAL, vs);
	    var proto = parse.toProto(t);
	    proto.properties.forEach(function (x) {
	        var prop = pc ? pc(x.id) : new nt.Property(x.id);
	        prop.withDomain(vs);
	        prop.withRange(toNominal(x.type, callback));
	        if (!x.optional) {
	            prop.withRequired(true);
	        }
	    });
	    proto.facetDeclarations.forEach(function (x) {
	        var prop = pc ? pc(x.facetName()) : new nt.Property(x.facetName());
	        prop.withRange(toNominal(x.type(), callback));
	        vs.addFacet(prop);
	    });
	    t.customFacets().forEach(function (x) {
	        vs.fixFacet(x.facetName(), x.value());
	    });
	    var basicFacets = t.metaOfType(restrictions.FacetRestriction);
	    for (var _i = 0, basicFacets_1 = basicFacets; _i < basicFacets_1.length; _i++) {
	        var x = basicFacets_1[_i];
	        vs.fixFacet(x.facetName(), x.value());
	    }
	    vs.addAdapter(t);
	    if (t.isEmpty()) {
	        vs.addAdapter(new nt.Empty());
	    }
	    vs._validator = function (x) { return t.validate(x, false).getErrors(); };
	    if (t.isBuiltin()) {
	        vs.buildIn = true;
	    }
	    else {
	        t.subTypes().forEach(function (x) {
	            var ns = toNominal(x, callback, customizer);
	        });
	    }
	    return vs;
	}
	exports.toNominal = toNominal;
	//# sourceMappingURL=nominals.js.map

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ti = __webpack_require__(104);
	var tsInterfaces = __webpack_require__(97);
	var _ = __webpack_require__(141);
	global["extraInjectors"] = [];
	//var extraInjections:Injector[]=[];
	function registerInjector(i) {
	    //  extraInjections.push(i);
	    global["extraInjectors"].push(i);
	}
	exports.registerInjector = registerInjector;
	var Adaptable = (function () {
	    function Adaptable() {
	        var _this = this;
	        this.adapters = [];
	        global["extraInjectors"].forEach(function (x) { return x.inject(_this); });
	    }
	    Adaptable.prototype.addAdapter = function (q) {
	        this.adapters.push(q);
	    };
	    Adaptable.prototype.getAdapter = function (adapterType) {
	        var result = null;
	        this.adapters.forEach(function (x) {
	            if (x instanceof adapterType) {
	                result = x;
	            }
	        });
	        return result;
	    };
	    Adaptable.prototype.getAdapters = function () {
	        return this.adapters;
	    };
	    return Adaptable;
	}());
	exports.Adaptable = Adaptable;
	var Described = (function (_super) {
	    __extends(Described, _super);
	    function Described(_name, _description) {
	        if (_description === void 0) { _description = ""; }
	        _super.call(this);
	        this._name = _name;
	        this._description = _description;
	        this._tags = [];
	        this._annotations = [];
	    }
	    Described.prototype.nameId = function () { return this._name; };
	    Described.prototype.description = function () { return this._description; };
	    Described.prototype.addAnnotation = function (a) {
	        this._annotations.push(a);
	    };
	    Described.prototype.removeAnnotation = function (a) {
	        this._annotations = this._annotations.filter(function (x) { return x != a; });
	    };
	    Described.prototype.annotations = function () {
	        return [].concat(this._annotations);
	    };
	    Described.prototype.tags = function () {
	        return this._tags;
	    };
	    Described.prototype.withDescription = function (d) {
	        this._description = d;
	        return this;
	    };
	    Described.prototype.setName = function (name) {
	        this._name = name;
	    };
	    return Described;
	}(Adaptable));
	exports.Described = Described;
	var Annotation = (function (_super) {
	    __extends(Annotation, _super);
	    function Annotation(type, parameters) {
	        _super.call(this, type.nameId());
	        this.type = type;
	        this.parameters = parameters;
	    }
	    Annotation.prototype.parameterNames = function () {
	        return Object.keys(this.parameters);
	    };
	    Annotation.prototype.parameter = function (name) {
	        return this.parameters[name];
	    };
	    Annotation.prototype.getType = function () {
	        return this.type;
	    };
	    return Annotation;
	}(Described));
	exports.Annotation = Annotation;
	var Empty = (function () {
	    function Empty() {
	    }
	    return Empty;
	}());
	exports.Empty = Empty;
	var EmptyUniverse = (function () {
	    function EmptyUniverse() {
	    }
	    EmptyUniverse.prototype.type = function (name) {
	        return null;
	    };
	    EmptyUniverse.prototype.version = function () {
	        return "Empty";
	    };
	    EmptyUniverse.prototype.types = function () {
	        return [];
	    };
	    EmptyUniverse.prototype.matched = function () {
	        return {};
	    };
	    return EmptyUniverse;
	}());
	var emptyUniverse = new EmptyUniverse();
	var ebuilder = __webpack_require__(137);
	var AbstractType = (function (_super) {
	    __extends(AbstractType, _super);
	    function AbstractType(_name, _universe, _path) {
	        if (_universe === void 0) { _universe = emptyUniverse; }
	        if (_path === void 0) { _path = ""; }
	        _super.call(this, _name);
	        this._universe = _universe;
	        this._path = _path;
	        this._customProperties = [];
	        this._facets = [];
	        this._superTypes = [];
	        this._subTypes = [];
	        this._requirements = [];
	        this.fixedFacets = {};
	        this.uc = false;
	    }
	    AbstractType.prototype.properties = function () {
	        return [];
	    };
	    AbstractType.prototype.externalInHierarchy = function () {
	        var x = this.allSuperTypes();
	        var res = null;
	        x.forEach(function (y) {
	            if (y instanceof ExternalType) {
	                res = y;
	            }
	        });
	        return res;
	    };
	    AbstractType.prototype.addFacet = function (q) {
	        this._facets.push(q);
	    };
	    AbstractType.prototype.validate = function (x) {
	        if (!this._validator) {
	            throw new Error("Validate can be used only on runtime types instances");
	        }
	        return this._validator(x);
	    };
	    AbstractType.prototype.allFacets = function (ps) {
	        if (ps === void 0) { ps = {}; }
	        if (this._allFacets) {
	            return this._allFacets;
	        }
	        if (ps[this.nameId()]) {
	            return [];
	        }
	        ps[this.typeId()] = this;
	        var n = {};
	        if (this.superTypes().length > 0) {
	            this.superTypes().forEach(function (x) {
	                if (x instanceof AbstractType) {
	                    x.allFacets(ps).forEach(function (y) { return n[y.nameId()] = y; });
	                }
	            });
	        }
	        this._facets.forEach(function (x) { return n[x.nameId()] = x; });
	        //this.properties().forEach(x=>n[x.nameId()]=x);
	        this._allFacets = Object.keys(n).map(function (x) { return n[x]; });
	        return this._allFacets;
	    };
	    AbstractType.prototype.facets = function () {
	        return [].concat(this._facets);
	    };
	    AbstractType.prototype.facet = function (name) {
	        return _.find(this.allFacets(), function (x) { return x.nameId() == name; });
	    };
	    AbstractType.prototype.typeId = function () {
	        return this.nameId();
	    };
	    AbstractType.prototype.allProperties = function (ps) {
	        if (ps === void 0) { ps = {}; }
	        if (this._props) {
	            return this._props;
	        }
	        if (ps[this.typeId()]) {
	            return [];
	        }
	        ps[this.typeId()] = this;
	        var n = {};
	        if (this.superTypes().length > 0) {
	            this.superTypes().forEach(function (x) {
	                if (x instanceof AbstractType) {
	                    x.allProperties(ps).forEach(function (y) { return n[y.nameId()] = y; });
	                }
	                else {
	                    x.allProperties().forEach(function (y) { return n[y.nameId()] = y; });
	                }
	            });
	        }
	        for (var x in this.getFixedFacets()) {
	            delete n[x];
	        }
	        this.properties().forEach(function (x) { return n[x.nameId()] = x; });
	        this._props = Object.keys(n).map(function (x) { return n[x]; });
	        return this._props;
	    };
	    AbstractType.prototype.property = function (propName) {
	        return _.find(this.allProperties(), function (x) { return x.nameId() == propName; });
	    };
	    AbstractType.prototype.hasValueTypeInHierarchy = function () {
	        return _.find(this.allSuperTypes(), function (x) {
	            var mm = x;
	            if (mm.uc) {
	                return false;
	            }
	            mm.uc = true;
	            try {
	                return x.hasValueTypeInHierarchy();
	            }
	            finally {
	                mm.uc = false;
	            }
	        }) != null;
	    };
	    AbstractType.prototype.isAnnotationType = function () {
	        return false;
	    };
	    AbstractType.prototype.hasStructure = function () {
	        return false;
	    };
	    AbstractType.prototype.key = function () {
	        if (this._key) {
	            return this._key;
	        }
	        if (this._universe) {
	            this._key = this.universe().matched()[this.nameId()];
	            if (!this._key) {
	                return null;
	            }
	        }
	        return this._key;
	    };
	    AbstractType.prototype.hasArrayInHierarchy = function () {
	        var arr = _.find(this.allSuperTypes(), function (x) { return x instanceof Array; }) != null;
	        return arr;
	    };
	    AbstractType.prototype.arrayInHierarchy = function () {
	        var x = this.allSuperTypes();
	        var res = null;
	        x.forEach(function (y) {
	            if (y instanceof Array) {
	                res = y;
	            }
	        });
	        return res;
	    };
	    AbstractType.prototype.unionInHierarchy = function () {
	        var x = this.allSuperTypes();
	        var res = null;
	        x.forEach(function (y) {
	            if (y instanceof Union) {
	                res = y;
	            }
	        });
	        return res;
	    };
	    AbstractType.prototype.hasExternalInHierarchy = function () {
	        return _.find(this.allSuperTypes(), function (x) {
	            var mm = x;
	            if (mm.uc) {
	                return false;
	            }
	            mm.uc = true;
	            try {
	                return x instanceof ExternalType;
	            }
	            finally {
	                mm.uc = false;
	            }
	        }) != null;
	    };
	    AbstractType.prototype.hasUnionInHierarchy = function () {
	        return _.find(this.allSuperTypes(), function (x) {
	            var mm = x;
	            if (mm.uc) {
	                return false;
	            }
	            mm.uc = true;
	            try {
	                return x.hasUnionInHierarchy();
	            }
	            finally {
	                mm.uc = false;
	            }
	        }) != null;
	    };
	    AbstractType.prototype.fixFacet = function (name, v) {
	        this.fixedFacets[name] = v;
	    };
	    AbstractType.prototype.getFixedFacets = function () {
	        var mm = {};
	        for (var q in this.fixedFacets) {
	            mm[q] = this.fixedFacets[q];
	        }
	        this.contributeFacets(mm);
	        return mm;
	    };
	    AbstractType.prototype.allFixedFacets = function () {
	        if (this._af) {
	            return this._af;
	        }
	        var sp = this.allSuperTypes();
	        sp.push(this);
	        var mm = {};
	        sp.forEach(function (x) {
	            var ff = x.getFixedFacets();
	            for (var key in Object.keys(ff)) {
	                mm[key] = ff[key];
	            }
	        });
	        this._af = mm;
	        return mm;
	    };
	    AbstractType.prototype.contributeFacets = function (x) {
	    };
	    AbstractType.prototype.getPath = function () {
	        return this._path;
	    };
	    AbstractType.prototype.setNameAtRuntime = function (name) {
	        this._nameAtRuntime = name;
	    };
	    AbstractType.prototype.getNameAtRuntime = function () {
	        return this._nameAtRuntime;
	    };
	    AbstractType.prototype.universe = function () {
	        if (!this._universe) {
	            return new EmptyUniverse();
	        }
	        return this._universe;
	    };
	    AbstractType.prototype.superTypes = function () {
	        return [].concat(this._superTypes);
	    };
	    AbstractType.prototype.isAssignableFrom = function (typeName) {
	        if (this.nameId() == typeName) {
	            if (this.isUserDefined()) {
	                return false;
	            }
	            return true;
	        }
	        var currentSuperTypes = this.allSuperTypes();
	        for (var i = 0; i < currentSuperTypes.length; i++) {
	            if (currentSuperTypes[i].nameId() == typeName) {
	                return true;
	            }
	        }
	        return false;
	    };
	    AbstractType.prototype.annotationType = function () {
	        return null;
	    };
	    AbstractType.prototype.subTypes = function () {
	        return [].concat(this._subTypes);
	    };
	    AbstractType.prototype.allSubTypes = function () {
	        var rs = [];
	        this.subTypes().forEach(function (x) {
	            rs.push(x);
	            rs = rs.concat(x.allSubTypes());
	        });
	        return _.unique(rs);
	    };
	    AbstractType.prototype.allSuperTypes = function () {
	        if (this._allSupers) {
	            return this._allSupers;
	        }
	        var rs = [];
	        this.allSuperTypesRecurrent(this, {}, rs);
	        this._allSupers = _.unique(rs);
	        return this._allSupers;
	    };
	    AbstractType.prototype.allSuperTypesRecurrent = function (t, m, result) {
	        var _this = this;
	        t.superTypes().forEach(function (x) {
	            if (!m[x.typeId()]) {
	                result.push(x);
	                m[x.typeId()] = x;
	                _this.allSuperTypesRecurrent(x, m, result);
	            }
	        });
	    };
	    AbstractType.prototype.addSuperType = function (q) {
	        q._subTypes.push(this);
	        this._superTypes.push(q);
	    };
	    AbstractType.prototype.addRequirement = function (name, value) {
	        this._requirements.push(new ti.ValueRequirement(name, value));
	    };
	    //FIXME simplify it
	    AbstractType.prototype.valueRequirements = function () {
	        return this._requirements;
	    };
	    AbstractType.prototype.requiredProperties = function () {
	        return this.allProperties().filter(function (x) { return x.isRequired(); });
	    };
	    AbstractType.prototype.printDetails = function (indent, settings) {
	        var _this = this;
	        if (!indent) {
	            indent = "";
	        }
	        if (!settings) {
	            settings = {
	                hideProperties: false,
	                hideSuperTypeProperties: false,
	                printStandardSuperclasses: false
	            };
	        }
	        var standardIndent = "  ";
	        var result = "";
	        var className = this.getTypeClassName();
	        result += indent + this.nameId() + "[" + className + "]" + "\n";
	        var properties = this.properties();
	        if (properties && properties.length > 0 && !settings.hideProperties) {
	            result += indent + standardIndent + "Properties:\n";
	            properties.forEach(function (property) {
	                var propertyType = "";
	                var propertyRange = property.range();
	                if (propertyRange instanceof Described) {
	                    propertyType += propertyRange.nameId();
	                }
	                if (propertyRange instanceof AbstractType) {
	                    propertyType += "[";
	                    propertyType += propertyRange.getTypeClassName();
	                    propertyType += "]";
	                }
	                result += indent + standardIndent + standardIndent + property.nameId() + " : " + propertyType + "\n";
	            });
	        }
	        var superTypes = this.superTypes();
	        var filteredSuperTypes = superTypes;
	        if (superTypes && !settings.printStandardSuperclasses) {
	            filteredSuperTypes = _.filter(superTypes, function (superType) {
	                var name = superType instanceof Described ? superType.nameId() : "";
	                var type = superType instanceof AbstractType ?
	                    superType.getTypeClassName() : "";
	                return !_this.isStandardSuperclass(name, type);
	            });
	        }
	        if (filteredSuperTypes && filteredSuperTypes.length > 0) {
	            result += indent + standardIndent + "Super types:\n";
	            filteredSuperTypes.forEach(function (superType) {
	                result += superType.printDetails(indent + standardIndent + standardIndent, {
	                    hideProperties: settings.hideSuperTypeProperties,
	                    hideSuperTypeProperties: settings.hideSuperTypeProperties,
	                    printStandardSuperclasses: settings.printStandardSuperclasses
	                });
	            });
	        }
	        return result;
	    };
	    AbstractType.prototype.getTypeClassName = function () {
	        return this.constructor.toString().match(/\w+/g)[1];
	    };
	    AbstractType.prototype.isStandardSuperclass = function (nameId, className) {
	        if (nameId === "TypeDeclaration" && className === "NodeClass")
	            return true;
	        if (nameId === "ObjectTypeDeclaration" && className === "NodeClass")
	            return true;
	        if (nameId === "RAMLLanguageElement" && className === "NodeClass")
	            return true;
	        return false;
	    };
	    /**
	     * Returns example for this type.
	     * Returned example should be tested for being empty and being expandable.
	     */
	    AbstractType.prototype.examples = function () {
	        return ebuilder.exampleFromNominal(this);
	    };
	    /**
	     * Returns whether this type contain genuine user defined type in its hierarchy.
	     * Genuine user defined type is a type user intentionally defined and filled with
	     * properties or facets, or having user-defined name as opposed to a synthetic user-defined type.
	     */
	    AbstractType.prototype.isGenuineUserDefinedType = function () {
	        if (this.buildIn)
	            return false;
	        if (this.properties() && this.properties().length > 0)
	            return true;
	        if (this.getFixedFacets() && Object.keys(this.getFixedFacets()).length > 0)
	            return true;
	        return this.isTopLevel() && this.nameId() && this.nameId().length > 0;
	    };
	    /**
	     * Returns nearest genuine user-define type in the hierarchy.
	     * Genuine user defined type is a type user intentionally defined and filled with
	     * properties or facets, or having user-defined name as opposed to a synthetic user-defined type.
	     */
	    AbstractType.prototype.genuineUserDefinedTypeInHierarchy = function () {
	        if (this.isGenuineUserDefinedType())
	            return this;
	        var result = null;
	        var allSuperTypes = this.allSuperTypes();
	        allSuperTypes.forEach(function (currentSuperType) {
	            if (!result && currentSuperType.isGenuineUserDefinedType()) {
	                result = currentSuperType;
	            }
	        });
	        return result;
	    };
	    /**
	     * Returns whether this type contain genuine user defined type in its hierarchy.
	     * Genuine user defined type is a type user intentionally defined and filled with
	     * properties or facets, or having user-defined name as opposed to a synthetic user-defined type.
	     */
	    AbstractType.prototype.hasGenuineUserDefinedTypeInHierarchy = function () {
	        return _.find(this.allSuperTypes(), function (x) {
	            var mm = x;
	            if (mm.uc) {
	                return false;
	            }
	            mm.uc = true;
	            try {
	                return x.isGenuineUserDefinedType();
	            }
	            finally {
	                mm.uc = false;
	            }
	        }) != null;
	    };
	    AbstractType.prototype.customProperties = function () {
	        return [].concat(this._customProperties);
	    };
	    AbstractType.prototype.allCustomProperties = function () {
	        var props = [];
	        this.superTypes().forEach(function (x) { return props = props.concat(x.allCustomProperties()); });
	        props = props.concat(this.customProperties());
	        return props;
	    };
	    AbstractType.prototype.registerCustomProperty = function (p) {
	        if (p.domain() != this) {
	            throw new Error("Should be already owned by this");
	        }
	        if (this._customProperties.indexOf(p) != -1) {
	            throw new Error("Already included");
	        }
	        this._customProperties.push(p);
	    };
	    AbstractType.prototype.setCustom = function (val) {
	        this._isCustom = val;
	    };
	    AbstractType.prototype.isCustom = function () {
	        return this._isCustom;
	    };
	    AbstractType.prototype.isUnion = function () {
	        return false;
	    };
	    AbstractType.prototype.union = function () {
	        return null;
	    };
	    AbstractType.prototype.isExternal = function () {
	        return false;
	    };
	    AbstractType.prototype.external = function () {
	        return null;
	    };
	    AbstractType.prototype.isArray = function () {
	        return false;
	    };
	    AbstractType.prototype.isObject = function () {
	        if (this.nameId() == "object") {
	            return true;
	        }
	        for (var _i = 0, _a = this.allSuperTypes(); _i < _a.length; _i++) {
	            var t = _a[_i];
	            if (t.isObject()) {
	                return true;
	            }
	        }
	        return false;
	    };
	    AbstractType.prototype.array = function () {
	        return null;
	    };
	    AbstractType.prototype.isValueType = function () {
	        return false;
	    };
	    AbstractType.prototype.kind = function () {
	        var result = [];
	        if (this.isObject()) {
	            result.push("object");
	        }
	        if (this.isArray()) {
	            result.push("array");
	        }
	        if (this.isValueType()) {
	            result.push("value");
	        }
	        if (this.isUnion()) {
	            result.push("union");
	        }
	        if (this.isAnnotationType()) {
	            result.push("annotation");
	        }
	        if (this.isExternal()) {
	            result.push("external");
	        }
	        return result;
	    };
	    AbstractType.prototype.isBuiltIn = function () {
	        return this.buildIn;
	    };
	    AbstractType.prototype.setBuiltIn = function (builtIn) {
	        this.buildIn = builtIn;
	    };
	    AbstractType.prototype.isTopLevel = function () {
	        //TODO determine whether "topLevel" actually means a simple top-level type and
	        //this flag is absent due to a bug
	        if (this.getExtra(tsInterfaces.DEFINED_IN_TYPES_EXTRA) || this.getExtra(tsInterfaces.TOP_LEVEL_EXTRA))
	            return true;
	        return false;
	    };
	    AbstractType.prototype.isUserDefined = function () {
	        return this.getExtra(tsInterfaces.USER_DEFINED_EXTRA) && !this.buildIn;
	    };
	    AbstractType.prototype.putExtra = function (extraName, value) {
	        var extraAdapter = this.getExtraAdapter();
	        if (!extraAdapter)
	            return;
	        extraAdapter.putExtra(extraName, value);
	    };
	    AbstractType.prototype.getExtra = function (name) {
	        var extraAdapter = this.getExtraAdapter();
	        if (!extraAdapter)
	            return null;
	        return extraAdapter.getExtra(name);
	    };
	    AbstractType.prototype.getExtraAdapter = function () {
	        if (this.getAdapters()) {
	            var extraAdapter = _.find(this.getAdapters(), function (adapter) {
	                //weird duck-typing, but we can touch anything from nominal-types here
	                if (adapter.getExtra && typeof (adapter.getExtra) == "function"
	                    && adapter.putExtra && typeof (adapter.putExtra) == "function") {
	                    return true;
	                }
	            });
	            return extraAdapter;
	        }
	        return null;
	    };
	    return AbstractType;
	}(Described));
	exports.AbstractType = AbstractType;
	var ValueType = (function (_super) {
	    __extends(ValueType, _super);
	    function ValueType(name, _universe, path, description) {
	        if (_universe === void 0) { _universe = null; }
	        if (path === void 0) { path = ""; }
	        if (description === void 0) { description = ""; }
	        _super.call(this, name, _universe, path);
	    }
	    ValueType.prototype.hasStructure = function () {
	        return false;
	    };
	    ValueType.prototype.hasValueTypeInHierarchy = function () {
	        return true;
	    };
	    ValueType.prototype.isValueType = function () {
	        return true;
	    };
	    ValueType.prototype.isUnionType = function () {
	        return false;
	    };
	    ValueType.prototype.isObject = function () {
	        return false;
	    };
	    return ValueType;
	}(AbstractType));
	exports.ValueType = ValueType;
	var StructuredType = (function (_super) {
	    __extends(StructuredType, _super);
	    function StructuredType() {
	        _super.apply(this, arguments);
	        this._properties = [];
	    }
	    StructuredType.prototype.hasStructure = function () {
	        return true;
	    };
	    StructuredType.prototype.propertyIndex = function (name) {
	        var props = this.properties();
	        for (var i = 0; i < props.length; i++) {
	            if (props[i].nameId() == name)
	                return i;
	        }
	        return -1;
	    };
	    StructuredType.prototype.addProperty = function (name, range) {
	        return new Property(name).withDomain(this).withRange(range);
	    };
	    StructuredType.prototype.allPropertyIndex = function (name) {
	        var props = this.allProperties();
	        for (var i = 0; i < props.length; i++) {
	            if (props[i].nameId() == name)
	                return i;
	        }
	        return -1;
	    };
	    StructuredType.prototype.properties = function () {
	        return [].concat(this._properties);
	    };
	    StructuredType.prototype.registerProperty = function (p) {
	        if (p.domain() != this) {
	            throw new Error("Should be already owned by this");
	        }
	        if (this._properties.indexOf(p) != -1) {
	            throw new Error("Already included");
	        }
	        this._properties.push(p);
	    };
	    return StructuredType;
	}(AbstractType));
	exports.StructuredType = StructuredType;
	var Property = (function (_super) {
	    __extends(Property, _super);
	    function Property() {
	        _super.apply(this, arguments);
	        this._keyShouldStartFrom = null;
	        this._isRequired = false;
	        this._isMultiValue = false;
	        this._descriminates = false;
	        this._defaultBooleanValue = null;
	        this._defaultIntegerValue = null;
	    }
	    Property.prototype.withMultiValue = function (v) {
	        if (v === void 0) { v = true; }
	        this._isMultiValue = v;
	        return this;
	    };
	    Property.prototype.withDescriminating = function (b) {
	        this._descriminates = b;
	        return this;
	    };
	    Property.prototype.withRequired = function (req) {
	        this._isRequired = req;
	        return this;
	    };
	    Property.prototype.isRequired = function () {
	        return this._isRequired;
	    };
	    Property.prototype.withKeyRestriction = function (keyShouldStartFrom) {
	        this._keyShouldStartFrom = keyShouldStartFrom;
	        return this;
	    };
	    Property.prototype.withDomain = function (d, custom) {
	        if (custom === void 0) { custom = false; }
	        this._ownerClass = d;
	        if (custom) {
	            d.registerCustomProperty(this);
	        }
	        else {
	            d.registerProperty(this);
	        }
	        return this;
	    };
	    Property.prototype.setDefaultVal = function (s) {
	        this._defaultValue = s;
	        return this;
	    };
	    Property.prototype.setDefaultBooleanVal = function (s) {
	        this._defaultBooleanValue = s;
	        return this;
	    };
	    Property.prototype.setDefaultIntegerVal = function (s) {
	        this._defaultIntegerValue = s;
	        return this;
	    };
	    Property.prototype.defaultValue = function () {
	        if (this._defaultValue != null) {
	            return this._defaultValue;
	        }
	        else if (this._defaultBooleanValue != null) {
	            return this._defaultBooleanValue;
	        }
	        else if (this._defaultIntegerValue != null) {
	            return this._defaultIntegerValue;
	        }
	        return null;
	    };
	    Property.prototype.isPrimitive = function () {
	        return false;
	    };
	    Property.prototype.withRange = function (t) {
	        this._nodeRange = t;
	        return this;
	    };
	    Property.prototype.isValueProperty = function () {
	        return this._nodeRange.hasValueTypeInHierarchy();
	    };
	    Property.prototype.enumOptions = function () {
	        if (this._enumOptions && typeof this._enumOptions == 'string') {
	            return [this._enumOptions + ""];
	        }
	        return this._enumOptions;
	    };
	    Property.prototype.keyPrefix = function () {
	        return this._keyShouldStartFrom;
	    };
	    Property.prototype.withEnumOptions = function (op) {
	        this._enumOptions = op;
	        return this;
	    };
	    Property.prototype.withKeyRegexp = function (regexp) {
	        this._keyRegexp = regexp;
	        return this;
	    };
	    Property.prototype.getKeyRegexp = function () {
	        return this._keyRegexp;
	    };
	    Property.prototype.matchKey = function (k) {
	        if (k == null) {
	            return false;
	        }
	        if (this._groupName != null) {
	            return this._groupName == k;
	        }
	        else {
	            if (this._keyShouldStartFrom != null) {
	                if (k.indexOf(this._keyShouldStartFrom) == 0) {
	                    return true;
	                }
	            }
	            if (this._enumOptions) {
	                if (this._enumOptions.indexOf(k) != -1) {
	                    return true;
	                }
	            }
	            if (this.getKeyRegexp()) {
	                try {
	                    if (new RegExp(this.getKeyRegexp()).test(k)) {
	                        return true;
	                    }
	                }
	                catch (Error) {
	                }
	            }
	            return false;
	        }
	    };
	    Property.prototype.getFacetValidator = function () {
	        return this.facetValidator;
	    };
	    Property.prototype.setFacetValidator = function (f) {
	        this.facetValidator = f;
	    };
	    Property.prototype.domain = function () {
	        return this._ownerClass;
	    };
	    Property.prototype.range = function () {
	        return this._nodeRange;
	    };
	    Property.prototype.isMultiValue = function () {
	        if (this.range() && this.range().hasArrayInHierarchy()) {
	            return true;
	        }
	        return this._isMultiValue;
	    };
	    Property.prototype.isDescriminator = function () {
	        return this._descriminates;
	    };
	    return Property;
	}(Described));
	exports.Property = Property;
	var Union = (function (_super) {
	    __extends(Union, _super);
	    function Union() {
	        _super.apply(this, arguments);
	    }
	    Union.prototype.key = function () {
	        return null;
	    };
	    Union.prototype.leftType = function () {
	        return this.left;
	    };
	    Union.prototype.rightType = function () {
	        return this.right;
	    };
	    Union.prototype.isUserDefined = function () {
	        return true;
	    };
	    Union.prototype.unionInHierarchy = function () {
	        return this;
	    };
	    Union.prototype.union = function () {
	        return this;
	    };
	    Union.prototype.hasUnionInHierarchy = function () {
	        return true;
	    };
	    Union.prototype.isUnion = function () {
	        return true;
	    };
	    Union.prototype.isObject = function () {
	        return this.leftType().isObject() && this.rightType().isObject();
	    };
	    Union.prototype.hasArrayInHierarchy = function () {
	        if (this.left && this.right) {
	            return this.left.hasArrayInHierarchy() || this.right.hasArrayInHierarchy();
	        }
	        if (this.left) {
	            return this.left.hasArrayInHierarchy();
	        }
	        if (this.right) {
	            return this.right.hasArrayInHierarchy();
	        }
	    };
	    return Union;
	}(AbstractType));
	exports.Union = Union;
	var Array = (function (_super) {
	    __extends(Array, _super);
	    function Array() {
	        _super.apply(this, arguments);
	    }
	    Array.prototype.hasArrayInHierarchy = function () {
	        return true;
	    };
	    Array.prototype.isArray = function () {
	        return true;
	    };
	    Array.prototype.isObject = function () {
	        return false;
	    };
	    Array.prototype.arrayInHierarchy = function () {
	        return this;
	    };
	    Array.prototype.array = function () {
	        return this;
	    };
	    Array.prototype.isUserDefined = function () {
	        return true;
	    };
	    Array.prototype.componentType = function () {
	        return this.component;
	    };
	    Array.prototype.setComponent = function (t) {
	        this.component = t;
	    };
	    Array.prototype.key = function () {
	        return null;
	    };
	    return Array;
	}(AbstractType));
	exports.Array = Array;
	var ExternalType = (function (_super) {
	    __extends(ExternalType, _super);
	    function ExternalType() {
	        _super.apply(this, arguments);
	    }
	    ExternalType.prototype.externalInHierarchy = function () {
	        return this;
	    };
	    ExternalType.prototype.typeId = function () {
	        return this.schemaString;
	    };
	    ExternalType.prototype.schema = function () {
	        return this.schemaString;
	    };
	    ExternalType.prototype.isUserDefined = function () {
	        return true;
	    };
	    ExternalType.prototype.hasExternalInHierarchy = function () {
	        return true;
	    };
	    ExternalType.prototype.isExternal = function () {
	        return true;
	    };
	    ExternalType.prototype.external = function () {
	        return this;
	    };
	    return ExternalType;
	}(StructuredType));
	exports.ExternalType = ExternalType;
	//# sourceMappingURL=nominal-types.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ValueRequirement = (function () {
	    /**
	     *
	     * @param name name of the property to discriminate
	     * @param value expected value of discriminating property
	     */
	    function ValueRequirement(name, value) {
	        this.name = name;
	        this.value = value;
	    }
	    return ValueRequirement;
	}());
	exports.ValueRequirement = ValueRequirement;
	//# sourceMappingURL=nominal-interfaces.js.map

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var te = __webpack_require__(139);
	function visit(node, action) {
	    te.visit(node, action);
	}
	exports.visit = visit;
	function serializeToString(node) {
	    return te.serializeToString(node);
	}
	exports.serializeToString = serializeToString;
	function parse(str) {
	    return te.parse(str);
	}
	exports.parse = parse;
	//# sourceMappingURL=typeExpressionUtil.js.map

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/// <reference path="../typings/main.d.ts" />
	"use strict";
	var _ = __webpack_require__(141);
	var xmlUtil = __webpack_require__(142);
	var DOMParser = __webpack_require__(178).DOMParser;
	var ZSchema = __webpack_require__(185);
	var ValidationResult = (function () {
	    function ValidationResult() {
	    }
	    return ValidationResult;
	}());
	exports.ValidationResult = ValidationResult;
	var useLint = true;
	var ErrorsCache = (function () {
	    function ErrorsCache() {
	        this.errors = {};
	    }
	    ErrorsCache.prototype.getValue = function (key) {
	        return this.errors[key];
	    };
	    ErrorsCache.prototype.setValue = function (key, value) {
	        this.errors[key] = value;
	    };
	    return ErrorsCache;
	}());
	var globalCache = new ErrorsCache();
	global.cleanCache = function () {
	    globalCache = new ErrorsCache();
	};
	var DummyProvider = (function () {
	    function DummyProvider() {
	    }
	    DummyProvider.prototype.contextPath = function () {
	        return "";
	    };
	    DummyProvider.prototype.normalizePath = function (url) {
	        return "";
	    };
	    DummyProvider.prototype.content = function (reference) {
	        return "";
	    };
	    DummyProvider.prototype.hasAsyncRequests = function () {
	        return false;
	    };
	    DummyProvider.prototype.resolvePath = function (context, relativePath) {
	        return "";
	    };
	    DummyProvider.prototype.isAbsolutePath = function (uri) {
	        return false;
	    };
	    DummyProvider.prototype.contentAsync = function (reference) {
	        var _this = this;
	        return {
	            then: function (arg) { return arg(_this.content(reference)); },
	            resolve: function () { return null; }
	        };
	    };
	    DummyProvider.prototype.promiseResolve = function (arg) {
	        return {
	            then: function (arg1) { return arg1(arg); },
	            resolve: function () { return null; }
	        };
	    };
	    return DummyProvider;
	}());
	var exampleKey = function (content, schema, contextPath) {
	    return "__EXAMPLE_" + content + schema + contextPath;
	};
	var JSONSchemaObject = (function () {
	    function JSONSchemaObject(schema, provider) {
	        this.schema = schema;
	        this.provider = provider;
	        if (!provider) {
	            this.provider = new DummyProvider();
	        }
	        else {
	            this.provider = provider;
	        }
	        if (!schema || schema.trim().length == 0 || schema.trim().charAt(0) != '{') {
	            throw new Error("Invalid JSON schema content");
	        }
	        var jsonSchemaObject;
	        try {
	            var jsonSchemaObject = JSON.parse(schema);
	        }
	        catch (err) {
	            throw new Error("It is not JSON schema(can not parse JSON:" + err.message + ")");
	        }
	        if (!jsonSchemaObject) {
	            return;
	        }
	        try {
	            var api = __webpack_require__(179);
	            this.setupId(jsonSchemaObject, this.provider.contextPath());
	            var schemaVer = "" + jsonSchemaObject["$schema"];
	            if (schemaVer.indexOf("http://json-schema.org/draft-04/") == -1) {
	                jsonSchemaObject = api.v4(jsonSchemaObject);
	            }
	            else {
	                this.fixRequired(jsonSchemaObject);
	            }
	        }
	        catch (e) {
	            throw new Error('Can not parse schema' + schema);
	        }
	        delete jsonSchemaObject['$schema'];
	        this.jsonSchema = jsonSchemaObject;
	    }
	    JSONSchemaObject.prototype.fixRequired = function (obj) {
	        // Object.keys(obj).forEach(x=>{
	        //     var val=obj[x];
	        //     if (x==="required"){
	        //         if (typeof val==="string"){
	        //             obj[x]=[val];
	        //         }
	        //     }
	        //     if (x==="properties"||x==="items"||x==="additionalItems"||x==="patternProperties"){
	        //         this.fixRequired(val);
	        //     }
	        //
	        // })
	    };
	    JSONSchemaObject.prototype.getType = function () {
	        return "source.json";
	    };
	    JSONSchemaObject.prototype.validateObject = function (object) {
	        //TODO Validation of objects
	        //xmlutil(content);
	        this.validate(JSON.stringify(object));
	    };
	    JSONSchemaObject.prototype.getMissingReferences = function (references, normalize) {
	        var _this = this;
	        if (normalize === void 0) { normalize = false; }
	        var result = [];
	        var validator = new ZSchema();
	        references.forEach(function (references) { return validator.setRemoteReference(references.reference, references.content || {}); });
	        var schemaUrl = null;
	        if (this.jsonSchema.id && typeof (this.jsonSchema.id) === "string") {
	            schemaUrl = this.jsonSchema.id;
	            var innerPos = schemaUrl.indexOf("#");
	            if (innerPos != -1) {
	                schemaUrl = schemaUrl.substr(0, innerPos);
	            }
	        }
	        try {
	            validator.validateSchema(this.jsonSchema);
	        }
	        catch (Error) {
	            //we should never be exploding here, instead we'll report this error later
	            return [];
	        }
	        var result = validator.getMissingRemoteReferences();
	        var filteredReferences = [];
	        if (result)
	            filteredReferences = _.filter(result, function (referenceUrl) {
	                return validator.cache[referenceUrl] == null && referenceUrl != schemaUrl;
	            });
	        return normalize ? filteredReferences.map(function (reference) { return _this.provider.normalizePath(reference); }) : filteredReferences;
	    };
	    JSONSchemaObject.prototype.getSchemaPath = function (schema, normalize) {
	        if (normalize === void 0) { normalize = false; }
	        if (!schema) {
	            return "";
	        }
	        if (!schema.id) {
	            return "";
	        }
	        var id = schema.id.trim();
	        if (!(id.lastIndexOf('#') === id.length - 1)) {
	            return id;
	        }
	        var result = id.substr(0, id.length - 1);
	        if (!normalize) {
	            return result;
	        }
	        return this.provider.normalizePath(result);
	    };
	    JSONSchemaObject.prototype.patchSchema = function (schema) {
	        var _this = this;
	        if (!schema) {
	            return schema;
	        }
	        if (!schema.id) {
	            return schema;
	        }
	        var id = schema.id.trim();
	        if (!(id.lastIndexOf('#') === id.length - 1)) {
	            id = id + '#';
	            schema.id = id;
	        }
	        ;
	        var currentPath = id.substr(0, id.length - 1);
	        if (!this.provider.isAbsolutePath(currentPath)) {
	            return schema;
	        }
	        currentPath = this.provider.normalizePath(currentPath);
	        var refContainers = [];
	        this.collectRefContainers(schema, refContainers);
	        refContainers.forEach(function (refConatiner) {
	            var reference = refConatiner['$ref'];
	            if (typeof reference !== 'string') {
	                return;
	            }
	            if (reference.indexOf('#') === 0) {
	                return;
	            }
	            if (reference.indexOf('#') === -1) {
	                reference = reference + '#';
	            }
	            var resolvedRef = _this.provider.resolvePath(currentPath, reference);
	            refConatiner['$ref'] = resolvedRef;
	        });
	    };
	    JSONSchemaObject.prototype.collectRefContainers = function (rootObject, refContainers) {
	        var _this = this;
	        Object.keys(rootObject).forEach(function (key) {
	            if (key === '$ref') {
	                refContainers.push(rootObject);
	                return;
	            }
	            if (!rootObject[key]) {
	                return;
	            }
	            if (typeof rootObject[key] === 'object') {
	                _this.collectRefContainers(rootObject[key], refContainers);
	            }
	        });
	    };
	    JSONSchemaObject.prototype.validate = function (content, alreadyAccepted) {
	        var _this = this;
	        if (alreadyAccepted === void 0) { alreadyAccepted = []; }
	        var key = exampleKey(content, this.schema, this.provider.contextPath());
	        var error = globalCache.getValue(key);
	        if (error) {
	            if (error instanceof Error) {
	                throw error;
	            }
	            return;
	        }
	        var validator = new ZSchema();
	        alreadyAccepted.forEach(function (accepted) { return validator.setRemoteReference(accepted.reference, accepted.content); });
	        validator.validate(JSON.parse(content), this.jsonSchema);
	        var missingReferences = validator.getMissingRemoteReferences().filter(function (reference) { return !_.find(alreadyAccepted, function (acceptedReference) { return reference === acceptedReference.reference; }); });
	        if (!missingReferences || missingReferences.length === 0) {
	            this.acceptErrors(key, validator.getLastErrors(), true);
	            return;
	        }
	        var acceptedReferences = [];
	        missingReferences.forEach(function (reference) {
	            var remoteSchemeContent;
	            var result = { reference: reference };
	            try {
	                var api = __webpack_require__(179);
	                var jsonObject = JSON.parse(_this.provider.content(reference));
	                _this.setupId(jsonObject, _this.provider.normalizePath(reference));
	                remoteSchemeContent = api.v4(jsonObject);
	                delete remoteSchemeContent['$schema'];
	                result.content = remoteSchemeContent;
	            }
	            catch (exception) {
	                result.error = exception;
	            }
	            finally {
	                acceptedReferences.push(result);
	            }
	        });
	        if (this.provider.hasAsyncRequests()) {
	            return;
	        }
	        acceptedReferences.forEach(function (accepted) {
	            alreadyAccepted.push(accepted);
	        });
	        this.validate(content, alreadyAccepted);
	    };
	    JSONSchemaObject.prototype.setupId = function (json, path) {
	        if (!path) {
	            return;
	        }
	        if (!json) {
	            return;
	        }
	        if (json.id) {
	            json.id = json.id.trim();
	            if (json.id.indexOf('#') < 0) {
	                json.id = json.id + '#';
	            }
	            return;
	        }
	        json.id = path.replace(/\\/g, '/') + '#';
	        this.patchSchema(json);
	    };
	    JSONSchemaObject.prototype.acceptErrors = function (key, errors, throwImmediately) {
	        if (throwImmediately === void 0) { throwImmediately = false; }
	        if (errors && errors.length > 0) {
	            var res = new Error("Content is not valid according to schema:" + errors.map(function (x) { return x.message + " " + x.params; }).join(", "));
	            res.errors = errors;
	            globalCache.setValue(key, res);
	            if (throwImmediately) {
	                throw res;
	            }
	            return;
	        }
	        globalCache.setValue(key, 1);
	    };
	    JSONSchemaObject.prototype.contentAsync = function (reference) {
	        var _this = this;
	        var remoteSchemeContent;
	        var api = __webpack_require__(179);
	        var contentPromise = this.provider.contentAsync(reference);
	        if (!contentPromise) {
	            return this.provider.promiseResolve({
	                reference: reference,
	                content: null,
	                error: new Error('Reference not found: ' + reference)
	            });
	        }
	        var result = contentPromise.then(function (cnt) {
	            var content = { reference: reference };
	            try {
	                var jsonObject = JSON.parse(cnt);
	                _this.setupId(jsonObject, _this.provider.normalizePath(reference));
	                remoteSchemeContent = api.v4(jsonObject);
	                delete remoteSchemeContent['$schema'];
	                content.content = remoteSchemeContent;
	            }
	            catch (exception) {
	                content.error = exception;
	            }
	            return content;
	        });
	        return result;
	    };
	    return JSONSchemaObject;
	}());
	exports.JSONSchemaObject = JSONSchemaObject;
	var MAX_EXAMPLES_TRESHOLD = 10;
	var XMLSchemaObject = (function () {
	    function XMLSchemaObject(schema) {
	        this.schema = schema;
	        this.extraElementData = null;
	        this.contentToResult = {};
	        if (schema.charAt(0) != '<') {
	            throw new Error("Invalid JSON schema");
	        }
	        this.schemaObj = xmlUtil.getValidator(this.handleReferenceElement(schema));
	    }
	    XMLSchemaObject.prototype.getType = function () {
	        return "text.xml";
	    };
	    XMLSchemaObject.prototype.validateObject = function (object) {
	        if (this.extraElementData) {
	            var objectName = Object.keys(object)[0];
	            if (!this.extraElementData.type && !this.extraElementData.originalName) {
	                this.acceptErrors("key", [new Error('Referenced type "' + this.extraElementData.requestedName + '" is not match with "' + objectName + '" root node')], true);
	                return;
	            }
	            if (this.extraElementData.originalName && objectName !== this.extraElementData.originalName) {
	                this.acceptErrors("key", [new Error('Referenced type "' + this.extraElementData.requestedName + '" is not match with "' + objectName + '" root node')], true);
	                return;
	            }
	            if (this.extraElementData.type) {
	                var root = object[objectName];
	                delete object[objectName];
	                object[this.extraElementData.name] = root;
	            }
	        }
	        this.validate(xmlUtil.jsonToXml(object));
	    };
	    XMLSchemaObject.prototype.validate = function (xml) {
	        try {
	            var rs = this.contentToResult[xml];
	            if (rs === false) {
	                return;
	            }
	            if (rs) {
	                throw rs;
	            }
	            var validationErrors = this.schemaObj.validate(xml);
	            this.acceptErrors("key", validationErrors, true);
	            this.contentToResult[xml] = false;
	            if (Object.keys(this.contentToResult).length > MAX_EXAMPLES_TRESHOLD) {
	                this.contentToResult = {};
	            }
	        }
	        catch (e) {
	            this.contentToResult[xml] = e;
	            throw e;
	        }
	    };
	    XMLSchemaObject.prototype.handleReferenceElement = function (content) {
	        var doc = new DOMParser().parseFromString(content);
	        var schema = elementChildrenByName(doc, 'xs:schema')[0];
	        var elements = elementChildrenByName(schema, 'xs:element');
	        var element = _.find(elements, function (element) { return element.getAttribute('extraelement') === 'true'; });
	        if (!element) {
	            return content;
	        }
	        var extraElementData = {};
	        extraElementData.name = element.getAttribute('name');
	        extraElementData.type = element.getAttribute('type');
	        extraElementData.originalName = element.getAttribute('originalname');
	        extraElementData.requestedName = element.getAttribute('requestedname');
	        if (!extraElementData.type) {
	            schema.removeChild(element);
	        }
	        element.removeAttribute('originalname');
	        element.removeAttribute('requestedname');
	        element.removeAttribute('extraelement');
	        this.extraElementData = extraElementData;
	        return doc.toString();
	    };
	    XMLSchemaObject.prototype.acceptErrors = function (key, errors, throwImmediately) {
	        if (throwImmediately === void 0) { throwImmediately = false; }
	        if (errors && errors.length > 0) {
	            var res = new Error("Content is not valid according to schema:" + errors.map(function (x) { return x.message; }).join(", "));
	            res.errors = errors;
	            globalCache.setValue(key, res);
	            if (throwImmediately) {
	                throw res;
	            }
	            return;
	        }
	    };
	    return XMLSchemaObject;
	}());
	exports.XMLSchemaObject = XMLSchemaObject;
	function getJSONSchema(content, provider) {
	    var key = schemaKey(provider, content);
	    var rs = useLint ? globalCache.getValue(key) : false;
	    if (rs && rs.provider) {
	        return rs;
	    }
	    var res = new JSONSchemaObject(content, provider);
	    globalCache.setValue(key, res);
	    return res;
	}
	exports.getJSONSchema = getJSONSchema;
	var schemaKey = function (provider, content) {
	    var contextPath = "";
	    if (provider) {
	        contextPath = provider.contextPath();
	    }
	    var key = "__SCHEMA_" + content + contextPath;
	    return key;
	};
	function getXMLSchema(content, provider) {
	    var key = schemaKey(provider, content);
	    var rs = useLint ? globalCache.getValue(content) : false;
	    if (rs) {
	        return rs;
	    }
	    var res = new XMLSchemaObject(content);
	    if (useLint) {
	        globalCache.setValue(content, res);
	    }
	    return res;
	}
	exports.getXMLSchema = getXMLSchema;
	function createSchema(content, provider) {
	    var key = schemaKey(provider, content);
	    var rs = useLint ? globalCache.getValue(key) : false;
	    if (rs) {
	        return rs;
	    }
	    try {
	        var res = new JSONSchemaObject(content, provider);
	        if (useLint) {
	            globalCache.setValue(key, res);
	        }
	        return res;
	    }
	    catch (e) {
	        try {
	            var res = new XMLSchemaObject(content);
	            if (useLint) {
	                globalCache.setValue(key, res);
	            }
	            return res;
	        }
	        catch (e) {
	            if (useLint) {
	                globalCache.setValue(key, new Error("Can not parse schema"));
	            }
	            return null;
	        }
	    }
	}
	exports.createSchema = createSchema;
	function elementChildrenByName(parent, tagName) {
	    var elements = parent.getElementsByTagName(tagName);
	    var result = [];
	    for (var i = 0; i < elements.length; i++) {
	        var child = elements[i];
	        if (child.parentNode === parent) {
	            result.push(child);
	        }
	    }
	    return result;
	}
	//# sourceMappingURL=schemaUtil.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	var undefined = (void 0); // Paranoia

	// Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to
	// create, and consume so much memory, that the browser appears frozen.
	var MAX_ARRAY_LENGTH = 1e5;

	// Approximations of internal ECMAScript conversion functions
	var ECMAScript = (function() {
	  // Stash a copy in case other scripts modify these
	  var opts = Object.prototype.toString,
	      ophop = Object.prototype.hasOwnProperty;

	  return {
	    // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
	    Class: function(v) { return opts.call(v).replace(/^\[object *|\]$/g, ''); },
	    HasProperty: function(o, p) { return p in o; },
	    HasOwnProperty: function(o, p) { return ophop.call(o, p); },
	    IsCallable: function(o) { return typeof o === 'function'; },
	    ToInt32: function(v) { return v >> 0; },
	    ToUint32: function(v) { return v >>> 0; }
	  };
	}());

	// Snapshot intrinsics
	var LN2 = Math.LN2,
	    abs = Math.abs,
	    floor = Math.floor,
	    log = Math.log,
	    min = Math.min,
	    pow = Math.pow,
	    round = Math.round;

	// ES5: lock down object properties
	function configureProperties(obj) {
	  if (getOwnPropNames && defineProp) {
	    var props = getOwnPropNames(obj), i;
	    for (i = 0; i < props.length; i += 1) {
	      defineProp(obj, props[i], {
	        value: obj[props[i]],
	        writable: false,
	        enumerable: false,
	        configurable: false
	      });
	    }
	  }
	}

	// emulate ES5 getter/setter API using legacy APIs
	// http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx
	// (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but
	// note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)
	var defineProp
	if (Object.defineProperty && (function() {
	      try {
	        Object.defineProperty({}, 'x', {});
	        return true;
	      } catch (e) {
	        return false;
	      }
	    })()) {
	  defineProp = Object.defineProperty;
	} else {
	  defineProp = function(o, p, desc) {
	    if (!o === Object(o)) throw new TypeError("Object.defineProperty called on non-object");
	    if (ECMAScript.HasProperty(desc, 'get') && Object.prototype.__defineGetter__) { Object.prototype.__defineGetter__.call(o, p, desc.get); }
	    if (ECMAScript.HasProperty(desc, 'set') && Object.prototype.__defineSetter__) { Object.prototype.__defineSetter__.call(o, p, desc.set); }
	    if (ECMAScript.HasProperty(desc, 'value')) { o[p] = desc.value; }
	    return o;
	  };
	}

	var getOwnPropNames = Object.getOwnPropertyNames || function (o) {
	  if (o !== Object(o)) throw new TypeError("Object.getOwnPropertyNames called on non-object");
	  var props = [], p;
	  for (p in o) {
	    if (ECMAScript.HasOwnProperty(o, p)) {
	      props.push(p);
	    }
	  }
	  return props;
	};

	// ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)
	// for index in 0 ... obj.length
	function makeArrayAccessors(obj) {
	  if (!defineProp) { return; }

	  if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError("Array too large for polyfill");

	  function makeArrayAccessor(index) {
	    defineProp(obj, index, {
	      'get': function() { return obj._getter(index); },
	      'set': function(v) { obj._setter(index, v); },
	      enumerable: true,
	      configurable: false
	    });
	  }

	  var i;
	  for (i = 0; i < obj.length; i += 1) {
	    makeArrayAccessor(i);
	  }
	}

	// Internal conversion functions:
	//    pack<Type>()   - take a number (interpreted as Type), output a byte array
	//    unpack<Type>() - take a byte array, output a Type-like number

	function as_signed(value, bits) { var s = 32 - bits; return (value << s) >> s; }
	function as_unsigned(value, bits) { var s = 32 - bits; return (value << s) >>> s; }

	function packI8(n) { return [n & 0xff]; }
	function unpackI8(bytes) { return as_signed(bytes[0], 8); }

	function packU8(n) { return [n & 0xff]; }
	function unpackU8(bytes) { return as_unsigned(bytes[0], 8); }

	function packU8Clamped(n) { n = round(Number(n)); return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff]; }

	function packI16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
	function unpackI16(bytes) { return as_signed(bytes[0] << 8 | bytes[1], 16); }

	function packU16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
	function unpackU16(bytes) { return as_unsigned(bytes[0] << 8 | bytes[1], 16); }

	function packI32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
	function unpackI32(bytes) { return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }

	function packU32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
	function unpackU32(bytes) { return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }

	function packIEEE754(v, ebits, fbits) {

	  var bias = (1 << (ebits - 1)) - 1,
	      s, e, f, ln,
	      i, bits, str, bytes;

	  function roundToEven(n) {
	    var w = floor(n), f = n - w;
	    if (f < 0.5)
	      return w;
	    if (f > 0.5)
	      return w + 1;
	    return w % 2 ? w + 1 : w;
	  }

	  // Compute sign, exponent, fraction
	  if (v !== v) {
	    // NaN
	    // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping
	    e = (1 << ebits) - 1; f = pow(2, fbits - 1); s = 0;
	  } else if (v === Infinity || v === -Infinity) {
	    e = (1 << ebits) - 1; f = 0; s = (v < 0) ? 1 : 0;
	  } else if (v === 0) {
	    e = 0; f = 0; s = (1 / v === -Infinity) ? 1 : 0;
	  } else {
	    s = v < 0;
	    v = abs(v);

	    if (v >= pow(2, 1 - bias)) {
	      e = min(floor(log(v) / LN2), 1023);
	      f = roundToEven(v / pow(2, e) * pow(2, fbits));
	      if (f / pow(2, fbits) >= 2) {
	        e = e + 1;
	        f = 1;
	      }
	      if (e > bias) {
	        // Overflow
	        e = (1 << ebits) - 1;
	        f = 0;
	      } else {
	        // Normalized
	        e = e + bias;
	        f = f - pow(2, fbits);
	      }
	    } else {
	      // Denormalized
	      e = 0;
	      f = roundToEven(v / pow(2, 1 - bias - fbits));
	    }
	  }

	  // Pack sign, exponent, fraction
	  bits = [];
	  for (i = fbits; i; i -= 1) { bits.push(f % 2 ? 1 : 0); f = floor(f / 2); }
	  for (i = ebits; i; i -= 1) { bits.push(e % 2 ? 1 : 0); e = floor(e / 2); }
	  bits.push(s ? 1 : 0);
	  bits.reverse();
	  str = bits.join('');

	  // Bits to bytes
	  bytes = [];
	  while (str.length) {
	    bytes.push(parseInt(str.substring(0, 8), 2));
	    str = str.substring(8);
	  }
	  return bytes;
	}

	function unpackIEEE754(bytes, ebits, fbits) {

	  // Bytes to bits
	  var bits = [], i, j, b, str,
	      bias, s, e, f;

	  for (i = bytes.length; i; i -= 1) {
	    b = bytes[i - 1];
	    for (j = 8; j; j -= 1) {
	      bits.push(b % 2 ? 1 : 0); b = b >> 1;
	    }
	  }
	  bits.reverse();
	  str = bits.join('');

	  // Unpack sign, exponent, fraction
	  bias = (1 << (ebits - 1)) - 1;
	  s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
	  e = parseInt(str.substring(1, 1 + ebits), 2);
	  f = parseInt(str.substring(1 + ebits), 2);

	  // Produce number
	  if (e === (1 << ebits) - 1) {
	    return f !== 0 ? NaN : s * Infinity;
	  } else if (e > 0) {
	    // Normalized
	    return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
	  } else if (f !== 0) {
	    // Denormalized
	    return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
	  } else {
	    return s < 0 ? -0 : 0;
	  }
	}

	function unpackF64(b) { return unpackIEEE754(b, 11, 52); }
	function packF64(v) { return packIEEE754(v, 11, 52); }
	function unpackF32(b) { return unpackIEEE754(b, 8, 23); }
	function packF32(v) { return packIEEE754(v, 8, 23); }


	//
	// 3 The ArrayBuffer Type
	//

	(function() {

	  /** @constructor */
	  var ArrayBuffer = function ArrayBuffer(length) {
	    length = ECMAScript.ToInt32(length);
	    if (length < 0) throw new RangeError('ArrayBuffer size is not a small enough positive integer');

	    this.byteLength = length;
	    this._bytes = [];
	    this._bytes.length = length;

	    var i;
	    for (i = 0; i < this.byteLength; i += 1) {
	      this._bytes[i] = 0;
	    }

	    configureProperties(this);
	  };

	  exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;

	  //
	  // 4 The ArrayBufferView Type
	  //

	  // NOTE: this constructor is not exported
	  /** @constructor */
	  var ArrayBufferView = function ArrayBufferView() {
	    //this.buffer = null;
	    //this.byteOffset = 0;
	    //this.byteLength = 0;
	  };

	  //
	  // 5 The Typed Array View Types
	  //

	  function makeConstructor(bytesPerElement, pack, unpack) {
	    // Each TypedArray type requires a distinct constructor instance with
	    // identical logic, which this produces.

	    var ctor;
	    ctor = function(buffer, byteOffset, length) {
	      var array, sequence, i, s;

	      if (!arguments.length || typeof arguments[0] === 'number') {
	        // Constructor(unsigned long length)
	        this.length = ECMAScript.ToInt32(arguments[0]);
	        if (length < 0) throw new RangeError('ArrayBufferView size is not a small enough positive integer');

	        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
	        this.buffer = new ArrayBuffer(this.byteLength);
	        this.byteOffset = 0;
	      } else if (typeof arguments[0] === 'object' && arguments[0].constructor === ctor) {
	        // Constructor(TypedArray array)
	        array = arguments[0];

	        this.length = array.length;
	        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
	        this.buffer = new ArrayBuffer(this.byteLength);
	        this.byteOffset = 0;

	        for (i = 0; i < this.length; i += 1) {
	          this._setter(i, array._getter(i));
	        }
	      } else if (typeof arguments[0] === 'object' &&
	                 !(arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
	        // Constructor(sequence<type> array)
	        sequence = arguments[0];

	        this.length = ECMAScript.ToUint32(sequence.length);
	        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
	        this.buffer = new ArrayBuffer(this.byteLength);
	        this.byteOffset = 0;

	        for (i = 0; i < this.length; i += 1) {
	          s = sequence[i];
	          this._setter(i, Number(s));
	        }
	      } else if (typeof arguments[0] === 'object' &&
	                 (arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
	        // Constructor(ArrayBuffer buffer,
	        //             optional unsigned long byteOffset, optional unsigned long length)
	        this.buffer = buffer;

	        this.byteOffset = ECMAScript.ToUint32(byteOffset);
	        if (this.byteOffset > this.buffer.byteLength) {
	          throw new RangeError("byteOffset out of range");
	        }

	        if (this.byteOffset % this.BYTES_PER_ELEMENT) {
	          // The given byteOffset must be a multiple of the element
	          // size of the specific type, otherwise an exception is raised.
	          throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
	        }

	        if (arguments.length < 3) {
	          this.byteLength = this.buffer.byteLength - this.byteOffset;

	          if (this.byteLength % this.BYTES_PER_ELEMENT) {
	            throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
	          }
	          this.length = this.byteLength / this.BYTES_PER_ELEMENT;
	        } else {
	          this.length = ECMAScript.ToUint32(length);
	          this.byteLength = this.length * this.BYTES_PER_ELEMENT;
	        }

	        if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
	          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
	        }
	      } else {
	        throw new TypeError("Unexpected argument type(s)");
	      }

	      this.constructor = ctor;

	      configureProperties(this);
	      makeArrayAccessors(this);
	    };

	    ctor.prototype = new ArrayBufferView();
	    ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
	    ctor.prototype._pack = pack;
	    ctor.prototype._unpack = unpack;
	    ctor.BYTES_PER_ELEMENT = bytesPerElement;

	    // getter type (unsigned long index);
	    ctor.prototype._getter = function(index) {
	      if (arguments.length < 1) throw new SyntaxError("Not enough arguments");

	      index = ECMAScript.ToUint32(index);
	      if (index >= this.length) {
	        return undefined;
	      }

	      var bytes = [], i, o;
	      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
	           i < this.BYTES_PER_ELEMENT;
	           i += 1, o += 1) {
	        bytes.push(this.buffer._bytes[o]);
	      }
	      return this._unpack(bytes);
	    };

	    // NONSTANDARD: convenience alias for getter: type get(unsigned long index);
	    ctor.prototype.get = ctor.prototype._getter;

	    // setter void (unsigned long index, type value);
	    ctor.prototype._setter = function(index, value) {
	      if (arguments.length < 2) throw new SyntaxError("Not enough arguments");

	      index = ECMAScript.ToUint32(index);
	      if (index >= this.length) {
	        return undefined;
	      }

	      var bytes = this._pack(value), i, o;
	      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
	           i < this.BYTES_PER_ELEMENT;
	           i += 1, o += 1) {
	        this.buffer._bytes[o] = bytes[i];
	      }
	    };

	    // void set(TypedArray array, optional unsigned long offset);
	    // void set(sequence<type> array, optional unsigned long offset);
	    ctor.prototype.set = function(index, value) {
	      if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
	      var array, sequence, offset, len,
	          i, s, d,
	          byteOffset, byteLength, tmp;

	      if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {
	        // void set(TypedArray array, optional unsigned long offset);
	        array = arguments[0];
	        offset = ECMAScript.ToUint32(arguments[1]);

	        if (offset + array.length > this.length) {
	          throw new RangeError("Offset plus length of array is out of range");
	        }

	        byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
	        byteLength = array.length * this.BYTES_PER_ELEMENT;

	        if (array.buffer === this.buffer) {
	          tmp = [];
	          for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
	            tmp[i] = array.buffer._bytes[s];
	          }
	          for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
	            this.buffer._bytes[d] = tmp[i];
	          }
	        } else {
	          for (i = 0, s = array.byteOffset, d = byteOffset;
	               i < byteLength; i += 1, s += 1, d += 1) {
	            this.buffer._bytes[d] = array.buffer._bytes[s];
	          }
	        }
	      } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {
	        // void set(sequence<type> array, optional unsigned long offset);
	        sequence = arguments[0];
	        len = ECMAScript.ToUint32(sequence.length);
	        offset = ECMAScript.ToUint32(arguments[1]);

	        if (offset + len > this.length) {
	          throw new RangeError("Offset plus length of array is out of range");
	        }

	        for (i = 0; i < len; i += 1) {
	          s = sequence[i];
	          this._setter(offset + i, Number(s));
	        }
	      } else {
	        throw new TypeError("Unexpected argument type(s)");
	      }
	    };

	    // TypedArray subarray(long begin, optional long end);
	    ctor.prototype.subarray = function(start, end) {
	      function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }

	      start = ECMAScript.ToInt32(start);
	      end = ECMAScript.ToInt32(end);

	      if (arguments.length < 1) { start = 0; }
	      if (arguments.length < 2) { end = this.length; }

	      if (start < 0) { start = this.length + start; }
	      if (end < 0) { end = this.length + end; }

	      start = clamp(start, 0, this.length);
	      end = clamp(end, 0, this.length);

	      var len = end - start;
	      if (len < 0) {
	        len = 0;
	      }

	      return new this.constructor(
	        this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);
	    };

	    return ctor;
	  }

	  var Int8Array = makeConstructor(1, packI8, unpackI8);
	  var Uint8Array = makeConstructor(1, packU8, unpackU8);
	  var Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8);
	  var Int16Array = makeConstructor(2, packI16, unpackI16);
	  var Uint16Array = makeConstructor(2, packU16, unpackU16);
	  var Int32Array = makeConstructor(4, packI32, unpackI32);
	  var Uint32Array = makeConstructor(4, packU32, unpackU32);
	  var Float32Array = makeConstructor(4, packF32, unpackF32);
	  var Float64Array = makeConstructor(8, packF64, unpackF64);

	  exports.Int8Array = exports.Int8Array || Int8Array;
	  exports.Uint8Array = exports.Uint8Array || Uint8Array;
	  exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray;
	  exports.Int16Array = exports.Int16Array || Int16Array;
	  exports.Uint16Array = exports.Uint16Array || Uint16Array;
	  exports.Int32Array = exports.Int32Array || Int32Array;
	  exports.Uint32Array = exports.Uint32Array || Uint32Array;
	  exports.Float32Array = exports.Float32Array || Float32Array;
	  exports.Float64Array = exports.Float64Array || Float64Array;
	}());

	//
	// 6 The DataView View Type
	//

	(function() {
	  function r(array, index) {
	    return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
	  }

	  var IS_BIG_ENDIAN = (function() {
	    var u16array = new(exports.Uint16Array)([0x1234]),
	        u8array = new(exports.Uint8Array)(u16array.buffer);
	    return r(u8array, 0) === 0x12;
	  }());

	  // Constructor(ArrayBuffer buffer,
	  //             optional unsigned long byteOffset,
	  //             optional unsigned long byteLength)
	  /** @constructor */
	  var DataView = function DataView(buffer, byteOffset, byteLength) {
	    if (arguments.length === 0) {
	      buffer = new exports.ArrayBuffer(0);
	    } else if (!(buffer instanceof exports.ArrayBuffer || ECMAScript.Class(buffer) === 'ArrayBuffer')) {
	      throw new TypeError("TypeError");
	    }

	    this.buffer = buffer || new exports.ArrayBuffer(0);

	    this.byteOffset = ECMAScript.ToUint32(byteOffset);
	    if (this.byteOffset > this.buffer.byteLength) {
	      throw new RangeError("byteOffset out of range");
	    }

	    if (arguments.length < 3) {
	      this.byteLength = this.buffer.byteLength - this.byteOffset;
	    } else {
	      this.byteLength = ECMAScript.ToUint32(byteLength);
	    }

	    if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
	      throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
	    }

	    configureProperties(this);
	  };

	  function makeGetter(arrayType) {
	    return function(byteOffset, littleEndian) {

	      byteOffset = ECMAScript.ToUint32(byteOffset);

	      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
	        throw new RangeError("Array index out of range");
	      }
	      byteOffset += this.byteOffset;

	      var uint8Array = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),
	          bytes = [], i;
	      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
	        bytes.push(r(uint8Array, i));
	      }

	      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
	        bytes.reverse();
	      }

	      return r(new arrayType(new exports.Uint8Array(bytes).buffer), 0);
	    };
	  }

	  DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);
	  DataView.prototype.getInt8 = makeGetter(exports.Int8Array);
	  DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);
	  DataView.prototype.getInt16 = makeGetter(exports.Int16Array);
	  DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);
	  DataView.prototype.getInt32 = makeGetter(exports.Int32Array);
	  DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);
	  DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);

	  function makeSetter(arrayType) {
	    return function(byteOffset, value, littleEndian) {

	      byteOffset = ECMAScript.ToUint32(byteOffset);
	      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
	        throw new RangeError("Array index out of range");
	      }

	      // Get bytes
	      var typeArray = new arrayType([value]),
	          byteArray = new exports.Uint8Array(typeArray.buffer),
	          bytes = [], i, byteView;

	      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
	        bytes.push(r(byteArray, i));
	      }

	      // Flip if necessary
	      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
	        bytes.reverse();
	      }

	      // Write them
	      byteView = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
	      byteView.set(bytes);
	    };
	  }

	  DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);
	  DataView.prototype.setInt8 = makeSetter(exports.Int8Array);
	  DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);
	  DataView.prototype.setInt16 = makeSetter(exports.Int16Array);
	  DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);
	  DataView.prototype.setInt32 = makeSetter(exports.Int32Array);
	  DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);
	  DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);

	  exports.DataView = exports.DataView || DataView;

	}());


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var indexOf = __webpack_require__(176);

	var Object_keys = function (obj) {
	    if (Object.keys) return Object.keys(obj)
	    else {
	        var res = [];
	        for (var key in obj) res.push(key)
	        return res;
	    }
	};

	var forEach = function (xs, fn) {
	    if (xs.forEach) return xs.forEach(fn)
	    else for (var i = 0; i < xs.length; i++) {
	        fn(xs[i], i, xs);
	    }
	};

	var defineProp = (function() {
	    try {
	        Object.defineProperty({}, '_', {});
	        return function(obj, name, value) {
	            Object.defineProperty(obj, name, {
	                writable: true,
	                enumerable: false,
	                configurable: true,
	                value: value
	            })
	        };
	    } catch(e) {
	        return function(obj, name, value) {
	            obj[name] = value;
	        };
	    }
	}());

	var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
	'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
	'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
	'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
	'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

	function Context() {}
	Context.prototype = {};

	var Script = exports.Script = function NodeScript (code) {
	    if (!(this instanceof Script)) return new Script(code);
	    this.code = code;
	};

	Script.prototype.runInContext = function (context) {
	    if (!(context instanceof Context)) {
	        throw new TypeError("needs a 'context' argument.");
	    }
	    
	    var iframe = document.createElement('iframe');
	    if (!iframe.style) iframe.style = {};
	    iframe.style.display = 'none';
	    
	    document.body.appendChild(iframe);
	    
	    var win = iframe.contentWindow;
	    var wEval = win.eval, wExecScript = win.execScript;

	    if (!wEval && wExecScript) {
	        // win.eval() magically appears when this is called in IE:
	        wExecScript.call(win, 'null');
	        wEval = win.eval;
	    }
	    
	    forEach(Object_keys(context), function (key) {
	        win[key] = context[key];
	    });
	    forEach(globals, function (key) {
	        if (context[key]) {
	            win[key] = context[key];
	        }
	    });
	    
	    var winKeys = Object_keys(win);

	    var res = wEval.call(win, this.code);
	    
	    forEach(Object_keys(win), function (key) {
	        // Avoid copying circular objects like `top` and `window` by only
	        // updating existing context properties or new properties in the `win`
	        // that was only introduced after the eval.
	        if (key in context || indexOf(winKeys, key) === -1) {
	            context[key] = win[key];
	        }
	    });

	    forEach(globals, function (key) {
	        if (!(key in context)) {
	            defineProp(context, key, win[key]);
	        }
	    });
	    
	    document.body.removeChild(iframe);
	    
	    return res;
	};

	Script.prototype.runInThisContext = function () {
	    return eval(this.code); // maybe...
	};

	Script.prototype.runInNewContext = function (context) {
	    var ctx = Script.createContext(context);
	    var res = this.runInContext(ctx);

	    forEach(Object_keys(ctx), function (key) {
	        context[key] = ctx[key];
	    });

	    return res;
	};

	forEach(Object_keys(Script.prototype), function (name) {
	    exports[name] = Script[name] = function (code) {
	        var s = Script(code);
	        return s[name].apply(s, [].slice.call(arguments, 1));
	    };
	});

	exports.createScript = function (code) {
	    return exports.Script(code);
	};

	exports.createContext = Script.createContext = function (context) {
	    var copy = new Context();
	    if(typeof context === 'object') {
	        forEach(Object_keys(context), function (key) {
	            copy[key] = context[key];
	        });
	    }
	    return copy;
	};


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = (function (){
	  try {
	    return __webpack_require__(174); // hack to fix a circular dependency issue when used with browserify
	  } catch(_){}
	}());
	exports = module.exports = __webpack_require__(147);
	exports.Stream = Stream || exports;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(148);
	exports.Duplex = __webpack_require__(149);
	exports.Transform = __webpack_require__(150);
	exports.PassThrough = __webpack_require__(151);


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function isNothing(subject) {
	    return (typeof subject === 'undefined') || (null === subject);
	}
	exports.isNothing = isNothing;
	function isObject(subject) {
	    return (typeof subject === 'object') && (null !== subject);
	}
	exports.isObject = isObject;
	function toArray(sequence) {
	    if (Array.isArray(sequence)) {
	        return sequence;
	    }
	    else if (isNothing(sequence)) {
	        return [];
	    }
	    return [sequence];
	}
	exports.toArray = toArray;
	function extend(target, source) {
	    var index, length, key, sourceKeys;
	    if (source) {
	        sourceKeys = Object.keys(source);
	        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
	            key = sourceKeys[index];
	            target[key] = source[key];
	        }
	    }
	    return target;
	}
	exports.extend = extend;
	function repeat(string, count) {
	    var result = '', cycle;
	    for (cycle = 0; cycle < count; cycle += 1) {
	        result += string;
	    }
	    return result;
	}
	exports.repeat = repeat;
	function isNegativeZero(number) {
	    return (0 === number) && (Number.NEGATIVE_INFINITY === 1 / number);
	}
	exports.isNegativeZero = isNegativeZero;
	//# sourceMappingURL=common.js.map

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';
	var YAMLException = (function () {
	    function YAMLException(reason, mark) {
	        if (mark === void 0) { mark = null; }
	        this.name = 'YAMLException';
	        this.reason = reason;
	        this.mark = mark;
	        this.message = this.toString(false);
	    }
	    YAMLException.prototype.toString = function (compact) {
	        if (compact === void 0) { compact = false; }
	        var result;
	        result = 'JS-YAML: ' + (this.reason || '(unknown reason)');
	        if (!compact && this.mark) {
	            result += ' ' + this.mark.toString();
	        }
	        return result;
	    };
	    return YAMLException;
	}());
	module.exports = YAMLException;
	//# sourceMappingURL=exception.js.map

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	(function (Kind) {
	    Kind[Kind["SCALAR"] = 0] = "SCALAR";
	    Kind[Kind["MAPPING"] = 1] = "MAPPING";
	    Kind[Kind["MAP"] = 2] = "MAP";
	    Kind[Kind["SEQ"] = 3] = "SEQ";
	    Kind[Kind["ANCHOR_REF"] = 4] = "ANCHOR_REF";
	    Kind[Kind["INCLUDE_REF"] = 5] = "INCLUDE_REF";
	})(exports.Kind || (exports.Kind = {}));
	var Kind = exports.Kind;
	function newMapping(key, value) {
	    var end = (value ? value.endPosition : key.endPosition + 1);
	    var node = {
	        key: key,
	        value: value,
	        startPosition: key.startPosition,
	        endPosition: end,
	        kind: Kind.MAPPING,
	        parent: null,
	        errors: []
	    };
	    return node;
	}
	exports.newMapping = newMapping;
	function newAnchorRef(key, start, end, value) {
	    return {
	        errors: [],
	        referencesAnchor: key,
	        value: value,
	        startPosition: start,
	        endPosition: end,
	        kind: Kind.ANCHOR_REF,
	        parent: null
	    };
	}
	exports.newAnchorRef = newAnchorRef;
	function newScalar(v) {
	    if (v === void 0) { v = ""; }
	    return {
	        errors: [],
	        startPosition: -1,
	        endPosition: -1,
	        value: v,
	        kind: Kind.SCALAR,
	        parent: null,
	        doubleQuoted: false
	    };
	}
	exports.newScalar = newScalar;
	function newItems() {
	    return {
	        errors: [],
	        startPosition: -1,
	        endPosition: -1,
	        items: [],
	        kind: Kind.SEQ,
	        parent: null
	    };
	}
	exports.newItems = newItems;
	function newSeq() {
	    return newItems();
	}
	exports.newSeq = newSeq;
	function newMap(mappings) {
	    return {
	        errors: [],
	        startPosition: -1,
	        endPosition: -1,
	        mappings: mappings ? mappings : [],
	        kind: Kind.MAP,
	        parent: null
	    };
	}
	exports.newMap = newMap;
	//# sourceMappingURL=yamlAST.js.map

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var common = __webpack_require__(110);
	var Mark = (function () {
	    function Mark(name, buffer, position, line, column) {
	        this.name = name;
	        this.buffer = buffer;
	        this.position = position;
	        this.line = line;
	        this.column = column;
	    }
	    Mark.prototype.getSnippet = function (indent, maxLength) {
	        if (indent === void 0) { indent = 0; }
	        if (maxLength === void 0) { maxLength = 75; }
	        var head, start, tail, end, snippet;
	        if (!this.buffer) {
	            return null;
	        }
	        indent = indent || 4;
	        maxLength = maxLength || 75;
	        head = '';
	        start = this.position;
	        while (start > 0 && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1))) {
	            start -= 1;
	            if (this.position - start > (maxLength / 2 - 1)) {
	                head = ' ... ';
	                start += 5;
	                break;
	            }
	        }
	        tail = '';
	        end = this.position;
	        while (end < this.buffer.length && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end))) {
	            end += 1;
	            if (end - this.position > (maxLength / 2 - 1)) {
	                tail = ' ... ';
	                end -= 5;
	                break;
	            }
	        }
	        snippet = this.buffer.slice(start, end);
	        return common.repeat(' ', indent) + head + snippet + tail + '\n' +
	            common.repeat(' ', indent + this.position - start + head.length) + '^';
	    };
	    Mark.prototype.toString = function (compact) {
	        if (compact === void 0) { compact = true; }
	        var snippet, where = '';
	        if (this.name) {
	            where += 'in "' + this.name + '" ';
	        }
	        where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);
	        if (!compact) {
	            snippet = this.getSnippet();
	            if (snippet) {
	                where += ':\n' + snippet;
	            }
	        }
	        return where;
	    };
	    return Mark;
	}());
	module.exports = Mark;
	//# sourceMappingURL=mark.js.map

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(154)


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var upperCase = __webpack_require__(121)
	var lowerCase = __webpack_require__(118)

	/**
	 * Swap the case of a string. Manually iterate over every character and check
	 * instead of replacing certain characters for better unicode support.
	 *
	 * @param  {String} str
	 * @param  {String} [locale]
	 * @return {String}
	 */
	module.exports = function (str, locale) {
	  if (str == null) {
	    return ''
	  }

	  var result = ''

	  for (var i = 0; i < str.length; i++) {
	    var c = str[i]
	    var u = upperCase(c, locale)

	    result += u === c ? lowerCase(c, locale) : u
	  }

	  return result
	}


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	var sentenceCase = __webpack_require__(129)

	/**
	 * Dot case a string.
	 *
	 * @param  {String} string
	 * @param  {String} [locale]
	 * @return {String}
	 */
	module.exports = function (string, locale) {
	  return sentenceCase(string, locale, '.')
	}


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Special language-specific overrides.
	 *
	 * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
	 *
	 * @type {Object}
	 */
	var LANGUAGES = {
	  tr: {
	    regexp: /\u0130|\u0049|\u0049\u0307/g,
	    map: {
	      '\u0130': '\u0069',
	      '\u0049': '\u0131',
	      '\u0049\u0307': '\u0069'
	    }
	  },
	  az: {
	    regexp: /[\u0130]/g,
	    map: {
	      '\u0130': '\u0069',
	      '\u0049': '\u0131',
	      '\u0049\u0307': '\u0069'
	    }
	  },
	  lt: {
	    regexp: /[\u0049\u004A\u012E\u00CC\u00CD\u0128]/g,
	    map: {
	      '\u0049': '\u0069\u0307',
	      '\u004A': '\u006A\u0307',
	      '\u012E': '\u012F\u0307',
	      '\u00CC': '\u0069\u0307\u0300',
	      '\u00CD': '\u0069\u0307\u0301',
	      '\u0128': '\u0069\u0307\u0303'
	    }
	  }
	}

	/**
	 * Lowercase a string.
	 *
	 * @param  {String} str
	 * @return {String}
	 */
	module.exports = function (str, locale) {
	  var lang = LANGUAGES[locale]

	  str = str == null ? '' : String(str)

	  if (lang) {
	    str = str.replace(lang.regexp, function (m) { return lang.map[m] })
	  }

	  return str.toLowerCase()
	}


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	var sentenceCase = __webpack_require__(129)

	/**
	 * Path case a string.
	 *
	 * @param  {String} string
	 * @param  {String} [locale]
	 * @return {String}
	 */
	module.exports = function (string, locale) {
	  return sentenceCase(string, locale, '/')
	}


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	var upperCase = __webpack_require__(121)
	var sentenceCase = __webpack_require__(129)

	/**
	 * Camel case a string.
	 *
	 * @param  {String} string
	 * @param  {String} [locale]
	 * @return {String}
	 */
	module.exports = function (string, locale, mergeNumbers) {
	  var result = sentenceCase(string, locale)

	  // Replace periods between numeric entities with an underscore.
	  if (!mergeNumbers) {
	    result = result.replace(/(\d) (?=\d)/g, '$1_')
	  }

	  // Replace spaces between words with an upper cased character.
	  return result.replace(/ (.)/g, function (m, $1) {
	    return upperCase($1, locale)
	  })
	}


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Special language-specific overrides.
	 *
	 * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
	 *
	 * @type {Object}
	 */
	var LANGUAGES = {
	  tr: {
	    regexp: /[\u0069]/g,
	    map: {
	      '\u0069': '\u0130'
	    }
	  },
	  az: {
	    regexp: /[\u0069]/g,
	    map: {
	      '\u0069': '\u0130'
	    }
	  },
	  lt: {
	    regexp: /[\u0069\u006A\u012F]\u0307|\u0069\u0307[\u0300\u0301\u0303]/g,
	    map: {
	      '\u0069\u0307': '\u0049',
	      '\u006A\u0307': '\u004A',
	      '\u012F\u0307': '\u012E',
	      '\u0069\u0307\u0300': '\u00CC',
	      '\u0069\u0307\u0301': '\u00CD',
	      '\u0069\u0307\u0303': '\u0128'
	    }
	  }
	}

	/**
	 * Upper case a string.
	 *
	 * @param  {String} str
	 * @return {String}
	 */
	module.exports = function (str, locale) {
	  var lang = LANGUAGES[locale]

	  str = str == null ? '' : String(str)

	  if (lang) {
	    str = str.replace(lang.regexp, function (m) { return lang.map[m] })
	  }

	  return str.toUpperCase()
	}


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var sentenceCase = __webpack_require__(129)

	/**
	 * Param case a string.
	 *
	 * @param  {String} string
	 * @param  {String} [locale]
	 * @return {String}
	 */
	module.exports = function (string, locale) {
	  return sentenceCase(string, locale, '-')
	}


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var upperCase = __webpack_require__(121)
	var sentenceCase = __webpack_require__(129)

	/**
	 * Title case a string.
	 *
	 * @param  {String} string
	 * @param  {String} [locale]
	 * @return {String}
	 */
	module.exports = function (str, locale) {
	  return sentenceCase(str, locale).replace(/^.| ./g, function (m) {
	    return upperCase(m, locale)
	  })
	}


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	var sentenceCase = __webpack_require__(129)

	/**
	 * Snake case a string.
	 *
	 * @param  {String} str
	 * @param  {String} [locale]
	 * @return {String}
	 */
	module.exports = function (str, locale) {
	  return sentenceCase(str, locale, '_')
	}


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var camelCase = __webpack_require__(120)
	var upperCaseFirst = __webpack_require__(131)

	/**
	 * Pascal case a string.
	 *
	 * @param  {String} string
	 * @param  {String} [locale]
	 * @return {String}
	 */
	module.exports = function (string, locale) {
	  return upperCaseFirst(camelCase(string, locale), locale)
	}


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var upperCase = __webpack_require__(121)
	var snakeCase = __webpack_require__(124)

	/**
	 * Constant case a string.
	 *
	 * @param  {String} string
	 * @param  {String} [locale]
	 * @return {String}
	 */
	module.exports = function (string, locale) {
	  return upperCase(snakeCase(string, locale), locale)
	}


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var upperCase = __webpack_require__(121)

	/**
	 * Check if a string is upper case.
	 *
	 * @param  {String}  string
	 * @param  {String}  [locale]
	 * @return {Boolean}
	 */
	module.exports = function (string, locale) {
	  return upperCase(string, locale) === string
	}


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var lowerCase = __webpack_require__(118)

	/**
	 * Check if a string is lower case.
	 *
	 * @param  {String}  string
	 * @param  {String}  [locale]
	 * @return {Boolean}
	 */
	module.exports = function (string, locale) {
	  return lowerCase(string, locale) === string
	}


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var lowerCase = __webpack_require__(118)

	var NON_WORD_REGEXP = __webpack_require__(155)
	var CAMEL_CASE_REGEXP = __webpack_require__(156)
	var TRAILING_DIGIT_REGEXP = __webpack_require__(157)

	/**
	 * Sentence case a string.
	 *
	 * @param  {String} str
	 * @param  {String} locale
	 * @param  {String} replacement
	 * @return {String}
	 */
	module.exports = function (str, locale, replacement) {
	  if (str == null) {
	    return ''
	  }

	  replacement = replacement || ' '

	  function replace (match, index, string) {
	    if (index === 0 || index === (string.length - match.length)) {
	      return ''
	    }

	    return replacement
	  }

	  str = String(str)
	    // Support camel case ("camelCase" -> "camel Case").
	    .replace(CAMEL_CASE_REGEXP, '$1 $2')
	    // Support digit groups ("test2012" -> "test 2012").
	    .replace(TRAILING_DIGIT_REGEXP, '$1 $2')
	    // Remove all non-word characters and replace with a single space.
	    .replace(NON_WORD_REGEXP, replace)

	  // Lower case the entire string.
	  return lowerCase(str, locale)
	}


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	var lowerCase = __webpack_require__(118)

	/**
	 * Lower case the first character of a string.
	 *
	 * @param  {String} str
	 * @return {String}
	 */
	module.exports = function (str, locale) {
	  if (str == null) {
	    return ''
	  }

	  str = String(str)

	  return lowerCase(str.charAt(0), locale) + str.substr(1)
	}


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	var upperCase = __webpack_require__(121)

	/**
	 * Upper case the first character of a string.
	 *
	 * @param  {String} str
	 * @return {String}
	 */
	module.exports = function (str, locale) {
	  if (str == null) {
	    return ''
	  }

	  str = String(str)

	  return upperCase(str.charAt(0), locale) + str.substr(1)
	}


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var Schema = __webpack_require__(152);
	var schema = new Schema({
	    include: [
	        __webpack_require__(133)
	    ],
	    explicit: [
	        __webpack_require__(167),
	        __webpack_require__(168)
	    ]
	});
	Schema.DEFAULT = schema;
	module.exports = schema;
	//# sourceMappingURL=default_full.js.map

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var Schema = __webpack_require__(152);
	var schema = new Schema({
	    include: [
	        __webpack_require__(153)
	    ],
	    implicit: [
	        __webpack_require__(161),
	        __webpack_require__(162)
	    ],
	    explicit: [
	        __webpack_require__(163),
	        __webpack_require__(164),
	        __webpack_require__(165),
	        __webpack_require__(166)
	    ]
	});
	module.exports = schema;
	//# sourceMappingURL=default_safe.js.map

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var index = __webpack_require__(91);
	var helperMethodExtractor = __webpack_require__(158);
	var ns = { 'RamlWrapper': true };
	var HelperMethod = (function () {
	    function HelperMethod(originalName, wrapperMethodName, returnType, args, meta) {
	        this.originalName = originalName;
	        this.wrapperMethodName = wrapperMethodName;
	        this.returnType = returnType;
	        this.args = args;
	        this.meta = meta;
	    }
	    HelperMethod.prototype.targetWrappers = function () {
	        var isValid = true;
	        var result = [];
	        this.args.forEach(function (x) {
	            var arr = flatten(x.type, ns);
	            if (arr.length == 0) {
	                return;
	            }
	            if (!isValid || result.length != 0) {
	                result = [];
	                isValid = false;
	                return;
	            }
	            result = result.concat(arr);
	        });
	        return result;
	    };
	    HelperMethod.prototype.callArgs = function () {
	        return this.args.map(function (x) {
	            if (flatten(x.type, ns).length == 0) {
	                return x;
	            }
	            return {
	                name: "this",
	                type: null,
	                optional: false,
	                defaultValue: undefined
	            };
	        });
	    };
	    return HelperMethod;
	}());
	exports.HelperMethod = HelperMethod;
	function flatten(t, namespaces) {
	    if (t.typeKind == index.TypeKind.ARRAY) {
	        if (namespaces) {
	            return [];
	        }
	        else {
	            return [flatten(t.base)[0] + '[]'];
	        }
	    }
	    else if (t.typeKind == index.TypeKind.BASIC) {
	        var bt = t;
	        var str = bt.basicName;
	        var nameSpace = bt.nameSpace && bt.nameSpace.trim();
	        if (nameSpace != null && nameSpace.length > 0 && nameSpace != "RamlWrapper") {
	            str = nameSpace + "." + str;
	        }
	        if (bt.typeArguments && bt.typeArguments.length != 0) {
	            str += "<" + bt.typeArguments.map(function (x) { return flatten(x); }).join(', ') + ">";
	        }
	        if (namespaces) {
	            if (bt.nameSpace) {
	                return namespaces[bt.nameSpace] ? [str] : [];
	            }
	            else {
	                return [];
	            }
	        }
	        return [str];
	    }
	    else if (t.typeKind == index.TypeKind.UNION) {
	        var ut = t;
	        var result = [];
	        ut.options.forEach(function (x) { return result = result.concat(flatten(x, namespaces)); });
	        return result;
	    }
	    return [];
	}
	exports.flatten = flatten;
	function getHelperMethods(srcPath) {
	    return helperMethodExtractor.getHelperMethods(srcPath);
	}
	exports.getHelperMethods = getHelperMethods;
	//# sourceMappingURL=helpers.js.map

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by kor on 08/05/15.
	 */
	"use strict";
	var ts = __webpack_require__(146);
	exports.tsm = __webpack_require__(159);
	exports.helperMethodExtractor = __webpack_require__(158);
	var fsUtil = __webpack_require__(160);
	var index_1 = __webpack_require__(91);
	var index_2 = __webpack_require__(91);
	function parse(content) {
	    return ts.createSourceFile("sample.ts", content, ts.ScriptTarget.ES3, true);
	}
	var fld = exports.tsm.Matching.field();
	function parseStruct(content, modules, mpth) {
	    var mod = parse(content);
	    var module = { classes: [], aliases: [], enumDeclarations: [], imports: {}, name: mpth };
	    modules[mpth] = module;
	    var currentModule = null;
	    exports.tsm.Matching.visit(mod, function (x) {
	        if (x.kind == ts.SyntaxKind.ModuleDeclaration) {
	            var cmod = x;
	            currentModule = cmod.name.text;
	        }
	        if (x.kind == ts.SyntaxKind.ImportEqualsDeclaration) {
	            var imp = x;
	            var namespace = imp.name.text;
	            if (namespace == "RamlWrapper") {
	                return;
	            }
	            var path = imp.moduleReference;
	            var literal = path.expression;
	            var importPath = literal.text;
	            var absPath = fsUtil.resolve(fsUtil.dirname(mpth) + "/", importPath) + ".ts";
	            if (!fsUtil.existsSync(absPath)) {
	                throw new Error("Path " + importPath + " resolve to " + absPath + "do not exists");
	            }
	            if (!modules[absPath]) {
	                var cnt = fsUtil.readFileSync(absPath);
	                var mod = parseStruct(cnt, modules, absPath);
	            }
	            module.imports[namespace] = modules[absPath];
	        }
	        if (x.kind == ts.SyntaxKind.TypeAliasDeclaration) {
	            var u = x;
	            if (u.name) {
	                var aliasName = u.name.text;
	                var type = buildType(u.type, mpth);
	                module.aliases.push({ name: aliasName, type: type });
	            }
	        }
	        if (x.kind == ts.SyntaxKind.EnumDeclaration) {
	            var e = x;
	            var members = [];
	            if (e.members) {
	                e.members.forEach(function (y) {
	                    members.push(y['name']['text']);
	                });
	            }
	            if (e.name) {
	                module.enumDeclarations.push({ name: e.name.text, members: members });
	            }
	        }
	        var isInterface = x.kind == ts.SyntaxKind.InterfaceDeclaration;
	        var isClass = x.kind == ts.SyntaxKind.ClassDeclaration;
	        if (!isInterface && !isClass) {
	            return;
	        }
	        var c = x;
	        if (c) {
	            var fields = {};
	            var clazz = index_2.classDecl(c.name.text, isInterface);
	            clazz.moduleName = currentModule;
	            module.classes.push(clazz);
	            c.members.forEach(function (x) {
	                if (x.kind == ts.SyntaxKind.MethodDeclaration) {
	                    var md = x;
	                    var method = buildMethod(md, content, mpth);
	                    clazz.methods.push(method);
	                }
	                var field = fld.doMatch(x);
	                if (field) {
	                    var f = buildField(field, mpth);
	                    if (f.name == '$') {
	                        clazz.annotations = f.annotations;
	                    }
	                    else if (f.name.charAt(0) != '$' || f.name == '$ref') {
	                        fields[f.name] = f;
	                        clazz.fields.push(f);
	                    }
	                    else {
	                        var targetField = f.name.substr(1);
	                        var of = fields[targetField];
	                        if (!of) {
	                            if (f.name != '$$') {
	                                //console.log('Overriding annotations for field:'+targetField);
	                                var overridings = clazz.annotationOverridings[targetField];
	                                if (!overridings) {
	                                    overridings = [];
	                                }
	                                clazz.annotationOverridings[targetField] = overridings.concat(f.annotations);
	                            }
	                        }
	                        else {
	                            of.annotations = f.annotations;
	                        }
	                    }
	                }
	            });
	            if (c.typeParameters) {
	                c.typeParameters.forEach(function (x) {
	                    clazz.typeParameters.push(x.name['text']);
	                    if (x.constraint == null) {
	                        clazz.typeParameterConstraint.push(null);
	                    }
	                    else {
	                        clazz.typeParameterConstraint.push(x.constraint['typeName']['text']);
	                    }
	                });
	            }
	            if (c.heritageClauses) {
	                c.heritageClauses.forEach(function (x) {
	                    x.types.forEach(function (y) {
	                        if (x.token == ts.SyntaxKind.ExtendsKeyword) {
	                            clazz.extends.push(buildType(y, mpth));
	                        }
	                        else if (x.token == ts.SyntaxKind.ImplementsKeyword) {
	                            clazz.implements.push(buildType(y, mpth));
	                        }
	                        else {
	                            throw new Error("Unknown token class heritage");
	                        }
	                    });
	                });
	            }
	            return exports.tsm.Matching.SKIP;
	        }
	    });
	    return module;
	}
	exports.parseStruct = parseStruct;
	function buildField(f, path) {
	    return {
	        name: f.name['text'],
	        type: buildType(f.type, path),
	        annotations: f.name['text'].charAt(0) == '$' ? buildInitializer(f.initializer) : [],
	        valueConstraint: f.name['text'].charAt(0) != '$' ? buildConstraint(f.initializer) : null,
	        optional: f.questionToken != null
	    };
	}
	function buildMethod(md, content, path) {
	    var aliasName = md.name.text;
	    var text = content.substring(md.pos, md.end);
	    var params = [];
	    md.parameters.forEach(function (x) {
	        params.push(buildParameter(x, content, path));
	    });
	    var method = {
	        returnType: buildType(md.type, path),
	        name: aliasName,
	        start: md.pos,
	        end: md.end,
	        text: text,
	        arguments: params
	    };
	    return method;
	}
	;
	function buildParameter(f, content, path) {
	    var text = content.substring(f.pos, f.end);
	    return {
	        name: f.name['text'],
	        start: f.pos,
	        end: f.end,
	        text: text,
	        type: buildType(f.type, path)
	    };
	}
	function buildConstraint(e) {
	    if (e == null) {
	        return null;
	    }
	    if (e.kind == ts.SyntaxKind.CallExpression) {
	        return {
	            isCallConstraint: true,
	            value: buildAnnotation(e)
	        };
	    }
	    else {
	        return {
	            isCallConstraint: false,
	            value: parseArg(e)
	        };
	    }
	}
	function buildInitializer(i) {
	    if (i == null) {
	        return [];
	    }
	    if (i.kind == ts.SyntaxKind.ArrayLiteralExpression) {
	        var arr = i;
	        var annotations = [];
	        arr.elements.forEach(function (x) {
	            annotations.push(buildAnnotation(x));
	        });
	        return annotations;
	    }
	    else {
	        throw new Error("Only Array Literals supported now");
	    }
	}
	function buildAnnotation(e) {
	    if (e.kind == ts.SyntaxKind.CallExpression) {
	        var call = e;
	        var name = parseName(call.expression);
	        var a = {
	            name: name,
	            arguments: []
	        };
	        call.arguments.forEach(function (x) {
	            a.arguments.push(parseArg(x));
	        });
	        return a;
	    }
	    else {
	        throw new Error("Only call expressions may be annotations");
	    }
	}
	function parseArg(n) {
	    if (n.kind == ts.SyntaxKind.StringLiteral) {
	        var l = n;
	        return l.text;
	    }
	    if (n.kind == ts.SyntaxKind.NoSubstitutionTemplateLiteral) {
	        var ls = n;
	        return ls.text;
	    }
	    if (n.kind == ts.SyntaxKind.ArrayLiteralExpression) {
	        var arr = n;
	        var annotations = [];
	        arr.elements.forEach(function (x) {
	            annotations.push(parseArg(x));
	        });
	        return annotations;
	    }
	    if (n.kind == ts.SyntaxKind.TrueKeyword) {
	        return true;
	    }
	    if (n.kind == ts.SyntaxKind.PropertyAccessExpression) {
	        var pa = n;
	        return parseArg(pa.expression) + "." + parseArg(pa.name);
	    }
	    if (n.kind == ts.SyntaxKind.Identifier) {
	        var ident = n;
	        return ident.text;
	    }
	    if (n.kind == ts.SyntaxKind.FalseKeyword) {
	        return false;
	    }
	    if (n.kind == ts.SyntaxKind.NumericLiteral) {
	        var nl = n;
	        return Number(nl.text);
	    }
	    if (n.kind == ts.SyntaxKind.BinaryExpression) {
	        var bin = n;
	        if (bin.operatorToken.kind = ts.SyntaxKind.PlusToken) {
	            return parseArg(bin.left) + parseArg(bin.right);
	        }
	    }
	    throw new Error("Unknown value in annotation");
	}
	exports.parseArg = parseArg;
	function parseName(n) {
	    if (n.kind == ts.SyntaxKind.Identifier) {
	        return n['text'];
	    }
	    if (n.kind == ts.SyntaxKind.PropertyAccessExpression) {
	        var m = n;
	        return parseName(m.expression) + "." + parseName(m.name);
	    }
	    throw new Error("Only simple identifiers are supported now");
	}
	function basicType(n, path) {
	    var namespaceIndex = n.indexOf(".");
	    var namespace = namespaceIndex != -1 ? n.substring(0, namespaceIndex) : "";
	    var basicName = namespaceIndex != -1 ? n.substring(namespaceIndex + 1) : n;
	    return { typeName: n, nameSpace: namespace, basicName: basicName, typeKind: index_1.TypeKind.BASIC, typeArguments: [], modulePath: path };
	}
	function arrayType(b) {
	    return { base: b, typeKind: index_1.TypeKind.ARRAY };
	}
	function unionType(b) {
	    return { options: b, typeKind: index_1.TypeKind.UNION };
	}
	function buildType(t, path) {
	    if (t == null) {
	        return null;
	    }
	    if (t.kind == ts.SyntaxKind.StringKeyword) {
	        return basicType("string", null);
	    }
	    if (t.kind == ts.SyntaxKind.NumberKeyword) {
	        return basicType("number", null);
	    }
	    if (t.kind == ts.SyntaxKind.BooleanKeyword) {
	        return basicType("boolean", null);
	    }
	    if (t.kind == ts.SyntaxKind.AnyKeyword) {
	        return basicType("any", null);
	    }
	    if (t.kind == ts.SyntaxKind.VoidKeyword) {
	        return basicType("void", null);
	    }
	    if (t.kind == ts.SyntaxKind.TypeReference) {
	        var tr = t;
	        var res = basicType(parseQualified(tr.typeName), path);
	        if (tr.typeArguments) {
	            tr.typeArguments.forEach(function (x) {
	                res.typeArguments.push(buildType(x, path));
	            });
	        }
	        return res;
	    }
	    if (t.kind == ts.SyntaxKind.ArrayType) {
	        var q = t;
	        return arrayType(buildType(q.elementType, path));
	    }
	    if (t.kind == ts.SyntaxKind.UnionType) {
	        var ut = t;
	        return unionType(ut.types.map(function (x) { return buildType(x, path); }));
	    }
	    if (t.kind == ts.SyntaxKind.ExpressionWithTypeArguments) {
	        var tra = t;
	        var res = basicType(parseQualified2(tra.expression), path);
	        if (tra.typeArguments) {
	            tra.typeArguments.forEach(function (x) {
	                res.typeArguments.push(buildType(x, path));
	            });
	        }
	        return res;
	    }
	    throw new Error("Case not supported: " + t.kind);
	}
	exports.buildType = buildType;
	function parseQualified2(n) {
	    if (!n.name) {
	        return n.text;
	    }
	    return n.name.text;
	}
	function parseQualified(n) {
	    if (n.kind == ts.SyntaxKind.Identifier) {
	        return n['text'];
	    }
	    else {
	        var q = n;
	        return parseQualified(q.left) + "." + parseQualified(q.right);
	    }
	}
	//# sourceMappingURL=tsStructureParser.js.map

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*jshint node:true*/

	if (false) {
	    var define = require('amdefine')(module);
	}

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	    "use strict";

	    var statusCodes = __webpack_require__(180),
	        statusCodesToPhrases = {},
	        statusPhrasesToCodes = {},
	        methods = __webpack_require__(181),
	        headers = __webpack_require__(182),
	        relations = __webpack_require__(183);

	    statusCodes.forEach(function(item) {
	        var code = parseInt(item.code, 10),
	            phrase;

	        // Ignore codes for classes
	        if (code.toString() !== item.code) {
	            return;
	        }

	        phrase = item.phrase.toUpperCase().replace(/[^A-Z]/g, '_');

	        statusCodesToPhrases[code] = item.phrase;
	        statusPhrasesToCodes[phrase] = item.code;
	    });

	    return {
	        statusCodes: statusCodes,
	        statusCodesToPhrases: statusCodesToPhrases,
	        statusPhrasesToCodes: statusPhrasesToCodes,
	        methods: methods,
	        headers: headers,
	        relations: relations
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var rt = __webpack_require__(96);
	var meta = __webpack_require__(101);
	var restrictions_1 = __webpack_require__(100);
	var restrictions_2 = __webpack_require__(100);
	var exCalcFlag = "exampleCalculation";
	function example(t) {
	    var ms = t.oneMeta(meta.Example);
	    if (ms) {
	        return ms.example();
	    }
	    if (t.getExtra(exCalcFlag)) {
	        return null;
	    }
	    t.putExtra(exCalcFlag, true);
	    try {
	        var ms1 = t.oneMeta(meta.Examples);
	        if (ms1) {
	            var examples = ms1.examples();
	            if (examples && examples.length > 0) {
	                return examples[0];
	            }
	        }
	        var d = t.oneMeta(meta.Default);
	        if (d) {
	            return d.value();
	        }
	        if (t.isObject()) {
	            var result = {};
	            t.meta().forEach(function (x) {
	                if (x instanceof restrictions_2.PropertyIs) {
	                    var p = x;
	                    var ex = example(p.value());
	                    result[p.propertyName()] = ex;
	                }
	            });
	            t.superTypes().forEach(function (x) {
	                if (x.oneMeta(meta.Example) || x.oneMeta(meta.Examples)) {
	                    var ex = example(x);
	                    if (ex && typeof ex === "object") {
	                        Object.keys(ex).forEach(function (key) {
	                            result[key] = ex[key];
	                        });
	                    }
	                }
	            });
	            return result;
	        }
	        if (t.isArray()) {
	            var c = t.oneMeta(restrictions_1.ComponentShouldBeOfType);
	            var resultArray = [];
	            if (c) {
	                resultArray.push(example(c.value()));
	            }
	            return resultArray;
	        }
	        if (t.isUnion()) {
	            return example(t.typeFamily()[0]);
	        }
	        if (t.isNumber()) {
	            return 1;
	        }
	        if (t.isBoolean()) {
	            return true;
	        }
	        return "some value";
	    }
	    finally {
	        t.putExtra(exCalcFlag, false);
	    }
	}
	exports.example = example;
	var Example = (function () {
	    function Example(_value, _name, _displayName, _description, _strict, _annotations, _isSingle, _empty) {
	        if (_name === void 0) { _name = undefined; }
	        if (_displayName === void 0) { _displayName = undefined; }
	        if (_description === void 0) { _description = undefined; }
	        if (_strict === void 0) { _strict = true; }
	        if (_annotations === void 0) { _annotations = undefined; }
	        if (_isSingle === void 0) { _isSingle = false; }
	        if (_empty === void 0) { _empty = false; }
	        this._value = _value;
	        this._name = _name;
	        this._displayName = _displayName;
	        this._description = _description;
	        this._strict = _strict;
	        this._annotations = _annotations;
	        this._isSingle = _isSingle;
	        this._empty = _empty;
	    }
	    Example.prototype.isEmpty = function () {
	        return this._empty;
	    };
	    Example.prototype.isJSONString = function () {
	        return typeof this._value === "string" && ((this._value + "").trim().indexOf("{") == 0 || (this._value + "").trim().indexOf("[") == 0);
	    };
	    Example.prototype.isXMLString = function () {
	        return typeof this._value === "string" && (this._value + "").trim().indexOf("<") == 0;
	    };
	    Example.prototype.asXMLString = function () {
	        if (this.isXMLString()) {
	            return this._value;
	        }
	        if (this._owner) {
	            return this._owner.asXMLString();
	        }
	        return null;
	    };
	    Example.prototype.isYAML = function () {
	        if (typeof this._value === "string") {
	            return !(this.isJSONString() || this.isXMLString());
	        }
	        return true;
	    };
	    Example.prototype.asString = function () {
	        if (typeof this._value === "string") {
	            return "" + this._value;
	        }
	        return this.expandAsString();
	    };
	    Example.prototype.asJSON = function () {
	        if (this.isJSONString()) {
	            try {
	                return JSON.parse(this._value);
	            }
	            catch (e) {
	                return null;
	            }
	        }
	        if (this.isYAML()) {
	            return this._value;
	        }
	        return this.expandAsString();
	    };
	    Example.prototype.original = function () {
	        return this._value;
	    };
	    Example.prototype.expandAsString = function () {
	        return JSON.stringify(this.expandAsJSON(), null, 2);
	    };
	    Example.prototype.expandAsJSON = function () {
	        return this._value;
	    };
	    Example.prototype.isSingle = function () {
	        return this._isSingle;
	    };
	    Example.prototype.strict = function () {
	        return this._strict;
	    };
	    Example.prototype.description = function () {
	        return this._description;
	    };
	    Example.prototype.displayName = function () {
	        return this._displayName;
	    };
	    Example.prototype.annotations = function () {
	        return this._annotations;
	    };
	    Example.prototype.name = function () {
	        return this._name;
	    };
	    return Example;
	}());
	var toExample = function (owner, exampleObj, name, isSingle) {
	    if (name === void 0) { name = null; }
	    if (isSingle === void 0) { isSingle = false; }
	    var example;
	    if (exampleObj != null) {
	        var val = exampleObj.value;
	        if (!val) {
	            val = exampleObj;
	            example = new Example(val, name, undefined, undefined, true, undefined, isSingle);
	        }
	        else {
	            var displayName = exampleObj.displayName;
	            var description = exampleObj.description;
	            var strict = exampleObj.strict;
	            var aObj = null;
	            var annotationNames = Object.keys(exampleObj).filter(function (x) { return x.charAt(0) == "("; });
	            if (annotationNames.length > 0) {
	                aObj = {};
	                for (var _i = 0, annotationNames_1 = annotationNames; _i < annotationNames_1.length; _i++) {
	                    var aName = annotationNames_1[_i];
	                    var aVal = exampleObj[aName];
	                    aName = aName.substring(1, aName.length - 1);
	                    aObj[aName] = aVal;
	                }
	            }
	            example = new Example(val, name, displayName, description, strict, aObj, isSingle);
	        }
	    }
	    if (example) {
	        example._owner = owner;
	    }
	    return example;
	};
	function exampleFromNominal(n) {
	    var tp = n.getAdapter(rt.InheritedType);
	    if (tp) {
	        var result = [];
	        var ms1 = tp.oneMeta(meta.Examples);
	        if (ms1) {
	            var vl = ms1.value();
	            if (vl && typeof vl === "object") {
	                var xmlValues;
	                Object.keys(vl).forEach(function (key) {
	                    var name = Array.isArray(vl) ? null : key;
	                    var exampleObj = vl[key];
	                    var example = toExample({ asXMLString: function () {
	                            if (!xmlValues) {
	                                xmlValues = ms1.asXMLStrings();
	                            }
	                            return xmlValues[key];
	                        } }, exampleObj, name);
	                    result.push(example);
	                });
	            }
	        }
	        var ms = tp.oneMeta(meta.Example);
	        if (ms) {
	            var exampleV = ms.example();
	            if (exampleV != null) {
	                result.push(toExample(ms, ms.value(), undefined, true));
	            }
	        }
	        if (result.length > 0) {
	            return result;
	        }
	    }
	    if (tp) {
	        return [new Example(example(tp), undefined, undefined, undefined, false, undefined, undefined, true)];
	    }
	    return [];
	}
	exports.exampleFromNominal = exampleFromNominal;
	//# sourceMappingURL=exampleBuilder.js.map

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var date = __webpack_require__(196);
	var ts = __webpack_require__(96);
	function checkDate(dateStr) {
	    return date.isValid(dateStr, "YYYY-MM-DD");
	}
	var DateOnlyR = (function (_super) {
	    __extends(DateOnlyR, _super);
	    function DateOnlyR() {
	        _super.apply(this, arguments);
	    }
	    DateOnlyR.prototype.check = function (value) {
	        if (typeof value == "string") {
	            if (!checkDate(value)) {
	                return new ts.Status(ts.Status.ERROR, 0, "date-only should match to yyyy-mm-dd pattern", this);
	            }
	            return ts.ok();
	        }
	        return new ts.Status(ts.Status.ERROR, 0, "date-only should be string matching to  yyyy-mm-dd pattern ", this);
	    };
	    DateOnlyR.prototype.requiredType = function () {
	        return ts.STRING;
	    };
	    DateOnlyR.prototype.value = function () {
	        return true;
	    };
	    DateOnlyR.prototype.facetName = function () {
	        return "should be date-only";
	    };
	    return DateOnlyR;
	}(ts.GenericTypeOf));
	exports.DateOnlyR = DateOnlyR;
	function checkTime(time) {
	    return date.isValid("11 " + time.trim(), "YY HH:mm:ss");
	}
	var TimeOnlyR = (function (_super) {
	    __extends(TimeOnlyR, _super);
	    function TimeOnlyR() {
	        _super.apply(this, arguments);
	    }
	    TimeOnlyR.prototype.check = function (value) {
	        if (typeof value == "string") {
	            var regexp = /^([0-9][0-9]:[0-9][0-9]:[0-9][0-9])(.[0-9]+)?$/;
	            var matches = value.match(regexp);
	            if (!matches) {
	                return new ts.Status(ts.Status.ERROR, 0, "time-only should match to hh:mm:ss[.ff...] pattern", this);
	            }
	            var hhmmssTime = matches[1];
	            if (!checkTime(hhmmssTime)) {
	                return new ts.Status(ts.Status.ERROR, 0, "time-only should match to hh:mm:ss[.ff...] pattern", this);
	            }
	            return ts.ok();
	        }
	        return new ts.Status(ts.Status.ERROR, 0, "time-only should be string matching to  hh:mm:ss[.ff...] pattern ", this);
	    };
	    TimeOnlyR.prototype.requiredType = function () {
	        return ts.STRING;
	    };
	    TimeOnlyR.prototype.value = function () {
	        return true;
	    };
	    TimeOnlyR.prototype.facetName = function () {
	        return "should be time-only";
	    };
	    return TimeOnlyR;
	}(ts.GenericTypeOf));
	exports.TimeOnlyR = TimeOnlyR;
	var DateTimeOnlyR = (function (_super) {
	    __extends(DateTimeOnlyR, _super);
	    function DateTimeOnlyR() {
	        _super.apply(this, arguments);
	    }
	    DateTimeOnlyR.prototype.check = function (value) {
	        if (typeof value == "string") {
	            var regexp = /^(\d{4}-\d{2}-\d{2})T([0-9][0-9]:[0-9][0-9]:[0-9][0-9])(.[0-9]+)?$/;
	            var matches = value.match(regexp);
	            if (!matches || matches.length < 3) {
	                return new ts.Status(ts.Status.ERROR, 0, "datetime-only should match to yyyy-mm-ddThh:mm:ss[.ff...] pattern", this);
	            }
	            var date = matches[1];
	            var time = matches[2];
	            if (!checkDate(date) || !checkTime(time)) {
	                return new ts.Status(ts.Status.ERROR, 0, "datetime-only should match to yyyy-mm-ddThh:mm:ss[.ff...] pattern", this);
	            }
	            return ts.ok();
	        }
	        return new ts.Status(ts.Status.ERROR, 0, "datetime-only should be string matching to  yyyy-mm-ddThh:mm:ss[.ff...] pattern ", this);
	    };
	    DateTimeOnlyR.prototype.requiredType = function () {
	        return ts.STRING;
	    };
	    DateTimeOnlyR.prototype.value = function () {
	        return true;
	    };
	    DateTimeOnlyR.prototype.facetName = function () {
	        return "should be datetime-only";
	    };
	    return DateTimeOnlyR;
	}(ts.GenericTypeOf));
	exports.DateTimeOnlyR = DateTimeOnlyR;
	var r1 = /(Mon|Tue|Wed|Thu|Fri|Sat|Sun)\,[ ]+\d{2}[ ]+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]+\d{4}[ ]+\d{2}:\d{2}:\d{2}[ ]+GMT/;
	var r2 = /(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)\,[ ]+\d{2}-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-\d{2}[ ]+\d{2}:\d{2}:\d{2}[ ]+GMT/;
	var r3 = /(Mon|Tue|Wed|Thu|Fri|Sat|Sun)\,[ ]+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]+\d{1,2}[ ]+\d{2}:\d{2}:\d{2}[ ]+GMT/;
	var r0 = /^(\d{4}-\d{2}-\d{2})T(\d{2}:\d{2}:\d{2})(?:\.\d{1,3})?((?:[\+\-]\d{2}:\d{2})|Z)$/;
	var DateTimeR = (function (_super) {
	    __extends(DateTimeR, _super);
	    function DateTimeR() {
	        _super.apply(this, arguments);
	    }
	    DateTimeR.prototype.check = function (value) {
	        var c = ts.VALIDATED_TYPE;
	        var rfc2616 = false;
	        c.allFacets().forEach(function (x) {
	            if (x.facetName() == "format") {
	                if (x.value() === "rfc2616") {
	                    rfc2616 = true;
	                }
	            }
	        });
	        if (typeof value == "string") {
	            if (!rfc2616) {
	                var rfc3339Matches = value.match(r0);
	                if (!rfc3339Matches || rfc3339Matches.length < 3) {
	                    return new ts.Status(ts.Status.ERROR, 0, "valid rfc3339 formatted string is expected", this);
	                }
	                else {
	                    var date = rfc3339Matches[1];
	                    var time = rfc3339Matches[2];
	                    if (!checkDate(date) || !checkTime(time)) {
	                        return new ts.Status(ts.Status.ERROR, 0, "valid rfc3339 formatted string is expected", this);
	                    }
	                }
	                return ts.ok();
	            }
	            else {
	                if (!(value.match(r1) || value.match(r2) || value.match(r3))) {
	                    return new ts.Status(ts.Status.ERROR, 0, "valid rfc2616 formatted string is expected", this);
	                }
	            }
	            return ts.ok();
	        }
	        return new ts.Status(ts.Status.ERROR, 0, "valid datetime formatted string is expected", this);
	    };
	    DateTimeR.prototype.requiredType = function () {
	        return ts.STRING;
	    };
	    DateTimeR.prototype.value = function () {
	        return true;
	    };
	    DateTimeR.prototype.facetName = function () {
	        return "should be datetime-only";
	    };
	    return DateTimeR;
	}(ts.GenericTypeOf));
	exports.DateTimeR = DateTimeR;
	//# sourceMappingURL=datetime.js.map

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var typeExpression = __webpack_require__(173);
	var ts = __webpack_require__(96);
	var restrictions_1 = __webpack_require__(100);
	function parseToType(val, t, contentProvider) {
	    if (contentProvider === void 0) { contentProvider = null; }
	    try {
	        var q = val.trim();
	        if (q.length > 0) {
	            var json = q.charAt(0) == '{';
	            if (json || (q.charAt(0) == '<' && q.length > 1 && q.charAt(1) != '<')) {
	                return new ts.ExternalType("", q, json, contentProvider);
	            }
	            var node = typeExpression.parse(val);
	            var result = parseNode(node, t);
	            return result;
	        }
	        else {
	            return ts.derive(val, [ts.STRING]);
	        }
	    }
	    catch (e) {
	        return ts.derive(val, [ts.UNKNOWN]);
	    }
	}
	exports.parseToType = parseToType;
	function wrapArray(a, result) {
	    while (a > 0) {
	        var nt = ts.derive("", [ts.ARRAY]);
	        nt.addMeta(new restrictions_1.ComponentShouldBeOfType(result));
	        result = nt;
	        a--;
	    }
	    return result;
	}
	function parseNode(node, t) {
	    if (node.type == "union") {
	        var ut = node;
	        return ts.union("", [parseNode(ut.first, t), parseNode(ut.rest, t)]);
	    }
	    else if (node.type == "parens") {
	        var ps = node;
	        var rs = parseNode(ps.expr, t);
	        return wrapArray(ps.arr, rs);
	    }
	    else {
	        var lit = node;
	        if (lit.value.charAt(lit.value.length - 1) == '?') {
	            var result = t.get(lit.value.substr(0, lit.value.length - 1));
	            if (!result) {
	                result = ts.derive(lit.value, [ts.UNKNOWN]);
	            }
	            result = ts.union(lit.value, [result, ts.NIL]);
	            var a = lit.arr;
	            return wrapArray(a, result);
	        }
	        var result = t.get(lit.value);
	        if (!result) {
	            result = ts.derive(lit.value, [ts.UNKNOWN]);
	        }
	        var a = lit.arr;
	        return wrapArray(a, result);
	    }
	}
	function storeToString(t) {
	    if (t.isSubTypeOf(ts.ARRAY)) {
	        var cm = t.oneMeta(restrictions_1.ComponentShouldBeOfType);
	        if (cm) {
	            if (cm.value().isUnion()) {
	                return "(" + storeToString(cm.value()) + ")" + "[]";
	            }
	            else
	                return storeToString(cm.value()) + "[]";
	        }
	        return "array";
	    }
	    if (t instanceof ts.UnionType) {
	        var ut = t;
	        return ut.options().map(function (x) { return storeToString(x); }).join(" | ");
	    }
	    if (t.isAnonymous()) {
	        if (t.isEmpty()) {
	            return t.superTypes().map(function (x) { return storeToString(x); }).join(" , ");
	        }
	    }
	    return t.name();
	}
	exports.storeToString = storeToString;
	function visit(node, action) {
	    action(node);
	    if (node.type == "union") {
	        var union = node;
	        visit(union.first, action);
	        visit(union.rest, action);
	    }
	    else if (node.type == "parens") {
	        var parens = node;
	        visit(parens.expr, action);
	    }
	}
	exports.visit = visit;
	function serializeToString(node) {
	    var arr = 0;
	    var str;
	    if (node.type == "name") {
	        var literal = node;
	        str = literal.value;
	        arr = literal.arr;
	    }
	    else if (node.type == "union") {
	        var union = node;
	        str = serializeToString(union.first) + " | " + serializeToString(union.rest);
	    }
	    else if (node.type == "parens") {
	        var parens = node;
	        str = "(" + serializeToString(parens.expr) + ")";
	        arr = parens.arr;
	    }
	    while (--arr >= 0) {
	        str += "[]";
	    }
	    return str;
	}
	exports.serializeToString = serializeToString;
	function parse(str) {
	    return typeExpression.parse(str);
	}
	exports.parse = parse;
	//# sourceMappingURL=typeExpressions.js.map

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/// <reference path="../typings/main.d.ts" />
	var xml2js = __webpack_require__(197);
	var _ = __webpack_require__(175);
	var restrictions_1 = __webpack_require__(100);
	var metainfo_1 = __webpack_require__(101);
	var typesystem_1 = __webpack_require__(96);
	var XML_ERRORS = '@unexpected_root_attributes_and_elements';
	var bodyNames = [
	    'application/x-www-form-urlencoded',
	    'application/json',
	    'application/xml',
	    'multipart/form-data'
	];
	function xmlOpen(tagname, attributes, level, newLine) {
	    if (level === void 0) { level = 0; }
	    if (newLine === void 0) { newLine = true; }
	    var result = '<' + tagname;
	    for (var i = 0; i < level; i++) {
	        result = '    ' + result;
	    }
	    if (attributes && Object.keys(attributes).length > 0) {
	        Object.keys(attributes).forEach(function (key) {
	            if (typeof attributes[key] !== 'string') {
	                return;
	            }
	            result = result + ' ' + key + '="' + attributes[key] + '"';
	        });
	    }
	    result = result + '>' + (newLine ? '\n' : '');
	    return result;
	}
	;
	function xmlClose(tagname, level) {
	    if (level === void 0) { level = 0; }
	    var result = '</' + tagname;
	    for (var i = 0; i < level && i > -1; i++) {
	        result = '    ' + result;
	    }
	    var result = (level > -1 ? '\n' : '') + result + '>\n';
	    return result;
	}
	function serializeToXML(object, type) {
	    type = actualType(type);
	    var expectedRootNodeName = rootXmlName(type);
	    var infos = getInfos(type);
	    var result = xmlOpen(expectedRootNodeName, getAttributesFromJson(object, infos));
	    var valueWrapper = {};
	    valueWrapper[expectedRootNodeName] = object;
	    if (type.isArray()) {
	        var componentMeta = type.meta().filter(function (metaInfo) { return metaInfo instanceof restrictions_1.ComponentShouldBeOfType; })[0];
	        result = result + getArrayFromJson(valueWrapper, type, 1, true);
	    }
	    else {
	        result = result + getElementsFromJson(object, infos, 1);
	    }
	    var result = result + xmlClose(expectedRootNodeName);
	    return result;
	}
	exports.serializeToXML = serializeToXML;
	function getAttributesFromJson(node, infos) {
	    var nodeAttributes = {};
	    var attributeInfos = _.filter(infos, function (info) { return xmlDescriptor(info.value()).attribute; });
	    attributeInfos.forEach(function (info) {
	        var key = info.propId();
	        var xmlKey = xmlName(info);
	        if (node[key]) {
	            nodeAttributes[xmlKey] = node[key].toString();
	        }
	    });
	    return nodeAttributes;
	}
	function getElementFromJson(node, type, level) {
	    var jsonKey = Object.keys(node)[0];
	    var jsonValue = node[jsonKey];
	    var result = null;
	    if (type.isScalar()) {
	        var infos = getInfos(type);
	        result = xmlOpen(jsonKey, getAttributesFromJson(jsonValue, infos), level, !type.isScalar()) + jsonValue.toString();
	    }
	    else if (type.isUnion()) {
	        return getElementFromJson(node, selectTypeFromJson(jsonValue, type), level);
	    }
	    else {
	        var infos = getInfos(type);
	        result = xmlOpen(jsonKey, getAttributesFromJson(jsonValue, infos), level, !type.isScalar()) + getElementsFromJson(jsonValue, infos, level + 1);
	    }
	    result = result + xmlClose(jsonKey, type.isScalar() ? -1 : level);
	    return result;
	}
	function selectTypeFromJson(value, unionType) {
	    var canBeTypes = unionType.typeFamily();
	    var results = [];
	    var result = null;
	    canBeTypes.forEach(function (type) {
	        var xmlValue = serializeToXML(value, type);
	        if (!xmlValue) {
	            return;
	        }
	        var jsonValue = readObject(xmlValue, type);
	        if (jsonValue) {
	            var errors = getXmlErrors(jsonValue);
	            results.push({ type: type, errors: (errors && errors.length) || 0 });
	        }
	    });
	    result = results.length > 0 ? results[0] : { type: canBeTypes[0] };
	    results.forEach(function (canBe) {
	        if (canBe.errors < result.errors) {
	            result = canBe;
	        }
	    });
	    return result.type;
	}
	function getElementsFromJson(node, infos, level) {
	    var elementInfos = _.filter(infos, function (info) { return !xmlDescriptor(info.value()).attribute; });
	    var result = '';
	    elementInfos.forEach(function (info) {
	        var xmlKey = xmlName(info);
	        var key = info.propId();
	        var value = {};
	        value[xmlKey] = node[key];
	        if (info.value().isArray()) {
	            result = result + getArrayFromJson(value, info.value(), level);
	        }
	        else {
	            result = result + ((node[key] || node[key] === '') ? getElementFromJson(value, info.value(), level) : '');
	        }
	    });
	    return result;
	}
	function getArrayFromJson(values, type, level, rootNode) {
	    if (rootNode === void 0) { rootNode = false; }
	    var jsonKey = Object.keys(values)[0];
	    var jsonValue = values[jsonKey];
	    var descriptor = xmlDescriptor(type);
	    var isWrapped = rootNode || descriptor.wrapped;
	    var result = '';
	    var componentType = arrayElementType(type);
	    var typeName = componentType && componentType.name();
	    var elementsLevel = level;
	    if (isWrapped && !rootNode) {
	        result = xmlOpen(jsonKey, null, level);
	        elementsLevel = elementsLevel + 1;
	    }
	    if (jsonValue && isArray(jsonValue)) {
	        jsonValue.forEach(function (item) {
	            var itemWrapper = {};
	            itemWrapper[isWrapped ? typeName : jsonKey] = item;
	            result = result + getElementFromJson(itemWrapper, componentType, elementsLevel);
	        });
	    }
	    if (isWrapped) {
	        result = result + xmlClose(jsonKey, level);
	    }
	    return result;
	}
	function readObject(content, t) {
	    var result = null;
	    var opts = {};
	    opts.explicitChildren = false;
	    opts.explicitArray = false;
	    opts.explicitRoot = isSchema(t) || !t.isExternal();
	    xml2js.parseString(content, opts, function (err, res) {
	        result = res;
	        if (err) {
	            throw new Error();
	        }
	    });
	    result = isSchema(t) ? result : postProcess(result, actualType(t));
	    return result;
	}
	exports.readObject = readObject;
	function getXmlErrors(root) {
	    var errors = root[XML_ERRORS];
	    delete root[XML_ERRORS];
	    if (!errors || errors.length === 0) {
	        return null;
	    }
	    return errors.map(function (error) { return new typesystem_1.Status(typesystem_1.Status.ERROR, 0, error, {}); });
	}
	exports.getXmlErrors = getXmlErrors;
	function actualType(type) {
	    if (!type) {
	        return type;
	    }
	    if (isBodyLike(type)) {
	        if (!type.superTypes() || type.superTypes().length === 0) {
	            return type;
	        }
	        if (type.superTypes().length === 1) {
	            return type.superTypes()[0];
	        }
	        return _.find(type.allSuperTypes(), function (superType) { return superType.name() === 'object'; }) || type;
	    }
	    return type;
	}
	function isBodyLike(type) {
	    if (!type) {
	        return false;
	    }
	    return _.find(bodyNames, function (name) { return type.name() === name; }) ? true : false;
	}
	function isSchema(t) {
	    if (isXmlContent(t)) {
	        return true;
	    }
	    return _.find(t.allSuperTypes(), function (supertype) { return isXmlContent(supertype); }) ? true : false;
	}
	function isXmlContent(t) {
	    if (t.isExternal() && t._content && typeof t._content === 'string' && t._content.trim().indexOf('<') === 0) {
	        return true;
	    }
	    return false;
	}
	function postProcess(result, type) {
	    var rootNodeName = Object.keys(result)[0];
	    var rootNode = result[rootNodeName];
	    var errors = [];
	    var expectedRootNodeName = rootXmlName(type);
	    if (expectedRootNodeName !== rootNodeName) {
	        errors.push('Unexpected root node "' + rootNodeName + '", "' + expectedRootNodeName + '" is expected.');
	    }
	    var newJson;
	    if (type.isArray()) {
	        var expectedAttributeNames = [];
	        var expectedElementNames = [];
	        var componentMeta = type.meta().filter(function (metaInfo) { return metaInfo instanceof restrictions_1.ComponentShouldBeOfType; })[0];
	        var typeName = componentMeta && componentMeta.value().name();
	        expectedElementNames.push(typeName);
	        newJson = getArray(rootNode, type, errors, true);
	        fillExtras(rootNode, errors, expectedAttributeNames, expectedElementNames);
	    }
	    else {
	        newJson = buildJson(rootNode, type.isUnion() ? selectFromUnion(rootNode, type) : type, errors);
	    }
	    newJson[XML_ERRORS] = errors;
	    return newJson;
	}
	function checkErrors(rootNode, actualType) {
	    var errors = [];
	    var newJson;
	    newJson = buildJson(rootNode, actualType, errors);
	    var validationErrors = actualType.validateDirect(newJson, true, false).getErrors();
	    return errors.length + (validationErrors && validationErrors.length);
	}
	function selectFromUnion(rootNode, union) {
	    var results = [];
	    union.typeFamily().forEach(function (type) { return results.push({ type: type, errors: checkErrors(JSON.parse(JSON.stringify(rootNode)), type) }); });
	    if (results.length === 0) {
	        return union;
	    }
	    var result = results[0];
	    results.forEach(function (oneOf) {
	        if (oneOf.errors < result.errors) {
	            result = oneOf;
	        }
	    });
	    return result.type;
	}
	function buildJson(node, type, errors) {
	    var initialRoot = {};
	    if (!type) {
	        return node;
	    }
	    if (type.isScalar()) {
	        return toPrimitiveValue(type, node, errors);
	    }
	    if (type.isUnion()) {
	        return buildJson(node, selectFromUnion(node, type), errors);
	    }
	    var infos = getInfos(type);
	    var expectedAttributeNames = [];
	    var expectedElementNames = [];
	    getAttributes(node, infos, expectedAttributeNames).forEach(function (attribute) { return initialRoot[Object.keys(attribute)[0]] = attribute[Object.keys(attribute)[0]]; });
	    getElements(node, infos, expectedElementNames, errors).forEach(function (element) { return initialRoot[Object.keys(element)[0]] = element[Object.keys(element)[0]]; });
	    fillExtras(node, errors, expectedAttributeNames, expectedElementNames);
	    return initialRoot;
	}
	function fillExtras(node, errors, expectedAttributeNames, expectedElementNames, remove) {
	    if (remove === void 0) { remove = false; }
	    if (typeof node !== "object") {
	        return;
	    }
	    if (!node['$']) {
	        node['$'] = {};
	    }
	    expectedAttributeNames.forEach(function (name) {
	        delete node['$'][name];
	    });
	    expectedElementNames.forEach(function (name) {
	        delete node[name];
	    });
	    var extraAttributes = Object.keys(node['$']);
	    delete node['$'];
	    var extraElements = Object.keys(node);
	    extraAttributes.forEach(function (name) {
	        errors.push('Unexpected attribute "' + name + '".');
	    });
	    extraElements.forEach(function (name) {
	        errors.push('Unexpected element "' + name + '".');
	        if (remove) {
	            delete node[name];
	        }
	    });
	}
	function getInfos(type) {
	    return type.meta().filter(function (info) { return info instanceof restrictions_1.PropertyIs; }).map(function (info) { return info; }) || [];
	}
	function getAttributes(node, infos, expectedNames) {
	    var nodeAttributes = node['$'];
	    if (!nodeAttributes) {
	        return [];
	    }
	    var attributeInfos = _.filter(infos, function (info) { return xmlDescriptor(info.value()).attribute; });
	    return attributeInfos.map(function (info) {
	        var attribute = {};
	        var key = info.propId();
	        var xmlKey = xmlName(info);
	        expectedNames.push(xmlKey);
	        var value = nodeAttributes[xmlKey];
	        attribute[key] = toPrimitiveValue(info.value(), value);
	        return attribute[key] === null ? null : attribute;
	    }).filter(function (attribute) { return attribute; });
	}
	function getElements(node, infos, expectedNames, errors) {
	    var elementInfos = _.filter(infos, function (info) { return !xmlDescriptor(info.value()).attribute; });
	    return elementInfos.map(function (info) {
	        var element = {};
	        var descriptor = xmlDescriptor(info.value());
	        var key = info.propId();
	        var xmlKey = xmlName(info);
	        expectedNames.push(xmlKey);
	        var value = node[xmlKey];
	        if (info.value().isArray()) {
	            element[key] = getArray(node[xmlKey], info.value(), errors);
	        }
	        else {
	            element[key] = (value || value === '') ? buildJson(value, info.value(), errors) : null;
	        }
	        return element[key] === null ? null : element;
	    }).filter(function (info) { return info; });
	}
	function getArray(values, type, errors, rootNode) {
	    if (rootNode === void 0) { rootNode = false; }
	    var descriptor = xmlDescriptor(type);
	    var isWrapped = rootNode || descriptor.wrapped;
	    var componentType = arrayElementType(type);
	    var typeName = componentType && componentType.name();
	    if (isWrapped) {
	        var valuesWrapper = values;
	        values = values && values[typeName];
	        fillExtras(valuesWrapper, errors, [], [typeName], true);
	    }
	    if (!values) {
	        return [];
	    }
	    values = getArrayValues(values);
	    if (isArray(values)) {
	        values = values.map(function (value) { return buildJson(value, componentType, errors); });
	    }
	    else {
	        values = (typeof values === 'object' && values) || [];
	    }
	    return values;
	}
	function getArrayValues(preValues) {
	    if (isArray(preValues)) {
	        return preValues;
	    }
	    if (typeof preValues === 'object') {
	        return [preValues];
	    }
	    return [];
	}
	function arrayElementType(arrayType) {
	    if (!arrayType || !arrayType.isArray()) {
	        return null;
	    }
	    var componentMetas = arrayType.meta().filter(function (metaInfo) { return metaInfo instanceof restrictions_1.ComponentShouldBeOfType; });
	    return componentMetas && componentMetas.length > 0 && componentMetas[0].value();
	}
	function xmlName(property) {
	    var descriptor = xmlDescriptor(property.value());
	    var ramlName = property.propId();
	    var actualName = descriptor.name || ramlName;
	    if (descriptor.namespace) {
	        actualName = descriptor.namespace + ':' + actualName;
	    }
	    return (descriptor.prefix || '') + actualName;
	}
	function rootXmlName(type) {
	    var descriptor = xmlDescriptor(type);
	    var ramlName = type.name();
	    if (ramlName === '' && type.isUnion()) {
	        ramlName = 'object';
	    }
	    var actualName = descriptor.name || ramlName;
	    return (descriptor.prefix || '') + actualName;
	}
	function xmlDescriptor(type) {
	    var info = type.meta().filter(function (xmlInfo) { return xmlInfo instanceof metainfo_1.XMLInfo; }).map(function (xmlInfo) { return xmlInfo; })[0];
	    var result = {
	        attribute: false,
	        wrapped: false,
	        name: false,
	        namespace: false,
	        prefix: false
	    };
	    if (!info) {
	        return result;
	    }
	    var infoValue = info.value();
	    if (!infoValue) {
	        return result;
	    }
	    Object.keys(result).forEach(function (key) {
	        result[key] = infoValue[key] || result[key];
	    });
	    return result;
	}
	function toPrimitiveValue(type, actual, errors) {
	    if (errors === void 0) { errors = []; }
	    if (typeof actual === 'object') {
	        var result = toPrimitiveValue(type, actual['_']);
	        delete actual['_'];
	        fillExtras(actual, errors, [], [], true);
	        return result;
	    }
	    if (!actual && actual.trim() !== '') {
	        return null;
	    }
	    if (type.isNumber()) {
	        var parsedValue = parseFloat(actual);
	        if (!isNaN(parsedValue)) {
	            return parsedValue;
	        }
	    }
	    if (type.isBoolean()) {
	        if (actual === 'true') {
	            return true;
	        }
	        if (actual === 'false') {
	            return false;
	        }
	    }
	    if (typeof actual === 'string') {
	        return actual;
	    }
	    return null;
	}
	function isArray(instance) {
	    if (!instance) {
	        return false;
	    }
	    return typeof instance === 'object' && typeof instance.length === 'number';
	}
	//# sourceMappingURL=xmlio.js.map

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var _ = __webpack_require__(175);
	function find(t, it) {
	    return _.find(t, it);
	}
	exports.find = find;
	function filter(t, it) {
	    return _.filter(t, it);
	}
	exports.filter = filter;
	function unique(t) {
	    return _.unique(t);
	}
	exports.unique = unique;
	//# sourceMappingURL=utils.js.map

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../typings/main.d.ts" />
	"use strict";
	var sss;
	var XMLValidatorConstructor;
	try {
	    XMLValidatorConstructor = __webpack_require__(172).XMLValidator;
	}
	catch (exception) {
	    var XMLValidatorDummyImpl = (function () {
	        function XMLValidatorDummyImpl(arg) {
	        }
	        XMLValidatorDummyImpl.prototype.validate = function (xml) {
	            return [];
	        };
	        return XMLValidatorDummyImpl;
	    }());
	    XMLValidatorConstructor = XMLValidatorDummyImpl;
	}
	function objectToXml(object) {
	    if (!object) {
	        return '';
	    }
	    var nodeName = Object.keys(object)[0];
	    var root = object[nodeName];
	    if (!root && root !== '') {
	        return '';
	    }
	    var result = '<' + nodeName;
	    var attributes = root['$'] || {};
	    Object.keys(attributes).forEach(function (key) {
	        result = result + ' ' + key + '="' + attributes[key] + '"';
	    });
	    result = result + '>';
	    if (typeof root === 'string') {
	        result = result + root;
	    }
	    else {
	        Object.keys(root).forEach(function (key) {
	            if (key === '$') {
	                return;
	            }
	            if (typeof root[key] === 'object' && !root[key].length) {
	                var child = {};
	                child[key] = root[key];
	                result = result + objectToXml(child);
	            }
	            else if (typeof root[key] === 'string' || !root[key]) {
	                var child = {};
	                child[key] = root[key] || '';
	                result = result + objectToXml(child);
	            }
	            else if (typeof root[key] === 'array' || root[key].length) {
	                var children = root[key];
	                for (var i = 0; i < children.length; i++) {
	                    var member = children[i];
	                    var child = {};
	                    child[key] = member;
	                    result = result + objectToXml(child);
	                }
	            }
	        });
	    }
	    result = result + '</' + nodeName + '>';
	    return result;
	}
	function getValidator(arg) {
	    return new XMLValidatorConstructor(arg);
	}
	exports.getValidator = getValidator;
	function jsonToXml(jsonObject) {
	    var nodeName = jsonObject && Object.keys(jsonObject)[0];
	    if (nodeName) {
	        var root = jsonObject[nodeName];
	        checkAttributes(root);
	    }
	    return objectToXml(jsonObject);
	}
	exports.jsonToXml = jsonToXml;
	function checkAttributes(root) {
	    if (!root || typeof root === 'string') {
	        return;
	    }
	    var attributes = [];
	    Object.keys(root).forEach(function (key) {
	        if (key == "$") {
	            return;
	        }
	        if (key.indexOf('@') === 0) {
	            var attribute = { key: key, value: root[key] };
	            attributes.push(attribute);
	        }
	        else {
	            if (isArray(root[key])) {
	                var elements = root[key];
	                elements.forEach(function (element) { return checkAttributes(element); });
	            }
	            else if (typeof root[key] !== 'string') {
	                checkAttributes(root[key]);
	            }
	        }
	    });
	    if (!root['$']) {
	        root['$'] = {};
	    }
	    var newAttributes = root['$'];
	    attributes.forEach(function (attribute) {
	        delete root[attribute.key];
	        var newKey = attribute.key.substring(1);
	        newAttributes[newKey] = attribute.value;
	    });
	}
	function isArray(instance) {
	    if (!instance) {
	        return false;
	    }
	    return typeof instance === 'object' && typeof instance.length === 'number';
	}
	//# sourceMappingURL=xmlUtil.js.map

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	var at, // The index of the current character
	    ch, // The current character
	    escapee = {
	        '"':  '"',
	        '\\': '\\',
	        '/':  '/',
	        b:    '\b',
	        f:    '\f',
	        n:    '\n',
	        r:    '\r',
	        t:    '\t'
	    },
	    text,

	    error = function (m) {
	        // Call error when something is wrong.
	        throw {
	            name:    'SyntaxError',
	            message: m,
	            at:      at,
	            text:    text
	        };
	    },
	    
	    next = function (c) {
	        // If a c parameter is provided, verify that it matches the current character.
	        if (c && c !== ch) {
	            error("Expected '" + c + "' instead of '" + ch + "'");
	        }
	        
	        // Get the next character. When there are no more characters,
	        // return the empty string.
	        
	        ch = text.charAt(at);
	        at += 1;
	        return ch;
	    },
	    
	    number = function () {
	        // Parse a number value.
	        var number,
	            string = '';
	        
	        if (ch === '-') {
	            string = '-';
	            next('-');
	        }
	        while (ch >= '0' && ch <= '9') {
	            string += ch;
	            next();
	        }
	        if (ch === '.') {
	            string += '.';
	            while (next() && ch >= '0' && ch <= '9') {
	                string += ch;
	            }
	        }
	        if (ch === 'e' || ch === 'E') {
	            string += ch;
	            next();
	            if (ch === '-' || ch === '+') {
	                string += ch;
	                next();
	            }
	            while (ch >= '0' && ch <= '9') {
	                string += ch;
	                next();
	            }
	        }
	        number = +string;
	        if (!isFinite(number)) {
	            error("Bad number");
	        } else {
	            return number;
	        }
	    },
	    
	    string = function () {
	        // Parse a string value.
	        var hex,
	            i,
	            string = '',
	            uffff;
	        
	        // When parsing for string values, we must look for " and \ characters.
	        if (ch === '"') {
	            while (next()) {
	                if (ch === '"') {
	                    next();
	                    return string;
	                } else if (ch === '\\') {
	                    next();
	                    if (ch === 'u') {
	                        uffff = 0;
	                        for (i = 0; i < 4; i += 1) {
	                            hex = parseInt(next(), 16);
	                            if (!isFinite(hex)) {
	                                break;
	                            }
	                            uffff = uffff * 16 + hex;
	                        }
	                        string += String.fromCharCode(uffff);
	                    } else if (typeof escapee[ch] === 'string') {
	                        string += escapee[ch];
	                    } else {
	                        break;
	                    }
	                } else {
	                    string += ch;
	                }
	            }
	        }
	        error("Bad string");
	    },

	    white = function () {

	// Skip whitespace.

	        while (ch && ch <= ' ') {
	            next();
	        }
	    },

	    word = function () {

	// true, false, or null.

	        switch (ch) {
	        case 't':
	            next('t');
	            next('r');
	            next('u');
	            next('e');
	            return true;
	        case 'f':
	            next('f');
	            next('a');
	            next('l');
	            next('s');
	            next('e');
	            return false;
	        case 'n':
	            next('n');
	            next('u');
	            next('l');
	            next('l');
	            return null;
	        }
	        error("Unexpected '" + ch + "'");
	    },

	    value,  // Place holder for the value function.

	    array = function () {

	// Parse an array value.

	        var array = [];

	        if (ch === '[') {
	            next('[');
	            white();
	            if (ch === ']') {
	                next(']');
	                return array;   // empty array
	            }
	            while (ch) {
	                array.push(value());
	                white();
	                if (ch === ']') {
	                    next(']');
	                    return array;
	                }
	                next(',');
	                white();
	            }
	        }
	        error("Bad array");
	    },

	    object = function () {

	// Parse an object value.

	        var key,
	            object = {};

	        if (ch === '{') {
	            next('{');
	            white();
	            if (ch === '}') {
	                next('}');
	                return object;   // empty object
	            }
	            while (ch) {
	                key = string();
	                white();
	                next(':');
	                if (Object.hasOwnProperty.call(object, key)) {
	                    error('Duplicate key "' + key + '"');
	                }
	                object[key] = value();
	                white();
	                if (ch === '}') {
	                    next('}');
	                    return object;
	                }
	                next(',');
	                white();
	            }
	        }
	        error("Bad object");
	    };

	value = function () {

	// Parse a JSON value. It could be an object, an array, a string, a number,
	// or a word.

	    white();
	    switch (ch) {
	    case '{':
	        return object();
	    case '[':
	        return array();
	    case '"':
	        return string();
	    case '-':
	        return number();
	    default:
	        return ch >= '0' && ch <= '9' ? number() : word();
	    }
	};

	// Return the json_parse function. It will have access to all of the above
	// functions and variables.

	module.exports = function (source, reviver) {
	    var result;
	    
	    text = source;
	    at = 0;
	    ch = ' ';
	    result = value();
	    white();
	    if (ch) {
	        error("Syntax error");
	    }

	    // If there is a reviver function, we recursively walk the new structure,
	    // passing each name/value pair to the reviver function for possible
	    // transformation, starting with a temporary root object that holds the result
	    // in an empty key. If there is not a reviver function, we simply return the
	    // result.

	    return typeof reviver === 'function' ? (function walk(holder, key) {
	        var k, v, value = holder[key];
	        if (value && typeof value === 'object') {
	            for (k in value) {
	                if (Object.prototype.hasOwnProperty.call(value, k)) {
	                    v = walk(value, k);
	                    if (v !== undefined) {
	                        value[k] = v;
	                    } else {
	                        delete value[k];
	                    }
	                }
	            }
	        }
	        return reviver.call(holder, key, value);
	    }({'': result}, '')) : result;
	};


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	    gap,
	    indent,
	    meta = {    // table of character substitutions
	        '\b': '\\b',
	        '\t': '\\t',
	        '\n': '\\n',
	        '\f': '\\f',
	        '\r': '\\r',
	        '"' : '\\"',
	        '\\': '\\\\'
	    },
	    rep;

	function quote(string) {
	    // If the string contains no control characters, no quote characters, and no
	    // backslash characters, then we can safely slap some quotes around it.
	    // Otherwise we must also replace the offending characters with safe escape
	    // sequences.
	    
	    escapable.lastIndex = 0;
	    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
	        var c = meta[a];
	        return typeof c === 'string' ? c :
	            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	    }) + '"' : '"' + string + '"';
	}

	function str(key, holder) {
	    // Produce a string from holder[key].
	    var i,          // The loop counter.
	        k,          // The member key.
	        v,          // The member value.
	        length,
	        mind = gap,
	        partial,
	        value = holder[key];
	    
	    // If the value has a toJSON method, call it to obtain a replacement value.
	    if (value && typeof value === 'object' &&
	            typeof value.toJSON === 'function') {
	        value = value.toJSON(key);
	    }
	    
	    // If we were called with a replacer function, then call the replacer to
	    // obtain a replacement value.
	    if (typeof rep === 'function') {
	        value = rep.call(holder, key, value);
	    }
	    
	    // What happens next depends on the value's type.
	    switch (typeof value) {
	        case 'string':
	            return quote(value);
	        
	        case 'number':
	            // JSON numbers must be finite. Encode non-finite numbers as null.
	            return isFinite(value) ? String(value) : 'null';
	        
	        case 'boolean':
	        case 'null':
	            // If the value is a boolean or null, convert it to a string. Note:
	            // typeof null does not produce 'null'. The case is included here in
	            // the remote chance that this gets fixed someday.
	            return String(value);
	            
	        case 'object':
	            if (!value) return 'null';
	            gap += indent;
	            partial = [];
	            
	            // Array.isArray
	            if (Object.prototype.toString.apply(value) === '[object Array]') {
	                length = value.length;
	                for (i = 0; i < length; i += 1) {
	                    partial[i] = str(i, value) || 'null';
	                }
	                
	                // Join all of the elements together, separated with commas, and
	                // wrap them in brackets.
	                v = partial.length === 0 ? '[]' : gap ?
	                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
	                    '[' + partial.join(',') + ']';
	                gap = mind;
	                return v;
	            }
	            
	            // If the replacer is an array, use it to select the members to be
	            // stringified.
	            if (rep && typeof rep === 'object') {
	                length = rep.length;
	                for (i = 0; i < length; i += 1) {
	                    k = rep[i];
	                    if (typeof k === 'string') {
	                        v = str(k, value);
	                        if (v) {
	                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
	                        }
	                    }
	                }
	            }
	            else {
	                // Otherwise, iterate through all of the keys in the object.
	                for (k in value) {
	                    if (Object.prototype.hasOwnProperty.call(value, k)) {
	                        v = str(k, value);
	                        if (v) {
	                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
	                        }
	                    }
	                }
	            }
	            
	        // Join all of the member texts together, separated with commas,
	        // and wrap them in braces.

	        v = partial.length === 0 ? '{}' : gap ?
	            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
	            '{' + partial.join(',') + '}';
	        gap = mind;
	        return v;
	    }
	}

	module.exports = function (value, replacer, space) {
	    var i;
	    gap = '';
	    indent = '';
	    
	    // If the space parameter is a number, make an indent string containing that
	    // many spaces.
	    if (typeof space === 'number') {
	        for (i = 0; i < space; i += 1) {
	            indent += ' ';
	        }
	    }
	    // If the space parameter is a string, it will be used as the indent string.
	    else if (typeof space === 'string') {
	        indent = space;
	    }

	    // If there is a replacer, it must be a function or an array.
	    // Otherwise, throw an error.
	    rep = replacer;
	    if (replacer && typeof replacer !== 'function'
	    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
	        throw new Error('JSON.stringify');
	    }
	    
	    // Make a fake root object containing our value under the key of ''.
	    // Return the result of stringifying the value.
	    return str('', {'': value});
	};


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_146__;

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	module.exports = Readable;

	/*<replacement>*/
	var processNextTick = __webpack_require__(200);
	/*</replacement>*/

	/*<replacement>*/
	var isArray = __webpack_require__(202);
	/*</replacement>*/

	/*<replacement>*/
	var Buffer = __webpack_require__(92).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(201);

	/*<replacement>*/
	var EElistenerCount = function (emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(174);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(201).EventEmitter;
	  }
	})();
	/*</replacement>*/

	var Buffer = __webpack_require__(92).Buffer;

	/*<replacement>*/
	var util = __webpack_require__(218);
	util.inherits = __webpack_require__(112);
	/*</replacement>*/

	/*<replacement>*/
	var debugUtil = __webpack_require__(184);
	var debug = undefined;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/

	var StringDecoder;

	util.inherits(Readable, Stream);

	var Duplex;
	function ReadableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(149);

	  options = options || {};

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = __webpack_require__(203).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	var Duplex;
	function Readable(options) {
	  Duplex = Duplex || __webpack_require__(149);

	  if (!(this instanceof Readable)) return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  if (options && typeof options.read === 'function') this._read = options.read;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;

	  if (!state.objectMode && typeof chunk === 'string') {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      var skipAdd;
	      if (state.decoder && !addToFront && !encoding) {
	        chunk = state.decoder.write(chunk);
	        skipAdd = !state.objectMode && chunk.length === 0;
	      }

	      if (!addToFront) state.reading = false;

	      // Don't add to the buffer if we've decoded to an empty string chunk and
	      // we're not in object mode
	      if (!skipAdd) {
	        // if we want the data now, just emit it.
	        if (state.flowing && state.length === 0 && !state.sync) {
	          stream.emit('data', chunk);
	          stream.read(0);
	        } else {
	          // update the buffer info.
	          state.length += state.objectMode ? 1 : chunk.length;
	          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

	          if (state.needReadable) emitReadable(stream);
	        }
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}

	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = __webpack_require__(203).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended) return 0;

	  if (state.objectMode) return n === 0 ? 0 : 1;

	  if (n === null || isNaN(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;
	  }

	  if (n <= 0) return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else {
	      return state.length;
	    }
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;

	  if (typeof n !== 'number' || n > 0) state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }

	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);

	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;

	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended) state.needReadable = true;

	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);

	  if (ret !== null) this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}

	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}

	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    processNextTick(maybeReadMore_, stream, state);
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    cleanedUp = true;

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }

	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      if (state.pipesCount === 1 && state.pipes[0] === dest && src.listenerCount('data') === 1 && !cleanedUp) {
	        debug('false write response, pause', src._readableState.awaitDrain);
	        src._readableState.awaitDrain++;
	      }
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error) dest.on('error', onerror);else if (isArray(dest._events.error)) dest._events.error.unshift(onerror);else dest._events.error = [onerror, dest._events.error];

	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}

	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;

	    if (!dest) dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var _i = 0; _i < len; _i++) {
	      dests[_i].emit('unpipe', this);
	    }return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1) return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }

	  if (ev === 'readable' && !this._readableState.endEmitted) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        processNextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    processNextTick(resume_, stream, state);
	  }
	}

	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }

	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}

	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function (ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};

	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0) return null;

	  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode) ret = list.join('');else if (list.length === 1) ret = list[0];else ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode) ret = '';else ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode) ret += buf.slice(0, cpy);else buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length) list[0] = buf.slice(cpy);else list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    processNextTick(endReadableNT, state, stream);
	  }
	}

	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}

	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59)))

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// A bit simpler than readable streams.
	// Implement an async ._write(chunk, encoding, cb), and it'll handle all
	// the drain event emission and buffering.

	'use strict';

	module.exports = Writable;

	/*<replacement>*/
	var processNextTick = __webpack_require__(200);
	/*</replacement>*/

	/*<replacement>*/
	var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
	/*</replacement>*/

	/*<replacement>*/
	var Buffer = __webpack_require__(92).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;

	/*<replacement>*/
	var util = __webpack_require__(218);
	util.inherits = __webpack_require__(112);
	/*</replacement>*/

	/*<replacement>*/
	var internalUtil = {
	  deprecate: __webpack_require__(212)
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(174);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(201).EventEmitter;
	  }
	})();
	/*</replacement>*/

	var Buffer = __webpack_require__(92).Buffer;

	util.inherits(Writable, Stream);

	function nop() {}

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}

	var Duplex;
	function WritableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(149);

	  options = options || {};

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;

	  // count buffered requests
	  this.bufferedRequestCount = 0;

	  // create the two objects needed to store the corked requests
	  // they are not a linked list, as no new elements are inserted in there
	  this.corkedRequestsFree = new CorkedRequest(this);
	  this.corkedRequestsFree.next = new CorkedRequest(this);
	}

	WritableState.prototype.getBuffer = function writableStateGetBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};

	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function () {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
	    });
	  } catch (_) {}
	})();

	var Duplex;
	function Writable(options) {
	  Duplex = Duplex || __webpack_require__(149);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;

	    if (typeof options.writev === 'function') this._writev = options.writev;
	  }

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};

	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  processNextTick(cb, er);
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;

	  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    processNextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

	  if (typeof cb !== 'function') cb = nop;

	  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function () {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function () {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};

	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);

	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;

	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) processNextTick(cb, er);else cb(er);

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);

	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      /*<replacement>*/
	      asyncWrite(afterWrite, stream, state, finished, cb);
	      /*</replacement>*/
	    } else {
	        afterWrite(stream, state, finished, cb);
	      }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}

	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;

	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;

	    var count = 0;
	    while (entry) {
	      buffer[count] = entry;
	      entry = entry.next;
	      count += 1;
	    }

	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

	    // doWrite is always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    state.corkedRequestsFree = holder.next;
	    holder.next = null;
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }

	    if (entry === null) state.lastBufferedRequest = null;
	  }

	  state.bufferedRequestCount = 0;
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;

	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished) endWritable(this, state, cb);
	};

	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else {
	      prefinish(stream, state);
	    }
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}

	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;

	  this.next = null;
	  this.entry = null;

	  this.finish = function (err) {
	    var entry = _this.entry;
	    _this.entry = null;
	    while (entry) {
	      var cb = entry.callback;
	      state.pendingcb--;
	      cb(err);
	      entry = entry.next;
	    }
	    if (state.corkedRequestsFree) {
	      state.corkedRequestsFree.next = _this;
	    } else {
	      state.corkedRequestsFree = _this;
	    }
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59)))

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	'use strict';

	/*<replacement>*/

	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	};
	/*</replacement>*/

	module.exports = Duplex;

	/*<replacement>*/
	var processNextTick = __webpack_require__(200);
	/*</replacement>*/

	/*<replacement>*/
	var util = __webpack_require__(218);
	util.inherits = __webpack_require__(112);
	/*</replacement>*/

	var Readable = __webpack_require__(147);
	var Writable = __webpack_require__(148);

	util.inherits(Duplex, Readable);

	var keys = objectKeys(Writable.prototype);
	for (var v = 0; v < keys.length; v++) {
	  var method = keys[v];
	  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	}

	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false) this.readable = false;

	  if (options && options.writable === false) this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  processNextTick(onEndNT, this);
	}

	function onEndNT(self) {
	  self.end();
	}

	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	'use strict';

	module.exports = Transform;

	var Duplex = __webpack_require__(149);

	/*<replacement>*/
	var util = __webpack_require__(218);
	util.inherits = __webpack_require__(112);
	/*</replacement>*/

	util.inherits(Transform, Duplex);

	function TransformState(stream) {
	  this.afterTransform = function (er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	  this.writeencoding = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (data !== null && data !== undefined) stream.push(data);

	  cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}

	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;

	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }

	  this.once('prefinish', function () {
	    if (typeof this._flush === 'function') this._flush(function (er) {
	      done(stream, er);
	    });else done(stream);
	  });
	}

	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;

	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};

	function done(stream, er) {
	  if (er) return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length) throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming) throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	'use strict';

	module.exports = PassThrough;

	var Transform = __webpack_require__(150);

	/*<replacement>*/
	var util = __webpack_require__(218);
	util.inherits = __webpack_require__(112);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var common = __webpack_require__(110);
	var YAMLException = __webpack_require__(111);
	var Type = __webpack_require__(193);
	function compileList(schema, name, result) {
	    var exclude = [];
	    schema.include.forEach(function (includedSchema) {
	        result = compileList(includedSchema, name, result);
	    });
	    schema[name].forEach(function (currentType) {
	        result.forEach(function (previousType, previousIndex) {
	            if (previousType.tag === currentType.tag) {
	                exclude.push(previousIndex);
	            }
	        });
	        result.push(currentType);
	    });
	    return result.filter(function (type, index) {
	        return -1 === exclude.indexOf(index);
	    });
	}
	function compileMap() {
	    var result = {}, index, length;
	    function collectType(type) {
	        result[type.tag] = type;
	    }
	    for (index = 0, length = arguments.length; index < length; index += 1) {
	        arguments[index].forEach(collectType);
	    }
	    return result;
	}
	var Schema = (function () {
	    function Schema(definition) {
	        this.include = definition.include || [];
	        this.implicit = definition.implicit || [];
	        this.explicit = definition.explicit || [];
	        this.implicit.forEach(function (type) {
	            if (type.loadKind && 'scalar' !== type.loadKind) {
	                throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
	            }
	        });
	        this.compiledImplicit = compileList(this, 'implicit', []);
	        this.compiledExplicit = compileList(this, 'explicit', []);
	        this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
	    }
	    Schema.DEFAULT = null;
	    Schema.create = function createSchema() {
	        var schemas, types;
	        switch (arguments.length) {
	            case 1:
	                schemas = Schema.DEFAULT;
	                types = arguments[0];
	                break;
	            case 2:
	                schemas = arguments[0];
	                types = arguments[1];
	                break;
	            default:
	                throw new YAMLException('Wrong number of arguments for Schema.create function');
	        }
	        schemas = common.toArray(schemas);
	        types = common.toArray(types);
	        if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
	            throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
	        }
	        if (!types.every(function (type) { return type instanceof Type; })) {
	            throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
	        }
	        return new Schema({
	            include: schemas,
	            explicit: types
	        });
	    };
	    return Schema;
	}());
	module.exports = Schema;
	//# sourceMappingURL=schema.js.map

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var Schema = __webpack_require__(152);
	module.exports = new Schema({
	    include: [
	        __webpack_require__(192)
	    ]
	});
	//# sourceMappingURL=core.js.map

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(186);
	__webpack_require__(187);
	__webpack_require__(188);
	__webpack_require__(189);
	__webpack_require__(190);
	__webpack_require__(191);


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = /[^\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]+/g


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = /([\u0061-\u007A\u00B5\u00DF-\u00F6\u00F8-\u00FF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0561-\u0587\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7FA\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A])([\u0041-\u005A\u00C0-\u00D6\u00D8-\u00DE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA\uFF21-\uFF3A\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])/g


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = /([\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])([^\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])/g


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ts = __webpack_require__(146);
	var tsm = __webpack_require__(159);
	var path = __webpack_require__(15);
	var fs = __webpack_require__(38);
	var tsStructureParser = __webpack_require__(135);
	var helpers_1 = __webpack_require__(134);
	function getHelperMethods(srcPath) {
	    var result = [];
	    var content = fs.readFileSync(path.resolve(srcPath)).toString();
	    var mod = ts.createSourceFile("sample.ts", content, ts.ScriptTarget.ES3, true);
	    tsm.Matching.visit(mod, function (x) {
	        var node = x;
	        if (node.kind == ts.SyntaxKind.FunctionDeclaration) {
	            var meta = getMeta(node, content);
	            if (!meta) {
	                return;
	            }
	            var originalName = node.name.text;
	            var wrapperMethodName = originalName;
	            if (meta.name) {
	                wrapperMethodName = meta.name;
	            }
	            else {
	                meta.name = originalName;
	            }
	            var wrapperMethodName = meta.name ? meta.name : originalName;
	            var args = node.parameters ? node.parameters.map(function (a) { return readArg(a, srcPath); }) : [];
	            var override = meta.override ? meta.override : false;
	            var returnType = tsStructureParser.buildType(node.type, srcPath);
	            result.push(new helpers_1.HelperMethod(originalName, wrapperMethodName, returnType, args, meta));
	        }
	    });
	    return result;
	}
	exports.getHelperMethods = getHelperMethods;
	var refineComment = function (comment) {
	    return comment.replace(/^\s*\/\*+/g, '').replace(/\*+\/\s*$/g, '').split('\n')
	        .map(function (x) { return x.replace(/^\s*\/\//g, '').replace(/^\s*\* {0,1}/g, ''); }).join('\n').trim();
	};
	function getMeta(node, content) {
	    var cRange = ts.getLeadingCommentRanges(content, node.pos);
	    if (!cRange) {
	        return null;
	    }
	    var comment = cRange.map(function (x) { return content.substring(x.pos, x.end); }).join('\n');
	    var ind = comment.indexOf('__$helperMethod__');
	    if (ind < 0) {
	        return null;
	    }
	    ind += '__$helperMethod__'.length;
	    var indMeta = comment.indexOf('__$meta__');
	    if (indMeta < 0) {
	        return { comment: refineComment(comment.substring(ind)) };
	    }
	    var commentStr = refineComment(comment.substring(ind, indMeta));
	    var indMetaObj = comment.indexOf('{', indMeta);
	    if (indMetaObj < 0) {
	        return { comment: commentStr };
	    }
	    try {
	        var meta = JSON.parse(refineComment(comment.substring(indMetaObj)));
	        meta.comment = commentStr.trim().length > 0 ? commentStr : null;
	        meta.override = meta.override || false;
	        meta.primary = meta.primary || false;
	        meta.deprecated = meta.deprecated || false;
	        return meta;
	    }
	    catch (e) {
	        console.log(e);
	    }
	    return {};
	}
	function readArg(node, srcPath) {
	    var name = node.name.text;
	    var type = tsStructureParser.buildType(node.type, srcPath);
	    var defaultValue;
	    var optional = node.questionToken != null;
	    if (node.initializer != null) {
	        defaultValue = tsStructureParser.parseArg(node.initializer);
	        optional = true;
	    }
	    return {
	        name: name,
	        type: type,
	        defaultValue: defaultValue,
	        optional: optional
	    };
	}
	//# sourceMappingURL=helperMethodExtractor.js.map

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ts = __webpack_require__(146);
	/***
	 * This module is designed to match simple patterns on Typescript AST Tree
	 * it functionality mirrors jsASTMatchers which allows you to match on jsAST
	 */
	//TODO RENAME TO MATCHERS
	var Matching;
	(function (Matching) {
	    /**
	     * do match checks the node type and if node type is ok
	     * calls match function otherwise it returns null
	     */
	    var BasicMatcher = (function () {
	        function BasicMatcher() {
	        }
	        BasicMatcher.prototype.match = function (node) {
	            throw new Error();
	        };
	        BasicMatcher.prototype.nodeType = function () {
	            throw new Error();
	        };
	        BasicMatcher.prototype.doMatch = function (n) {
	            if (!n) {
	                return null;
	            }
	            if (this.nodeType() == n.kind) {
	                return this.match(n);
	            }
	        };
	        return BasicMatcher;
	    }());
	    Matching.BasicMatcher = BasicMatcher;
	    var ClassDeclarationMatcher = (function (_super) {
	        __extends(ClassDeclarationMatcher, _super);
	        function ClassDeclarationMatcher() {
	            _super.call(this);
	        }
	        ClassDeclarationMatcher.prototype.match = function (node) {
	            return node;
	        };
	        ClassDeclarationMatcher.prototype.nodeType = function () {
	            return ts.SyntaxKind.ClassDeclaration;
	        };
	        return ClassDeclarationMatcher;
	    }(BasicMatcher));
	    Matching.ClassDeclarationMatcher = ClassDeclarationMatcher;
	    var FieldMatcher = (function (_super) {
	        __extends(FieldMatcher, _super);
	        function FieldMatcher() {
	            _super.apply(this, arguments);
	        }
	        FieldMatcher.prototype.match = function (node) {
	            return node;
	        };
	        FieldMatcher.prototype.nodeType = function () {
	            return ts.SyntaxKind.PropertyDeclaration;
	        };
	        return FieldMatcher;
	    }(BasicMatcher));
	    Matching.FieldMatcher = FieldMatcher;
	    var AssignmentExpressionMatcher = (function (_super) {
	        __extends(AssignmentExpressionMatcher, _super);
	        function AssignmentExpressionMatcher(left, right, tr) {
	            _super.call(this);
	            this.left = left;
	            this.right = right;
	            this.tr = tr;
	        }
	        AssignmentExpressionMatcher.prototype.match = function (node) {
	            if (node.operatorToken.kind == ts.SyntaxKind.EqualsToken) {
	                if (this.left.doMatch(node.left) && this.right.doMatch(node.right)) {
	                    return this.tr(node);
	                }
	            }
	            return null;
	        };
	        AssignmentExpressionMatcher.prototype.nodeType = function () {
	            return ts.SyntaxKind.BinaryExpression;
	        };
	        return AssignmentExpressionMatcher;
	    }(BasicMatcher));
	    Matching.AssignmentExpressionMatcher = AssignmentExpressionMatcher;
	    var VariableDeclarationMatcher = (function (_super) {
	        __extends(VariableDeclarationMatcher, _super);
	        function VariableDeclarationMatcher(left, right, tr) {
	            _super.call(this);
	            this.left = left;
	            this.right = right;
	            this.tr = tr;
	        }
	        VariableDeclarationMatcher.prototype.match = function (node) {
	            if (this.left.doMatch(node.name) && this.right.doMatch(node.initializer)) {
	                return this.tr(node);
	            }
	        };
	        VariableDeclarationMatcher.prototype.nodeType = function () {
	            return ts.SyntaxKind.VariableDeclaration;
	        };
	        return VariableDeclarationMatcher;
	    }(BasicMatcher));
	    Matching.VariableDeclarationMatcher = VariableDeclarationMatcher;
	    var ExpressionStatementMatcher = (function (_super) {
	        __extends(ExpressionStatementMatcher, _super);
	        function ExpressionStatementMatcher(expression, tr) {
	            _super.call(this);
	            this.expression = expression;
	            this.tr = tr;
	        }
	        ExpressionStatementMatcher.prototype.match = function (node) {
	            var exp = this.expression.doMatch(node.expression);
	            if (exp) {
	                var v = this.tr(node.expression);
	                if (v == true) {
	                    return exp;
	                }
	                return v;
	            }
	            return null;
	        };
	        ExpressionStatementMatcher.prototype.nodeType = function () {
	            return ts.SyntaxKind.ExpressionStatement;
	        };
	        return ExpressionStatementMatcher;
	    }(BasicMatcher));
	    var SimpleIdentMatcher = (function (_super) {
	        __extends(SimpleIdentMatcher, _super);
	        function SimpleIdentMatcher(val) {
	            _super.call(this);
	            this.val = val;
	        }
	        SimpleIdentMatcher.prototype.match = function (node) {
	            if (node.text == this.val) {
	                return true;
	            }
	            return null;
	        };
	        SimpleIdentMatcher.prototype.nodeType = function () {
	            return ts.SyntaxKind.Identifier;
	        };
	        return SimpleIdentMatcher;
	    }(BasicMatcher));
	    var TrueMatcher = (function () {
	        function TrueMatcher() {
	        }
	        TrueMatcher.prototype.doMatch = function (node) {
	            return true;
	        };
	        TrueMatcher.prototype.nodeType = function () {
	            return null;
	        };
	        return TrueMatcher;
	    }());
	    var CallExpressionMatcher = (function (_super) {
	        __extends(CallExpressionMatcher, _super);
	        function CallExpressionMatcher(calleeMatcher, tr) {
	            _super.call(this);
	            this.calleeMatcher = calleeMatcher;
	            this.tr = tr;
	        }
	        CallExpressionMatcher.prototype.match = function (node) {
	            if (this.calleeMatcher.doMatch(node.expression)) {
	                return this.tr(node);
	            }
	            return null;
	        };
	        CallExpressionMatcher.prototype.nodeType = function () {
	            return ts.SyntaxKind.CallExpression;
	        };
	        return CallExpressionMatcher;
	    }(BasicMatcher));
	    Matching.SKIP = {};
	    function visit(n, cb) {
	        var r0 = cb(n);
	        if (r0) {
	            if (r0 == Matching.SKIP) {
	                return null;
	            }
	            return r0;
	        }
	        var r = ts.forEachChild(n, function (x) {
	            var r = visit(x, cb);
	            if (r) {
	                return r;
	            }
	        });
	        return r;
	    }
	    Matching.visit = visit;
	    var PathNode = (function () {
	        function PathNode(name, _base) {
	            this._base = _base;
	            this.arguments = null;
	            this.name = name;
	        }
	        return PathNode;
	    }());
	    Matching.PathNode = PathNode;
	    var CallPath = (function () {
	        function CallPath(base, _baseNode) {
	            this._baseNode = _baseNode;
	            this.path = [];
	            this.base = base;
	        }
	        CallPath.prototype.start = function () {
	            return this._baseNode.pos;
	        };
	        CallPath.prototype.startLocation = function () {
	            return this._baseNode.getSourceFile().getLineAndCharacterOfPosition(this.start());
	        };
	        CallPath.prototype.endLocation = function () {
	            return this._baseNode.getSourceFile().getLineAndCharacterOfPosition(this.end());
	        };
	        CallPath.prototype.end = function () {
	            var ce = this.path[this.path.length - 1]._callExpression;
	            if (ce) {
	                return ce.end;
	            }
	            return this.start();
	        };
	        CallPath.prototype.toString = function () {
	            return this.path.map(function (x) { return x.name; }).join(".");
	        };
	        return CallPath;
	    }());
	    Matching.CallPath = CallPath;
	    var MemberExpressionMatcher = (function (_super) {
	        __extends(MemberExpressionMatcher, _super);
	        function MemberExpressionMatcher(objectMatcher, propertyMatcher, tr) {
	            _super.call(this);
	            this.objectMatcher = objectMatcher;
	            this.propertyMatcher = propertyMatcher;
	            this.tr = tr;
	        }
	        MemberExpressionMatcher.prototype.match = function (node) {
	            if (this.objectMatcher.doMatch(node.expression) && this.propertyMatcher.doMatch(node.name)) {
	                return this.tr(node);
	            }
	            return null;
	        };
	        MemberExpressionMatcher.prototype.nodeType = function () {
	            return ts.SyntaxKind.PropertyAccessExpression;
	        };
	        return MemberExpressionMatcher;
	    }(BasicMatcher));
	    function memberFromExp(objMatcher, tr) {
	        if (tr === void 0) { tr = function (x) { return true; }; }
	        var array = objMatcher.split(".");
	        var result = null;
	        for (var a = 0; a < array.length; a++) {
	            var arg = array[a];
	            var ci = arg.indexOf("(*)");
	            var isCall = false;
	            if (ci != -1) {
	                arg = arg.substr(0, ci);
	                isCall = true;
	            }
	            if (result == null) {
	                result = arg == '*' ? anyNode() : ident(arg);
	            }
	            else {
	                result = new MemberExpressionMatcher(result, arg == '*' ? anyNode() : ident(arg), tr);
	            }
	            if (isCall) {
	                result = new CallExpressionMatcher(result, tr);
	            }
	        }
	        //console.log(result)
	        return result;
	    }
	    Matching.memberFromExp = memberFromExp;
	    var CallBaseMatcher = (function () {
	        function CallBaseMatcher(rootMatcher) {
	            this.rootMatcher = rootMatcher;
	        }
	        CallBaseMatcher.prototype.doMatch = function (node) {
	            var original = node;
	            if (node.kind == ts.SyntaxKind.CallExpression) {
	                var call = node;
	                var res = this.doMatch(call.expression);
	                if (res) {
	                    if (res.path.length > 0 && res.path[res.path.length - 1].arguments == null) {
	                        res.path[res.path.length - 1].arguments = call.arguments;
	                        res.path[res.path.length - 1]._callExpression = call;
	                        return res;
	                    }
	                    //This case should not exist in type script clients now
	                    //but leaving it here for possible future use at the moment;
	                    //if (res.path.length==0&&call.arguments.length==1){
	                    //    //this is not resource based call!!!
	                    //    if (call.arguments[0].kind==ts.SyntaxKind.StringLiteral){
	                    //        var l:ts.LiteralExpression=<ts.LiteralExpression>call.arguments[0];
	                    //        var url=l.text;
	                    //        var uriPath=url.toString().split("/");
	                    //        uriPath.forEach(x=>res.path.push(
	                    //            new PathNode(x)
	                    //        ))
	                    //        return res;
	                    //    }
	                    //}
	                    return null;
	                }
	            }
	            else if (node.kind == ts.SyntaxKind.PropertyAccessExpression) {
	                var me = node;
	                var v = this.doMatch(me.expression);
	                if (v) {
	                    if (me.name.kind == ts.SyntaxKind.Identifier) {
	                        v.path.push(new PathNode(me.name.text, me.name));
	                        return v;
	                    }
	                    return null;
	                }
	            }
	            else if (node.kind == ts.SyntaxKind.Identifier) {
	                var id = node;
	                if (this.rootMatcher.doMatch(id)) {
	                    return new CallPath(id.text, id);
	                }
	            }
	            return null;
	        };
	        CallBaseMatcher.prototype.nodeType = function () {
	            return null;
	        };
	        return CallBaseMatcher;
	    }());
	    Matching.CallBaseMatcher = CallBaseMatcher;
	    function ident(name) {
	        return new SimpleIdentMatcher(name);
	    }
	    Matching.ident = ident;
	    function anyNode() {
	        return new TrueMatcher();
	    }
	    Matching.anyNode = anyNode;
	    function call(calleeMatcher, tr) {
	        if (tr === void 0) { tr = function (x) { return true; }; }
	        return new CallExpressionMatcher(calleeMatcher, tr);
	    }
	    Matching.call = call;
	    function exprStmt(eM, tr) {
	        if (tr === void 0) { tr = function (x) { return true; }; }
	        return new ExpressionStatementMatcher(eM, tr);
	    }
	    Matching.exprStmt = exprStmt;
	    function assign(left, right, tr) {
	        if (tr === void 0) { tr = function (x) { return true; }; }
	        return new AssignmentExpressionMatcher(left, right, tr);
	    }
	    Matching.assign = assign;
	    function varDecl(left, right, tr) {
	        if (tr === void 0) { tr = function (x) { return true; }; }
	        return new VariableDeclarationMatcher(left, right, tr);
	    }
	    Matching.varDecl = varDecl;
	    function field() {
	        return new FieldMatcher();
	    }
	    Matching.field = field;
	    function classDeclaration() {
	        return new ClassDeclarationMatcher();
	    }
	    Matching.classDeclaration = classDeclaration;
	})(Matching = exports.Matching || (exports.Matching = {}));
	//# sourceMappingURL=tsASTMatchers.js.map

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/// <reference path="../typings/main.d.ts" />
	var pth = __webpack_require__(15);
	var fs = __webpack_require__(38);
	function resolve(p1, p2) {
	    return pth.resolve(p1, p2);
	}
	exports.resolve = resolve;
	function readFileSync(p) {
	    return fs.readFileSync(p).toString();
	}
	exports.readFileSync = readFileSync;
	function dirname(p) {
	    return pth.dirname(p);
	}
	exports.dirname = dirname;
	function existsSync(p) {
	    return fs.existsSync(p);
	}
	exports.existsSync = existsSync;
	//# sourceMappingURL=fsUtils.js.map

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var Type = __webpack_require__(193);
	var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' +
	    '-([0-9][0-9]?)' +
	    '-([0-9][0-9]?)' +
	    '(?:(?:[Tt]|[ \\t]+)' +
	    '([0-9][0-9]?)' +
	    ':([0-9][0-9])' +
	    ':([0-9][0-9])' +
	    '(?:\\.([0-9]*))?' +
	    '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' +
	    '(?::([0-9][0-9]))?))?)?$');
	function resolveYamlTimestamp(data) {
	    if (null === data) {
	        return false;
	    }
	    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
	    match = YAML_TIMESTAMP_REGEXP.exec(data);
	    if (null === match) {
	        return false;
	    }
	    return true;
	}
	function constructYamlTimestamp(data) {
	    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
	    match = YAML_TIMESTAMP_REGEXP.exec(data);
	    if (null === match) {
	        throw new Error('Date resolve error');
	    }
	    year = +(match[1]);
	    month = +(match[2]) - 1;
	    day = +(match[3]);
	    if (!match[4]) {
	        return new Date(Date.UTC(year, month, day));
	    }
	    hour = +(match[4]);
	    minute = +(match[5]);
	    second = +(match[6]);
	    if (match[7]) {
	        fraction = match[7].slice(0, 3);
	        while (fraction.length < 3) {
	            fraction = fraction + '0';
	        }
	        fraction = +fraction;
	    }
	    if (match[9]) {
	        tz_hour = +(match[10]);
	        tz_minute = +(match[11] || 0);
	        delta = (tz_hour * 60 + tz_minute) * 60000;
	        if ('-' === match[9]) {
	            delta = -delta;
	        }
	    }
	    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
	    if (delta) {
	        date.setTime(date.getTime() - delta);
	    }
	    return date;
	}
	function representYamlTimestamp(object) {
	    return object.toISOString();
	}
	module.exports = new Type('tag:yaml.org,2002:timestamp', {
	    kind: 'scalar',
	    resolve: resolveYamlTimestamp,
	    construct: constructYamlTimestamp,
	    instanceOf: Date,
	    represent: representYamlTimestamp
	});
	//# sourceMappingURL=timestamp.js.map

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var Type = __webpack_require__(193);
	function resolveYamlMerge(data) {
	    return '<<' === data || null === data;
	}
	module.exports = new Type('tag:yaml.org,2002:merge', {
	    kind: 'scalar',
	    resolve: resolveYamlMerge
	});
	//# sourceMappingURL=merge.js.map

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var NodeBuffer = __webpack_require__(92).Buffer;
	var Type = __webpack_require__(193);
	var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';
	function resolveYamlBinary(data) {
	    if (null === data) {
	        return false;
	    }
	    var code, idx, bitlen = 0, len = 0, max = data.length, map = BASE64_MAP;
	    for (idx = 0; idx < max; idx++) {
	        code = map.indexOf(data.charAt(idx));
	        if (code > 64) {
	            continue;
	        }
	        if (code < 0) {
	            return false;
	        }
	        bitlen += 6;
	    }
	    return (bitlen % 8) === 0;
	}
	function constructYamlBinary(data) {
	    var code, idx, tailbits, input = data.replace(/[\r\n=]/g, ''), max = input.length, map = BASE64_MAP, bits = 0, result = [];
	    for (idx = 0; idx < max; idx++) {
	        if ((idx % 4 === 0) && idx) {
	            result.push((bits >> 16) & 0xFF);
	            result.push((bits >> 8) & 0xFF);
	            result.push(bits & 0xFF);
	        }
	        bits = (bits << 6) | map.indexOf(input.charAt(idx));
	    }
	    tailbits = (max % 4) * 6;
	    if (tailbits === 0) {
	        result.push((bits >> 16) & 0xFF);
	        result.push((bits >> 8) & 0xFF);
	        result.push(bits & 0xFF);
	    }
	    else if (tailbits === 18) {
	        result.push((bits >> 10) & 0xFF);
	        result.push((bits >> 2) & 0xFF);
	    }
	    else if (tailbits === 12) {
	        result.push((bits >> 4) & 0xFF);
	    }
	    if (NodeBuffer) {
	        return new NodeBuffer(result);
	    }
	    return result;
	}
	function representYamlBinary(object) {
	    var result = '', bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
	    for (idx = 0; idx < max; idx++) {
	        if ((idx % 3 === 0) && idx) {
	            result += map[(bits >> 18) & 0x3F];
	            result += map[(bits >> 12) & 0x3F];
	            result += map[(bits >> 6) & 0x3F];
	            result += map[bits & 0x3F];
	        }
	        bits = (bits << 8) + object[idx];
	    }
	    tail = max % 3;
	    if (tail === 0) {
	        result += map[(bits >> 18) & 0x3F];
	        result += map[(bits >> 12) & 0x3F];
	        result += map[(bits >> 6) & 0x3F];
	        result += map[bits & 0x3F];
	    }
	    else if (tail === 2) {
	        result += map[(bits >> 10) & 0x3F];
	        result += map[(bits >> 4) & 0x3F];
	        result += map[(bits << 2) & 0x3F];
	        result += map[64];
	    }
	    else if (tail === 1) {
	        result += map[(bits >> 2) & 0x3F];
	        result += map[(bits << 4) & 0x3F];
	        result += map[64];
	        result += map[64];
	    }
	    return result;
	}
	function isBinary(object) {
	    return NodeBuffer && NodeBuffer.isBuffer(object);
	}
	module.exports = new Type('tag:yaml.org,2002:binary', {
	    kind: 'scalar',
	    resolve: resolveYamlBinary,
	    construct: constructYamlBinary,
	    predicate: isBinary,
	    represent: representYamlBinary
	});
	//# sourceMappingURL=binary.js.map

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var Type = __webpack_require__(193);
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	var _toString = Object.prototype.toString;
	function resolveYamlOmap(data) {
	    if (null === data) {
	        return true;
	    }
	    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
	    for (index = 0, length = object.length; index < length; index += 1) {
	        pair = object[index];
	        pairHasKey = false;
	        if ('[object Object]' !== _toString.call(pair)) {
	            return false;
	        }
	        for (pairKey in pair) {
	            if (_hasOwnProperty.call(pair, pairKey)) {
	                if (!pairHasKey) {
	                    pairHasKey = true;
	                }
	                else {
	                    return false;
	                }
	            }
	        }
	        if (!pairHasKey) {
	            return false;
	        }
	        if (-1 === objectKeys.indexOf(pairKey)) {
	            objectKeys.push(pairKey);
	        }
	        else {
	            return false;
	        }
	    }
	    return true;
	}
	function constructYamlOmap(data) {
	    return null !== data ? data : [];
	}
	module.exports = new Type('tag:yaml.org,2002:omap', {
	    kind: 'sequence',
	    resolve: resolveYamlOmap,
	    construct: constructYamlOmap
	});
	//# sourceMappingURL=omap.js.map

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var Type = __webpack_require__(193);
	var _toString = Object.prototype.toString;
	function resolveYamlPairs(data) {
	    if (null === data) {
	        return true;
	    }
	    var index, length, pair, keys, result, object = data;
	    result = new Array(object.length);
	    for (index = 0, length = object.length; index < length; index += 1) {
	        pair = object[index];
	        if ('[object Object]' !== _toString.call(pair)) {
	            return false;
	        }
	        keys = Object.keys(pair);
	        if (1 !== keys.length) {
	            return false;
	        }
	        result[index] = [keys[0], pair[keys[0]]];
	    }
	    return true;
	}
	function constructYamlPairs(data) {
	    if (null === data) {
	        return [];
	    }
	    var index, length, pair, keys, result, object = data;
	    result = new Array(object.length);
	    for (index = 0, length = object.length; index < length; index += 1) {
	        pair = object[index];
	        keys = Object.keys(pair);
	        result[index] = [keys[0], pair[keys[0]]];
	    }
	    return result;
	}
	module.exports = new Type('tag:yaml.org,2002:pairs', {
	    kind: 'sequence',
	    resolve: resolveYamlPairs,
	    construct: constructYamlPairs
	});
	//# sourceMappingURL=pairs.js.map

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var Type = __webpack_require__(193);
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	function resolveYamlSet(data) {
	    if (null === data) {
	        return true;
	    }
	    var key, object = data;
	    for (key in object) {
	        if (_hasOwnProperty.call(object, key)) {
	            if (null !== object[key]) {
	                return false;
	            }
	        }
	    }
	    return true;
	}
	function constructYamlSet(data) {
	    return null !== data ? data : {};
	}
	module.exports = new Type('tag:yaml.org,2002:set', {
	    kind: 'mapping',
	    resolve: resolveYamlSet,
	    construct: constructYamlSet
	});
	//# sourceMappingURL=set.js.map

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var Type = __webpack_require__(193);
	function resolveJavascriptUndefined() {
	    return true;
	}
	function constructJavascriptUndefined() {
	    return undefined;
	}
	function representJavascriptUndefined() {
	    return '';
	}
	function isUndefined(object) {
	    return 'undefined' === typeof object;
	}
	module.exports = new Type('tag:yaml.org,2002:js/undefined', {
	    kind: 'scalar',
	    resolve: resolveJavascriptUndefined,
	    construct: constructJavascriptUndefined,
	    predicate: isUndefined,
	    represent: representJavascriptUndefined
	});
	//# sourceMappingURL=undefined.js.map

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var Type = __webpack_require__(193);
	function resolveJavascriptRegExp(data) {
	    if (null === data) {
	        return false;
	    }
	    if (0 === data.length) {
	        return false;
	    }
	    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = '';
	    if ('/' === regexp[0]) {
	        if (tail) {
	            modifiers = tail[1];
	        }
	        if (modifiers.length > 3) {
	            return false;
	        }
	        if (regexp[regexp.length - modifiers.length - 1] !== '/') {
	            return false;
	        }
	        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
	    }
	    try {
	        var dummy = new RegExp(regexp, modifiers);
	        return true;
	    }
	    catch (error) {
	        return false;
	    }
	}
	function constructJavascriptRegExp(data) {
	    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = '';
	    if ('/' === regexp[0]) {
	        if (tail) {
	            modifiers = tail[1];
	        }
	        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
	    }
	    return new RegExp(regexp, modifiers);
	}
	function representJavascriptRegExp(object) {
	    var result = '/' + object.source + '/';
	    if (object.global) {
	        result += 'g';
	    }
	    if (object.multiline) {
	        result += 'm';
	    }
	    if (object.ignoreCase) {
	        result += 'i';
	    }
	    return result;
	}
	function isRegExp(object) {
	    return '[object RegExp]' === Object.prototype.toString.call(object);
	}
	module.exports = new Type('tag:yaml.org,2002:js/regexp', {
	    kind: 'scalar',
	    resolve: resolveJavascriptRegExp,
	    construct: constructJavascriptRegExp,
	    predicate: isRegExp,
	    represent: representJavascriptRegExp
	});
	//# sourceMappingURL=regexp.js.map

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Stringify = __webpack_require__(194);
	var Parse = __webpack_require__(195);

	module.exports = {
	    stringify: Stringify,
	    parse: Parse
	};


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	if(typeof __WEBPACK_EXTERNAL_MODULE_172__ === 'undefined') {var e = new Error("Cannot find module \"RAML.XmlValidation\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
	module.exports = __WEBPACK_EXTERNAL_MODULE_172__;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var parser = (function () {
	    "use strict";
	    /*
	     * Generated by PEG.js 0.9.0.
	     *
	     * http://pegjs.org/
	     */
	    function peg$subclass(child, parent) {
	        function ctor() { this.constructor = child; }
	        ctor.prototype = parent.prototype;
	        child.prototype = new ctor();
	    }
	    function peg$SyntaxError(message, expected, found, location) {
	        this.message = message;
	        this.expected = expected;
	        this.found = found;
	        this.location = location;
	        this.name = "SyntaxError";
	        if (typeof Error.captureStackTrace === "function") {
	            Error.captureStackTrace(this, peg$SyntaxError);
	        }
	    }
	    peg$subclass(peg$SyntaxError, Error);
	    function peg$parse(input) {
	        var options = arguments.length > 1 ? arguments[1] : {}, parser = this, peg$FAILED = {}, peg$startRuleFunctions = { Term: peg$parseTerm }, peg$startRuleFunction = peg$parseTerm, peg$c0 = "|", peg$c1 = { type: "literal", value: "|", description: "\"|\"" }, peg$c2 = function (first, rest) {
	            return rest ? { "type": "union", "first": first, "rest": rest[3] } : first;
	        }, peg$c3 = "(", peg$c4 = { type: "literal", value: "(", description: "\"(\"" }, peg$c5 = ")", peg$c6 = { type: "literal", value: ")", description: "\")\"" }, peg$c7 = "[]", peg$c8 = { type: "literal", value: "[]", description: "\"[]\"" }, peg$c9 = function (expr, arr) { return { "type": "parens", "expr": expr, "arr": arr.length }; }, peg$c10 = "<", peg$c11 = { type: "literal", value: "<", description: "\"<\"" }, peg$c12 = ">", peg$c13 = { type: "literal", value: ">", description: "\">\"" }, peg$c14 = function (first, other) { return [first].concat(other); }, peg$c15 = ",", peg$c16 = { type: "literal", value: ",", description: "\",\"" }, peg$c17 = function (r) { return r; }, peg$c18 = { type: "other", description: "name" }, peg$c19 = function (r, c) { return { "type": "name", "value": r.join(""), "arr": (c.length) }; }, peg$c20 = { type: "other", description: "whitespace" }, peg$c21 = /^[ \t\n\r]/, peg$c22 = { type: "class", value: "[ \\t\\n\\r]", description: "[ \\t\\n\\r]" }, peg$c23 = /^[A-Z]/, peg$c24 = { type: "class", value: "[A-Z]", description: "[A-Z]" }, peg$c25 = "_", peg$c26 = { type: "literal", value: "_", description: "\"_\"" }, peg$c27 = "-", peg$c28 = { type: "literal", value: "-", description: "\"-\"" }, peg$c29 = ".", peg$c30 = { type: "literal", value: ".", description: "\".\"" }, peg$c31 = /^[a-z:#\/]/, peg$c32 = { type: "class", value: "[a-z]", description: "[a-z]" }, peg$c33 = /^[0-9]/, peg$c34 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c35 = "?", peg$c36 = { type: "literal", value: "?", description: "\"?\"" }, peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1, seenCR: false }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
	        if ("startRule" in options) {
	            if (!(options.startRule in peg$startRuleFunctions)) {
	                throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	            }
	            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	        }
	        function text() {
	            return input.substring(peg$savedPos, peg$currPos);
	        }
	        function location() {
	            return peg$computeLocation(peg$savedPos, peg$currPos);
	        }
	        function expected(description) {
	            throw peg$buildException(null, [{ type: "other", description: description }], input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
	        }
	        function error(message) {
	            throw peg$buildException(message, null, input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
	        }
	        function peg$computePosDetails(pos) {
	            var details = peg$posDetailsCache[pos], p, ch;
	            if (details) {
	                return details;
	            }
	            else {
	                p = pos - 1;
	                while (!peg$posDetailsCache[p]) {
	                    p--;
	                }
	                details = peg$posDetailsCache[p];
	                details = {
	                    line: details.line,
	                    column: details.column,
	                    seenCR: details.seenCR
	                };
	                while (p < pos) {
	                    ch = input.charAt(p);
	                    if (ch === "\n") {
	                        if (!details.seenCR) {
	                            details.line++;
	                        }
	                        details.column = 1;
	                        details.seenCR = false;
	                    }
	                    else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
	                        details.line++;
	                        details.column = 1;
	                        details.seenCR = true;
	                    }
	                    else {
	                        details.column++;
	                        details.seenCR = false;
	                    }
	                    p++;
	                }
	                peg$posDetailsCache[pos] = details;
	                return details;
	            }
	        }
	        function peg$computeLocation(startPos, endPos) {
	            var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
	            return {
	                start: {
	                    offset: startPos,
	                    line: startPosDetails.line,
	                    column: startPosDetails.column
	                },
	                end: {
	                    offset: endPos,
	                    line: endPosDetails.line,
	                    column: endPosDetails.column
	                }
	            };
	        }
	        function peg$fail(expected) {
	            if (peg$currPos < peg$maxFailPos) {
	                return;
	            }
	            if (peg$currPos > peg$maxFailPos) {
	                peg$maxFailPos = peg$currPos;
	                peg$maxFailExpected = [];
	            }
	            peg$maxFailExpected.push(expected);
	        }
	        function peg$buildException(message, expected, found, location) {
	            function cleanupExpected(expected) {
	                var i = 1;
	                expected.sort(function (a, b) {
	                    if (a.description < b.description) {
	                        return -1;
	                    }
	                    else if (a.description > b.description) {
	                        return 1;
	                    }
	                    else {
	                        return 0;
	                    }
	                });
	                while (i < expected.length) {
	                    if (expected[i - 1] === expected[i]) {
	                        expected.splice(i, 1);
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	            function buildMessage(expected, found) {
	                function stringEscape(s) {
	                    function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }
	                    return s
	                        .replace(/\\/g, '\\\\')
	                        .replace(/"/g, '\\"')
	                        .replace(/\x08/g, '\\b')
	                        .replace(/\t/g, '\\t')
	                        .replace(/\n/g, '\\n')
	                        .replace(/\f/g, '\\f')
	                        .replace(/\r/g, '\\r')
	                        .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) { return '\\x0' + hex(ch); })
	                        .replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) { return '\\x' + hex(ch); })
	                        .replace(/[\u0100-\u0FFF]/g, function (ch) { return '\\u0' + hex(ch); })
	                        .replace(/[\u1000-\uFFFF]/g, function (ch) { return '\\u' + hex(ch); });
	                }
	                var expectedDescs = new Array(expected.length), expectedDesc, foundDesc, i;
	                for (i = 0; i < expected.length; i++) {
	                    expectedDescs[i] = expected[i].description;
	                }
	                expectedDesc = expected.length > 1
	                    ? expectedDescs.slice(0, -1).join(", ")
	                        + " or "
	                        + expectedDescs[expected.length - 1]
	                    : expectedDescs[0];
	                foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
	                return "Expected " + expectedDesc + " but " + foundDesc + " found.";
	            }
	            if (expected !== null) {
	                cleanupExpected(expected);
	            }
	            return new peg$SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, location);
	        }
	        function peg$parseTerm() {
	            var s0, s1, s2, s3, s4, s5, s6, s7;
	            s0 = peg$currPos;
	            s1 = peg$parse_();
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseFactor();
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$currPos;
	                    s4 = peg$parse_();
	                    if (s4 !== peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 124) {
	                            s5 = peg$c0;
	                            peg$currPos++;
	                        }
	                        else {
	                            s5 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c1);
	                            }
	                        }
	                        if (s5 !== peg$FAILED) {
	                            s6 = peg$parse_();
	                            if (s6 !== peg$FAILED) {
	                                s7 = peg$parseTerm();
	                                if (s7 !== peg$FAILED) {
	                                    s4 = [s4, s5, s6, s7];
	                                    s3 = s4;
	                                }
	                                else {
	                                    peg$currPos = s3;
	                                    s3 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s3;
	                                s3 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s3;
	                            s3 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                    if (s3 === peg$FAILED) {
	                        s3 = null;
	                    }
	                    if (s3 !== peg$FAILED) {
	                        peg$savedPos = s0;
	                        s1 = peg$c2(s2, s3);
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseFactor() {
	            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 40) {
	                s1 = peg$c3;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c4);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parse_();
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$parseTerm();
	                    if (s3 !== peg$FAILED) {
	                        s4 = peg$parse_();
	                        if (s4 !== peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 41) {
	                                s5 = peg$c5;
	                                peg$currPos++;
	                            }
	                            else {
	                                s5 = peg$FAILED;
	                                if (peg$silentFails === 0) {
	                                    peg$fail(peg$c6);
	                                }
	                            }
	                            if (s5 !== peg$FAILED) {
	                                s6 = [];
	                                s7 = peg$currPos;
	                                s8 = peg$parse_();
	                                if (s8 !== peg$FAILED) {
	                                    if (input.substr(peg$currPos, 2) === peg$c7) {
	                                        s9 = peg$c7;
	                                        peg$currPos += 2;
	                                    }
	                                    else {
	                                        s9 = peg$FAILED;
	                                        if (peg$silentFails === 0) {
	                                            peg$fail(peg$c8);
	                                        }
	                                    }
	                                    if (s9 !== peg$FAILED) {
	                                        s8 = [s8, s9];
	                                        s7 = s8;
	                                    }
	                                    else {
	                                        peg$currPos = s7;
	                                        s7 = peg$FAILED;
	                                    }
	                                }
	                                else {
	                                    peg$currPos = s7;
	                                    s7 = peg$FAILED;
	                                }
	                                while (s7 !== peg$FAILED) {
	                                    s6.push(s7);
	                                    s7 = peg$currPos;
	                                    s8 = peg$parse_();
	                                    if (s8 !== peg$FAILED) {
	                                        if (input.substr(peg$currPos, 2) === peg$c7) {
	                                            s9 = peg$c7;
	                                            peg$currPos += 2;
	                                        }
	                                        else {
	                                            s9 = peg$FAILED;
	                                            if (peg$silentFails === 0) {
	                                                peg$fail(peg$c8);
	                                            }
	                                        }
	                                        if (s9 !== peg$FAILED) {
	                                            s8 = [s8, s9];
	                                            s7 = s8;
	                                        }
	                                        else {
	                                            peg$currPos = s7;
	                                            s7 = peg$FAILED;
	                                        }
	                                    }
	                                    else {
	                                        peg$currPos = s7;
	                                        s7 = peg$FAILED;
	                                    }
	                                }
	                                if (s6 !== peg$FAILED) {
	                                    peg$savedPos = s0;
	                                    s1 = peg$c9(s3, s6);
	                                    s0 = s1;
	                                }
	                                else {
	                                    peg$currPos = s0;
	                                    s0 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s0;
	                                s0 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            if (s0 === peg$FAILED) {
	                s0 = peg$parseLiteral();
	            }
	            return s0;
	        }
	        function peg$parseTypeParams() {
	            var s0, s1, s2, s3, s4;
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 60) {
	                s1 = peg$c10;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c11);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseTerm();
	                if (s2 !== peg$FAILED) {
	                    s3 = [];
	                    s4 = peg$parseExtraParam();
	                    while (s4 !== peg$FAILED) {
	                        s3.push(s4);
	                        s4 = peg$parseExtraParam();
	                    }
	                    if (s3 !== peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 62) {
	                            s4 = peg$c12;
	                            peg$currPos++;
	                        }
	                        else {
	                            s4 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c13);
	                            }
	                        }
	                        if (s4 !== peg$FAILED) {
	                            peg$savedPos = s0;
	                            s1 = peg$c14(s2, s3);
	                            s0 = s1;
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseExtraParam() {
	            var s0, s1, s2;
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 44) {
	                s1 = peg$c15;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c16);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseTerm();
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c17(s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseLiteral() {
	            var s0, s1, s2, s3, s4, s5;
	            peg$silentFails++;
	            s0 = peg$currPos;
	            s1 = [];
	            s2 = peg$parsechar();
	            if (s2 !== peg$FAILED) {
	                while (s2 !== peg$FAILED) {
	                    s1.push(s2);
	                    s2 = peg$parsechar();
	                }
	            }
	            else {
	                s1 = peg$FAILED;
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = [];
	                s3 = peg$currPos;
	                s4 = peg$parse_();
	                if (s4 !== peg$FAILED) {
	                    if (input.substr(peg$currPos, 2) === peg$c7) {
	                        s5 = peg$c7;
	                        peg$currPos += 2;
	                    }
	                    else {
	                        s5 = peg$FAILED;
	                        if (peg$silentFails === 0) {
	                            peg$fail(peg$c8);
	                        }
	                    }
	                    if (s5 !== peg$FAILED) {
	                        s4 = [s4, s5];
	                        s3 = s4;
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s3;
	                    s3 = peg$FAILED;
	                }
	                while (s3 !== peg$FAILED) {
	                    s2.push(s3);
	                    s3 = peg$currPos;
	                    s4 = peg$parse_();
	                    if (s4 !== peg$FAILED) {
	                        if (input.substr(peg$currPos, 2) === peg$c7) {
	                            s5 = peg$c7;
	                            peg$currPos += 2;
	                        }
	                        else {
	                            s5 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c8);
	                            }
	                        }
	                        if (s5 !== peg$FAILED) {
	                            s4 = [s4, s5];
	                            s3 = s4;
	                        }
	                        else {
	                            peg$currPos = s3;
	                            s3 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                }
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c19(s1, s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            peg$silentFails--;
	            if (s0 === peg$FAILED) {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c18);
	                }
	            }
	            return s0;
	        }
	        function peg$parse_() {
	            var s0, s1;
	            peg$silentFails++;
	            s0 = [];
	            if (peg$c21.test(input.charAt(peg$currPos))) {
	                s1 = input.charAt(peg$currPos);
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c22);
	                }
	            }
	            while (s1 !== peg$FAILED) {
	                s0.push(s1);
	                if (peg$c21.test(input.charAt(peg$currPos))) {
	                    s1 = input.charAt(peg$currPos);
	                    peg$currPos++;
	                }
	                else {
	                    s1 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c22);
	                    }
	                }
	            }
	            peg$silentFails--;
	            if (s0 === peg$FAILED) {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c20);
	                }
	            }
	            return s0;
	        }
	        function peg$parsechar() {
	            var s0;
	            if (peg$c23.test(input.charAt(peg$currPos))) {
	                s0 = input.charAt(peg$currPos);
	                peg$currPos++;
	            }
	            else {
	                s0 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c24);
	                }
	            }
	            if (s0 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 95) {
	                    s0 = peg$c25;
	                    peg$currPos++;
	                }
	                else {
	                    s0 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c26);
	                    }
	                }
	                if (s0 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 45) {
	                        s0 = peg$c27;
	                        peg$currPos++;
	                    }
	                    else {
	                        s0 = peg$FAILED;
	                        if (peg$silentFails === 0) {
	                            peg$fail(peg$c28);
	                        }
	                    }
	                    if (s0 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 46) {
	                            s0 = peg$c29;
	                            peg$currPos++;
	                        }
	                        else {
	                            s0 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c30);
	                            }
	                        }
	                        if (s0 === peg$FAILED) {
	                            if (peg$c31.test(input.charAt(peg$currPos))) {
	                                s0 = input.charAt(peg$currPos);
	                                peg$currPos++;
	                            }
	                            else {
	                                s0 = peg$FAILED;
	                                if (peg$silentFails === 0) {
	                                    peg$fail(peg$c32);
	                                }
	                            }
	                            if (s0 === peg$FAILED) {
	                                if (peg$c33.test(input.charAt(peg$currPos))) {
	                                    s0 = input.charAt(peg$currPos);
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s0 = peg$FAILED;
	                                    if (peg$silentFails === 0) {
	                                        peg$fail(peg$c34);
	                                    }
	                                }
	                                if (s0 === peg$FAILED) {
	                                    if (input.charCodeAt(peg$currPos) === 63) {
	                                        s0 = peg$c35;
	                                        peg$currPos++;
	                                    }
	                                    else {
	                                        s0 = peg$FAILED;
	                                        if (peg$silentFails === 0) {
	                                            peg$fail(peg$c36);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            return s0;
	        }
	        peg$result = peg$startRuleFunction();
	        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	            return peg$result;
	        }
	        else {
	            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	                peg$fail({ type: "end", description: "end of input" });
	            }
	            throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length
	                ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
	                : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
	        }
	    }
	    return {
	        SyntaxError: peg$SyntaxError,
	        parse: peg$parse
	    };
	})();
	module.exports = parser;
	//# sourceMappingURL=typeExpressionParser.js.map

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Stream;

	var EE = __webpack_require__(201).EventEmitter;
	var inherits = __webpack_require__(228);

	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(221);
	Stream.Writable = __webpack_require__(222);
	Stream.Duplex = __webpack_require__(223);
	Stream.Transform = __webpack_require__(224);
	Stream.PassThrough = __webpack_require__(225);

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;



	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.

	function Stream() {
	  EE.call(this);
	}

	Stream.prototype.pipe = function(dest, options) {
	  var source = this;

	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }

	  source.on('data', ondata);

	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }

	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }

	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    dest.end();
	  }


	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }

	  source.on('error', onerror);
	  dest.on('error', onerror);

	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);

	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);

	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);

	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);

	    dest.removeListener('close', cleanup);
	  }

	  source.on('end', cleanup);
	  source.on('close', cleanup);

	  dest.on('close', cleanup);

	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
	//     http://underscorejs.org
	//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind,
	    nativeCreate       = Object.create;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.8.3';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      case 2: return function(value, other) {
	        return func.call(context, value, other);
	      };
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };

	  // A mostly-internal function to generate callbacks that can be applied
	  // to each element in a collection, returning the desired result  either
	  // identity, an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value)) return _.matcher(value);
	    return _.property(value);
	  };
	  _.iteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };

	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, undefinedOnly) {
	    return function(obj) {
	      var length = arguments.length;
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };

	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };

	  var property = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = property('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };

	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Optimized iterator function as using arguments.length
	    // in the main function will deoptimize the, see #1991.
	    function iterator(obj, iteratee, memo, keys, index, length) {
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    }

	    return function(obj, iteratee, memo, context) {
	      iteratee = optimizeCb(iteratee, context, 4);
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      // Determine the initial value if none is provided.
	      if (arguments.length < 3) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      return iterator(obj, iteratee, memo, keys, index, length);
	    };
	  }

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var key;
	    if (isArrayLike(obj)) {
	      key = _.findIndex(obj, predicate, context);
	    } else {
	      key = _.findKey(obj, predicate, context);
	    }
	    if (key !== void 0 && key !== -1) return obj[key];
	  };

	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };

	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      var func = isFunc ? method : value[method];
	      return func == null ? func : func.apply(value, args);
	    });
	  };

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };

	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Shuffle a collection, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
	  _.shuffle = function(obj) {
	    var set = isArrayLike(obj) ? obj : _.values(obj);
	    var length = set.length;
	    var shuffled = Array(length);
	    for (var index = 0, rand; index < length; index++) {
	      rand = _.random(0, index);
	      if (rand !== index) shuffled[index] = shuffled[rand];
	      shuffled[rand] = set[index];
	    }
	    return shuffled;
	  };

	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };

	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iteratee(value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iteratee, context) {
	      var result = {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key]++; else result[key] = 1;
	  });

	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var pass = [], fail = [];
	    _.each(obj, function(value, key, obj) {
	      (predicate(value, key, obj) ? pass : fail).push(value);
	    });
	    return [pass, fail];
	  };

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, startIndex) {
	    var output = [], idx = 0;
	    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        //flatten current level of array or arguments object
	        if (!shallow) value = flatten(value, shallow, strict);
	        var j = 0, len = value.length;
	        output.length += len;
	        while (j < len) {
	          output[idx++] = value[j++];
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(flatten(arguments, true, true));
	  };

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      for (var j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = flatten(arguments, true, true, 1);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    return _.unzip(arguments);
	  };

	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // Generator function to create the findIndex and findLastIndex functions
	  function createPredicateIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }

	  // Returns the first index on an array-like that passes a predicate test
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };

	  // Generator function to create the indexOf and lastIndexOf functions
	  function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	            i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  }

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = step || 1;

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var args = slice.call(arguments, 2);
	    var bound = function() {
	      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
	    };
	    return bound;
	  };

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  };

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var i, length = arguments.length, key;
	    if (length <= 1) throw new Error('bindAll must be passed function names');
	    for (i = 1; i < length; i++) {
	      key = arguments[i];
	      obj[key] = _.bind(obj[key], obj);
	    }
	    return obj;
	  };

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){
	      return func.apply(null, args);
	    }, wait);
	  };

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    if (!options) options = {};
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;

	    var later = function() {
	      var last = _.now() - timestamp;

	      if (last < wait && last >= 0) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          if (!timeout) context = args = null;
	        }
	      }
	    };

	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) timeout = setTimeout(later, wait);
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }

	      return result;
	    };
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };

	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };

	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  function collectNonEnumProps(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  }

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Returns the results of applying the iteratee to each element of the object
	  // In contrast to _.map it returns an object
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys =  _.keys(obj),
	          length = keys.length,
	          results = {},
	          currentKey;
	      for (var index = 0; index < length; index++) {
	        currentKey = keys[index];
	        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	      }
	      return results;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s)
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);

	  // Returns the first key on an object that passes a predicate test
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(object, oiteratee, context) {
	    var result = {}, obj = object, iteratee, keys;
	    if (obj == null) return result;
	    if (_.isFunction(oiteratee)) {
	      keys = _.allKeys(obj);
	      iteratee = optimizeCb(oiteratee, context);
	    } else {
	      keys = flatten(arguments, false, false, 1);
	      iteratee = function(value, key, obj) { return key in obj; };
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  };

	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj, iteratee, context) {
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	    } else {
	      var keys = _.map(flatten(arguments, false, false, 1), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  };

	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };


	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return _.has(obj, 'callee');
	    };
	  }

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), and in Safari 8 (#1929).
	  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj !== +obj;
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return obj != null && hasOwnProperty.call(obj, key);
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };

	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };

	  _.noop = function(){};

	  _.property = property;

	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    return obj == null ? function(){} : function(key) {
	      return obj[key];
	    };
	  };

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };

	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };

	   // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);

	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property, fallback) {
	    var value = object == null ? void 0 : object[property];
	    if (value === void 0) {
	      value = fallback;
	    }
	    return _.isFunction(value) ? value.call(object) : value;
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escaper, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offest.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    try {
	      var render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var result = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result(this, func.apply(_, args));
	      };
	    });
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return result(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return '' + this._wrapped;
	  };

	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}.call(this));


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	
	var indexOf = [].indexOf;

	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array

		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)

		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}

		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length

			var L = 0

			function push (v) {
				arr[L++] = v
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}

			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}

			return arr
		}

		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length

			function encode (num) {
				return lookup.charAt(num)
			}

			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}

			return output
		}

		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	function DOMParser(options){
		this.options = options ||{locator:{}};
		
	}
	DOMParser.prototype.parseFromString = function(source,mimeType){	
		var options = this.options;
		var sax =  new XMLReader();
		var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
		var errorHandler = options.errorHandler;
		var locator = options.locator;
		var defaultNSMap = options.xmlns||{};
		var entityMap = {'lt':'<','gt':'>','amp':'&','quot':'"','apos':"'"}
		if(locator){
			domBuilder.setDocumentLocator(locator)
		}
		
		sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
		sax.domBuilder = options.domBuilder || domBuilder;
		if(/\/x?html?$/.test(mimeType)){
			entityMap.nbsp = '\xa0';
			entityMap.copy = '\xa9';
			defaultNSMap['']= 'http://www.w3.org/1999/xhtml';
		}
		defaultNSMap.xml = defaultNSMap.xml || 'http://www.w3.org/XML/1998/namespace';
		if(source){
			sax.parse(source,defaultNSMap,entityMap);
		}else{
			sax.errorHandler.error("invalid document source");
		}
		return domBuilder.document;
	}
	function buildErrorHandler(errorImpl,domBuilder,locator){
		if(!errorImpl){
			if(domBuilder instanceof DOMHandler){
				return domBuilder;
			}
			errorImpl = domBuilder ;
		}
		var errorHandler = {}
		var isCallback = errorImpl instanceof Function;
		locator = locator||{}
		function build(key){
			var fn = errorImpl[key];
			if(!fn && isCallback){
				fn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;
			}
			errorHandler[key] = fn && function(msg){
				fn('[xmldom '+key+']\t'+msg+_locator(locator));
			}||function(){};
		}
		build('warning');
		build('error');
		build('fatalError');
		return errorHandler;
	}

	//console.log('#\n\n\n\n\n\n\n####')
	/**
	 * +ContentHandler+ErrorHandler
	 * +LexicalHandler+EntityResolver2
	 * -DeclHandler-DTDHandler 
	 * 
	 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
	 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
	 */
	function DOMHandler() {
	    this.cdata = false;
	}
	function position(locator,node){
		node.lineNumber = locator.lineNumber;
		node.columnNumber = locator.columnNumber;
	}
	/**
	 * @see org.xml.sax.ContentHandler#startDocument
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
	 */ 
	DOMHandler.prototype = {
		startDocument : function() {
	    	this.document = new DOMImplementation().createDocument(null, null, null);
	    	if (this.locator) {
	        	this.document.documentURI = this.locator.systemId;
	    	}
		},
		startElement:function(namespaceURI, localName, qName, attrs) {
			var doc = this.document;
		    var el = doc.createElementNS(namespaceURI, qName||localName);
		    var len = attrs.length;
		    appendElement(this, el);
		    this.currentElement = el;
		    
			this.locator && position(this.locator,el)
		    for (var i = 0 ; i < len; i++) {
		        var namespaceURI = attrs.getURI(i);
		        var value = attrs.getValue(i);
		        var qName = attrs.getQName(i);
				var attr = doc.createAttributeNS(namespaceURI, qName);
				if( attr.getOffset){
					position(attr.getOffset(1),attr)
				}
				attr.value = attr.nodeValue = value;
				el.setAttributeNode(attr)
		    }
		},
		endElement:function(namespaceURI, localName, qName) {
			var current = this.currentElement
		    var tagName = current.tagName;
		    this.currentElement = current.parentNode;
		},
		startPrefixMapping:function(prefix, uri) {
		},
		endPrefixMapping:function(prefix) {
		},
		processingInstruction:function(target, data) {
		    var ins = this.document.createProcessingInstruction(target, data);
		    this.locator && position(this.locator,ins)
		    appendElement(this, ins);
		},
		ignorableWhitespace:function(ch, start, length) {
		},
		characters:function(chars, start, length) {
			chars = _toString.apply(this,arguments)
			//console.log(chars)
			if(this.currentElement && chars){
				if (this.cdata) {
					var charNode = this.document.createCDATASection(chars);
					this.currentElement.appendChild(charNode);
				} else {
					var charNode = this.document.createTextNode(chars);
					this.currentElement.appendChild(charNode);
				}
				this.locator && position(this.locator,charNode)
			}
		},
		skippedEntity:function(name) {
		},
		endDocument:function() {
			this.document.normalize();
		},
		setDocumentLocator:function (locator) {
		    if(this.locator = locator){// && !('lineNumber' in locator)){
		    	locator.lineNumber = 0;
		    }
		},
		//LexicalHandler
		comment:function(chars, start, length) {
			chars = _toString.apply(this,arguments)
		    var comm = this.document.createComment(chars);
		    this.locator && position(this.locator,comm)
		    appendElement(this, comm);
		},
		
		startCDATA:function() {
		    //used in characters() methods
		    this.cdata = true;
		},
		endCDATA:function() {
		    this.cdata = false;
		},
		
		startDTD:function(name, publicId, systemId) {
			var impl = this.document.implementation;
		    if (impl && impl.createDocumentType) {
		        var dt = impl.createDocumentType(name, publicId, systemId);
		        this.locator && position(this.locator,dt)
		        appendElement(this, dt);
		    }
		},
		/**
		 * @see org.xml.sax.ErrorHandler
		 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
		 */
		warning:function(error) {
			console.warn('[xmldom warning]\t'+error,_locator(this.locator));
		},
		error:function(error) {
			console.error('[xmldom error]\t'+error,_locator(this.locator));
		},
		fatalError:function(error) {
			console.error('[xmldom fatalError]\t'+error,_locator(this.locator));
		    throw error;
		}
	}
	function _locator(l){
		if(l){
			return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
		}
	}
	function _toString(chars,start,length){
		if(typeof chars == 'string'){
			return chars.substr(start,length)
		}else{//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
			if(chars.length >= start+length || start){
				return new java.lang.String(chars,start,length)+'';
			}
			return chars;
		}
	}

	/*
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
	 * used method of org.xml.sax.ext.LexicalHandler:
	 *  #comment(chars, start, length)
	 *  #startCDATA()
	 *  #endCDATA()
	 *  #startDTD(name, publicId, systemId)
	 *
	 *
	 * IGNORED method of org.xml.sax.ext.LexicalHandler:
	 *  #endDTD()
	 *  #startEntity(name)
	 *  #endEntity(name)
	 *
	 *
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
	 * IGNORED method of org.xml.sax.ext.DeclHandler
	 * 	#attributeDecl(eName, aName, type, mode, value)
	 *  #elementDecl(name, model)
	 *  #externalEntityDecl(name, publicId, systemId)
	 *  #internalEntityDecl(name, value)
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
	 * IGNORED method of org.xml.sax.EntityResolver2
	 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
	 *  #resolveEntity(publicId, systemId)
	 *  #getExternalSubset(name, baseURI)
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
	 * IGNORED method of org.xml.sax.DTDHandler
	 *  #notationDecl(name, publicId, systemId) {};
	 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
	 */
	"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
		DOMHandler.prototype[key] = function(){return null}
	})

	/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
	function appendElement (hander,node) {
	    if (!hander.currentElement) {
	        hander.document.appendChild(node);
	    } else {
	        hander.currentElement.appendChild(node);
	    }
	}//appendChild and setAttributeNS are preformance key

	if(true){
		var XMLReader = __webpack_require__(198).XMLReader;
		var DOMImplementation = exports.DOMImplementation = __webpack_require__(199).DOMImplementation;
		exports.XMLSerializer = __webpack_require__(199).XMLSerializer ;
		exports.DOMParser = DOMParser;
	}


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	var JsonSchemaCompatability = (function () {

		function convert3to4Type(types, always) {
			if (!Array.isArray(types)) {
				types = [types];
			}
			var needsReplacement = !!always;
			var result = [];
			for (var i = 0; i < types.length; i++) {
				var entry = types[i];
				if (typeof entry === 'object') {
					result.push(entry);
					needsReplacement = true;
				} else {
					result.push({"type": entry});
				}
			}
			return needsReplacement && result;
		}

		function convert3to4(obj) {
			// Old-style "type"
			if (obj.type) {
				if (typeof obj.type !== 'string') {
					var anyOf = convert3to4Type(obj.type);
					if (anyOf) {
						obj.anyOf = anyOf;
						delete obj.type;
					}
				}
				else if (obj.type == 'any') {
					delete obj.type;
				}
			}
			if (obj['extends']) {
				var allOf = obj['extends'];
				if (!Array.isArray(allOf)) {
					allOf = [allOf];
				}
				obj.allOf = allOf;
				delete obj['extends'];
			}
			if (obj.disallow) {
				if (typeof obj.disallow === 'string') {
					obj.not = {"type": obj.disallow};
				} else {
					obj.not = {"anyOf": convert3to4Type(obj.disallow, true)};
				}
				delete obj.disallow;
			}

			// Object concerns
			if (obj.properties) {
				var required = Array.isArray(obj.required) ? obj.required : [];
				for (var key in obj.properties) {
					var subSchema = obj.properties[key];
					if (subSchema && typeof subSchema.required === 'boolean') {
						if (subSchema.required) {
							required.push(key);
						}
						delete subSchema.required;
					}
				}
				if (required.length) {
					obj.required = required;
				}
			}
			if (obj.dependencies) {
				for (var key in obj.dependencies) {
					if (typeof obj.dependencies[key] === 'string') {
						obj.dependencies[key] = [obj.dependencies[key]];
					}
				}
			}
			// This is safe as long as we process our children *after* we collect their "required" properties
			// - otherwise, they'd delete their "required" booleans before we got a chance to see them
			if (typeof obj.required === 'boolean') {
				delete obj.required;
			}
			
			// Numeric concerns
			if (typeof obj.divisibleBy !== 'undefined') {
				obj.multipleOf = obj.divisibleBy;
				delete obj.divisibleBy;
			}
			
			// This MUST happen at the end of the function, otherwise it'll screw up "required" collection
			for (var key in obj) {
				if (key === "properties" || key === "patternProperties" || key === "dependencies") {
					for (var subKey in obj[key]) {
						obj[key][subKey] = convert3to4(obj[key][subKey]);
					}
				} else if (key !== "enum") {
					if (Array.isArray(obj[key])) {
						for (var i = 0; i < obj[key].length; i++) {
							obj[key][i] = convert3to4(obj[key][i]);
						}
					} else if (typeof obj[key] === "object") {
						obj[key] = convert3to4(obj[key]);
					}
				}
			}
			return obj;
		}

		var api = {
			v4: convert3to4
		};
		
		if (true) {
			module.exports = api;
		}
		return api;
	})();

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [
		{
			"code": "1xx",
			"phrase": "**Informational**",
			"description": "\"indicates an interim response for communicating connection status or request progress prior to completing the requested action and sending a final response.\" ~ [sure](http://www.urbandictionary.com/define.php?term=sure)",
			"spec_title": "RFC7231#6.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.2"
		},
		{
			"code": "100",
			"phrase": "Continue",
			"description": "\"indicates that the initial part of a request has been received and has not yet been rejected by the server.\"",
			"spec_title": "RFC7231#6.2.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.2.1"
		},
		{
			"code": "101",
			"phrase": "Switching Protocols",
			"description": "\"indicates that the server understands and is willing to comply with the client's request, via the Upgrade header field, for a change in the application protocol being used on this connection.\"",
			"spec_title": "RFC7231#6.2.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.2.2"
		},
		{
			"code": "2xx",
			"phrase": "**Successful**",
			"description": "\"indicates that the client's request was successfully received, understood, and accepted.\" ~ [cool](https://twitter.com/DanaDanger/status/183316183494311936)",
			"spec_title": "RFC7231#6.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3"
		},
		{
			"code": "200",
			"phrase": "OK",
			"description": "\"indicates that the request has succeeded.\"",
			"spec_title": "RFC7231#6.3.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.1"
		},
		{
			"code": "201",
			"phrase": "Created",
			"description": "\"indicates that the request has been fulfilled and has resulted in one or more new resources being created.\"",
			"spec_title": "RFC7231#6.3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.2"
		},
		{
			"code": "202",
			"phrase": "Accepted",
			"description": "\"indicates that the request has been accepted for processing, but the processing has not been completed.\"",
			"spec_title": "RFC7231#6.3.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.3"
		},
		{
			"code": "203",
			"phrase": "Non-Authoritative Information",
			"description": "\"indicates that the request was successful but the enclosed payload has been modified from that of the origin server's 200 (OK) response by a transforming proxy.\"",
			"spec_title": "RFC7231#6.3.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.4"
		},
		{
			"code": "204",
			"phrase": "No Content",
			"description": "\"indicates that the server has successfully fulfilled the request and that there is no additional content to send in the response payload body.\"",
			"spec_title": "RFC7231#6.3.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.5"
		},
		{
			"code": "205",
			"phrase": "Reset Content",
			"description": "\"indicates that the server has fulfilled the request and desires that the user agent reset the \"document view\", which caused the request to be sent, to its original state as received from the origin server.\"",
			"spec_title": "RFC7231#6.3.6",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.6"
		},
		{
			"code": "206",
			"phrase": "Partial Content",
			"description": "\"indicates that the server is successfully fulfilling a range request for the target resource by transferring one or more parts of the selected representation that correspond to the satisfiable ranges found in the requests's Range header field.\"",
			"spec_title": "RFC7233#4.1",
			"spec_href": "http://tools.ietf.org/html/rfc7233#section-4.1"
		},
		{
			"code": "3xx",
			"phrase": "**Redirection**",
			"description": "\"indicates that further action needs to be taken by the user agent in order to fulfill the request.\" ~ [ask that dude over there](https://twitter.com/DanaDanger/status/183316183494311936)",
			"spec_title": "RFC7231#6.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4"
		},
		{
			"code": "300",
			"phrase": "Multiple Choices",
			"description": "\"indicates that the target resource has more than one representation, each with its own more specific identifier, and information about the alternatives is being provided so that the user (or user agent) can select a preferred representation by redirecting its request to one or more of those identifiers.\"",
			"spec_title": "RFC7231#6.4.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4.1"
		},
		{
			"code": "301",
			"phrase": "Moved Permanently",
			"description": "\"indicates that the target resource has been assigned a new permanent URI and any future references to this resource ought to use one of the enclosed URIs.\"",
			"spec_title": "RFC7231#6.4.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4.2"
		},
		{
			"code": "302",
			"phrase": "Found",
			"description": "\"indicates that the target resource resides temporarily under a different URI.\"",
			"spec_title": "RFC7231#6.4.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4.3"
		},
		{
			"code": "303",
			"phrase": "See Other",
			"description": "\"indicates that the server is redirecting the user agent to a different resource, as indicated by a URI in the Location header field, that is intended to provide an indirect response to the original request.\"",
			"spec_title": "RFC7231#6.4.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4.4"
		},
		{
			"code": "304",
			"phrase": "Not Modified",
			"description": "\"indicates that a conditional GET request has been received and would have resulted in a 200 (OK) response if it were not for the fact that the condition has evaluated to false.\"",
			"spec_title": "RFC7232#4.1",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-4.1"
		},
		{
			"code": "305",
			"phrase": "Use Proxy",
			"description": "*deprecated*",
			"spec_title": "RFC7231#6.4.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4.5"
		},
		{
			"code": "307",
			"phrase": "Temporary Redirect",
			"description": "\"indicates that the target resource resides temporarily under a different URI and the user agent MUST NOT change the request method if it performs an automatic redirection to that URI.\"",
			"spec_title": "RFC7231#6.4.7",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4.7"
		},
		{
			"code": "4xx",
			"phrase": "**Client Error**",
			"description": "\"indicates that the client seems to have erred.\" ~ [*you* fucked up](https://twitter.com/DanaDanger/status/183316183494311936)",
			"spec_title": "RFC7231#6.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5"
		},
		{
			"code": "400",
			"phrase": "Bad Request",
			"description": "\"indicates that the server cannot or will not process the request because the received syntax is invalid, nonsensical, or exceeds some limitation on what the server is willing to process.\"",
			"spec_title": "RFC7231#6.5.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.1"
		},
		{
			"code": "401",
			"phrase": "Unauthorized",
			"description": "\"indicates that the request has not been applied because it lacks valid authentication credentials for the target resource.\"",
			"spec_title": "RFC7235#6.3.1",
			"spec_href": "http://tools.ietf.org/html/rfc7235#section-3.1"
		},
		{
			"code": "402",
			"phrase": "Payment Required",
			"description": "*reserved*",
			"spec_title": "RFC7231#6.5.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.2"
		},
		{
			"code": "403",
			"phrase": "Forbidden",
			"description": "\"indicates that the server understood the request but refuses to authorize it.\"",
			"spec_title": "RFC7231#6.5.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.3"
		},
		{
			"code": "404",
			"phrase": "Not Found",
			"description": "\"indicates that the origin server did not find a current representation for the target resource or is not willing to disclose that one exists.\"",
			"spec_title": "RFC7231#6.5.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.4"
		},
		{
			"code": "405",
			"phrase": "Method Not Allowed",
			"description": "\"indicates that the method specified in the request-line is known by the origin server but not supported by the target resource.\"",
			"spec_title": "RFC7231#6.5.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.5"
		},
		{
			"code": "406",
			"phrase": "Not Acceptable",
			"description": "\"indicates that the target resource does not have a current representation that would be acceptable to the user agent, according to the proactive negotiation header fields received in the request, and the server is unwilling to supply a default representation.\"",
			"spec_title": "RFC7231#6.5.6",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.6"
		},
		{
			"code": "407",
			"phrase": "Proxy Authentication Required",
			"description": "\"is similar to 401 (Unauthorized), but indicates that the client needs to authenticate itself in order to use a proxy.\"",
			"spec_title": "RFC7231#6.3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.2"
		},
		{
			"code": "408",
			"phrase": "Request Timeout",
			"description": "\"indicates that the server did not receive a complete request message within the time that it was prepared to wait.\"",
			"spec_title": "RFC7231#6.5.7",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.7"
		},
		{
			"code": "409",
			"phrase": "Conflict",
			"description": "\"indicates that the request could not be completed due to a conflict with the current state of the resource.\"",
			"spec_title": "RFC7231#6.5.8",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.8"
		},
		{
			"code": "410",
			"phrase": "Gone",
			"description": "\"indicates that access to the target resource is no longer available at the origin server and that this condition is likely to be permanent.\"",
			"spec_title": "RFC7231#6.5.9",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.9"
		},
		{
			"code": "411",
			"phrase": "Length Required",
			"description": "\"indicates that the server refuses to accept the request without a defined Content-Length.\"",
			"spec_title": "RFC7231#6.5.10",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.10"
		},
		{
			"code": "412",
			"phrase": "Precondition Failed",
			"description": "\"indicates that one or more preconditions given in the request header fields evaluated to false when tested on the server.\"",
			"spec_title": "RFC7232#4.2",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-4.2"
		},
		{
			"code": "413",
			"phrase": "Payload Too Large",
			"description": "\"indicates that the server is refusing to process a request because the request payload is larger than the server is willing or able to process.\"",
			"spec_title": "RFC7231#6.5.11",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.11"
		},
		{
			"code": "414",
			"phrase": "URI Too Long",
			"description": "\"indicates that the server is refusing to service the request because the request-target is longer than the server is willing to interpret.\"",
			"spec_title": "RFC7231#6.5.12",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.12"
		},
		{
			"code": "415",
			"phrase": "Unsupported Media Type",
			"description": "\"indicates that the origin server is refusing to service the request because the payload is in a format not supported by the target resource for this method.\"",
			"spec_title": "RFC7231#6.5.13",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.13"
		},
		{
			"code": "416",
			"phrase": "Range Not Satisfiable",
			"description": "\"indicates that none of the ranges in the request's Range header field overlap the current extent of the selected resource or that the set of ranges requested has been rejected due to invalid ranges or an excessive request of small or overlapping ranges.\"",
			"spec_title": "RFC7233#4.4",
			"spec_href": "http://tools.ietf.org/html/rfc7233#section-4.4"
		},
		{
			"code": "417",
			"phrase": "Expectation Failed",
			"description": "\"indicates that the expectation given in the request's Expect header field could not be met by at least one of the inbound servers.\"",
			"spec_title": "RFC7231#6.5.14",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.14"
		},
		{
			"code": "426",
			"phrase": "Upgrade Required",
			"description": "\"indicates that the server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol.\"",
			"spec_title": "RFC7231#6.5.15",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.15"
		},
		{
			"code": "5xx",
			"phrase": "**Server Error**",
			"description": "\"indicates that the server is aware that it has erred or is incapable of performing the requested method.\" ~ [*we* fucked up](https://twitter.com/DanaDanger/status/183316183494311936)",
			"spec_title": "RFC7231#6.6",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6"
		},
		{
			"code": "500",
			"phrase": "Internal Server Error",
			"description": "\"indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.\"",
			"spec_title": "RFC7231#6.6.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6.1"
		},
		{
			"code": "501",
			"phrase": "Not Implemented",
			"description": "\"indicates that the server does not support the functionality required to fulfill the request.\"",
			"spec_title": "RFC7231#6.6.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6.2"
		},
		{
			"code": "502",
			"phrase": "Bad Gateway",
			"description": "\"indicates that the server, while acting as a gateway or proxy, received an invalid response from an inbound server it accessed while attempting to fulfill the request.\"",
			"spec_title": "RFC7231#6.6.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6.3"
		},
		{
			"code": "503",
			"phrase": "Service Unavailable",
			"description": "\"indicates that the server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.\"",
			"spec_title": "RFC7231#6.6.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6.4"
		},
		{
			"code": "504",
			"phrase": "Gateway Time-out",
			"description": "\"indicates that the server, while acting as a gateway or proxy, did not receive a timely response from an upstream server it needed to access in order to complete the request.\"",
			"spec_title": "RFC7231#6.6.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6.5"
		},
		{
			"code": "505",
			"phrase": "HTTP Version Not Supported",
			"description": "\"indicates that the server does not support, or refuses to support, the protocol version that was used in the request message.\"",
			"spec_title": "RFC7231#6.6.6",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6.6"
		},
		{
			"code": "102",
			"phrase": "Processing",
			"description": "\"is an interim response used to inform the client that the server has accepted the complete request, but has not yet completed it.\"",
			"spec_title": "RFC5218#10.1",
			"spec_href": "http://tools.ietf.org/html/rfc2518#section-10.1"
		},
		{
			"code": "207",
			"phrase": "Multi-Status",
			"description": "\"provides status for multiple independent operations.\"",
			"spec_title": "RFC5218#10.2",
			"spec_href": "http://tools.ietf.org/html/rfc2518#section-10.2"
		},
		{
			"code": "226",
			"phrase": "IM Used",
			"description": "\"The server has fulfilled a GET request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.\"",
			"spec_title": "RFC3229#10.4.1",
			"spec_href": "http://tools.ietf.org/html/rfc3229#section-10.4.1"
		},
		{
			"code": "308",
			"phrase": "Permanent Redirect",
			"description": "\"The target resource has been assigned a new permanent URI and any future references to this resource SHOULD use one of the returned URIs. [...] This status code is similar to 301 Moved Permanently (Section 7.3.2 of rfc7231), except that it does not allow rewriting the request method from POST to GET.\"",
			"spec_title": "RFC7238",
			"spec_href": "http://tools.ietf.org/html/rfc7238"
		},
		{
			"code": "422",
			"phrase": "Unprocessable Entity",
			"description": "\"means the server understands the content type of the request entity (hence a 415(Unsupported Media Type) status code is inappropriate), and the syntax of the request entity is correct (thus a 400 (Bad Request) status code is inappropriate) but was unable to process the contained instructions.\"",
			"spec_title": "RFC5218#10.3",
			"spec_href": "http://tools.ietf.org/html/rfc2518#section-10.3"
		},
		{
			"code": "423",
			"phrase": "Locked",
			"description": "\"means the source or destination resource of a method is locked.\"",
			"spec_title": "RFC5218#10.4",
			"spec_href": "http://tools.ietf.org/html/rfc2518#section-10.4"
		},
		{
			"code": "424",
			"phrase": "Failed Dependency",
			"description": "\"means that the method could not be performed on the resource because the requested action depended on another action and that action failed.\"",
			"spec_title": "RFC5218#10.5",
			"spec_href": "http://tools.ietf.org/html/rfc2518#section-10.5"
		},
		{
			"code": "428",
			"phrase": "Precondition Required",
			"description": "\"indicates that the origin server requires the request to be conditional.\"",
			"spec_title": "RFC6585#3",
			"spec_href": "http://tools.ietf.org/html/rfc6585#section-3"
		},
		{
			"code": "429",
			"phrase": "Too Many Requests",
			"description": "\"indicates that the user has sent too many requests in a given amount of time (\"rate limiting\").\"",
			"spec_title": "RFC6585#4",
			"spec_href": "http://tools.ietf.org/html/rfc6585#section-4"
		},
		{
			"code": "431",
			"phrase": "Request Header Fields Too Large",
			"description": "\"indicates that the server is unwilling to process the request because its header fields are too large.\"",
			"spec_title": "RFC6585#5",
			"spec_href": "http://tools.ietf.org/html/rfc6585#section-5"
		},
		{
			"code": "451",
			"phrase": "Unavailable For Legal Reasons",
			"description": "\"This status code indicates that the server is denying access to the resource in response to a legal demand.\"",
			"spec_title": "draft-tbray-http-legally-restricted-status",
			"spec_href": "http://tools.ietf.org/html/draft-tbray-http-legally-restricted-status"
		},
		{
			"code": "506",
			"phrase": "Variant Also Negotiates",
			"description": "\"indicates that the server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself, and is therefore not a proper end point in the negotiation process.\"",
			"spec_title": "RFC2295#8.1",
			"spec_href": "http://tools.ietf.org/html/rfc2295#section-8.1"
		},
		{
			"code": "507",
			"phrase": "Insufficient Storage",
			"description": "\"means the method could not be performed on the resource because the server is unable to store the representation needed to successfully complete the request.\"",
			"spec_title": "RFC5218#10.6",
			"spec_href": "http://tools.ietf.org/html/rfc2518#section-10.6"
		},
		{
			"code": "511",
			"phrase": "Network Authentication Required",
			"description": "\"indicates that the client needs to authenticate to gain network access.\"",
			"spec_title": "RFC6585#6",
			"spec_href": "http://tools.ietf.org/html/rfc6585#section-6"
		},
		{
			"code": "7xx",
			"phrase": "**Developer Error**",
			"description": "[err](http://www.urbandictionary.com/define.php?term=err)",
			"spec_title": "7xx-rfc",
			"spec_href": "http://documentup.com/joho/7XX-rfc"
		}
	];

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [
		{
			"method": "CONNECT",
			"description": "\"requests that the recipient establish a tunnel to the destination origin server identified by the request-target and, if successful, thereafter restrict its behavior to blind forwarding of packets, in both directions, until the connection is closed.\"",
			"safe": true,
			"idempotent": true,
			"cacheable": false,
			"spec_title": "RFC7231#4.3.6",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.6"
		},
		{
			"method": "DELETE",
			"description": "\"requests that the origin server remove the association between the target resource and its current functionality.\"",
			"safe": false,
			"idempotent": true,
			"cacheable": false,
			"spec_title": "RFC7231#4.3.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.5"
		},
		{
			"method": "GET",
			"description": "\"requests transfer of a current selected representation for the target resource.\"",
			"safe": true,
			"idempotent": true,
			"cacheable": true,
			"spec_title": "RFC7231#4.3.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.1"
		},
		{
			"method": "HEAD",
			"description": "\"is identical to GET except that the server MUST NOT send a message body in the response (i.e., the response terminates at the end of the header block).\"",
			"safe": true,
			"idempotent": true,
			"cacheable": true,
			"spec_title": "RFC7231#4.3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.2"
		},
		{
			"method": "OPTIONS",
			"description": "\"requests information about the communication options available on the request/response chain identified by the effective request URI.\"",
			"safe": true,
			"idempotent": true,
			"cacheable": false,
			"spec_title": "RFC7231#4.3.7",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.7"
		},
		{
			"method": "POST",
			"description": "\"requests that the target resource process the representation enclosed in the request according to the resource's own specific semantics.\"",
			"safe": false,
			"idempotent": false,
			"cacheable": false,
			"spec_title": "RFC7231#4.3.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.3"
		},
		{
			"method": "PUT",
			"description": "\"requests that the state of the target resource be created or replaced with the state defined by the representation enclosed in the request message payload.\"",
			"safe": false,
			"idempotent": true,
			"cacheable": false,
			"spec_title": "RFC7231#4.3.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.4"
		},
		{
			"method": "TRACE",
			"description": "\"is used to invoke a remote, application-layer loopback of the request message.\"",
			"safe": true,
			"idempotent": true,
			"cacheable": false,
			"spec_title": "RFC7231#4.3.8",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.8"
		},
		{
			"method": "ACL",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3744#8.1",
			"spec_href": "http://tools.ietf.org/html/rfc3744#section-8.1"
		},
		{
			"method": "BASELINE-CONTROL",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#12.6",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-12.6"
		},
		{
			"method": "BIND",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC5842#4",
			"spec_href": "http://tools.ietf.org/html/rfc5842#section-4"
		},
		{
			"method": "CHECKIN",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#4.4",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-4.4"
		},
		{
			"method": "CHECKOUT",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#4.3",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-4.3"
		},
		{
			"method": "COPY",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4918#9.8",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.8"
		},
		{
			"method": "LABEL",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#8.2",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-8.2"
		},
		{
			"method": "LINK",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC2068#19.6.1.2",
			"spec_href": "http://tools.ietf.org/html/rfc2068#section-19.6.1.2"
		},
		{
			"method": "LOCK",
			"description": "",
			"safe": false,
			"idempotent": false,
			"cacheable": "",
			"spec_title": "RFC4918#9.10",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.10"
		},
		{
			"method": "MERGE",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#11.2",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-11.2"
		},
		{
			"method": "MKACTIVITY",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#13.5",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-13.5"
		},
		{
			"method": "MKCALENDAR",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4791#5.3.1",
			"spec_href": "http://tools.ietf.org/html/rfc4791#section-5.3.1"
		},
		{
			"method": "MKCOL",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4918#9.3",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.3"
		},
		{
			"method": "MKREDIRECTREF",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4437#6",
			"spec_href": "http://tools.ietf.org/html/rfc4437#section-6"
		},
		{
			"method": "MKWORKSPACE",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#6.3",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-6.3"
		},
		{
			"method": "MOVE",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4918#9.9",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.9"
		},
		{
			"method": "ORDERPATCH",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3648#7",
			"spec_href": "http://tools.ietf.org/html/rfc3648#section-7"
		},
		{
			"method": "PATCH",
			"description": "\"requests that a set of changes described in the request entity be applied to the resource identified by the Request-URI.\"",
			"safe": false,
			"idempotent": false,
			"cacheable": false,
			"spec_title": "RFC5789",
			"spec_href": "http://tools.ietf.org/html/rfc5789#section-2"
		},
		{
			"method": "PROPFIND",
			"description": "",
			"safe": true,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4918#9.1",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.1"
		},
		{
			"method": "PROPPATCH",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4918#9.2",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.2"
		},
		{
			"method": "REBIND",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC5842#6",
			"spec_href": "http://tools.ietf.org/html/rfc5842#section-6"
		},
		{
			"method": "REPORT",
			"description": "",
			"safe": true,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#3.6",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-3.6"
		},
		{
			"method": "SEARCH",
			"description": "",
			"safe": true,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC5323#2",
			"spec_href": "http://tools.ietf.org/html/rfc5323#section-2"
		},
		{
			"method": "UNBIND",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC5842#5",
			"spec_href": "http://tools.ietf.org/html/rfc5842#section-5"
		},
		{
			"method": "UNCHECKOUT",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#4.5",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-4.5"
		},
		{
			"method": "UNLINK",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC2068#19.6.1.3",
			"spec_href": "http://tools.ietf.org/html/rfc2068#section-19.6.1.3"
		},
		{
			"method": "UNLOCK",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4918#9.11",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.11"
		},
		{
			"method": "UPDATE",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#7.1",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-7.1"
		},
		{
			"method": "UPDATEREDIRECTREF",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4437#7",
			"spec_href": "http://tools.ietf.org/html/rfc4437#section-7"
		},
		{
			"method": "VERSION-CONTROL",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#3.5",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-3.5"
		}
	];

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [
		{
			"header": "Content-Encoding",
			"description": "\"indicates what content codings have been applied to the representation, beyond those inherent in the media type, and thus what decoding mechanisms have to be applied in order to obtain data in the media type referenced by the Content-Type header field.\"",
			"spec_title": "RFC7231#3.1.2.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-3.1.2.2"
		},
		{
			"header": "Content-Language",
			"description": "\"describes the natural language(s) of the intended audience for the representation.\"",
			"spec_title": "RFC7231#3.1.3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-3.1.3.2"
		},
		{
			"header": "Content-Location",
			"description": "\"references a URI that can be used as an identifier for a specific resource corresponding to the representation in this message's payload.\"",
			"spec_title": "RFC7231#3.1.4.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-3.1.4.2"
		},
		{
			"header": "Content-Type",
			"description": "\"indicates the media type of the associated representation: either the representation enclosed in the message payload or the selected representation, as determined by the message semantics.\"",
			"spec_title": "RFC7231#3.1.1.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-3.1.1.5"
		},
		{
			"header": "Content-Length",
			"description": "\"can provide the anticipated size, as a decimal number of octets, for a potential payload body.\"",
			"spec_title": "RFC7230#3.3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7230#section-3.3.2"
		},
		{
			"header": "Content-Range",
			"description": "\"is sent in a single part 206 (Partial Content) response to indicate the partial range of the selected representation enclosed as the message payload, sent in each part of a multipart 206 response to indicate the range enclosed within each body part, and sent in 416 (Range Not Satisfiable) responses to provide information about the selected representation.\"",
			"spec_title": "RFC7233#4.2",
			"spec_href": "http://tools.ietf.org/html/rfc7233#section-4.2"
		},
		{
			"header": "Transfer-Encoding",
			"description": "\"lists the transfer coding names corresponding to the sequence of transfer codings that have been (or will be) applied to the payload body in order to form the message body.\"",
			"spec_title": "RFC7230#3.3.1",
			"spec_href": "http://tools.ietf.org/html/rfc7230#section-3.3.1"
		},
		{
			"header": "Cache-Control",
			"description": "\"is used to specify directives for caches along the request/response chain.\"",
			"spec_title": "RFC7234#7.2",
			"spec_href": "http://tools.ietf.org/html/rfc7234#section-7.2"
		},
		{
			"header": "Expect",
			"description": "\"is used to indicate that particular server behaviors are required by the client.\"",
			"spec_title": "RFC7231#5.1.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.1.1"
		},
		{
			"header": "Host",
			"description": "\"provides the host and port information from the target URI, enabling the origin server to distinguish among resources while servicing requests for multiple host names on a single IP address.\"",
			"spec_title": "RFC7230#5.4",
			"spec_href": "http://tools.ietf.org/html/rfc7230#section-5.4"
		},
		{
			"header": "Max-Forwards",
			"description": "\"provides a mechanism with the TRACE and OPTIONS methods to limit the number of times that the request is forwarded by proxies.\"",
			"spec_title": "RFC7231#5.1.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.1.2"
		},
		{
			"header": "Pragma",
			"description": "\"allows backwards compatibility with HTTP/1.0 caches, so that clients can specify a \"no-cache\" request that they will understand (as Cache-Control was not defined until HTTP/1.1).\"",
			"spec_title": "RFC7234#7.4",
			"spec_href": "http://tools.ietf.org/html/rfc7234#section-7.4"
		},
		{
			"header": "Range",
			"description": "\"modifies the method semantics to request transfer of only one or more subranges of the selected representation data, rather than the entire selected representation data.\"",
			"spec_title": "RFC7233#3.1",
			"spec_href": "http://tools.ietf.org/html/rfc7233#section-3.1"
		},
		{
			"header": "TE",
			"description": "\"indicates what transfer codings, besides chunked, the client is willing to accept in response, and whether or not the client is willing to accept trailer fields in a chunked transfer coding.\"",
			"spec_title": "RFC7230#4.3",
			"spec_href": "http://tools.ietf.org/html/rfc7230#section-4.3"
		},
		{
			"header": "If-Match",
			"description": "\"can be used to make a request method conditional on the current existence or value of an entity-tag for one or more representations of the target resource.\"",
			"spec_title": "RFC7232#3.1",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-3.1"
		},
		{
			"header": "If-Modified-Since",
			"description": "\"can be used with GET or HEAD to make the method conditional by modification date: if the selected representation has not been modified since the time specified in this field, then do not perform the request method; instead, respond as detailed below.\"",
			"spec_title": "RFC7232#3.3",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-3.3"
		},
		{
			"header": "If-None-Match",
			"description": "\"can be used to make a request method conditional on not matching any of the current entity-tag values for representations of the target resource.\"",
			"spec_title": "RFC7232#3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-3.2"
		},
		{
			"header": "If-Range",
			"description": "\"Informally, its meaning is: if the representation is unchanged, send me the part(s) that I am requesting in Range; otherwise, send me the entire representation.\"",
			"spec_title": "RFC7233#3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7233#section-3.2"
		},
		{
			"header": "If-Unmodified-Since",
			"description": "\"can be used to make a request method conditional by modification date: if the selected representation has been modified since the time specified in this field, then the server MUST NOT perform the requested operation and MUST instead respond with the 412 (Precondition Failed) status code.\"",
			"spec_title": "RFC7232#3.4",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-3.4"
		},
		{
			"header": "Accept",
			"description": "\"can be used to specify certain media types which are acceptable for the response.\"",
			"spec_title": "RFC7231#5.3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.3.2"
		},
		{
			"header": "Accept-Charset",
			"description": "\"can be sent by a user agent to indicate what charsets are acceptable in textual response content.\"",
			"spec_title": "RFC7231#5.3.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.3.3"
		},
		{
			"header": "Accept-Encoding",
			"description": "\"can be used by user agents to indicate what response content-codings are acceptable in the response.\"",
			"spec_title": "RFC7231#5.3.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.3.4"
		},
		{
			"header": "Accept-Language",
			"description": "\"can be used by user agents to indicate the set of natural languages that are preferred in the response.\"",
			"spec_title": "RFC7231#5.3.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.3.5"
		},
		{
			"header": "Authorization",
			"description": "\"allows a user agent to authenticate itself with a server -- usually, but not necessarily, after receiving a 401 (Unauthorized) response.\"",
			"spec_title": "RFC7235#4.1",
			"spec_href": "http://tools.ietf.org/html/rfc7235#section-4.1"
		},
		{
			"header": "Proxy-Authorization",
			"description": "\"allows the client to identify itself (or its user) to a proxy that requires authentication.\"",
			"spec_title": "RFC7235#4.3",
			"spec_href": "http://tools.ietf.org/html/rfc7235#section-4.3"
		},
		{
			"header": "DNT",
			"description": "\"defined as the means for expressing a user's tracking preference via HTTP.\"",
			"spec_title": "Tracking Preference Expression (DNT)",
			"spec_href": "http://www.w3.org/TR/tracking-dnt/#dnt-header-field"
		},
		{
			"header": "From",
			"description": "\"contains an Internet email address for a human user who controls the requesting user agent.\"",
			"spec_title": "RFC7231#5.5.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.5.1"
		},
		{
			"header": "Referer",
			"description": "\"allows the user agent to specify a URI reference for the resource from which the target URI was obtained (i.e., the \"referrer\", though the field name is misspelled).\"",
			"spec_title": "RFC7231#5.5.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.5.2"
		},
		{
			"header": "User-Agent",
			"description": "\"contains information about the user agent originating the request, which is often used by servers to help identify the scope of reported interoperability problems, to work around or tailor responses to avoid particular user agent limitations, and for analytics regarding browser or operating system use.\"",
			"spec_title": "RFC7231#5.5.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.5.3"
		},
		{
			"header": "Age",
			"description": "\"conveys the sender's estimate of the amount of time since the response was generated or successfully validated at the origin server.\"",
			"spec_title": "RFC7234#5.1",
			"spec_href": "http://tools.ietf.org/html/rfc7234#section-5.1"
		},
		{
			"header": "Cache-Control",
			"description": "\"is used to specify directives for caches along the request/response chain.\"",
			"spec_title": "RFC7234#7.2",
			"spec_href": "http://tools.ietf.org/html/rfc7234#section-7.2"
		},
		{
			"header": "Expires",
			"description": "\"gives the date/time after which the response is considered stale.\"",
			"spec_title": "RFC7234#7.3",
			"spec_href": "http://tools.ietf.org/html/rfc7234#section-7.3"
		},
		{
			"header": "Date",
			"description": "\"represents the date and time at which the message was originated\"",
			"spec_title": "RFC7231#7.1.1.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-7.1.1.2"
		},
		{
			"header": "Location",
			"description": "\"is used in some responses to refer to a specific resource in relation to the response.\"",
			"spec_title": "RFC7231#7.1.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-7.1.2"
		},
		{
			"header": "Retry-After",
			"description": "\"indicates how long the user agent ought to wait before making a follow-up request.\"",
			"spec_title": "RFC7231#7.1.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-7.1.3"
		},
		{
			"header": "Tk",
			"description": "\"defined as an OPTIONAL means for indicating the tracking status that applied to the corresponding request and as a REQUIRED means for indicating that a state-changing request has resulted in an interactive change to the tracking status. \"",
			"spec_title": "Tracking Preference Expression (DNT)",
			"spec_href": "http://www.w3.org/TR/tracking-dnt/#response-header-field"
		},
		{
			"header": "Vary",
			"description": "\"describes what parts of a request message, aside from the method and request target, might influence the origin server's process for selecting and representing the response.\"",
			"spec_title": "RFC7231#7.1.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-7.1.4"
		},
		{
			"header": "Warning",
			"description": "\"is used to carry additional information about the status or transformation of a message that might not be reflected in the message.\"",
			"spec_title": "RFC7234#7.6",
			"spec_href": "http://tools.ietf.org/html/rfc7234#section-7.6"
		},
		{
			"header": "ETag",
			"description": "\"provides the current entity-tag for the selected representation, as determined at the conclusion of handling the request.\"",
			"spec_title": "RFC7232#2.3",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-2.3"
		},
		{
			"header": "Last-Modified",
			"description": "\"provides a timestamp indicating the date and time at which the origin server believes the selected representation was last modified, as determined at the conclusion of handling the request.\"",
			"spec_title": "RFC7232#2.2",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-2.2"
		},
		{
			"header": "WWW-Authenticate",
			"description": "\"consists of at least one challenge that indicates the authentication scheme(s) and parameters applicable to the effective request URI.\"",
			"spec_title": "RFC7235#4.4",
			"spec_href": "http://tools.ietf.org/html/rfc7235#section-4.4"
		},
		{
			"header": "Proxy-Authenticate",
			"description": "\"consists of at least one challenge that indicates the authentication scheme(s) and parameters applicable to the proxy for this effective request URI.\"",
			"spec_title": "RFC7235#4.2",
			"spec_href": "http://tools.ietf.org/html/rfc7235#section-4.2"
		},
		{
			"header": "Accept-Ranges",
			"description": "\"allows a server to indicate that it supports range requests for the target resource.\"",
			"spec_title": "RFC7233#2.3",
			"spec_href": "http://tools.ietf.org/html/rfc7233#section-2.3"
		},
		{
			"header": "Allow",
			"description": "\"lists the set of methods advertised as supported by the target resource.\"",
			"spec_title": "RFC7231#7.4.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-7.4.1"
		},
		{
			"header": "Server",
			"description": "\"contains information about the software used by the origin server to handle the request, which is often used by clients to help identify the scope of reported interoperability problems, to work around or tailor requests to avoid particular server limitations, and for analytics regarding server or operating system use.\"",
			"spec_title": "RFC7231#7.4.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-7.4.2"
		},
		{
			"header": "Accept-Patch",
			"description": "\"used to specify the patch document formats accepted by the server.\"",
			"spec_title": "RFC5789#3.1",
			"spec_href": "http://tools.ietf.org/html/rfc5789#section-3.1"
		},
		{
			"header": "Accept-Post",
			"description": "\"indicates server support for specific media types for entity bodies in HTTP POST requests.\"",
			"spec_title": "draft-wilde-accept-post",
			"spec_href": "http://tools.ietf.org/html/draft-wilde-accept-post"
		},
		{
			"header": "Access-Control-Allow-Credentials",
			"description": "\"indicates whether the response to request can be exposed when the omit credentials flag is unset\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-allow-credentials-response-header"
		},
		{
			"header": "Access-Control-Allow-Headers",
			"description": "\"indicates, as part of the response to a preflight request, which header field names can be used during the actual request\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-allow-headers-response-header"
		},
		{
			"header": "Access-Control-Allow-Methods",
			"description": "\"indicates, as part of the response to a preflight request, which methods can be used during the actual request\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-allow-methods-response-header"
		},
		{
			"header": "Access-Control-Allow-Origin",
			"description": "\"indicates whether a resource can be shared\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-allow-origin-response-header"
		},
		{
			"header": "Access-Control-Expose-Headers",
			"description": "\"indicates which headers are safe to expose to the API of a CORS API specification\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-expose-headers-response-header"
		},
		{
			"header": "Access-Control-Max-Age",
			"description": "\"indicates how long the results of a preflight request can be cached in a preflight result cache\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-max-age-response-header"
		},
		{
			"header": "Access-Control-Request-Headers",
			"description": "\"indicates which headers will be used in the actual request as part of the preflight request\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-request-headers-request-header"
		},
		{
			"header": "Access-Control-Request-Method",
			"description": "\"indicates which method will be used in the actual request as part of the preflight request\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-request-method-request-header"
		},
		{
			"header": "Content-Disposition",
			"description": "\"standard\"",
			"spec_title": "RFC6266",
			"spec_href": "http://tools.ietf.org/html/rfc6266"
		},
		{
			"header": "Content-Security-Policy",
			"description": "\"is the preferred mechanism for delivering a CSP policy\"",
			"spec_title": "CSP",
			"spec_href": "http://www.w3.org/TR/CSP/#content-security-policy-header-field"
		},
		{
			"header": "Content-Security-Policy-Report-Only",
			"description": "\"lets servers experiment with policies by monitoring (rather than enforcing) a policy\"",
			"spec_title": "CSP",
			"spec_href": "http://www.w3.org/TR/CSP/#content-security-policy-report-only-header-field"
		},
		{
			"header": "Cookie",
			"description": "\"standard\"",
			"spec_title": "RFC6265",
			"spec_href": "http://tools.ietf.org/html/rfc6265"
		},
		{
			"header": "Forwarded",
			"description": "\"standard\"",
			"spec_title": "RFC7239",
			"spec_href": "http://tools.ietf.org/html/rfc7239"
		},
		{
			"header": "Link",
			"description": "\"provides a means for serialising one or more links in HTTP headers.\"",
			"spec_title": "RFC5988#5",
			"spec_href": "http://tools.ietf.org/html/rfc5988#section-5"
		},
		{
			"header": "Origin",
			"description": "\"standard\"",
			"spec_title": "RFC6454",
			"spec_href": "http://tools.ietf.org/html/rfc6454"
		},
		{
			"header": "Prefer",
			"description": "\"is used to indicate that particular server behaviors are preferred by the client, but not required for successful completion of the request.\"",
			"spec_title": "draft-snell-http-prefer#2",
			"spec_href": "http://tools.ietf.org/html/draft-snell-http-prefer#section-2"
		},
		{
			"header": "Preference-Applied",
			"description": "\"MAY be included within a response message as an indication as to which Prefer tokens were honored by the server and applied to the processing of a request.\"",
			"spec_title": "draft-snell-http-prefer#3",
			"spec_href": "http://tools.ietf.org/html/draft-snell-http-prefer#section-3"
		},
		{
			"header": "Set-Cookie",
			"description": "\"standard\"",
			"spec_title": "RFC6265",
			"spec_href": "http://tools.ietf.org/html/rfc6265"
		},
		{
			"header": "Strict-Transport-Security",
			"description": "\"standard\"",
			"spec_title": "RFC6797",
			"spec_href": "http://tools.ietf.org/html/rfc6797"
		},
		{
			"header": "Via",
			"description": "\"\"",
			"spec_title": "RFC7230#5.7.1",
			"spec_href": "http://tools.ietf.org/html/rfc7230#section-5.7.1"
		},
		{
			"header": "A-IM",
			"description": "\"\"",
			"spec_title": "RFC3229#10.5.3",
			"spec_href": "http://tools.ietf.org/html/rfc3229#section-10.5.3"
		},
		{
			"header": "Accept-Features",
			"description": "\"can be used by a user agent to give information about the presence or absence of certain features in the feature set of the current request.\"",
			"spec_title": "RFC2295#8.2",
			"spec_href": "http://tools.ietf.org/html/rfc2295#section-8.2"
		},
		{
			"header": "Alt-Svc",
			"description": "\"is advertising the availability of alternate services to HTTP/1.1 and HTTP/2.0 clients by adding an Alt-Svc header field to responses.\"",
			"spec_title": "draft-nottingham-httpbis-alt-svc",
			"spec_href": "http://tools.ietf.org/html/draft-nottingham-httpbis-alt-svc"
		},
		{
			"header": "Alternates",
			"description": "\"is used to convey the list of variants bound to a negotiable resource.\"",
			"spec_title": "RFC2295#8.3",
			"spec_href": "http://tools.ietf.org/html/rfc2295#section-8.3"
		},
		{
			"header": "Apply-To-Redirect-Ref",
			"description": "\"\"",
			"spec_title": "RFC4437",
			"spec_href": "http://tools.ietf.org/html/rfc4437"
		},
		{
			"header": "CH",
			"description": "\"describes an example list of client preferences that the server can use to adapt and optimize the resource to satisfy a given request.\"",
			"spec_title": "draft-grigorik-http-client-hints",
			"spec_href": "http://tools.ietf.org/html/draft-grigorik-http-client-hints"
		},
		{
			"header": "Content-Base",
			"description": "\"obsoleted\"",
			"spec_title": "RFC2068",
			"spec_href": "http://tools.ietf.org/html/rfc2068"
		},
		{
			"header": "Cookie2",
			"description": "\"obsoleted\"",
			"spec_title": "RFC2965",
			"spec_href": "http://tools.ietf.org/html/rfc2965"
		},
		{
			"header": "DASL",
			"description": "\"standard\"",
			"spec_title": "RFC5323",
			"spec_href": "http://tools.ietf.org/html/rfc5323"
		},
		{
			"header": "DAV",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "Delta-Base",
			"description": "\"\"",
			"spec_title": "RFC3229#10.5.1",
			"spec_href": "http://tools.ietf.org/html/rfc3229#section-10.5.1"
		},
		{
			"header": "Depth",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "Destination",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "IM",
			"description": "\"\"",
			"spec_title": "RFC3229#10.5.2",
			"spec_href": "http://tools.ietf.org/html/rfc3229#section-10.5.2"
		},
		{
			"header": "If",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "If-Schedule-Tag-Match",
			"description": "\"standard\"",
			"spec_title": "RFC6638",
			"spec_href": "http://tools.ietf.org/html/rfc6638"
		},
		{
			"header": "Last-Event-ID",
			"description": "\"The value of the event source's last event ID string, encoded as UTF-8.\"",
			"spec_title": "Server-Sent Events",
			"spec_href": "http://www.w3.org/TR/eventsource/#last-event-id"
		},
		{
			"header": "Link-Template",
			"description": "\"provides a means for serialising one or more links into HTTP headers.\"",
			"spec_title": "draft-nottingham-link-template",
			"spec_href": "http://tools.ietf.org/html/draft-nottingham-link-template"
		},
		{
			"header": "Lock-Token",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "Negotiate",
			"description": "\"can contain directives for any content negotiation process initiated by the request.\"",
			"spec_title": "RFC2295#8.4",
			"spec_href": "http://tools.ietf.org/html/rfc2295#section-8.4"
		},
		{
			"header": "Nice",
			"description": "\"indicates that a request is less important than a request that doesn't bear this header.\"",
			"spec_title": "draft-thomson-http-nice",
			"spec_href": "http://tools.ietf.org/html/draft-thomson-http-nice"
		},
		{
			"header": "Overwrite",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "Redirect-Ref",
			"description": "\"\"",
			"spec_title": "RFC4437",
			"spec_href": "http://tools.ietf.org/html/rfc4437"
		},
		{
			"header": "Schedule-Reply",
			"description": "\"standard\"",
			"spec_title": "RFC6638",
			"spec_href": "http://tools.ietf.org/html/rfc6638"
		},
		{
			"header": "Schedule-Tag",
			"description": "\"standard\"",
			"spec_title": "RFC6638",
			"spec_href": "http://tools.ietf.org/html/rfc6638"
		},
		{
			"header": "Sec-WebSocket-Accept",
			"description": "\"standard\"",
			"spec_title": "RFC6455",
			"spec_href": "http://tools.ietf.org/html/rfc6455"
		},
		{
			"header": "Sec-WebSocket-Extensions",
			"description": "\"standard\"",
			"spec_title": "RFC6455",
			"spec_href": "http://tools.ietf.org/html/rfc6455"
		},
		{
			"header": "Sec-WebSocket-Key",
			"description": "\"standard\"",
			"spec_title": "RFC6455",
			"spec_href": "http://tools.ietf.org/html/rfc6455"
		},
		{
			"header": "Sec-WebSocket-Protocol",
			"description": "\"standard\"",
			"spec_title": "RFC6455",
			"spec_href": "http://tools.ietf.org/html/rfc6455"
		},
		{
			"header": "Sec-WebSocket-Version",
			"description": "\"standard\"",
			"spec_title": "RFC6455",
			"spec_href": "http://tools.ietf.org/html/rfc6455"
		},
		{
			"header": "Set-Cookie2",
			"description": "\"obsoleted\"",
			"spec_title": "RFC2965",
			"spec_href": "http://tools.ietf.org/html/rfc2965"
		},
		{
			"header": "SLUG",
			"description": "\"standard\"",
			"spec_title": "RFC5023",
			"spec_href": "http://tools.ietf.org/html/rfc5023"
		},
		{
			"header": "TCN",
			"description": "\"is used by a server to signal that the resource is transparently negotiated.\"",
			"spec_title": "RFC2295#8.5",
			"spec_href": "http://tools.ietf.org/html/rfc2295#section-8.5"
		},
		{
			"header": "Timeout",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "Variant-Vary",
			"description": "\"can be used in a choice response to record any vary information which applies to the variant data (the entity body combined with some of the entity headers) contained in the response, rather than to the response as a whole.\"",
			"spec_title": "RFC2295#8.6",
			"spec_href": "http://tools.ietf.org/html/rfc2295#section-8.6"
		},
		{
			"header": "X-Frame-Options",
			"description": "\"indicates a policy that specifies whether the browser should render the transmitted resource within a <frame> or an <iframe>. Servers can declare this policy in the header of their HTTP responses to prevent clickjacking attacks, which ensures that their content is not embedded into other pages or frames.\"",
			"spec_title": "RFC7034",
			"spec_href": "http://tools.ietf.org/html/rfc7034"
		}
	];

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [
		{
			"relation": "about",
			"description": "\"Refers to a resource that is the subject of the link's context.\"",
			"spec_title": "RFC6903",
			"spec_href": "http://tools.ietf.org/html/rfc6903"
		},
		{
			"relation": "alternate",
			"description": "\"Refers to a substitute for this context\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-alternate"
		},
		{
			"relation": "appendix",
			"description": "\"Refers to an appendix.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "archives",
			"description": "\"Refers to a collection of records, documents, or other materials of historical interest.\"",
			"spec_title": "HTML5linksWD",
			"spec_href": "http://www.w3.org/TR/2011/WD-html5-20110113/links.html#rel-archives"
		},
		{
			"relation": "author",
			"description": "\"Refers to the context's author.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-author"
		},
		{
			"relation": "bookmark",
			"description": "\"Gives a permanent link to use for bookmarking purposes.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-bookmark"
		},
		{
			"relation": "canonical",
			"description": "\"Designates the preferred version of a resource (the IRI and its contents).\"",
			"spec_title": "RFC6596",
			"spec_href": "http://tools.ietf.org/html/rfc6596"
		},
		{
			"relation": "chapter",
			"description": "\"Refers to a chapter in a collection of resources.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "collection",
			"description": "\"The target IRI points to a resource which represents the collection resource for the context IRI.\"",
			"spec_title": "RFC6573",
			"spec_href": "http://tools.ietf.org/html/rfc6573"
		},
		{
			"relation": "contents",
			"description": "\"Refers to a table of contents.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "copyright",
			"description": "\"Refers to a copyright statement that applies to the link's context.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "create-form",
			"description": "\"The target IRI points to a resource where a submission form can be obtained.\"",
			"spec_title": "RFC6861",
			"spec_href": "http://tools.ietf.org/html/rfc6861"
		},
		{
			"relation": "current",
			"description": "\"Refers to a resource containing the most recent item(s) in a collection of resources.\"",
			"spec_title": "RFC5005",
			"spec_href": "http://tools.ietf.org/html/rfc5005"
		},
		{
			"relation": "describedby",
			"description": "\"Refers to a resource providing information about the link's context.\"",
			"spec_title": "POWDER",
			"spec_href": "http://www.w3.org/TR/powder-dr/#assoc-linking"
		},
		{
			"relation": "describes",
			"description": "\"The relationship A 'describes' B asserts that resource A provides a description of resource B. There are no constraints on the format or representation of either A or B, neither are there any further constraints on either resource.\"",
			"spec_title": "RFC6892",
			"spec_href": "http://tools.ietf.org/html/rfc6892"
		},
		{
			"relation": "disclosure",
			"description": "\"Refers to a list of patent disclosures made with respect to material for which `disclosure` relation is specified.\"",
			"spec_title": "RFC6579",
			"spec_href": "http://tools.ietf.org/html/rfc6579"
		},
		{
			"relation": "duplicate",
			"description": "\"Refers to a resource whose available representations are byte-for-byte identical with the corresponding representations of the context IRI.\"",
			"spec_title": "RFC6249",
			"spec_href": "http://tools.ietf.org/html/rfc6249"
		},
		{
			"relation": "edit",
			"description": "\"Refers to a resource that can be used to edit the link's context.\"",
			"spec_title": "RFC5023",
			"spec_href": "http://tools.ietf.org/html/rfc5023"
		},
		{
			"relation": "edit-form",
			"description": "\"The target IRI points to a resource where a submission form for editing associated resource can be obtained.\"",
			"spec_title": "RFC6861",
			"spec_href": "http://tools.ietf.org/html/rfc6861"
		},
		{
			"relation": "edit-media",
			"description": "\"Refers to a resource that can be used to edit media associated with the link's context.\"",
			"spec_title": "RFC5023",
			"spec_href": "http://tools.ietf.org/html/rfc5023"
		},
		{
			"relation": "enclosure",
			"description": "\"Identifies a related resource that is potentially large and might require special handling.\"",
			"spec_title": "RFC4287",
			"spec_href": "http://tools.ietf.org/html/rfc4287"
		},
		{
			"relation": "first",
			"description": "\"An IRI that refers to the furthest preceding resource in a series of resources.\"",
			"spec_title": "RFC5988",
			"spec_href": "http://tools.ietf.org/html/rfc5988"
		},
		{
			"relation": "glossary",
			"description": "\"Refers to a glossary of terms.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "help",
			"description": "\"Refers to context-sensitive help.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-help"
		},
		{
			"relation": "hosts",
			"description": "\"Refers to a resource hosted by the server indicated by the link context.\"",
			"spec_title": "RFC6690",
			"spec_href": "http://tools.ietf.org/html/rfc6690"
		},
		{
			"relation": "hub",
			"description": "\"Refers to a hub that enables registration for notification of updates to the context.\"",
			"spec_title": "pubsubhubbub",
			"spec_href": "http://pubsubhubbub.googlecode.com"
		},
		{
			"relation": "icon",
			"description": "\"Refers to an icon representing the link's context.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-icon"
		},
		{
			"relation": "index",
			"description": "\"Refers to an index.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "item",
			"description": "\"The target IRI points to a resource that is a member of the collection represented by the context IRI.\"",
			"spec_title": "RFC6573",
			"spec_href": "http://tools.ietf.org/html/rfc6573"
		},
		{
			"relation": "last",
			"description": "\"An IRI that refers to the furthest following resource in a series of resources.\"",
			"spec_title": "RFC5988",
			"spec_href": "http://tools.ietf.org/html/rfc5988"
		},
		{
			"relation": "latest-version",
			"description": "\"Points to a resource containing the latest (e.g., current) version of the context.\"",
			"spec_title": "RFC5829",
			"spec_href": "http://tools.ietf.org/html/rfc5829"
		},
		{
			"relation": "license",
			"description": "\"Refers to a license associated with this context.\"",
			"spec_title": "RFC4946",
			"spec_href": "http://tools.ietf.org/html/rfc4946"
		},
		{
			"relation": "lrdd",
			"description": "\"Refers to further information about the link's context, expressed as a LRDD (Link-based Resource Descriptor Document) resource. See [RFC6415](http://tools.ietf.org/html/rfc6415) for information about processing this relation type in host-meta documents. When used elsewhere, it refers to additional links and other metadata. Multiple instances indicate additional LRDD resources. LRDD resources MUST have an \"application/xrd+xml\" representation, and MAY have others.\"",
			"spec_title": "RFC6415",
			"spec_href": "http://tools.ietf.org/html/rfc6415"
		},
		{
			"relation": "monitor",
			"description": "\"Refers to a resource that can be used to monitor changes in an HTTP resource.\"",
			"spec_title": "RFC5989",
			"spec_href": "http://tools.ietf.org/html/rfc5989"
		},
		{
			"relation": "monitor-group",
			"description": "\"Refers to a resource that can be used to monitor changes in a specified group of HTTP resources.\"",
			"spec_title": "RFC5989",
			"spec_href": "http://tools.ietf.org/html/rfc5989"
		},
		{
			"relation": "next",
			"description": "\"Indicates that the link's context is a part of a series, and that the next in the series is the link target.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-next"
		},
		{
			"relation": "next-archive",
			"description": "\"Refers to the immediately following archive resource.\"",
			"spec_title": "RFC5005",
			"spec_href": "http://tools.ietf.org/html/rfc5005"
		},
		{
			"relation": "nofollow",
			"description": "\"Indicates that the contexts original author or publisher does not endorse the link target.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-nofollow"
		},
		{
			"relation": "noreferrer",
			"description": "\"Indicates that no referrer information is to be leaked when following the link.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-noreferrer"
		},
		{
			"relation": "payment",
			"description": "\"Indicates a resource where payment is accepted.\"",
			"spec_title": "RFC5988",
			"spec_href": "http://tools.ietf.org/html/rfc5988"
		},
		{
			"relation": "predecessor-version",
			"description": "\"Points to a resource containing the predecessor version in the version history.\"",
			"spec_title": "RFC5829",
			"spec_href": "http://tools.ietf.org/html/rfc5829"
		},
		{
			"relation": "prefetch",
			"description": "\"Indicates that the link target should be preemptively cached.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-prefetch"
		},
		{
			"relation": "prev",
			"description": "\"Indicates that the link's context is a part of a series, and that the previous in the series is the link target.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-prev"
		},
		{
			"relation": "preview",
			"description": "\"Refers to a resource that provides a preview of the link's context.\"",
			"spec_title": "RFC6903",
			"spec_href": "http://tools.ietf.org/html/rfc6903"
		},
		{
			"relation": "previous",
			"description": "\"Refers to the previous resource in an ordered series of resources. Synonym for `prev`.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "prev-archive",
			"description": "\"Refers to the immediately preceding archive resource.\"",
			"spec_title": "RFC5005",
			"spec_href": "http://tools.ietf.org/html/rfc5005"
		},
		{
			"relation": "privacy-policy",
			"description": "\"Refers to a privacy policy associated with the link's context.\"",
			"spec_title": "RFC6903",
			"spec_href": "http://tools.ietf.org/html/rfc6903"
		},
		{
			"relation": "profile",
			"description": "Identifying that a resource representation conforms to a certain profile, without affecting the non-profile semantics of the resource representation",
			"spec_title": "RFC6906",
			"spec_href": "http://tools.ietf.org/html/rfc6906"
		},
		{
			"relation": "related",
			"description": "\"Identifies a related resource.\"",
			"spec_title": "RFC4287",
			"spec_href": "http://tools.ietf.org/html/rfc4287"
		},
		{
			"relation": "replies",
			"description": "\"Identifies a resource that is a reply to the context of the link.\"",
			"spec_title": "RFC4685",
			"spec_href": "http://tools.ietf.org/html/rfc4685"
		},
		{
			"relation": "search",
			"description": "\"Refers to a resource that can be used to search through the link's context and related resources.\"",
			"spec_title": "OpenSearch",
			"spec_href": "http://www.opensearch.org/Specifications/OpenSearch/1.1"
		},
		{
			"relation": "section",
			"description": "\"Refers to a section in a collection of resources.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "self",
			"description": "\"Conveys an identifier for the link's context.\"",
			"spec_title": "RFC4287",
			"spec_href": "http://tools.ietf.org/html/rfc4287"
		},
		{
			"relation": "service",
			"description": "\"Indicates a URI that can be used to retrieve a service document.\"",
			"spec_title": "RFC5023",
			"spec_href": "http://tools.ietf.org/html/rfc5023"
		},
		{
			"relation": "start",
			"description": "\"Refers to the first resource in a collection of resources.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "stylesheet",
			"description": "\"Refers to a stylesheet.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-stylesheet"
		},
		{
			"relation": "subsection",
			"description": "\"Refers to a resource serving as a subsection in a collection of resources.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "successor-version",
			"description": "\"Points to a resource containing the successor version in the version history.\"",
			"spec_title": "RFC5829",
			"spec_href": "http://tools.ietf.org/html/rfc5829"
		},
		{
			"relation": "tag",
			"description": "\"Gives a tag (identified by the given address) that applies to the current document.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-tag"
		},
		{
			"relation": "terms-of-service",
			"description": "\"Refers to the terms of service associated with the link's context.\"",
			"spec_title": "RFC6903",
			"spec_href": "http://tools.ietf.org/html/rfc6903"
		},
		{
			"relation": "type",
			"description": "\"Refers to a resource identifying the abstract semantic type of which the link's context is considered to be an instance.\"",
			"spec_title": "RFC6903",
			"spec_href": "http://tools.ietf.org/html/rfc6903"
		},
		{
			"relation": "up",
			"description": "\"Refers to a parent document in a hierarchy of documents.\"",
			"spec_title": "RFC5988",
			"spec_href": "http://tools.ietf.org/html/rfc5988"
		},
		{
			"relation": "version-history",
			"description": "\"Points to a resource containing the version history for the context.\"",
			"spec_title": "RFC5829",
			"spec_href": "http://tools.ietf.org/html/rfc5829"
		},
		{
			"relation": "via",
			"description": "\"Identifies a resource that is the source of the information in the link's context.\"",
			"spec_title": "RFC4287",
			"spec_href": "http://tools.ietf.org/html/rfc4287"
		},
		{
			"relation": "working-copy",
			"description": "\"Points to a working copy for this resource.\"",
			"spec_title": "RFC5829",
			"spec_href": "http://tools.ietf.org/html/rfc5829"
		},
		{
			"relation": "working-copy-of",
			"description": "\"Points to the versioned resource from which this working copy was obtained.\"",
			"spec_title": "RFC5829",
			"spec_href": "http://tools.ietf.org/html/rfc5829"
		}
	];

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/* (ignored) */

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";

	__webpack_require__(204);
	var get               = __webpack_require__(229);
	var Report            = __webpack_require__(205);
	var FormatValidators  = __webpack_require__(206);
	var JsonValidation    = __webpack_require__(207);
	var SchemaCache       = __webpack_require__(208);
	var SchemaCompilation = __webpack_require__(209);
	var SchemaValidation  = __webpack_require__(210);
	var Utils             = __webpack_require__(211);
	var Draft4Schema      = __webpack_require__(247);
	var Draft4HyperSchema = __webpack_require__(248);

	/*
	    default options
	*/
	var defaultOptions = {
	    // default timeout for all async tasks
	    asyncTimeout: 2000,
	    // force additionalProperties and additionalItems to be defined on "object" and "array" types
	    forceAdditional: false,
	    // assume additionalProperties and additionalItems are defined as "false" where appropriate
	    assumeAdditional: false,
	    // force items to be defined on "array" types
	    forceItems: false,
	    // force minItems to be defined on "array" types
	    forceMinItems: false,
	    // force maxItems to be defined on "array" types
	    forceMaxItems: false,
	    // force minLength to be defined on "string" types
	    forceMinLength: false,
	    // force maxLength to be defined on "string" types
	    forceMaxLength: false,
	    // force properties or patternProperties to be defined on "object" types
	    forceProperties: false,
	    // ignore references that cannot be resolved (remote schemas) // TODO: make sure this is only for remote schemas, not local ones
	    ignoreUnresolvableReferences: false,
	    // disallow usage of keywords that this validator can't handle
	    noExtraKeywords: false,
	    // disallow usage of schema's without "type" defined
	    noTypeless: false,
	    // disallow zero length strings in validated objects
	    noEmptyStrings: false,
	    // disallow zero length arrays in validated objects
	    noEmptyArrays: false,
	    // forces "uri" format to be in fully rfc3986 compliant
	    strictUris: false,
	    // turn on some of the above
	    strictMode: false,
	    // report error paths as an array of path segments to get to the offending node
	    reportPathAsArray: false,
	    // stops validation as soon as an error is found, true by default but can be turned off
	    breakOnFirstError: true,
	    // check if schema follow best practices and common sence
	    pedanticCheck: false,
	    // ignore unknown formats (do not report them as an error)
	    ignoreUnknownFormats: false,
	    // function to be called on every schema
	    customValidator: null
	};

	/*
	    constructor
	*/
	function ZSchema(options) {
	    this.cache = {};
	    this.referenceCache = [];

	    this.setRemoteReference("http://json-schema.org/draft-04/schema", Draft4Schema);
	    this.setRemoteReference("http://json-schema.org/draft-04/hyper-schema", Draft4HyperSchema);

	    // options
	    if (typeof options === "object") {
	        var keys = Object.keys(options),
	            idx = keys.length,
	            key;

	        // check that the options are correctly configured
	        while (idx--) {
	            key = keys[idx];
	            if (defaultOptions[key] === undefined) {
	                throw new Error("Unexpected option passed to constructor: " + key);
	            }
	        }

	        // copy the default options into passed options
	        keys = Object.keys(defaultOptions);
	        idx = keys.length;
	        while (idx--) {
	            key = keys[idx];
	            if (options[key] === undefined) {
	                options[key] = Utils.clone(defaultOptions[key]);
	            }
	        }

	        this.options = options;
	    } else {
	        this.options = Utils.clone(defaultOptions);
	    }

	    if (this.options.strictMode === true) {
	        this.options.forceAdditional  = true;
	        this.options.forceItems       = true;
	        this.options.forceMaxLength   = true;
	        this.options.forceProperties  = true;
	        this.options.noExtraKeywords  = true;
	        this.options.noTypeless       = true;
	        this.options.noEmptyStrings   = true;
	        this.options.noEmptyArrays    = true;
	    }

	}

	/*
	    instance methods
	*/
	ZSchema.prototype.compileSchema = function (schema) {
	    var report = new Report(this.options);

	    schema = SchemaCache.getSchema.call(this, report, schema);

	    SchemaCompilation.compileSchema.call(this, report, schema);

	    this.lastReport = report;
	    return report.isValid();
	};
	ZSchema.prototype.validateSchema = function (schema) {
	    if (Array.isArray(schema) && schema.length === 0) {
	        throw new Error(".validateSchema was called with an empty array");
	    }

	    var report = new Report(this.options);

	    schema = SchemaCache.getSchema.call(this, report, schema);

	    var compiled = SchemaCompilation.compileSchema.call(this, report, schema);
	    if (compiled) { SchemaValidation.validateSchema.call(this, report, schema); }

	    this.lastReport = report;
	    return report.isValid();
	};
	ZSchema.prototype.validate = function (json, schema, options, callback) {

	    if (Utils.whatIs(options) === "function") {
	        callback = options;
	        options = {};
	    }
	    if (!options) { options = {}; }

	    var whatIs = Utils.whatIs(schema);
	    if (whatIs !== "string" && whatIs !== "object") {
	        var e = new Error("Invalid .validate call - schema must be an string or object but " + whatIs + " was passed!");
	        if (callback) {
	            process.nextTick(function () {
	                callback(e, false);
	            });
	            return;
	        }
	        throw e;
	    }

	    var foundError = false;
	    var report = new Report(this.options);

	    if (typeof schema === "string") {
	        var schemaName = schema;
	        schema = SchemaCache.getSchema.call(this, report, schemaName);
	        if (!schema) {
	            throw new Error("Schema with id '" + schemaName + "' wasn't found in the validator cache!");
	        }
	    } else {
	        schema = SchemaCache.getSchema.call(this, report, schema);
	    }

	    var compiled = false;
	    if (!foundError) {
	        compiled = SchemaCompilation.compileSchema.call(this, report, schema);
	    }
	    if (!compiled) {
	        this.lastReport = report;
	        foundError = true;
	    }

	    var validated = false;
	    if (!foundError) {
	        validated = SchemaValidation.validateSchema.call(this, report, schema);
	    }
	    if (!validated) {
	        this.lastReport = report;
	        foundError = true;
	    }

	    if (options.schemaPath) {
	        report.rootSchema = schema;
	        schema = get(schema, options.schemaPath);
	        if (!schema) {
	            throw new Error("Schema path '" + options.schemaPath + "' wasn't found in the schema!");
	        }
	    }

	    if (!foundError) {
	        JsonValidation.validate.call(this, report, schema, json);
	    }

	    if (callback) {
	        report.processAsyncTasks(this.options.asyncTimeout, callback);
	        return;
	    } else if (report.asyncTasks.length > 0) {
	        throw new Error("This validation has async tasks and cannot be done in sync mode, please provide callback argument.");
	    }

	    // assign lastReport so errors are retrievable in sync mode
	    this.lastReport = report;
	    return report.isValid();
	};
	ZSchema.prototype.getLastError = function () {
	    if (this.lastReport.errors.length === 0) {
	        return null;
	    }
	    var e = new Error();
	    e.name = "z-schema validation error";
	    e.message = this.lastReport.commonErrorMessage;
	    e.details = this.lastReport.errors;
	    return e;
	};
	ZSchema.prototype.getLastErrors = function () {
	    return this.lastReport && this.lastReport.errors.length > 0 ? this.lastReport.errors : undefined;
	};
	ZSchema.prototype.getMissingReferences = function (arr) {
	    arr = arr || this.lastReport.errors;
	    var res = [],
	        idx = arr.length;
	    while (idx--) {
	        var error = arr[idx];
	        if (error.code === "UNRESOLVABLE_REFERENCE") {
	            var reference = error.params[0];
	            if (res.indexOf(reference) === -1) {
	                res.push(reference);
	            }
	        }
	        if (error.inner) {
	            res = res.concat(this.getMissingReferences(error.inner));
	        }
	    }
	    return res;
	};
	ZSchema.prototype.getMissingRemoteReferences = function () {
	    var missingReferences = this.getMissingReferences(),
	        missingRemoteReferences = [],
	        idx = missingReferences.length;
	    while (idx--) {
	        var remoteReference = SchemaCache.getRemotePath(missingReferences[idx]);
	        if (remoteReference && missingRemoteReferences.indexOf(remoteReference) === -1) {
	            missingRemoteReferences.push(remoteReference);
	        }
	    }
	    return missingRemoteReferences;
	};
	ZSchema.prototype.setRemoteReference = function (uri, schema) {
	    if (typeof schema === "string") {
	        schema = JSON.parse(schema);
	    } else {
	        schema = Utils.cloneDeep(schema);
	    }
	    SchemaCache.cacheSchemaByUri.call(this, uri, schema);
	};
	ZSchema.prototype.getResolvedSchema = function (schema) {
	    var report = new Report(this.options);
	    schema = SchemaCache.getSchema.call(this, report, schema);

	    // clone before making any modifications
	    schema = Utils.cloneDeep(schema);

	    var visited = [];

	    // clean-up the schema and resolve references
	    var cleanup = function (schema) {
	        var key,
	            typeOf = Utils.whatIs(schema);
	        if (typeOf !== "object" && typeOf !== "array") {
	            return;
	        }

	        if (schema.___$visited) {
	            return;
	        }

	        schema.___$visited = true;
	        visited.push(schema);

	        if (schema.$ref && schema.__$refResolved) {
	            var from = schema.__$refResolved;
	            var to = schema;
	            delete schema.$ref;
	            delete schema.__$refResolved;
	            for (key in from) {
	                if (from.hasOwnProperty(key)) {
	                    to[key] = from[key];
	                }
	            }
	        }
	        for (key in schema) {
	            if (schema.hasOwnProperty(key)) {
	                if (key.indexOf("__$") === 0) {
	                    delete schema[key];
	                } else {
	                    cleanup(schema[key]);
	                }
	            }
	        }
	    };

	    cleanup(schema);
	    visited.forEach(function (s) {
	        delete s.___$visited;
	    });

	    this.lastReport = report;
	    if (report.isValid()) {
	        return schema;
	    } else {
	        throw this.getLastError();
	    }
	};
	ZSchema.prototype.setSchemaReader = function (schemaReader) {
	    return ZSchema.setSchemaReader(schemaReader);
	};
	ZSchema.prototype.getSchemaReader = function () {
	    return ZSchema.schemaReader;
	};

	/*
	    static methods
	*/
	ZSchema.setSchemaReader = function (schemaReader) {
	    ZSchema.schemaReader = schemaReader;
	};
	ZSchema.registerFormat = function (formatName, validatorFunction) {
	    FormatValidators[formatName] = validatorFunction;
	};
	ZSchema.unregisterFormat = function (formatName) {
	    delete FormatValidators[formatName];
	};
	ZSchema.getRegisteredFormats = function () {
	    return Object.keys(FormatValidators);
	};
	ZSchema.getDefaultOptions = function () {
	    return Utils.cloneDeep(defaultOptions);
	};

	module.exports = ZSchema;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59)))

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var asap = __webpack_require__(249);

	function noop() {}

	// States:
	//
	// 0 - pending
	// 1 - fulfilled with _value
	// 2 - rejected with _value
	// 3 - adopted the state of another promise, _value
	//
	// once the state is no longer pending (0) it is immutable

	// All `_` prefixed properties will be reduced to `_{random number}`
	// at build time to obfuscate them and discourage their use.
	// We don't use symbols or Object.defineProperty to fully hide them
	// because the performance isn't good enough.


	// to avoid using try/catch inside critical functions, we
	// extract them to here.
	var LAST_ERROR = null;
	var IS_ERROR = {};
	function getThen(obj) {
	  try {
	    return obj.then;
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}

	function tryCallOne(fn, a) {
	  try {
	    return fn(a);
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}
	function tryCallTwo(fn, a, b) {
	  try {
	    fn(a, b);
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}

	module.exports = Promise;

	function Promise(fn) {
	  if (typeof this !== 'object') {
	    throw new TypeError('Promises must be constructed via new');
	  }
	  if (typeof fn !== 'function') {
	    throw new TypeError('not a function');
	  }
	  this._45 = 0;
	  this._81 = 0;
	  this._65 = null;
	  this._54 = null;
	  if (fn === noop) return;
	  doResolve(fn, this);
	}
	Promise._10 = null;
	Promise._97 = null;
	Promise._61 = noop;

	Promise.prototype.then = function(onFulfilled, onRejected) {
	  if (this.constructor !== Promise) {
	    return safeThen(this, onFulfilled, onRejected);
	  }
	  var res = new Promise(noop);
	  handle(this, new Handler(onFulfilled, onRejected, res));
	  return res;
	};

	function safeThen(self, onFulfilled, onRejected) {
	  return new self.constructor(function (resolve, reject) {
	    var res = new Promise(noop);
	    res.then(resolve, reject);
	    handle(self, new Handler(onFulfilled, onRejected, res));
	  });
	};
	function handle(self, deferred) {
	  while (self._81 === 3) {
	    self = self._65;
	  }
	  if (Promise._10) {
	    Promise._10(self);
	  }
	  if (self._81 === 0) {
	    if (self._45 === 0) {
	      self._45 = 1;
	      self._54 = deferred;
	      return;
	    }
	    if (self._45 === 1) {
	      self._45 = 2;
	      self._54 = [self._54, deferred];
	      return;
	    }
	    self._54.push(deferred);
	    return;
	  }
	  handleResolved(self, deferred);
	}

	function handleResolved(self, deferred) {
	  asap(function() {
	    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;
	    if (cb === null) {
	      if (self._81 === 1) {
	        resolve(deferred.promise, self._65);
	      } else {
	        reject(deferred.promise, self._65);
	      }
	      return;
	    }
	    var ret = tryCallOne(cb, self._65);
	    if (ret === IS_ERROR) {
	      reject(deferred.promise, LAST_ERROR);
	    } else {
	      resolve(deferred.promise, ret);
	    }
	  });
	}
	function resolve(self, newValue) {
	  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	  if (newValue === self) {
	    return reject(
	      self,
	      new TypeError('A promise cannot be resolved with itself.')
	    );
	  }
	  if (
	    newValue &&
	    (typeof newValue === 'object' || typeof newValue === 'function')
	  ) {
	    var then = getThen(newValue);
	    if (then === IS_ERROR) {
	      return reject(self, LAST_ERROR);
	    }
	    if (
	      then === self.then &&
	      newValue instanceof Promise
	    ) {
	      self._81 = 3;
	      self._65 = newValue;
	      finale(self);
	      return;
	    } else if (typeof then === 'function') {
	      doResolve(then.bind(newValue), self);
	      return;
	    }
	  }
	  self._81 = 1;
	  self._65 = newValue;
	  finale(self);
	}

	function reject(self, newValue) {
	  self._81 = 2;
	  self._65 = newValue;
	  if (Promise._97) {
	    Promise._97(self, newValue);
	  }
	  finale(self);
	}
	function finale(self) {
	  if (self._45 === 1) {
	    handle(self, self._54);
	    self._54 = null;
	  }
	  if (self._45 === 2) {
	    for (var i = 0; i < self._54.length; i++) {
	      handle(self, self._54[i]);
	    }
	    self._54 = null;
	  }
	}

	function Handler(onFulfilled, onRejected, promise){
	  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	  this.promise = promise;
	}

	/**
	 * Take a potentially misbehaving resolver function and make sure
	 * onFulfilled and onRejected are only called once.
	 *
	 * Makes no guarantees about asynchrony.
	 */
	function doResolve(fn, promise) {
	  var done = false;
	  var res = tryCallTwo(fn, function (value) {
	    if (done) return;
	    done = true;
	    resolve(promise, value);
	  }, function (reason) {
	    if (done) return;
	    done = true;
	    reject(promise, reason);
	  })
	  if (!done && res === IS_ERROR) {
	    done = true;
	    reject(promise, LAST_ERROR);
	  }
	}


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(186);

	module.exports = Promise;
	Promise.prototype.done = function (onFulfilled, onRejected) {
	  var self = arguments.length ? this.then.apply(this, arguments) : this;
	  self.then(null, function (err) {
	    setTimeout(function () {
	      throw err;
	    }, 0);
	  });
	};


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(186);

	module.exports = Promise;
	Promise.prototype['finally'] = function (f) {
	  return this.then(function (value) {
	    return Promise.resolve(f()).then(function () {
	      return value;
	    });
	  }, function (err) {
	    return Promise.resolve(f()).then(function () {
	      throw err;
	    });
	  });
	};


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//This file contains the ES6 extensions to the core Promises/A+ API

	var Promise = __webpack_require__(186);

	module.exports = Promise;

	/* Static Functions */

	var TRUE = valuePromise(true);
	var FALSE = valuePromise(false);
	var NULL = valuePromise(null);
	var UNDEFINED = valuePromise(undefined);
	var ZERO = valuePromise(0);
	var EMPTYSTRING = valuePromise('');

	function valuePromise(value) {
	  var p = new Promise(Promise._61);
	  p._81 = 1;
	  p._65 = value;
	  return p;
	}
	Promise.resolve = function (value) {
	  if (value instanceof Promise) return value;

	  if (value === null) return NULL;
	  if (value === undefined) return UNDEFINED;
	  if (value === true) return TRUE;
	  if (value === false) return FALSE;
	  if (value === 0) return ZERO;
	  if (value === '') return EMPTYSTRING;

	  if (typeof value === 'object' || typeof value === 'function') {
	    try {
	      var then = value.then;
	      if (typeof then === 'function') {
	        return new Promise(then.bind(value));
	      }
	    } catch (ex) {
	      return new Promise(function (resolve, reject) {
	        reject(ex);
	      });
	    }
	  }
	  return valuePromise(value);
	};

	Promise.all = function (arr) {
	  var args = Array.prototype.slice.call(arr);

	  return new Promise(function (resolve, reject) {
	    if (args.length === 0) return resolve([]);
	    var remaining = args.length;
	    function res(i, val) {
	      if (val && (typeof val === 'object' || typeof val === 'function')) {
	        if (val instanceof Promise && val.then === Promise.prototype.then) {
	          while (val._81 === 3) {
	            val = val._65;
	          }
	          if (val._81 === 1) return res(i, val._65);
	          if (val._81 === 2) reject(val._65);
	          val.then(function (val) {
	            res(i, val);
	          }, reject);
	          return;
	        } else {
	          var then = val.then;
	          if (typeof then === 'function') {
	            var p = new Promise(then.bind(val));
	            p.then(function (val) {
	              res(i, val);
	            }, reject);
	            return;
	          }
	        }
	      }
	      args[i] = val;
	      if (--remaining === 0) {
	        resolve(args);
	      }
	    }
	    for (var i = 0; i < args.length; i++) {
	      res(i, args[i]);
	    }
	  });
	};

	Promise.reject = function (value) {
	  return new Promise(function (resolve, reject) {
	    reject(value);
	  });
	};

	Promise.race = function (values) {
	  return new Promise(function (resolve, reject) {
	    values.forEach(function(value){
	      Promise.resolve(value).then(resolve, reject);
	    });
	  });
	};

	/* Prototype Methods */

	Promise.prototype['catch'] = function (onRejected) {
	  return this.then(null, onRejected);
	};


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// This file contains then/promise specific extensions that are only useful
	// for node.js interop

	var Promise = __webpack_require__(186);
	var asap = __webpack_require__(250);

	module.exports = Promise;

	/* Static Functions */

	Promise.denodeify = function (fn, argumentCount) {
	  if (
	    typeof argumentCount === 'number' && argumentCount !== Infinity
	  ) {
	    return denodeifyWithCount(fn, argumentCount);
	  } else {
	    return denodeifyWithoutCount(fn);
	  }
	}

	var callbackFn = (
	  'function (err, res) {' +
	  'if (err) { rj(err); } else { rs(res); }' +
	  '}'
	);
	function denodeifyWithCount(fn, argumentCount) {
	  var args = [];
	  for (var i = 0; i < argumentCount; i++) {
	    args.push('a' + i);
	  }
	  var body = [
	    'return function (' + args.join(',') + ') {',
	    'var self = this;',
	    'return new Promise(function (rs, rj) {',
	    'var res = fn.call(',
	    ['self'].concat(args).concat([callbackFn]).join(','),
	    ');',
	    'if (res &&',
	    '(typeof res === "object" || typeof res === "function") &&',
	    'typeof res.then === "function"',
	    ') {rs(res);}',
	    '});',
	    '};'
	  ].join('');
	  return Function(['Promise', 'fn'], body)(Promise, fn);
	}
	function denodeifyWithoutCount(fn) {
	  var fnLength = Math.max(fn.length - 1, 3);
	  var args = [];
	  for (var i = 0; i < fnLength; i++) {
	    args.push('a' + i);
	  }
	  var body = [
	    'return function (' + args.join(',') + ') {',
	    'var self = this;',
	    'var args;',
	    'var argLength = arguments.length;',
	    'if (arguments.length > ' + fnLength + ') {',
	    'args = new Array(arguments.length + 1);',
	    'for (var i = 0; i < arguments.length; i++) {',
	    'args[i] = arguments[i];',
	    '}',
	    '}',
	    'return new Promise(function (rs, rj) {',
	    'var cb = ' + callbackFn + ';',
	    'var res;',
	    'switch (argLength) {',
	    args.concat(['extra']).map(function (_, index) {
	      return (
	        'case ' + (index) + ':' +
	        'res = fn.call(' + ['self'].concat(args.slice(0, index)).concat('cb').join(',') + ');' +
	        'break;'
	      );
	    }).join(''),
	    'default:',
	    'args[argLength] = cb;',
	    'res = fn.apply(self, args);',
	    '}',
	    
	    'if (res &&',
	    '(typeof res === "object" || typeof res === "function") &&',
	    'typeof res.then === "function"',
	    ') {rs(res);}',
	    '});',
	    '};'
	  ].join('');

	  return Function(
	    ['Promise', 'fn'],
	    body
	  )(Promise, fn);
	}

	Promise.nodeify = function (fn) {
	  return function () {
	    var args = Array.prototype.slice.call(arguments);
	    var callback =
	      typeof args[args.length - 1] === 'function' ? args.pop() : null;
	    var ctx = this;
	    try {
	      return fn.apply(this, arguments).nodeify(callback, ctx);
	    } catch (ex) {
	      if (callback === null || typeof callback == 'undefined') {
	        return new Promise(function (resolve, reject) {
	          reject(ex);
	        });
	      } else {
	        asap(function () {
	          callback.call(ctx, ex);
	        })
	      }
	    }
	  }
	}

	Promise.prototype.nodeify = function (callback, ctx) {
	  if (typeof callback != 'function') return this;

	  this.then(function (value) {
	    asap(function () {
	      callback.call(ctx, null, value);
	    });
	  }, function (err) {
	    asap(function () {
	      callback.call(ctx, err);
	    });
	  });
	}


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(186);

	module.exports = Promise;
	Promise.enableSynchronous = function () {
	  Promise.prototype.isPending = function() {
	    return this.getState() == 0;
	  };

	  Promise.prototype.isFulfilled = function() {
	    return this.getState() == 1;
	  };

	  Promise.prototype.isRejected = function() {
	    return this.getState() == 2;
	  };

	  Promise.prototype.getValue = function () {
	    if (this._81 === 3) {
	      return this._65.getValue();
	    }

	    if (!this.isFulfilled()) {
	      throw new Error('Cannot get a value of an unfulfilled promise.');
	    }

	    return this._65;
	  };

	  Promise.prototype.getReason = function () {
	    if (this._81 === 3) {
	      return this._65.getReason();
	    }

	    if (!this.isRejected()) {
	      throw new Error('Cannot get a rejection reason of a non-rejected promise.');
	    }

	    return this._65;
	  };

	  Promise.prototype.getState = function () {
	    if (this._81 === 3) {
	      return this._65.getState();
	    }
	    if (this._81 === -1 || this._81 === -2) {
	      return 0;
	    }

	    return this._81;
	  };
	};

	Promise.disableSynchronous = function() {
	  Promise.prototype.isPending = undefined;
	  Promise.prototype.isFulfilled = undefined;
	  Promise.prototype.isRejected = undefined;
	  Promise.prototype.getValue = undefined;
	  Promise.prototype.getReason = undefined;
	  Promise.prototype.getState = undefined;
	};


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var Schema = __webpack_require__(152);
	module.exports = new Schema({
	    include: [
	        __webpack_require__(213)
	    ],
	    implicit: [
	        __webpack_require__(214),
	        __webpack_require__(215),
	        __webpack_require__(216),
	        __webpack_require__(217)
	    ]
	});
	//# sourceMappingURL=json.js.map

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var YAMLException = __webpack_require__(111);
	var TYPE_CONSTRUCTOR_OPTIONS = [
	    'kind',
	    'resolve',
	    'construct',
	    'instanceOf',
	    'predicate',
	    'represent',
	    'defaultStyle',
	    'styleAliases'
	];
	var YAML_NODE_KINDS = [
	    'scalar',
	    'sequence',
	    'mapping'
	];
	function compileStyleAliases(map) {
	    var result = {};
	    if (null !== map) {
	        Object.keys(map).forEach(function (style) {
	            map[style].forEach(function (alias) {
	                result[String(alias)] = style;
	            });
	        });
	    }
	    return result;
	}
	function Type(tag, options) {
	    options = options || {};
	    Object.keys(options).forEach(function (name) {
	        if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) {
	            throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
	        }
	    });
	    this.tag = tag;
	    this.kind = options['kind'] || null;
	    this.resolve = options['resolve'] || function () { return true; };
	    this.construct = options['construct'] || function (data) { return data; };
	    this.instanceOf = options['instanceOf'] || null;
	    this.predicate = options['predicate'] || null;
	    this.represent = options['represent'] || null;
	    this.defaultStyle = options['defaultStyle'] || null;
	    this.styleAliases = compileStyleAliases(options['styleAliases'] || null);
	    if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) {
	        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
	    }
	}
	module.exports = Type;
	//# sourceMappingURL=type.js.map

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Utils = __webpack_require__(219);

	var internals = {
	    delimiter: '&',
	    arrayPrefixGenerators: {
	        brackets: function (prefix) {
	            return prefix + '[]';
	        },
	        indices: function (prefix, key) {
	            return prefix + '[' + key + ']';
	        },
	        repeat: function (prefix) {
	            return prefix;
	        }
	    },
	    strictNullHandling: false,
	    skipNulls: false,
	    encode: true
	};

	internals.stringify = function (object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort, allowDots) {
	    var obj = object;
	    if (typeof filter === 'function') {
	        obj = filter(prefix, obj);
	    } else if (Utils.isBuffer(obj)) {
	        obj = String(obj);
	    } else if (obj instanceof Date) {
	        obj = obj.toISOString();
	    } else if (obj === null) {
	        if (strictNullHandling) {
	            return encode ? Utils.encode(prefix) : prefix;
	        }

	        obj = '';
	    }

	    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {
	        if (encode) {
	            return [Utils.encode(prefix) + '=' + Utils.encode(obj)];
	        }
	        return [prefix + '=' + obj];
	    }

	    var values = [];

	    if (typeof obj === 'undefined') {
	        return values;
	    }

	    var objKeys;
	    if (Array.isArray(filter)) {
	        objKeys = filter;
	    } else {
	        var keys = Object.keys(obj);
	        objKeys = sort ? keys.sort(sort) : keys;
	    }

	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];

	        if (skipNulls && obj[key] === null) {
	            continue;
	        }

	        if (Array.isArray(obj)) {
	            values = values.concat(internals.stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort, allowDots));
	        } else {
	            values = values.concat(internals.stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort, allowDots));
	        }
	    }

	    return values;
	};

	module.exports = function (object, opts) {
	    var obj = object;
	    var options = opts || {};
	    var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;
	    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;
	    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : internals.skipNulls;
	    var encode = typeof options.encode === 'boolean' ? options.encode : internals.encode;
	    var sort = typeof options.sort === 'function' ? options.sort : null;
	    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
	    var objKeys;
	    var filter;
	    if (typeof options.filter === 'function') {
	        filter = options.filter;
	        obj = filter('', obj);
	    } else if (Array.isArray(options.filter)) {
	        objKeys = filter = options.filter;
	    }

	    var keys = [];

	    if (typeof obj !== 'object' || obj === null) {
	        return '';
	    }

	    var arrayFormat;
	    if (options.arrayFormat in internals.arrayPrefixGenerators) {
	        arrayFormat = options.arrayFormat;
	    } else if ('indices' in options) {
	        arrayFormat = options.indices ? 'indices' : 'repeat';
	    } else {
	        arrayFormat = 'indices';
	    }

	    var generateArrayPrefix = internals.arrayPrefixGenerators[arrayFormat];

	    if (!objKeys) {
	        objKeys = Object.keys(obj);
	    }

	    if (sort) {
	        objKeys.sort(sort);
	    }

	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];

	        if (skipNulls && obj[key] === null) {
	            continue;
	        }

	        keys = keys.concat(internals.stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort, allowDots));
	    }

	    return keys.join(delimiter);
	};


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Utils = __webpack_require__(219);

	var internals = {
	    delimiter: '&',
	    depth: 5,
	    arrayLimit: 20,
	    parameterLimit: 1000,
	    strictNullHandling: false,
	    plainObjects: false,
	    allowPrototypes: false,
	    allowDots: false
	};

	internals.parseValues = function (str, options) {
	    var obj = {};
	    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);

	    for (var i = 0; i < parts.length; ++i) {
	        var part = parts[i];
	        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;

	        if (pos === -1) {
	            obj[Utils.decode(part)] = '';

	            if (options.strictNullHandling) {
	                obj[Utils.decode(part)] = null;
	            }
	        } else {
	            var key = Utils.decode(part.slice(0, pos));
	            var val = Utils.decode(part.slice(pos + 1));

	            if (Object.prototype.hasOwnProperty.call(obj, key)) {
	                obj[key] = [].concat(obj[key]).concat(val);
	            } else {
	                obj[key] = val;
	            }
	        }
	    }

	    return obj;
	};

	internals.parseObject = function (chain, val, options) {
	    if (!chain.length) {
	        return val;
	    }

	    var root = chain.shift();

	    var obj;
	    if (root === '[]') {
	        obj = [];
	        obj = obj.concat(internals.parseObject(chain, val, options));
	    } else {
	        obj = options.plainObjects ? Object.create(null) : {};
	        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
	        var index = parseInt(cleanRoot, 10);
	        if (
	            !isNaN(index) &&
	            root !== cleanRoot &&
	            String(index) === cleanRoot &&
	            index >= 0 &&
	            (options.parseArrays && index <= options.arrayLimit)
	        ) {
	            obj = [];
	            obj[index] = internals.parseObject(chain, val, options);
	        } else {
	            obj[cleanRoot] = internals.parseObject(chain, val, options);
	        }
	    }

	    return obj;
	};

	internals.parseKeys = function (givenKey, val, options) {
	    if (!givenKey) {
	        return;
	    }

	    // Transform dot notation to bracket notation
	    var key = options.allowDots ? givenKey.replace(/\.([^\.\[]+)/g, '[$1]') : givenKey;

	    // The regex chunks

	    var parent = /^([^\[\]]*)/;
	    var child = /(\[[^\[\]]*\])/g;

	    // Get the parent

	    var segment = parent.exec(key);

	    // Stash the parent if it exists

	    var keys = [];
	    if (segment[1]) {
	        // If we aren't using plain objects, optionally prefix keys
	        // that would overwrite object prototype properties
	        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1])) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }

	        keys.push(segment[1]);
	    }

	    // Loop through children appending to the array until we hit depth

	    var i = 0;
	    while ((segment = child.exec(key)) !== null && i < options.depth) {
	        i += 1;
	        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {
	            if (!options.allowPrototypes) {
	                continue;
	            }
	        }
	        keys.push(segment[1]);
	    }

	    // If there's a remainder, just add whatever is left

	    if (segment) {
	        keys.push('[' + key.slice(segment.index) + ']');
	    }

	    return internals.parseObject(keys, val, options);
	};

	module.exports = function (str, opts) {
	    var options = opts || {};
	    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;
	    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;
	    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;
	    options.parseArrays = options.parseArrays !== false;
	    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : internals.allowDots;
	    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : internals.plainObjects;
	    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : internals.allowPrototypes;
	    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;
	    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;

	    if (
	        str === '' ||
	        str === null ||
	        typeof str === 'undefined'
	    ) {
	        return options.plainObjects ? Object.create(null) : {};
	    }

	    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;
	    var obj = options.plainObjects ? Object.create(null) : {};

	    // Iterate over the keys and setup the new object

	    var keys = Object.keys(tempObj);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var newObj = internals.parseKeys(key, tempObj[key], options);
	        obj = Utils.merge(obj, newObj, options);
	    }

	    return Utils.compact(obj);
	};


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @preserve date-and-time.js (c) KNOWLEDGECODE | MIT
	 */
	(function (global) {
	    'use strict';

	    var date = {},
	        lang = 'en',
	        locales = {
	            en: {
	                MMMM: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
	                MMM: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
	                dddd: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
	                ddd: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
	                dd: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
	                A: ['a.m.', 'p.m.'],
	                formats: {
	                    YYYY: function (d) { return ('000' + d.getFullYear()).slice(-4); },
	                    YY: function (d) { return ('0' + d.getFullYear()).slice(-2); },
	                    Y: function (d) { return '' + d.getFullYear(); },
	                    MMMM: function (d) { return this.MMMM[d.getMonth()]; },
	                    MMM: function (d) { return this.MMM[d.getMonth()]; },
	                    MM: function (d) { return ('0' + (d.getMonth() + 1)).slice(-2); },
	                    M: function (d) { return '' + (d.getMonth() + 1); },
	                    DD: function (d) { return ('0' + d.getDate()).slice(-2); },
	                    D: function (d) { return '' + d.getDate(); },
	                    HH: function (d) { return ('0' + d.getHours()).slice(-2); },
	                    H: function (d) { return '' + d.getHours(); },
	                    A: function (d) { return this.A[d.getHours() > 11 | 0]; },
	                    hh: function (d) { return ('0' + (d.getHours() % 12 || 12)).slice(-2); },
	                    h: function (d) { return '' + (d.getHours() % 12 || 12); },
	                    mm: function (d) { return ('0' + d.getMinutes()).slice(-2); },
	                    m: function (d) { return '' + d.getMinutes(); },
	                    ss: function (d) { return ('0' + d.getSeconds()).slice(-2); },
	                    s: function (d) { return '' + d.getSeconds(); },
	                    SSS: function (d) { return ('00' + d.getMilliseconds()).slice(-3); },
	                    SS: function (d) { return ('0' + (d.getMilliseconds() / 10 | 0)).slice(-2); },
	                    S: function (d) { return '' + (d.getMilliseconds() / 100 | 0); },
	                    dddd: function (d) { return this.dddd[d.getDay()]; },
	                    ddd: function (d) { return this.ddd[d.getDay()]; },
	                    dd: function (d) { return this.dd[d.getDay()]; },
	                    Z: function (d) {
	                        var offset = d.utc ? 0 : d.getTimezoneOffset() / 0.6;
	                        return (offset > 0 ? '-' : '+') + ('000' + Math.abs(offset - offset % 100 * 0.4)).slice(-4);
	                    },
	                    post: function (str) { return str; }
	                },
	                parsers: {
	                    h: function (h, a) { return (h === 12 ? 0 : h) + a * 12; },
	                    pre: function (str) { return str; }
	                }
	            }
	        },
	        isCommonJS = function () {
	            return typeof module === 'object' && typeof module.exports === 'object';
	        },
	        forEach = function (array, fn) {
	            for (var i = 0, len = array.length; i < len; i++) {
	                if (fn(array[i], i) === 0) {
	                    break;
	                }
	            }
	        },
	        parse = function (dateString, formatString) {
	            var offset = 0, k, length, str,
	                keys = formatString.match(/YYYY|YY|MMM?M?|DD|HH|hh|mm|ss|SSS?|./g),
	                dt = { Y: 0, M: 1, D: 1, A: 0, H: 0, h: 0, m: 0, s: 0, S: 0 };

	            dateString = locales[lang].parsers.pre(dateString);
	            forEach(keys, function (key) {
	                k = key.charAt(0);
	                length = key.length;
	                str = dateString.slice(offset);
	                if (/^(MM|DD|HH|hh|mm|ss|SS?S?)$/.test(key)) {
	                    dt[k] = str.slice(0, length) | 0;
	                } else if (/^(YYYY|YY|M|D|H|h|m|s)$/.test(key)) {
	                    str = (str.match(length === 4 ? /^\d{1,4}/ : /^\d\d?/) || [''])[0];
	                    length = str.length;
	                    dt[k] = str | 0;
	                    if (k === 'Y' && dt.Y < 70) {
	                        dt.Y += 2000;
	                    }
	                } else if (/^(MMMM?|A)$/.test(key)) {
	                    forEach(locales[lang][key], function (val, i) {
	                        if (!str.indexOf(val)) {
	                            dt[k] = k === 'M' ? i + 1 : i;
	                            length = val.length;
	                            return 0;
	                        }
	                    });
	                }
	                offset += length;
	            });
	            return dt;
	        },
	        toH = function (h, a) {
	            return locales[lang].parsers.h(h, a);
	        };

	    /**
	     * formatting a date
	     * @param {Object} dateObj - target date
	     * @param {String} formatString - format string
	     * @param {Boolean} [utc] - output as UTC
	     * @returns {String} the formatted string
	     */
	    date.format = function (dateObj, formatString, utc) {
	        var d = new Date(dateObj.getTime() + (utc ? dateObj.getTimezoneOffset() * 60000 : 0)),
	            locale = locales[lang], formats = locale.formats;

	        d.utc = utc;
	        return formatString.replace(/(\[[^\[\]]*]|\[.*\][^\[]*\]|YYYY|YY|MMM?M?|DD|HH|hh|mm|ss|SSS?|ddd?d?|.)/g, function (token) {
	            var format = formats[token];
	            return format ? formats.post(format.call(locale, d)) : token.replace(/\[(.*)]/, '$1');
	        });
	    };

	    /**
	     * parsing a date string
	     * @param {String} dateString - date string
	     * @param {String} formatString - format string
	     * @param {Boolean} [utc] - input as UTC
	     * @returns {Object} the constructed date
	     */
	    date.parse = function (dateString, formatString, utc) {
	        var dt = parse(dateString, formatString),
	            dateObj = new Date(dt.Y, dt.M - 1, dt.D, dt.H || toH(dt.h, dt.A), dt.m, dt.s, dt.S);

	        return utc ? new Date(dateObj.getTime() - dateObj.getTimezoneOffset() * 60000) : dateObj;
	    };

	    /**
	     * validation
	     * @param {String} dateString - date string
	     * @param {String} formatString - format string
	     * @returns {Boolean} whether the date string is a valid date
	     */
	    date.isValid = function (dateString, formatString) {
	        var dt = parse(dateString, formatString),
	            H = dt.H || toH(dt.h, dt.A),
	            d = new Date(dt.Y, dt.M - 1, dt.D, H, dt.m, dt.s, dt.S);

	        return dt.Y === d.getFullYear() && dt.M - 1 === d.getMonth() && dt.D === d.getDate()
	            && H === d.getHours() && dt.m === d.getMinutes() && dt.s === d.getSeconds()
	            && dt.S === d.getMilliseconds();
	    };

	    /**
	     * adding years
	     * @param {Object} dateObj - the augend
	     * @param {Number} years - the addend
	     * @returns {Object} the date after addition
	     */
	    date.addYears = function (dateObj, years) {
	        var d = new Date(dateObj.getTime());

	        d.setFullYear(d.getFullYear() + years);
	        return d;
	    };

	    /**
	     * adding months
	     * @param {Object} dateObj - the augend
	     * @param {Number} months - the addend
	     * @returns {Object} the date after addition
	     */
	    date.addMonths = function (dateObj, months) {
	        var d = new Date(dateObj.getTime());

	        d.setMonth(d.getMonth() + months);
	        return d;
	    };

	    /**
	     * adding days
	     * @param {Object} dateObj - the augend
	     * @param {Number} days - the addend
	     * @returns {Object} the date after addition
	     */
	    date.addDays = function (dateObj, days) {
	        return new Date(dateObj.getTime() + days * 86400000);
	    };

	    /**
	     * adding hours
	     * @param {Object} dateObj - the augend
	     * @param {Number} hours - the addend
	     * @returns {Object} the date after addition
	     */
	    date.addHours = function (dateObj, hours) {
	        return new Date(dateObj.getTime() + hours * 3600000);
	    };

	    /**
	     * adding minutes
	     * @param {Object} dateObj - the augend
	     * @param {Number} minutes - the addend
	     * @returns {Object} the date after addition
	     */
	    date.addMinutes = function (dateObj, minutes) {
	        return new Date(dateObj.getTime() + minutes * 60000);
	    };

	    /**
	     * adding seconds
	     * @param {Object} dateObj - the augend
	     * @param {Number} seconds - the addend
	     * @returns {Object} the date after addition
	     */
	    date.addSeconds = function (dateObj, seconds) {
	        return new Date(dateObj.getTime() + seconds * 1000);
	    };

	    /**
	     * adding milliseconds
	     * @param {Object} dateObj - the augend
	     * @param {Number} milliseconds - the addend
	     * @returns {Object} the date after addition
	     */
	    date.addMilliseconds = function (dateObj, milliseconds) {
	        return new Date(dateObj.getTime() + milliseconds);
	    };

	    /**
	     * subtracting
	     * @param {Object} date1 - the minuend
	     * @param {Object} date2 - the subtrahend
	     * @returns {Object} the result object after subtraction
	     */
	    date.subtract = function (date1, date2) {
	        var delta = date1.getTime() - date2.getTime();

	        return {
	            toMilliseconds: function () {
	                return delta;
	            },
	            toSeconds: function () {
	                return delta / 1000 | 0;
	            },
	            toMinutes: function () {
	                return delta / 60000 | 0;
	            },
	            toHours: function () {
	                return delta / 3600000 | 0;
	            },
	            toDays: function () {
	                return delta / 86400000 | 0;
	            }
	        };
	    };

	    /**
	     * leap year
	     * @param {Object} dateObj - target date
	     * @returns {Boolean} whether the year is a leap year
	     */
	    date.isLeapYear = function (dateObj) {
	        var y = dateObj.getFullYear();
	        return (!(y % 4) && !!(y % 100)) || !(y % 400);
	    };

	    /**
	     * setting a locale
	     * @param {String} [code] - language code
	     * @returns {String} current language code
	     */
	    date.locale = function (code) {
	        if (code) {
	            if (code !== 'en' && isCommonJS()) {
	                __webpack_require__(220)("./" + code);
	            }
	            lang = code;
	        }
	        return lang;
	    };

	    /**
	     * getting a definition of locale
	     * @param {String} code - language code
	     * @returns {Object} definition of locale
	     */
	    date.getLocales = function (code) {
	        return locales[code || lang];
	    };

	    /**
	     * adding a new definition of locale
	     * @param {String} code - language code
	     * @param {Object} options - definition of locale
	     * @returns {void}
	     */
	    date.setLocales = function (code, options) {
	        var copy = function (src, proto) {
	                var Locale = function () {}, dst, key;

	                Locale.prototype = proto;
	                dst = new Locale();
	                for (key in src) {
	                    if (src.hasOwnProperty(key)) {
	                        dst[key] = src[key];
	                    }
	                }
	                return dst;
	            },
	            base = locales[code] || locales.en,
	            locale = copy(options, base);

	        if (options.formats) {
	            locale.formats = copy(options.formats, base.formats);
	        }
	        if (options.parsers) {
	            locale.parsers = copy(options.parsers, base.parsers);
	        }
	        locales[code] = locale;
	    };

	    if (isCommonJS()) {
	        module.exports = date;
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return date;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        global.date = date;
	    }

	}(this));



/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  "use strict";
	  var bom, builder, escapeCDATA, events, isEmpty, processName, processors, requiresCDATA, sax, setImmediate, wrapCDATA,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty,
	    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

	  sax = __webpack_require__(259);

	  events = __webpack_require__(201);

	  builder = __webpack_require__(258);

	  bom = __webpack_require__(226);

	  processors = __webpack_require__(227);

	  setImmediate = __webpack_require__(251).setImmediate;

	  isEmpty = function(thing) {
	    return typeof thing === "object" && (thing != null) && Object.keys(thing).length === 0;
	  };

	  processName = function(processors, processedName) {
	    var i, len, process;
	    for (i = 0, len = processors.length; i < len; i++) {
	      process = processors[i];
	      processedName = process(processedName);
	    }
	    return processedName;
	  };

	  requiresCDATA = function(entry) {
	    return entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0;
	  };

	  wrapCDATA = function(entry) {
	    return "<![CDATA[" + (escapeCDATA(entry)) + "]]>";
	  };

	  escapeCDATA = function(entry) {
	    return entry.replace(']]>', ']]]]><![CDATA[>');
	  };

	  exports.processors = processors;

	  exports.defaults = {
	    "0.1": {
	      explicitCharkey: false,
	      trim: true,
	      normalize: true,
	      normalizeTags: false,
	      attrkey: "@",
	      charkey: "#",
	      explicitArray: false,
	      ignoreAttrs: false,
	      mergeAttrs: false,
	      explicitRoot: false,
	      validator: null,
	      xmlns: false,
	      explicitChildren: false,
	      childkey: '@@',
	      charsAsChildren: false,
	      async: false,
	      strict: true,
	      attrNameProcessors: null,
	      attrValueProcessors: null,
	      tagNameProcessors: null,
	      valueProcessors: null,
	      emptyTag: ''
	    },
	    "0.2": {
	      explicitCharkey: false,
	      trim: false,
	      normalize: false,
	      normalizeTags: false,
	      attrkey: "$",
	      charkey: "_",
	      explicitArray: true,
	      ignoreAttrs: false,
	      mergeAttrs: false,
	      explicitRoot: true,
	      validator: null,
	      xmlns: false,
	      explicitChildren: false,
	      preserveChildrenOrder: false,
	      childkey: '$$',
	      charsAsChildren: false,
	      async: false,
	      strict: true,
	      attrNameProcessors: null,
	      attrValueProcessors: null,
	      tagNameProcessors: null,
	      valueProcessors: null,
	      rootName: 'root',
	      xmldec: {
	        'version': '1.0',
	        'encoding': 'UTF-8',
	        'standalone': true
	      },
	      doctype: null,
	      renderOpts: {
	        'pretty': true,
	        'indent': '  ',
	        'newline': '\n'
	      },
	      headless: false,
	      chunkSize: 10000,
	      emptyTag: '',
	      cdata: false
	    }
	  };

	  exports.ValidationError = (function(superClass) {
	    extend(ValidationError, superClass);

	    function ValidationError(message) {
	      this.message = message;
	    }

	    return ValidationError;

	  })(Error);

	  exports.Builder = (function() {
	    function Builder(opts) {
	      var key, ref, value;
	      this.options = {};
	      ref = exports.defaults["0.2"];
	      for (key in ref) {
	        if (!hasProp.call(ref, key)) continue;
	        value = ref[key];
	        this.options[key] = value;
	      }
	      for (key in opts) {
	        if (!hasProp.call(opts, key)) continue;
	        value = opts[key];
	        this.options[key] = value;
	      }
	    }

	    Builder.prototype.buildObject = function(rootObj) {
	      var attrkey, charkey, render, rootElement, rootName;
	      attrkey = this.options.attrkey;
	      charkey = this.options.charkey;
	      if ((Object.keys(rootObj).length === 1) && (this.options.rootName === exports.defaults['0.2'].rootName)) {
	        rootName = Object.keys(rootObj)[0];
	        rootObj = rootObj[rootName];
	      } else {
	        rootName = this.options.rootName;
	      }
	      render = (function(_this) {
	        return function(element, obj) {
	          var attr, child, entry, index, key, value;
	          if (typeof obj !== 'object') {
	            if (_this.options.cdata && requiresCDATA(obj)) {
	              element.raw(wrapCDATA(obj));
	            } else {
	              element.txt(obj);
	            }
	          } else {
	            for (key in obj) {
	              if (!hasProp.call(obj, key)) continue;
	              child = obj[key];
	              if (key === attrkey) {
	                if (typeof child === "object") {
	                  for (attr in child) {
	                    value = child[attr];
	                    element = element.att(attr, value);
	                  }
	                }
	              } else if (key === charkey) {
	                if (_this.options.cdata && requiresCDATA(child)) {
	                  element = element.raw(wrapCDATA(child));
	                } else {
	                  element = element.txt(child);
	                }
	              } else if (Array.isArray(child)) {
	                for (index in child) {
	                  if (!hasProp.call(child, index)) continue;
	                  entry = child[index];
	                  if (typeof entry === 'string') {
	                    if (_this.options.cdata && requiresCDATA(entry)) {
	                      element = element.ele(key).raw(wrapCDATA(entry)).up();
	                    } else {
	                      element = element.ele(key, entry).up();
	                    }
	                  } else {
	                    element = render(element.ele(key), entry).up();
	                  }
	                }
	              } else if (typeof child === "object") {
	                element = render(element.ele(key), child).up();
	              } else {
	                if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
	                  element = element.ele(key).raw(wrapCDATA(child)).up();
	                } else {
	                  if (child == null) {
	                    child = '';
	                  }
	                  element = element.ele(key, child.toString()).up();
	                }
	              }
	            }
	          }
	          return element;
	        };
	      })(this);
	      rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
	        headless: this.options.headless,
	        allowSurrogateChars: this.options.allowSurrogateChars
	      });
	      return render(rootElement, rootObj).end(this.options.renderOpts);
	    };

	    return Builder;

	  })();

	  exports.Parser = (function(superClass) {
	    extend(Parser, superClass);

	    function Parser(opts) {
	      this.parseString = bind(this.parseString, this);
	      this.reset = bind(this.reset, this);
	      this.assignOrPush = bind(this.assignOrPush, this);
	      this.processAsync = bind(this.processAsync, this);
	      var key, ref, value;
	      if (!(this instanceof exports.Parser)) {
	        return new exports.Parser(opts);
	      }
	      this.options = {};
	      ref = exports.defaults["0.2"];
	      for (key in ref) {
	        if (!hasProp.call(ref, key)) continue;
	        value = ref[key];
	        this.options[key] = value;
	      }
	      for (key in opts) {
	        if (!hasProp.call(opts, key)) continue;
	        value = opts[key];
	        this.options[key] = value;
	      }
	      if (this.options.xmlns) {
	        this.options.xmlnskey = this.options.attrkey + "ns";
	      }
	      if (this.options.normalizeTags) {
	        if (!this.options.tagNameProcessors) {
	          this.options.tagNameProcessors = [];
	        }
	        this.options.tagNameProcessors.unshift(processors.normalize);
	      }
	      this.reset();
	    }

	    Parser.prototype.processAsync = function() {
	      var chunk, err, error1;
	      try {
	        if (this.remaining.length <= this.options.chunkSize) {
	          chunk = this.remaining;
	          this.remaining = '';
	          this.saxParser = this.saxParser.write(chunk);
	          return this.saxParser.close();
	        } else {
	          chunk = this.remaining.substr(0, this.options.chunkSize);
	          this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
	          this.saxParser = this.saxParser.write(chunk);
	          return setImmediate(this.processAsync);
	        }
	      } catch (error1) {
	        err = error1;
	        if (!this.saxParser.errThrown) {
	          this.saxParser.errThrown = true;
	          return this.emit(err);
	        }
	      }
	    };

	    Parser.prototype.assignOrPush = function(obj, key, newValue) {
	      if (!(key in obj)) {
	        if (!this.options.explicitArray) {
	          return obj[key] = newValue;
	        } else {
	          return obj[key] = [newValue];
	        }
	      } else {
	        if (!(obj[key] instanceof Array)) {
	          obj[key] = [obj[key]];
	        }
	        return obj[key].push(newValue);
	      }
	    };

	    Parser.prototype.reset = function() {
	      var attrkey, charkey, ontext, stack;
	      this.removeAllListeners();
	      this.saxParser = sax.parser(this.options.strict, {
	        trim: false,
	        normalize: false,
	        xmlns: this.options.xmlns
	      });
	      this.saxParser.errThrown = false;
	      this.saxParser.onerror = (function(_this) {
	        return function(error) {
	          _this.saxParser.resume();
	          if (!_this.saxParser.errThrown) {
	            _this.saxParser.errThrown = true;
	            return _this.emit("error", error);
	          }
	        };
	      })(this);
	      this.saxParser.onend = (function(_this) {
	        return function() {
	          if (!_this.saxParser.ended) {
	            _this.saxParser.ended = true;
	            return _this.emit("end", _this.resultObject);
	          }
	        };
	      })(this);
	      this.saxParser.ended = false;
	      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
	      this.resultObject = null;
	      stack = [];
	      attrkey = this.options.attrkey;
	      charkey = this.options.charkey;
	      this.saxParser.onopentag = (function(_this) {
	        return function(node) {
	          var key, newValue, obj, processedKey, ref;
	          obj = {};
	          obj[charkey] = "";
	          if (!_this.options.ignoreAttrs) {
	            ref = node.attributes;
	            for (key in ref) {
	              if (!hasProp.call(ref, key)) continue;
	              if (!(attrkey in obj) && !_this.options.mergeAttrs) {
	                obj[attrkey] = {};
	              }
	              newValue = _this.options.attrValueProcessors ? processName(_this.options.attrValueProcessors, node.attributes[key]) : node.attributes[key];
	              processedKey = _this.options.attrNameProcessors ? processName(_this.options.attrNameProcessors, key) : key;
	              if (_this.options.mergeAttrs) {
	                _this.assignOrPush(obj, processedKey, newValue);
	              } else {
	                obj[attrkey][processedKey] = newValue;
	              }
	            }
	          }
	          obj["#name"] = _this.options.tagNameProcessors ? processName(_this.options.tagNameProcessors, node.name) : node.name;
	          if (_this.options.xmlns) {
	            obj[_this.options.xmlnskey] = {
	              uri: node.uri,
	              local: node.local
	            };
	          }
	          return stack.push(obj);
	        };
	      })(this);
	      this.saxParser.onclosetag = (function(_this) {
	        return function() {
	          var cdata, emptyStr, err, error1, key, node, nodeName, obj, objClone, old, s, xpath;
	          obj = stack.pop();
	          nodeName = obj["#name"];
	          if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
	            delete obj["#name"];
	          }
	          if (obj.cdata === true) {
	            cdata = obj.cdata;
	            delete obj.cdata;
	          }
	          s = stack[stack.length - 1];
	          if (obj[charkey].match(/^\s*$/) && !cdata) {
	            emptyStr = obj[charkey];
	            delete obj[charkey];
	          } else {
	            if (_this.options.trim) {
	              obj[charkey] = obj[charkey].trim();
	            }
	            if (_this.options.normalize) {
	              obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
	            }
	            obj[charkey] = _this.options.valueProcessors ? processName(_this.options.valueProcessors, obj[charkey]) : obj[charkey];
	            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
	              obj = obj[charkey];
	            }
	          }
	          if (isEmpty(obj)) {
	            obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
	          }
	          if (_this.options.validator != null) {
	            xpath = "/" + ((function() {
	              var i, len, results;
	              results = [];
	              for (i = 0, len = stack.length; i < len; i++) {
	                node = stack[i];
	                results.push(node["#name"]);
	              }
	              return results;
	            })()).concat(nodeName).join("/");
	            try {
	              obj = _this.options.validator(xpath, s && s[nodeName], obj);
	            } catch (error1) {
	              err = error1;
	              _this.emit("error", err);
	            }
	          }
	          if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
	            if (!_this.options.preserveChildrenOrder) {
	              node = {};
	              if (_this.options.attrkey in obj) {
	                node[_this.options.attrkey] = obj[_this.options.attrkey];
	                delete obj[_this.options.attrkey];
	              }
	              if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
	                node[_this.options.charkey] = obj[_this.options.charkey];
	                delete obj[_this.options.charkey];
	              }
	              if (Object.getOwnPropertyNames(obj).length > 0) {
	                node[_this.options.childkey] = obj;
	              }
	              obj = node;
	            } else if (s) {
	              s[_this.options.childkey] = s[_this.options.childkey] || [];
	              objClone = {};
	              for (key in obj) {
	                if (!hasProp.call(obj, key)) continue;
	                objClone[key] = obj[key];
	              }
	              s[_this.options.childkey].push(objClone);
	              delete obj["#name"];
	              if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
	                obj = obj[charkey];
	              }
	            }
	          }
	          if (stack.length > 0) {
	            return _this.assignOrPush(s, nodeName, obj);
	          } else {
	            if (_this.options.explicitRoot) {
	              old = obj;
	              obj = {};
	              obj[nodeName] = old;
	            }
	            _this.resultObject = obj;
	            _this.saxParser.ended = true;
	            return _this.emit("end", _this.resultObject);
	          }
	        };
	      })(this);
	      ontext = (function(_this) {
	        return function(text) {
	          var charChild, s;
	          s = stack[stack.length - 1];
	          if (s) {
	            s[charkey] += text;
	            if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && text.replace(/\\n/g, '').trim() !== '') {
	              s[_this.options.childkey] = s[_this.options.childkey] || [];
	              charChild = {
	                '#name': '__text__'
	              };
	              charChild[charkey] = text;
	              s[_this.options.childkey].push(charChild);
	            }
	            return s;
	          }
	        };
	      })(this);
	      this.saxParser.ontext = ontext;
	      return this.saxParser.oncdata = (function(_this) {
	        return function(text) {
	          var s;
	          s = ontext(text);
	          if (s) {
	            return s.cdata = true;
	          }
	        };
	      })(this);
	    };

	    Parser.prototype.parseString = function(str, cb) {
	      var err, error1;
	      if ((cb != null) && typeof cb === "function") {
	        this.on("end", function(result) {
	          this.reset();
	          return cb(null, result);
	        });
	        this.on("error", function(err) {
	          this.reset();
	          return cb(err);
	        });
	      }
	      try {
	        str = str.toString();
	        if (str.trim() === '') {
	          this.emit("end", null);
	          return true;
	        }
	        str = bom.stripBOM(str);
	        if (this.options.async) {
	          this.remaining = str;
	          setImmediate(this.processAsync);
	          return this.saxParser;
	        }
	        return this.saxParser.write(str).close();
	      } catch (error1) {
	        err = error1;
	        if (!(this.saxParser.errThrown || this.saxParser.ended)) {
	          this.emit('error', err);
	          return this.saxParser.errThrown = true;
	        } else if (this.saxParser.ended) {
	          throw err;
	        }
	      }
	    };

	    return Parser;

	  })(events.EventEmitter);

	  exports.parseString = function(str, a, b) {
	    var cb, options, parser;
	    if (b != null) {
	      if (typeof b === 'function') {
	        cb = b;
	      }
	      if (typeof a === 'object') {
	        options = a;
	      }
	    } else {
	      if (typeof a === 'function') {
	        cb = a;
	      }
	      options = {};
	    }
	    parser = new exports.Parser(options);
	    return parser.parseString(str, cb);
	  };

	}).call(this);


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
	//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
	//[5]   	Name	   ::=   	NameStartChar (NameChar)*
	var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]///\u10000-\uEFFFF
	var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\u00B7\u0300-\u036F\\u203F-\u2040]");
	var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
	//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
	//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

	//S_TAG,	S_ATTR,	S_EQ,	S_V
	//S_ATTR_S,	S_E,	S_S,	S_C
	var S_TAG = 0;//tag name offerring
	var S_ATTR = 1;//attr name offerring 
	var S_ATTR_S=2;//attr name end and space offer
	var S_EQ = 3;//=space?
	var S_V = 4;//attr value(no quot value only)
	var S_E = 5;//attr value end and no space(quot end)
	var S_S = 6;//(attr value end || tag end ) && (space offer)
	var S_C = 7;//closed el<el />

	function XMLReader(){
		
	}

	XMLReader.prototype = {
		parse:function(source,defaultNSMap,entityMap){
			var domBuilder = this.domBuilder;
			domBuilder.startDocument();
			_copy(defaultNSMap ,defaultNSMap = {})
			parse(source,defaultNSMap,entityMap,
					domBuilder,this.errorHandler);
			domBuilder.endDocument();
		}
	}
	function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
	  function fixedFromCharCode(code) {
			// String.prototype.fromCharCode does not supports
			// > 2 bytes unicode chars directly
			if (code > 0xffff) {
				code -= 0x10000;
				var surrogate1 = 0xd800 + (code >> 10)
					, surrogate2 = 0xdc00 + (code & 0x3ff);

				return String.fromCharCode(surrogate1, surrogate2);
			} else {
				return String.fromCharCode(code);
			}
		}
		function entityReplacer(a){
			var k = a.slice(1,-1);
			if(k in entityMap){
				return entityMap[k]; 
			}else if(k.charAt(0) === '#'){
				return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
			}else{
				errorHandler.error('entity not found:'+a);
				return a;
			}
		}
		function appendText(end){//has some bugs
			if(end>start){
				var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
				locator&&position(start);
				domBuilder.characters(xt,0,end-start);
				start = end
			}
		}
		function position(p,m){
			while(p>=lineEnd && (m = linePattern.exec(source))){
				lineStart = m.index;
				lineEnd = lineStart + m[0].length;
				locator.lineNumber++;
				//console.log('line++:',locator,startPos,endPos)
			}
			locator.columnNumber = p-lineStart+1;
		}
		var lineStart = 0;
		var lineEnd = 0;
		var linePattern = /.+(?:\r\n?|\n)|.*$/g
		var locator = domBuilder.locator;
		
		var parseStack = [{currentNSMap:defaultNSMapCopy}]
		var closeMap = {};
		var start = 0;
		while(true){
			try{
				var tagStart = source.indexOf('<',start);
				if(tagStart<0){
					if(!source.substr(start).match(/^\s*$/)){
						var doc = domBuilder.document;
		    			var text = doc.createTextNode(source.substr(start));
		    			doc.appendChild(text);
		    			domBuilder.currentElement = text;
					}
					return;
				}
				if(tagStart>start){
					appendText(tagStart);
				}
				switch(source.charAt(tagStart+1)){
				case '/':
					var end = source.indexOf('>',tagStart+3);
					var tagName = source.substring(tagStart+2,end);
					var config = parseStack.pop();
					var localNSMap = config.localNSMap;
			        if(config.tagName != tagName){
			            errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName );
			        }
					domBuilder.endElement(config.uri,config.localName,tagName);
					if(localNSMap){
						for(var prefix in localNSMap){
							domBuilder.endPrefixMapping(prefix) ;
						}
					}
					end++;
					break;
					// end elment
				case '?':// <?...?>
					locator&&position(tagStart);
					end = parseInstruction(source,tagStart,domBuilder);
					break;
				case '!':// <!doctype,<![CDATA,<!--
					locator&&position(tagStart);
					end = parseDCC(source,tagStart,domBuilder,errorHandler);
					break;
				default:
				
					locator&&position(tagStart);
					
					var el = new ElementAttributes();
					
					//elStartEnd
					var end = parseElementStartPart(source,tagStart,el,entityReplacer,errorHandler);
					var len = el.length;
					
					if(locator){
						if(len){
							//attribute position fixed
							for(var i = 0;i<len;i++){
								var a = el[i];
								position(a.offset);
								a.offset = copyLocator(locator,{});
							}
						}
						position(end);
					}
					if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
						el.closed = true;
						if(!entityMap.nbsp){
							errorHandler.warning('unclosed xml attribute');
						}
					}
					appendElement(el,domBuilder,parseStack);
					
					
					if(el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed){
						end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)
					}else{
						end++;
					}
				}
			}catch(e){
				errorHandler.error('element parse error: '+e);
				end = -1;
			}
			if(end>start){
				start = end;
			}else{
				//TODO: sax
				appendText(Math.max(tagStart,start)+1);
			}
		}
	}
	function copyLocator(f,t){
		t.lineNumber = f.lineNumber;
		t.columnNumber = f.columnNumber;
		return t;
	}

	/**
	 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
	 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
	 */
	function parseElementStartPart(source,start,el,entityReplacer,errorHandler){
		var attrName;
		var value;
		var p = ++start;
		var s = S_TAG;//status
		while(true){
			var c = source.charAt(p);
			switch(c){
			case '=':
				if(s === S_ATTR){//attrName
					attrName = source.slice(start,p);
					s = S_EQ;
				}else if(s === S_ATTR_S){
					s = S_EQ;
				}else{
					//fatalError: equal must after attrName or space after attrName
					throw new Error('attribute equal must after attrName');
				}
				break;
			case '\'':
			case '"':
				if(s === S_EQ){//equal
					start = p+1;
					p = source.indexOf(c,start)
					if(p>0){
						value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
						el.add(attrName,value,start-1);
						s = S_E;
					}else{
						//fatalError: no end quot match
						throw new Error('attribute value no end \''+c+'\' match');
					}
				}else if(s == S_V){
					value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					//console.log(attrName,value,start,p)
					el.add(attrName,value,start);
					//console.dir(el)
					errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
					start = p+1;
					s = S_E
				}else{
					//fatalError: no equal before
					throw new Error('attribute value must after "="');
				}
				break;
			case '/':
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));
				case S_E:
				case S_S:
				case S_C:
					s = S_C;
					el.closed = true;
				case S_V:
				case S_ATTR:
				case S_ATTR_S:
					break;
				//case S_EQ:
				default:
					throw new Error("attribute invalid close char('/')")
				}
				break;
			case ''://end document
				//throw new Error('unexpected end of input')
				errorHandler.error('unexpected end of input');
			case '>':
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));
				case S_E:
				case S_S:
				case S_C:
					break;//normal
				case S_V://Compatible state
				case S_ATTR:
					value = source.slice(start,p);
					if(value.slice(-1) === '/'){
						el.closed  = true;
						value = value.slice(0,-1)
					}
				case S_ATTR_S:
					if(s === S_ATTR_S){
						value = attrName;
					}
					if(s == S_V){
						errorHandler.warning('attribute "'+value+'" missed quot(")!!');
						el.add(attrName,value.replace(/&#?\w+;/g,entityReplacer),start)
					}else{
						errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')
						el.add(value,value,start)
					}
					break;
				case S_EQ:
					throw new Error('attribute value missed!!');
				}
	//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
				return p;
			/*xml space '\x20' | #x9 | #xD | #xA; */
			case '\u0080':
				c = ' ';
			default:
				if(c<= ' '){//space
					switch(s){
					case S_TAG:
						el.setTagName(source.slice(start,p));//tagName
						s = S_S;
						break;
					case S_ATTR:
						attrName = source.slice(start,p)
						s = S_ATTR_S;
						break;
					case S_V:
						var value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
						errorHandler.warning('attribute "'+value+'" missed quot(")!!');
						el.add(attrName,value,start)
					case S_E:
						s = S_S;
						break;
					//case S_S:
					//case S_EQ:
					//case S_ATTR_S:
					//	void();break;
					//case S_C:
						//ignore warning
					}
				}else{//not space
	//S_TAG,	S_ATTR,	S_EQ,	S_V
	//S_ATTR_S,	S_E,	S_S,	S_C
					switch(s){
					//case S_TAG:void();break;
					//case S_ATTR:void();break;
					//case S_V:void();break;
					case S_ATTR_S:
						errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead!!')
						el.add(attrName,attrName,start);
						start = p;
						s = S_ATTR;
						break;
					case S_E:
						errorHandler.warning('attribute space is required"'+attrName+'"!!')
					case S_S:
						s = S_ATTR;
						start = p;
						break;
					case S_EQ:
						s = S_V;
						start = p;
						break;
					case S_C:
						throw new Error("elements closed character '/' and '>' must be connected to");
					}
				}
			}
			p++;
		}
	}
	/**
	 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
	 */
	function appendElement(el,domBuilder,parseStack){
		var tagName = el.tagName;
		var localNSMap = null;
		var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
		var i = el.length;
		while(i--){
			var a = el[i];
			var qName = a.qName;
			var value = a.value;
			var nsp = qName.indexOf(':');
			if(nsp>0){
				var prefix = a.prefix = qName.slice(0,nsp);
				var localName = qName.slice(nsp+1);
				var nsPrefix = prefix === 'xmlns' && localName
			}else{
				localName = qName;
				prefix = null
				nsPrefix = qName === 'xmlns' && ''
			}
			//can not set prefix,because prefix !== ''
			a.localName = localName ;
			//prefix == null for no ns prefix attribute 
			if(nsPrefix !== false){//hack!!
				if(localNSMap == null){
					localNSMap = {}
					//console.log(currentNSMap,0)
					_copy(currentNSMap,currentNSMap={})
					//console.log(currentNSMap,1)
				}
				currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
				a.uri = 'http://www.w3.org/2000/xmlns/'
				domBuilder.startPrefixMapping(nsPrefix, value) 
			}
		}
		var i = el.length;
		while(i--){
			a = el[i];
			var prefix = a.prefix;
			if(prefix){//no prefix attribute has no namespace
				if(prefix === 'xml'){
					a.uri = 'http://www.w3.org/XML/1998/namespace';
				}if(prefix !== 'xmlns'){
					a.uri = currentNSMap[prefix]
					
					//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
				}
			}
		}
		var nsp = tagName.indexOf(':');
		if(nsp>0){
			prefix = el.prefix = tagName.slice(0,nsp);
			localName = el.localName = tagName.slice(nsp+1);
		}else{
			prefix = null;//important!!
			localName = el.localName = tagName;
		}
		//no prefix element has default namespace
		var ns = el.uri = currentNSMap[prefix || ''];
		domBuilder.startElement(ns,localName,tagName,el);
		//endPrefixMapping and startPrefixMapping have not any help for dom builder
		//localNSMap = null
		if(el.closed){
			domBuilder.endElement(ns,localName,tagName);
			if(localNSMap){
				for(prefix in localNSMap){
					domBuilder.endPrefixMapping(prefix) 
				}
			}
		}else{
			el.currentNSMap = currentNSMap;
			el.localNSMap = localNSMap;
			parseStack.push(el);
		}
	}
	function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
		if(/^(?:script|textarea)$/i.test(tagName)){
			var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
			var text = source.substring(elStartEnd+1,elEndStart);
			if(/[&<]/.test(text)){
				if(/^script$/i.test(tagName)){
					//if(!/\]\]>/.test(text)){
						//lexHandler.startCDATA();
						domBuilder.characters(text,0,text.length);
						//lexHandler.endCDATA();
						return elEndStart;
					//}
				}//}else{//text area
					text = text.replace(/&#?\w+;/g,entityReplacer);
					domBuilder.characters(text,0,text.length);
					return elEndStart;
				//}
				
			}
		}
		return elStartEnd+1;
	}
	function fixSelfClosed(source,elStartEnd,tagName,closeMap){
		//if(tagName in closeMap){
		var pos = closeMap[tagName];
		if(pos == null){
			//console.log(tagName)
			pos = closeMap[tagName] = source.lastIndexOf('</'+tagName+'>')
		}
		return pos<elStartEnd;
		//} 
	}
	function _copy(source,target){
		for(var n in source){target[n] = source[n]}
	}
	function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
		var next= source.charAt(start+2)
		switch(next){
		case '-':
			if(source.charAt(start + 3) === '-'){
				var end = source.indexOf('-->',start+4);
				//append comment source.substring(4,end)//<!--
				if(end>start){
					domBuilder.comment(source,start+4,end-start-4);
					return end+3;
				}else{
					errorHandler.error("Unclosed comment");
					return -1;
				}
			}else{
				//error
				return -1;
			}
		default:
			if(source.substr(start+3,6) == 'CDATA['){
				var end = source.indexOf(']]>',start+9);
				domBuilder.startCDATA();
				domBuilder.characters(source,start+9,end-start-9);
				domBuilder.endCDATA() 
				return end+3;
			}
			//<!DOCTYPE
			//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) 
			var matchs = split(source,start);
			var len = matchs.length;
			if(len>1 && /!doctype/i.test(matchs[0][0])){
				var name = matchs[1][0];
				var pubid = len>3 && /^public$/i.test(matchs[2][0]) && matchs[3][0]
				var sysid = len>4 && matchs[4][0];
				var lastMatch = matchs[len-1]
				domBuilder.startDTD(name,pubid && pubid.replace(/^(['"])(.*?)\1$/,'$2'),
						sysid && sysid.replace(/^(['"])(.*?)\1$/,'$2'));
				domBuilder.endDTD();
				
				return lastMatch.index+lastMatch[0].length
			}
		}
		return -1;
	}



	function parseInstruction(source,start,domBuilder){
		var end = source.indexOf('?>',start);
		if(end){
			var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
			if(match){
				var len = match[0].length;
				domBuilder.processingInstruction(match[1], match[2]) ;
				return end+2;
			}else{//error
				return -1;
			}
		}
		return -1;
	}

	/**
	 * @param source
	 */
	function ElementAttributes(source){
		
	}
	ElementAttributes.prototype = {
		setTagName:function(tagName){
			if(!tagNamePattern.test(tagName)){
				throw new Error('invalid tagName:'+tagName)
			}
			this.tagName = tagName
		},
		add:function(qName,value,offset){
			if(!tagNamePattern.test(qName)){
				throw new Error('invalid attribute:'+qName)
			}
			this[this.length++] = {qName:qName,value:value,offset:offset}
		},
		length:0,
		getLocalName:function(i){return this[i].localName},
		getOffset:function(i){return this[i].offset},
		getQName:function(i){return this[i].qName},
		getURI:function(i){return this[i].uri},
		getValue:function(i){return this[i].value}
	//	,getIndex:function(uri, localName)){
	//		if(localName){
	//			
	//		}else{
	//			var qName = uri
	//		}
	//	},
	//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
	//	getType:function(uri,localName){}
	//	getType:function(i){},
	}




	function _set_proto_(thiz,parent){
		thiz.__proto__ = parent;
		return thiz;
	}
	if(!(_set_proto_({},_set_proto_.prototype) instanceof _set_proto_)){
		_set_proto_ = function(thiz,parent){
			function p(){};
			p.prototype = parent;
			p = new p();
			for(parent in thiz){
				p[parent] = thiz[parent];
			}
			return p;
		}
	}

	function split(source,start){
		var match;
		var buf = [];
		var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
		reg.lastIndex = start;
		reg.exec(source);//skip <
		while(match = reg.exec(source)){
			buf.push(match);
			if(match[1])return buf;
		}
	}

	if(true){
		exports.XMLReader = XMLReader;
	}



/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * DOM Level 2
	 * Object DOMException
	 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
	 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
	 */

	function copy(src,dest){
		for(var p in src){
			dest[p] = src[p];
		}
	}
	/**
	^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
	^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
	 */
	function _extends(Class,Super){
		var pt = Class.prototype;
		if(Object.create){
			var ppt = Object.create(Super.prototype)
			pt.__proto__ = ppt;
		}
		if(!(pt instanceof Super)){
			function t(){};
			t.prototype = Super.prototype;
			t = new t();
			copy(pt,t);
			Class.prototype = pt = t;
		}
		if(pt.constructor != Class){
			if(typeof Class != 'function'){
				console.error("unknow Class:"+Class)
			}
			pt.constructor = Class
		}
	}
	var htmlns = 'http://www.w3.org/1999/xhtml' ;
	// Node Types
	var NodeType = {}
	var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
	var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
	var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
	var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
	var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
	var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
	var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
	var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
	var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
	var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
	var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
	var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

	// ExceptionCode
	var ExceptionCode = {}
	var ExceptionMessage = {};
	var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
	var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
	var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
	var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
	var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
	var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
	var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
	var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
	var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
	var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
	//level2
	var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
	var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
	var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
	var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
	var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);


	function DOMException(code, message) {
		if(message instanceof Error){
			var error = message;
		}else{
			error = this;
			Error.call(this, ExceptionMessage[code]);
			this.message = ExceptionMessage[code];
			if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
		}
		error.code = code;
		if(message) this.message = this.message + ": " + message;
		return error;
	};
	DOMException.prototype = Error.prototype;
	copy(ExceptionCode,DOMException)
	/**
	 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
	 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
	 * The items in the NodeList are accessible via an integral index, starting from 0.
	 */
	function NodeList() {
	};
	NodeList.prototype = {
		/**
		 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
		 * @standard level1
		 */
		length:0, 
		/**
		 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
		 * @standard level1
		 * @param index  unsigned long 
		 *   Index into the collection.
		 * @return Node
		 * 	The node at the indexth position in the NodeList, or null if that is not a valid index. 
		 */
		item: function(index) {
			return this[index] || null;
		},
		toString:function(){
			for(var buf = [], i = 0;i<this.length;i++){
				serializeToString(this[i],buf);
			}
			return buf.join('');
		}
	};
	function LiveNodeList(node,refresh){
		this._node = node;
		this._refresh = refresh
		_updateLiveList(this);
	}
	function _updateLiveList(list){
		var inc = list._node._inc || list._node.ownerDocument._inc;
		if(list._inc != inc){
			var ls = list._refresh(list._node);
			//console.log(ls.length)
			__set__(list,'length',ls.length);
			copy(ls,list);
			list._inc = inc;
		}
	}
	LiveNodeList.prototype.item = function(i){
		_updateLiveList(this);
		return this[i];
	}

	_extends(LiveNodeList,NodeList);
	/**
	 * 
	 * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.
	 * NamedNodeMap objects in the DOM are live.
	 * used for attributes or DocumentType entities 
	 */
	function NamedNodeMap() {
	};

	function _findNodeIndex(list,node){
		var i = list.length;
		while(i--){
			if(list[i] === node){return i}
		}
	}

	function _addNamedNode(el,list,newAttr,oldAttr){
		if(oldAttr){
			list[_findNodeIndex(list,oldAttr)] = newAttr;
		}else{
			list[list.length++] = newAttr;
		}
		if(el){
			newAttr.ownerElement = el;
			var doc = el.ownerDocument;
			if(doc){
				oldAttr && _onRemoveAttribute(doc,el,oldAttr);
				_onAddAttribute(doc,el,newAttr);
			}
		}
	}
	function _removeNamedNode(el,list,attr){
		var i = _findNodeIndex(list,attr);
		if(i>=0){
			var lastIndex = list.length-1
			while(i<lastIndex){
				list[i] = list[++i]
			}
			list.length = lastIndex;
			if(el){
				var doc = el.ownerDocument;
				if(doc){
					_onRemoveAttribute(doc,el,attr);
					attr.ownerElement = null;
				}
			}
		}else{
			throw DOMException(NOT_FOUND_ERR,new Error())
		}
	}
	NamedNodeMap.prototype = {
		length:0,
		item:NodeList.prototype.item,
		getNamedItem: function(key) {
	//		if(key.indexOf(':')>0 || key == 'xmlns'){
	//			return null;
	//		}
			var i = this.length;
			while(i--){
				var attr = this[i];
				if(attr.nodeName == key){
					return attr;
				}
			}
		},
		setNamedItem: function(attr) {
			var el = attr.ownerElement;
			if(el && el!=this._ownerElement){
				throw new DOMException(INUSE_ATTRIBUTE_ERR);
			}
			var oldAttr = this.getNamedItem(attr.nodeName);
			_addNamedNode(this._ownerElement,this,attr,oldAttr);
			return oldAttr;
		},
		/* returns Node */
		setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
			var el = attr.ownerElement, oldAttr;
			if(el && el!=this._ownerElement){
				throw new DOMException(INUSE_ATTRIBUTE_ERR);
			}
			oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
			_addNamedNode(this._ownerElement,this,attr,oldAttr);
			return oldAttr;
		},

		/* returns Node */
		removeNamedItem: function(key) {
			var attr = this.getNamedItem(key);
			_removeNamedNode(this._ownerElement,this,attr);
			return attr;
			
			
		},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
		
		//for level2
		removeNamedItemNS:function(namespaceURI,localName){
			var attr = this.getNamedItemNS(namespaceURI,localName);
			_removeNamedNode(this._ownerElement,this,attr);
			return attr;
		},
		getNamedItemNS: function(namespaceURI, localName) {
			var i = this.length;
			while(i--){
				var node = this[i];
				if(node.localName == localName && node.namespaceURI == namespaceURI){
					return node;
				}
			}
			return null;
		}
	};
	/**
	 * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490
	 */
	function DOMImplementation(/* Object */ features) {
		this._features = {};
		if (features) {
			for (var feature in features) {
				 this._features = features[feature];
			}
		}
	};

	DOMImplementation.prototype = {
		hasFeature: function(/* string */ feature, /* string */ version) {
			var versions = this._features[feature.toLowerCase()];
			if (versions && (!version || version in versions)) {
				return true;
			} else {
				return false;
			}
		},
		// Introduced in DOM Level 2:
		createDocument:function(namespaceURI,  qualifiedName, doctype){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
			var doc = new Document();
			doc.implementation = this;
			doc.childNodes = new NodeList();
			doc.doctype = doctype;
			if(doctype){
				doc.appendChild(doctype);
			}
			if(qualifiedName){
				var root = doc.createElementNS(namespaceURI,qualifiedName);
				doc.appendChild(root);
			}
			return doc;
		},
		// Introduced in DOM Level 2:
		createDocumentType:function(qualifiedName, publicId, systemId){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
			var node = new DocumentType();
			node.name = qualifiedName;
			node.nodeName = qualifiedName;
			node.publicId = publicId;
			node.systemId = systemId;
			// Introduced in DOM Level 2:
			//readonly attribute DOMString        internalSubset;
			
			//TODO:..
			//  readonly attribute NamedNodeMap     entities;
			//  readonly attribute NamedNodeMap     notations;
			return node;
		}
	};


	/**
	 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
	 */

	function Node() {
	};

	Node.prototype = {
		firstChild : null,
		lastChild : null,
		previousSibling : null,
		nextSibling : null,
		attributes : null,
		parentNode : null,
		childNodes : null,
		ownerDocument : null,
		nodeValue : null,
		namespaceURI : null,
		prefix : null,
		localName : null,
		// Modified in DOM Level 2:
		insertBefore:function(newChild, refChild){//raises 
			return _insertBefore(this,newChild,refChild);
		},
		replaceChild:function(newChild, oldChild){//raises 
			this.insertBefore(newChild,oldChild);
			if(oldChild){
				this.removeChild(oldChild);
			}
		},
		removeChild:function(oldChild){
			return _removeChild(this,oldChild);
		},
		appendChild:function(newChild){
			return this.insertBefore(newChild,null);
		},
		hasChildNodes:function(){
			return this.firstChild != null;
		},
		cloneNode:function(deep){
			return cloneNode(this.ownerDocument||this,this,deep);
		},
		// Modified in DOM Level 2:
		normalize:function(){
			var child = this.firstChild;
			while(child){
				var next = child.nextSibling;
				if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
					this.removeChild(next);
					child.appendData(next.data);
				}else{
					child.normalize();
					child = next;
				}
			}
		},
	  	// Introduced in DOM Level 2:
		isSupported:function(feature, version){
			return this.ownerDocument.implementation.hasFeature(feature,version);
		},
	    // Introduced in DOM Level 2:
	    hasAttributes:function(){
	    	return this.attributes.length>0;
	    },
	    lookupPrefix:function(namespaceURI){
	    	var el = this;
	    	while(el){
	    		var map = el._nsMap;
	    		//console.dir(map)
	    		if(map){
	    			for(var n in map){
	    				if(map[n] == namespaceURI){
	    					return n;
	    				}
	    			}
	    		}
	    		el = el.nodeType == 2?el.ownerDocument : el.parentNode;
	    	}
	    	return null;
	    },
	    // Introduced in DOM Level 3:
	    lookupNamespaceURI:function(prefix){
	    	var el = this;
	    	while(el){
	    		var map = el._nsMap;
	    		//console.dir(map)
	    		if(map){
	    			if(prefix in map){
	    				return map[prefix] ;
	    			}
	    		}
	    		el = el.nodeType == 2?el.ownerDocument : el.parentNode;
	    	}
	    	return null;
	    },
	    // Introduced in DOM Level 3:
	    isDefaultNamespace:function(namespaceURI){
	    	var prefix = this.lookupPrefix(namespaceURI);
	    	return prefix == null;
	    }
	};


	function _xmlEncoder(c){
		return c == '<' && '&lt;' ||
	         c == '>' && '&gt;' ||
	         c == '&' && '&amp;' ||
	         c == '"' && '&quot;' ||
	         '&#'+c.charCodeAt()+';'
	}


	copy(NodeType,Node);
	copy(NodeType,Node.prototype);

	/**
	 * @param callback return true for continue,false for break
	 * @return boolean true: break visit;
	 */
	function _visitNode(node,callback){
		if(callback(node)){
			return true;
		}
		if(node = node.firstChild){
			do{
				if(_visitNode(node,callback)){return true}
	        }while(node=node.nextSibling)
	    }
	}



	function Document(){
	}
	function _onAddAttribute(doc,el,newAttr){
		doc && doc._inc++;
		var ns = newAttr.namespaceURI ;
		if(ns == 'http://www.w3.org/2000/xmlns/'){
			//update namespace
			el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value
		}
	}
	function _onRemoveAttribute(doc,el,newAttr,remove){
		doc && doc._inc++;
		var ns = newAttr.namespaceURI ;
		if(ns == 'http://www.w3.org/2000/xmlns/'){
			//update namespace
			delete el._nsMap[newAttr.prefix?newAttr.localName:'']
		}
	}
	function _onUpdateChild(doc,el,newChild){
		if(doc && doc._inc){
			doc._inc++;
			//update childNodes
			var cs = el.childNodes;
			if(newChild){
				cs[cs.length++] = newChild;
			}else{
				//console.log(1)
				var child = el.firstChild;
				var i = 0;
				while(child){
					cs[i++] = child;
					child =child.nextSibling;
				}
				cs.length = i;
			}
		}
	}

	/**
	 * attributes;
	 * children;
	 * 
	 * writeable properties:
	 * nodeValue,Attr:value,CharacterData:data
	 * prefix
	 */
	function _removeChild(parentNode,child){
		var previous = child.previousSibling;
		var next = child.nextSibling;
		if(previous){
			previous.nextSibling = next;
		}else{
			parentNode.firstChild = next
		}
		if(next){
			next.previousSibling = previous;
		}else{
			parentNode.lastChild = previous;
		}
		_onUpdateChild(parentNode.ownerDocument,parentNode);
		return child;
	}
	/**
	 * preformance key(refChild == null)
	 */
	function _insertBefore(parentNode,newChild,nextChild){
		var cp = newChild.parentNode;
		if(cp){
			cp.removeChild(newChild);//remove and update
		}
		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
			var newFirst = newChild.firstChild;
			if (newFirst == null) {
				return newChild;
			}
			var newLast = newChild.lastChild;
		}else{
			newFirst = newLast = newChild;
		}
		var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;

		newFirst.previousSibling = pre;
		newLast.nextSibling = nextChild;
		
		
		if(pre){
			pre.nextSibling = newFirst;
		}else{
			parentNode.firstChild = newFirst;
		}
		if(nextChild == null){
			parentNode.lastChild = newLast;
		}else{
			nextChild.previousSibling = newLast;
		}
		do{
			newFirst.parentNode = parentNode;
		}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
		_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);
		//console.log(parentNode.lastChild.nextSibling == null)
		if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
			newChild.firstChild = newChild.lastChild = null;
		}
		return newChild;
	}
	function _appendSingleChild(parentNode,newChild){
		var cp = newChild.parentNode;
		if(cp){
			var pre = parentNode.lastChild;
			cp.removeChild(newChild);//remove and update
			var pre = parentNode.lastChild;
		}
		var pre = parentNode.lastChild;
		newChild.parentNode = parentNode;
		newChild.previousSibling = pre;
		newChild.nextSibling = null;
		if(pre){
			pre.nextSibling = newChild;
		}else{
			parentNode.firstChild = newChild;
		}
		parentNode.lastChild = newChild;
		_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);
		return newChild;
		//console.log("__aa",parentNode.lastChild.nextSibling == null)
	}
	Document.prototype = {
		//implementation : null,
		nodeName :  '#document',
		nodeType :  DOCUMENT_NODE,
		doctype :  null,
		documentElement :  null,
		_inc : 1,
		
		insertBefore :  function(newChild, refChild){//raises 
			if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
				var child = newChild.firstChild;
				while(child){
					var next = child.nextSibling;
					this.insertBefore(child,refChild);
					child = next;
				}
				return newChild;
			}
			if(this.documentElement == null && newChild.nodeType == 1){
				this.documentElement = newChild;
			}
			
			return _insertBefore(this,newChild,refChild),(newChild.ownerDocument = this),newChild;
		},
		removeChild :  function(oldChild){
			if(this.documentElement == oldChild){
				this.documentElement = null;
			}
			return _removeChild(this,oldChild);
		},
		// Introduced in DOM Level 2:
		importNode : function(importedNode,deep){
			return importNode(this,importedNode,deep);
		},
		// Introduced in DOM Level 2:
		getElementById :	function(id){
			var rtv = null;
			_visitNode(this.documentElement,function(node){
				if(node.nodeType == 1){
					if(node.getAttribute('id') == id){
						rtv = node;
						return true;
					}
				}
			})
			return rtv;
		},
		
		//document factory method:
		createElement :	function(tagName){
			var node = new Element();
			node.ownerDocument = this;
			node.nodeName = tagName;
			node.tagName = tagName;
			node.childNodes = new NodeList();
			var attrs	= node.attributes = new NamedNodeMap();
			attrs._ownerElement = node;
			return node;
		},
		createDocumentFragment :	function(){
			var node = new DocumentFragment();
			node.ownerDocument = this;
			node.childNodes = new NodeList();
			return node;
		},
		createTextNode :	function(data){
			var node = new Text();
			node.ownerDocument = this;
			node.appendData(data)
			return node;
		},
		createComment :	function(data){
			var node = new Comment();
			node.ownerDocument = this;
			node.appendData(data)
			return node;
		},
		createCDATASection :	function(data){
			var node = new CDATASection();
			node.ownerDocument = this;
			node.appendData(data)
			return node;
		},
		createProcessingInstruction :	function(target,data){
			var node = new ProcessingInstruction();
			node.ownerDocument = this;
			node.tagName = node.target = target;
			node.nodeValue= node.data = data;
			return node;
		},
		createAttribute :	function(name){
			var node = new Attr();
			node.ownerDocument	= this;
			node.name = name;
			node.nodeName	= name;
			node.localName = name;
			node.specified = true;
			return node;
		},
		createEntityReference :	function(name){
			var node = new EntityReference();
			node.ownerDocument	= this;
			node.nodeName	= name;
			return node;
		},
		// Introduced in DOM Level 2:
		createElementNS :	function(namespaceURI,qualifiedName){
			var node = new Element();
			var pl = qualifiedName.split(':');
			var attrs	= node.attributes = new NamedNodeMap();
			node.childNodes = new NodeList();
			node.ownerDocument = this;
			node.nodeName = qualifiedName;
			node.tagName = qualifiedName;
			node.namespaceURI = namespaceURI;
			if(pl.length == 2){
				node.prefix = pl[0];
				node.localName = pl[1];
			}else{
				//el.prefix = null;
				node.localName = qualifiedName;
			}
			attrs._ownerElement = node;
			return node;
		},
		// Introduced in DOM Level 2:
		createAttributeNS :	function(namespaceURI,qualifiedName){
			var node = new Attr();
			var pl = qualifiedName.split(':');
			node.ownerDocument = this;
			node.nodeName = qualifiedName;
			node.name = qualifiedName;
			node.namespaceURI = namespaceURI;
			node.specified = true;
			if(pl.length == 2){
				node.prefix = pl[0];
				node.localName = pl[1];
			}else{
				//el.prefix = null;
				node.localName = qualifiedName;
			}
			return node;
		}
	};
	_extends(Document,Node);


	function Element() {
		this._nsMap = {};
	};
	Element.prototype = {
		nodeType : ELEMENT_NODE,
		hasAttribute : function(name){
			return this.getAttributeNode(name)!=null;
		},
		getAttribute : function(name){
			var attr = this.getAttributeNode(name);
			return attr && attr.value || '';
		},
		getAttributeNode : function(name){
			return this.attributes.getNamedItem(name);
		},
		setAttribute : function(name, value){
			var attr = this.ownerDocument.createAttribute(name);
			attr.value = attr.nodeValue = "" + value;
			this.setAttributeNode(attr)
		},
		removeAttribute : function(name){
			var attr = this.getAttributeNode(name)
			attr && this.removeAttributeNode(attr);
		},
		
		//four real opeartion method
		appendChild:function(newChild){
			if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
				return this.insertBefore(newChild,null);
			}else{
				return _appendSingleChild(this,newChild);
			}
		},
		setAttributeNode : function(newAttr){
			return this.attributes.setNamedItem(newAttr);
		},
		setAttributeNodeNS : function(newAttr){
			return this.attributes.setNamedItemNS(newAttr);
		},
		removeAttributeNode : function(oldAttr){
			return this.attributes.removeNamedItem(oldAttr.nodeName);
		},
		//get real attribute name,and remove it by removeAttributeNode
		removeAttributeNS : function(namespaceURI, localName){
			var old = this.getAttributeNodeNS(namespaceURI, localName);
			old && this.removeAttributeNode(old);
		},
		
		hasAttributeNS : function(namespaceURI, localName){
			return this.getAttributeNodeNS(namespaceURI, localName)!=null;
		},
		getAttributeNS : function(namespaceURI, localName){
			var attr = this.getAttributeNodeNS(namespaceURI, localName);
			return attr && attr.value || '';
		},
		setAttributeNS : function(namespaceURI, qualifiedName, value){
			var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
			attr.value = attr.nodeValue = "" + value;
			this.setAttributeNode(attr)
		},
		getAttributeNodeNS : function(namespaceURI, localName){
			return this.attributes.getNamedItemNS(namespaceURI, localName);
		},
		
		getElementsByTagName : function(tagName){
			return new LiveNodeList(this,function(base){
				var ls = [];
				_visitNode(base,function(node){
					if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
						ls.push(node);
					}
				});
				return ls;
			});
		},
		getElementsByTagNameNS : function(namespaceURI, localName){
			return new LiveNodeList(this,function(base){
				var ls = [];
				_visitNode(base,function(node){
					if(node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)){
						ls.push(node);
					}
				});
				return ls;
			});
		}
	};
	Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
	Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


	_extends(Element,Node);
	function Attr() {
	};
	Attr.prototype.nodeType = ATTRIBUTE_NODE;
	_extends(Attr,Node);


	function CharacterData() {
	};
	CharacterData.prototype = {
		data : '',
		substringData : function(offset, count) {
			return this.data.substring(offset, offset+count);
		},
		appendData: function(text) {
			text = this.data+text;
			this.nodeValue = this.data = text;
			this.length = text.length;
		},
		insertData: function(offset,text) {
			this.replaceData(offset,0,text);
		
		},
		appendChild:function(newChild){
			//if(!(newChild instanceof CharacterData)){
				throw new Error(ExceptionMessage[3])
			//}
			return Node.prototype.appendChild.apply(this,arguments)
		},
		deleteData: function(offset, count) {
			this.replaceData(offset,count,"");
		},
		replaceData: function(offset, count, text) {
			var start = this.data.substring(0,offset);
			var end = this.data.substring(offset+count);
			text = start + text + end;
			this.nodeValue = this.data = text;
			this.length = text.length;
		}
	}
	_extends(CharacterData,Node);
	function Text() {
	};
	Text.prototype = {
		nodeName : "#text",
		nodeType : TEXT_NODE,
		splitText : function(offset) {
			var text = this.data;
			var newText = text.substring(offset);
			text = text.substring(0, offset);
			this.data = this.nodeValue = text;
			this.length = text.length;
			var newNode = this.ownerDocument.createTextNode(newText);
			if(this.parentNode){
				this.parentNode.insertBefore(newNode, this.nextSibling);
			}
			return newNode;
		}
	}
	_extends(Text,CharacterData);
	function Comment() {
	};
	Comment.prototype = {
		nodeName : "#comment",
		nodeType : COMMENT_NODE
	}
	_extends(Comment,CharacterData);

	function CDATASection() {
	};
	CDATASection.prototype = {
		nodeName : "#cdata-section",
		nodeType : CDATA_SECTION_NODE
	}
	_extends(CDATASection,CharacterData);


	function DocumentType() {
	};
	DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
	_extends(DocumentType,Node);

	function Notation() {
	};
	Notation.prototype.nodeType = NOTATION_NODE;
	_extends(Notation,Node);

	function Entity() {
	};
	Entity.prototype.nodeType = ENTITY_NODE;
	_extends(Entity,Node);

	function EntityReference() {
	};
	EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
	_extends(EntityReference,Node);

	function DocumentFragment() {
	};
	DocumentFragment.prototype.nodeName =	"#document-fragment";
	DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
	_extends(DocumentFragment,Node);


	function ProcessingInstruction() {
	}
	ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
	_extends(ProcessingInstruction,Node);
	function XMLSerializer(){}
	XMLSerializer.prototype.serializeToString = function(node,attributeSorter){
		return node.toString(attributeSorter);
	}
	Node.prototype.toString =function(attributeSorter){
		var buf = [];
		serializeToString(this,buf,attributeSorter);
		return buf.join('');
	}
	function serializeToString(node,buf,attributeSorter,isHTML){
		switch(node.nodeType){
		case ELEMENT_NODE:
			var attrs = node.attributes;
			var len = attrs.length;
			var child = node.firstChild;
			var nodeName = node.tagName;
			isHTML =  (htmlns === node.namespaceURI) ||isHTML 
			buf.push('<',nodeName);
			if(attributeSorter){
				buf.sort.apply(attrs, attributeSorter);
			}
			for(var i=0;i<len;i++){
				serializeToString(attrs.item(i),buf,attributeSorter,isHTML);
			}
			if(child || isHTML && !/^(?:meta|link|img|br|hr|input|button)$/i.test(nodeName)){
				buf.push('>');
				//if is cdata child node
				if(isHTML && /^script$/i.test(nodeName)){
					if(child){
						buf.push(child.data);
					}
				}else{
					while(child){
						serializeToString(child,buf,attributeSorter,isHTML);
						child = child.nextSibling;
					}
				}
				buf.push('</',nodeName,'>');
			}else{
				buf.push('/>');
			}
			return;
		case DOCUMENT_NODE:
		case DOCUMENT_FRAGMENT_NODE:
			var child = node.firstChild;
			while(child){
				serializeToString(child,buf,attributeSorter,isHTML);
				child = child.nextSibling;
			}
			return;
		case ATTRIBUTE_NODE:
			return buf.push(' ',node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');
		case TEXT_NODE:
			return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));
		case CDATA_SECTION_NODE:
			return buf.push( '<![CDATA[',node.data,']]>');
		case COMMENT_NODE:
			return buf.push( "<!--",node.data,"-->");
		case DOCUMENT_TYPE_NODE:
			var pubid = node.publicId;
			var sysid = node.systemId;
			buf.push('<!DOCTYPE ',node.name);
			if(pubid){
				buf.push(' PUBLIC "',pubid);
				if (sysid && sysid!='.') {
					buf.push( '" "',sysid);
				}
				buf.push('">');
			}else if(sysid && sysid!='.'){
				buf.push(' SYSTEM "',sysid,'">');
			}else{
				var sub = node.internalSubset;
				if(sub){
					buf.push(" [",sub,"]");
				}
				buf.push(">");
			}
			return;
		case PROCESSING_INSTRUCTION_NODE:
			return buf.push( "<?",node.target," ",node.data,"?>");
		case ENTITY_REFERENCE_NODE:
			return buf.push( '&',node.nodeName,';');
		//case ENTITY_NODE:
		//case NOTATION_NODE:
		default:
			buf.push('??',node.nodeName);
		}
	}
	function importNode(doc,node,deep){
		var node2;
		switch (node.nodeType) {
		case ELEMENT_NODE:
			node2 = node.cloneNode(false);
			node2.ownerDocument = doc;
			//var attrs = node2.attributes;
			//var len = attrs.length;
			//for(var i=0;i<len;i++){
				//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
			//}
		case DOCUMENT_FRAGMENT_NODE:
			break;
		case ATTRIBUTE_NODE:
			deep = true;
			break;
		//case ENTITY_REFERENCE_NODE:
		//case PROCESSING_INSTRUCTION_NODE:
		////case TEXT_NODE:
		//case CDATA_SECTION_NODE:
		//case COMMENT_NODE:
		//	deep = false;
		//	break;
		//case DOCUMENT_NODE:
		//case DOCUMENT_TYPE_NODE:
		//cannot be imported.
		//case ENTITY_NODE:
		//case NOTATION_NODE
		//can not hit in level3
		//default:throw e;
		}
		if(!node2){
			node2 = node.cloneNode(false);//false
		}
		node2.ownerDocument = doc;
		node2.parentNode = null;
		if(deep){
			var child = node.firstChild;
			while(child){
				node2.appendChild(importNode(doc,child,deep));
				child = child.nextSibling;
			}
		}
		return node2;
	}
	//
	//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
	//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
	function cloneNode(doc,node,deep){
		var node2 = new node.constructor();
		for(var n in node){
			var v = node[n];
			if(typeof v != 'object' ){
				if(v != node2[n]){
					node2[n] = v;
				}
			}
		}
		if(node.childNodes){
			node2.childNodes = new NodeList();
		}
		node2.ownerDocument = doc;
		switch (node2.nodeType) {
		case ELEMENT_NODE:
			var attrs	= node.attributes;
			var attrs2	= node2.attributes = new NamedNodeMap();
			var len = attrs.length
			attrs2._ownerElement = node2;
			for(var i=0;i<len;i++){
				node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
			}
			break;;
		case ATTRIBUTE_NODE:
			deep = true;
		}
		if(deep){
			var child = node.firstChild;
			while(child){
				node2.appendChild(cloneNode(doc,child,deep));
				child = child.nextSibling;
			}
		}
		return node2;
	}

	function __set__(object,key,value){
		object[key] = value
	}
	//do dynamic
	try{
		if(Object.defineProperty){
			Object.defineProperty(LiveNodeList.prototype,'length',{
				get:function(){
					_updateLiveList(this);
					return this.$$length;
				}
			});
			Object.defineProperty(Node.prototype,'textContent',{
				get:function(){
					return getTextContent(this);
				},
				set:function(data){
					switch(this.nodeType){
					case 1:
					case 11:
						while(this.firstChild){
							this.removeChild(this.firstChild);
						}
						if(data || String(data)){
							this.appendChild(this.ownerDocument.createTextNode(data));
						}
						break;
					default:
						//TODO:
						this.data = data;
						this.value = value;
						this.nodeValue = data;
					}
				}
			})
			
			function getTextContent(node){
				switch(node.nodeType){
				case 1:
				case 11:
					var buf = [];
					node = node.firstChild;
					while(node){
						if(node.nodeType!==7 && node.nodeType !==8){
							buf.push(getTextContent(node));
						}
						node = node.nextSibling;
					}
					return buf.join('');
				default:
					return node.nodeValue;
				}
			}
			__set__ = function(object,key,value){
				//console.log(value)
				object['$$'+key] = value
			}
		}
	}catch(e){//ie8
	}

	if(true){
		exports.DOMImplementation = DOMImplementation;
		exports.XMLSerializer = XMLSerializer;
	}


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	if (!process.version ||
	    process.version.indexOf('v0.') === 0 ||
	    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
	  module.exports = nextTick;
	} else {
	  module.exports = process.nextTick;
	}

	function nextTick(fn) {
	  var args = new Array(arguments.length - 1);
	  var i = 0;
	  while (i < args.length) {
	    args[i++] = arguments[i];
	  }
	  process.nextTick(function afterTick() {
	    fn.apply(null, args);
	  });
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59)))

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(92).Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	// Number.isFinite polyfill
	// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite
	if (typeof Number.isFinite !== "function") {
	    Number.isFinite = function isFinite(value) {
	        // 1. If Type(number) is not Number, return false.
	        if (typeof value !== "number") {
	            return false;
	        }
	        // 2. If number is NaN, +, or , return false.
	        if (value !== value || value === Infinity || value === -Infinity) {
	            return false;
	        }
	        // 3. Otherwise, return true.
	        return true;
	    };
	}


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";

	var get    = __webpack_require__(229);
	var Errors = __webpack_require__(230);
	var Utils  = __webpack_require__(211);

	function Report(parentOrOptions, reportOptions) {
	    this.parentReport = parentOrOptions instanceof Report ?
	                            parentOrOptions :
	                            undefined;

	    this.options = parentOrOptions instanceof Report ?
	                       parentOrOptions.options :
	                       parentOrOptions || {};

	    this.reportOptions = reportOptions || {};

	    this.errors = [];
	    this.path = [];
	    this.asyncTasks = [];
	}

	Report.prototype.isValid = function () {
	    if (this.asyncTasks.length > 0) {
	        throw new Error("Async tasks pending, can't answer isValid");
	    }
	    return this.errors.length === 0;
	};

	Report.prototype.addAsyncTask = function (fn, args, asyncTaskResultProcessFn) {
	    this.asyncTasks.push([fn, args, asyncTaskResultProcessFn]);
	};

	Report.prototype.processAsyncTasks = function (timeout, callback) {

	    var validationTimeout = timeout || 2000,
	        tasksCount        = this.asyncTasks.length,
	        idx               = tasksCount,
	        timedOut          = false,
	        self              = this;

	    function finish() {
	        process.nextTick(function () {
	            var valid = self.errors.length === 0,
	                err   = valid ? undefined : self.errors;
	            callback(err, valid);
	        });
	    }

	    function respond(asyncTaskResultProcessFn) {
	        return function (asyncTaskResult) {
	            if (timedOut) { return; }
	            asyncTaskResultProcessFn(asyncTaskResult);
	            if (--tasksCount === 0) {
	                finish();
	            }
	        };
	    }

	    if (tasksCount === 0 || this.errors.length > 0) {
	        finish();
	        return;
	    }

	    while (idx--) {
	        var task = this.asyncTasks[idx];
	        task[0].apply(null, task[1].concat(respond(task[2])));
	    }

	    setTimeout(function () {
	        if (tasksCount > 0) {
	            timedOut = true;
	            self.addError("ASYNC_TIMEOUT", [tasksCount, validationTimeout]);
	            callback(self.errors, false);
	        }
	    }, validationTimeout);

	};

	Report.prototype.getPath = function (returnPathAsString) {
	    var path = [];
	    if (this.parentReport) {
	        path = path.concat(this.parentReport.path);
	    }
	    path = path.concat(this.path);

	    if (returnPathAsString !== true) {
	        // Sanitize the path segments (http://tools.ietf.org/html/rfc6901#section-4)
	        path = "#/" + path.map(function (segment) {

	            if (Utils.isAbsoluteUri(segment)) {
	                return "uri(" + segment + ")";
	            }

	            return segment.replace(/\~/g, "~0").replace(/\//g, "~1");
	        }).join("/");
	    }
	    return path;
	};

	Report.prototype.getSchemaId = function () {

	    if (!this.rootSchema) {
	        return null;
	    }

	    // get the error path as an array
	    var path = [];
	    if (this.parentReport) {
	        path = path.concat(this.parentReport.path);
	    }
	    path = path.concat(this.path);

	    // try to find id in the error path
	    while (path.length > 0) {
	        var obj = get(this.rootSchema, path);
	        if (obj && obj.id) { return obj.id; }
	        path.pop();
	    }

	    // return id of the root
	    return this.rootSchema.id;
	};

	Report.prototype.hasError = function (errorCode, params) {
	    var idx = this.errors.length;
	    while (idx--) {
	        if (this.errors[idx].code === errorCode) {
	            // assume match
	            var match = true;

	            // check the params too
	            var idx2 = this.errors[idx].params.length;
	            while (idx2--) {
	                if (this.errors[idx].params[idx2] !== params[idx2]) {
	                    match = false;
	                }
	            }

	            // if match, return true
	            if (match) { return match; }
	        }
	    }
	    return false;
	};

	Report.prototype.addError = function (errorCode, params, subReports, schemaDescription) {
	    if (!errorCode) { throw new Error("No errorCode passed into addError()"); }

	    this.addCustomError(errorCode, Errors[errorCode], params, subReports, schemaDescription);
	};

	Report.prototype.addCustomError = function (errorCode, errorMessage, params, subReports, schemaDescription) {
	    if (this.errors.length >= this.reportOptions.maxErrors) {
	        return;
	    }

	    if (!errorMessage) { throw new Error("No errorMessage known for code " + errorCode); }

	    params = params || [];

	    var idx = params.length;
	    while (idx--) {
	        var whatIs = Utils.whatIs(params[idx]);
	        var param = (whatIs === "object" || whatIs === "null") ? JSON.stringify(params[idx]) : params[idx];
	        errorMessage = errorMessage.replace("{" + idx + "}", param);
	    }

	    var err = {
	        code: errorCode,
	        params: params,
	        message: errorMessage,
	        path: this.getPath(this.options.reportPathAsArray),
	        schemaId: this.getSchemaId()
	    };

	    if (schemaDescription) {
	        err.description = schemaDescription;
	    }

	    if (subReports != null) {
	        if (!Array.isArray(subReports)) {
	            subReports = [subReports];
	        }
	        err.inner = [];
	        idx = subReports.length;
	        while (idx--) {
	            var subReport = subReports[idx],
	                idx2 = subReport.errors.length;
	            while (idx2--) {
	                err.inner.push(subReport.errors[idx2]);
	            }
	        }
	        if (err.inner.length === 0) {
	            err.inner = undefined;
	        }
	    }

	    this.errors.push(err);
	};

	module.exports = Report;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59)))

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/*jshint maxlen: false*/

	var validator = __webpack_require__(252);

	var FormatValidators = {
	    "date": function (date) {
	        if (typeof date !== "string") {
	            return true;
	        }
	        // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
	        var matches = /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/.exec(date);
	        if (matches === null) {
	            return false;
	        }
	        // var year = matches[1];
	        // var month = matches[2];
	        // var day = matches[3];
	        if (matches[2] < "01" || matches[2] > "12" || matches[3] < "01" || matches[3] > "31") {
	            return false;
	        }
	        return true;
	    },
	    "date-time": function (dateTime) {
	        if (typeof dateTime !== "string") {
	            return true;
	        }
	        // date-time from http://tools.ietf.org/html/rfc3339#section-5.6
	        var s = dateTime.toLowerCase().split("t");
	        if (!FormatValidators.date(s[0])) {
	            return false;
	        }
	        var matches = /^([0-9]{2}):([0-9]{2}):([0-9]{2})(.[0-9]+)?(z|([+-][0-9]{2}:[0-9]{2}))$/.exec(s[1]);
	        if (matches === null) {
	            return false;
	        }
	        // var hour = matches[1];
	        // var minute = matches[2];
	        // var second = matches[3];
	        // var fraction = matches[4];
	        // var timezone = matches[5];
	        if (matches[1] > "23" || matches[2] > "59" || matches[3] > "59") {
	            return false;
	        }
	        return true;
	    },
	    "email": function (email) {
	        if (typeof email !== "string") {
	            return true;
	        }
	        return validator.isEmail(email, { "require_tld": true });
	    },
	    "hostname": function (hostname) {
	        if (typeof hostname !== "string") {
	            return true;
	        }
	        /*
	            http://json-schema.org/latest/json-schema-validation.html#anchor114
	            A string instance is valid against this attribute if it is a valid
	            representation for an Internet host name, as defined by RFC 1034, section 3.1 [RFC1034].

	            http://tools.ietf.org/html/rfc1034#section-3.5

	            <digit> ::= any one of the ten digits 0 through 9
	            var digit = /[0-9]/;

	            <letter> ::= any one of the 52 alphabetic characters A through Z in upper case and a through z in lower case
	            var letter = /[a-zA-Z]/;

	            <let-dig> ::= <letter> | <digit>
	            var letDig = /[0-9a-zA-Z]/;

	            <let-dig-hyp> ::= <let-dig> | "-"
	            var letDigHyp = /[-0-9a-zA-Z]/;

	            <ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>
	            var ldhStr = /[-0-9a-zA-Z]+/;

	            <label> ::= <letter> [ [ <ldh-str> ] <let-dig> ]
	            var label = /[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?/;

	            <subdomain> ::= <label> | <subdomain> "." <label>
	            var subdomain = /^[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?(\.[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?)*$/;

	            <domain> ::= <subdomain> | " "
	            var domain = null;
	        */
	        var valid = /^[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?(\.[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?)*$/.test(hostname);
	        if (valid) {
	            // the sum of all label octets and label lengths is limited to 255.
	            if (hostname.length > 255) { return false; }
	            // Each node has a label, which is zero to 63 octets in length
	            var labels = hostname.split(".");
	            for (var i = 0; i < labels.length; i++) { if (labels[i].length > 63) { return false; } }
	        }
	        return valid;
	    },
	    "host-name": function (hostname) {
	        return FormatValidators.hostname.call(this, hostname);
	    },
	    "ipv4": function (ipv4) {
	        if (typeof ipv4 !== "string") { return true; }
	        return validator.isIP(ipv4, 4);
	    },
	    "ipv6": function (ipv6) {
	        if (typeof ipv6 !== "string") { return true; }
	        return validator.isIP(ipv6, 6);
	    },
	    "regex": function (str) {
	        try {
	            RegExp(str);
	            return true;
	        } catch (e) {
	            return false;
	        }
	    },
	    "uri": function (uri) {
	        if (this.options.strictUris) {
	            return FormatValidators["strict-uri"].apply(this, arguments);
	        }
	        // https://github.com/zaggino/z-schema/issues/18
	        // RegExp from http://tools.ietf.org/html/rfc3986#appendix-B
	        return typeof uri !== "string" || RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?").test(uri);
	    },
	    "strict-uri": function (uri) {
	        return typeof uri !== "string" || validator.isURL(uri);
	    }
	};

	module.exports = FormatValidators;


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var FormatValidators  = __webpack_require__(206),
	    Report            = __webpack_require__(205),
	    Utils             = __webpack_require__(211);

	var JsonValidators = {
	    multipleOf: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.1.2
	        if (typeof json !== "number") {
	            return;
	        }
	        if (Utils.whatIs(json / schema.multipleOf) !== "integer") {
	            report.addError("MULTIPLE_OF", [json, schema.multipleOf], null, schema.description);
	        }
	    },
	    maximum: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.2.2
	        if (typeof json !== "number") {
	            return;
	        }
	        if (schema.exclusiveMaximum !== true) {
	            if (json > schema.maximum) {
	                report.addError("MAXIMUM", [json, schema.maximum], null, schema.description);
	            }
	        } else {
	            if (json >= schema.maximum) {
	                report.addError("MAXIMUM_EXCLUSIVE", [json, schema.maximum], null, schema.description);
	            }
	        }
	    },
	    exclusiveMaximum: function () {
	        // covered in maximum
	    },
	    minimum: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.3.2
	        if (typeof json !== "number") {
	            return;
	        }
	        if (schema.exclusiveMinimum !== true) {
	            if (json < schema.minimum) {
	                report.addError("MINIMUM", [json, schema.minimum], null, schema.description);
	            }
	        } else {
	            if (json <= schema.minimum) {
	                report.addError("MINIMUM_EXCLUSIVE", [json, schema.minimum], null, schema.description);
	            }
	        }
	    },
	    exclusiveMinimum: function () {
	        // covered in minimum
	    },
	    maxLength: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.1.2
	        if (typeof json !== "string") {
	            return;
	        }
	        if (Utils.ucs2decode(json).length > schema.maxLength) {
	            report.addError("MAX_LENGTH", [json.length, schema.maxLength], null, schema.description);
	        }
	    },
	    minLength: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.2.2
	        if (typeof json !== "string") {
	            return;
	        }
	        if (Utils.ucs2decode(json).length < schema.minLength) {
	            report.addError("MIN_LENGTH", [json.length, schema.minLength], null, schema.description);
	        }
	    },
	    pattern: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.3.2
	        if (typeof json !== "string") {
	            return;
	        }
	        if (RegExp(schema.pattern).test(json) === false) {
	            report.addError("PATTERN", [schema.pattern, json], null, schema.description);
	        }
	    },
	    additionalItems: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.1.2
	        if (!Array.isArray(json)) {
	            return;
	        }
	        // if the value of "additionalItems" is boolean value false and the value of "items" is an array,
	        // the json is valid if its size is less than, or equal to, the size of "items".
	        if (schema.additionalItems === false && Array.isArray(schema.items)) {
	            if (json.length > schema.items.length) {
	                report.addError("ARRAY_ADDITIONAL_ITEMS", null, null, schema.description);
	            }
	        }
	    },
	    items: function () { /*report, schema, json*/
	        // covered in additionalItems
	    },
	    maxItems: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.2.2
	        if (!Array.isArray(json)) {
	            return;
	        }
	        if (json.length > schema.maxItems) {
	            report.addError("ARRAY_LENGTH_LONG", [json.length, schema.maxItems], null, schema.description);
	        }
	    },
	    minItems: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.3.2
	        if (!Array.isArray(json)) {
	            return;
	        }
	        if (json.length < schema.minItems) {
	            report.addError("ARRAY_LENGTH_SHORT", [json.length, schema.minItems], null, schema.description);
	        }
	    },
	    uniqueItems: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.4.2
	        if (!Array.isArray(json)) {
	            return;
	        }
	        if (schema.uniqueItems === true) {
	            var matches = [];
	            if (Utils.isUniqueArray(json, matches) === false) {
	                report.addError("ARRAY_UNIQUE", matches, null, schema.description);
	            }
	        }
	    },
	    maxProperties: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.1.2
	        if (Utils.whatIs(json) !== "object") {
	            return;
	        }
	        var keysCount = Object.keys(json).length;
	        if (keysCount > schema.maxProperties) {
	            report.addError("OBJECT_PROPERTIES_MAXIMUM", [keysCount, schema.maxProperties], null, schema.description);
	        }
	    },
	    minProperties: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.2.2
	        if (Utils.whatIs(json) !== "object") {
	            return;
	        }
	        var keysCount = Object.keys(json).length;
	        if (keysCount < schema.minProperties) {
	            report.addError("OBJECT_PROPERTIES_MINIMUM", [keysCount, schema.minProperties], null, schema.description);
	        }
	    },
	    required: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.3.2
	        if (Utils.whatIs(json) !== "object") {
	            return;
	        }
	        var idx = schema.required.length;
	        while (idx--) {
	            var requiredPropertyName = schema.required[idx];
	            if (json[requiredPropertyName] === undefined) {
	                report.addError("OBJECT_MISSING_REQUIRED_PROPERTY", [requiredPropertyName], null, schema.description);
	            }
	        }
	    },
	    additionalProperties: function (report, schema, json) {
	        // covered in properties and patternProperties
	        if (schema.properties === undefined && schema.patternProperties === undefined) {
	            return JsonValidators.properties.call(this, report, schema, json);
	        }
	    },
	    patternProperties: function (report, schema, json) {
	        // covered in properties
	        if (schema.properties === undefined) {
	            return JsonValidators.properties.call(this, report, schema, json);
	        }
	    },
	    properties: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.2
	        if (Utils.whatIs(json) !== "object") {
	            return;
	        }
	        var properties = schema.properties !== undefined ? schema.properties : {};
	        var patternProperties = schema.patternProperties !== undefined ? schema.patternProperties : {};
	        if (schema.additionalProperties === false) {
	            // The property set of the json to validate.
	            var s = Object.keys(json);
	            // The property set from "properties".
	            var p = Object.keys(properties);
	            // The property set from "patternProperties".
	            var pp = Object.keys(patternProperties);
	            // remove from "s" all elements of "p", if any;
	            s = Utils.difference(s, p);
	            // for each regex in "pp", remove all elements of "s" which this regex matches.
	            var idx = pp.length;
	            while (idx--) {
	                var regExp = RegExp(pp[idx]),
	                    idx2 = s.length;
	                while (idx2--) {
	                    if (regExp.test(s[idx2]) === true) {
	                        s.splice(idx2, 1);
	                    }
	                }
	            }
	            // Validation of the json succeeds if, after these two steps, set "s" is empty.
	            if (s.length > 0) {
	                // assumeAdditional can be an array of allowed properties
	                var idx3 = this.options.assumeAdditional.length;
	                if (idx3) {
	                    while (idx3--) {
	                        var io = s.indexOf(this.options.assumeAdditional[idx3]);
	                        if (io !== -1) {
	                            s.splice(io, 1);
	                        }
	                    }
	                }
	                if (s.length > 0) {
	                    report.addError("OBJECT_ADDITIONAL_PROPERTIES", [s], null, schema.description);
	                }
	            }
	        }
	    },
	    dependencies: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.5.2
	        if (Utils.whatIs(json) !== "object") {
	            return;
	        }

	        var keys = Object.keys(schema.dependencies),
	            idx = keys.length;

	        while (idx--) {
	            // iterate all dependencies
	            var dependencyName = keys[idx];
	            if (json[dependencyName]) {
	                var dependencyDefinition = schema.dependencies[dependencyName];
	                if (Utils.whatIs(dependencyDefinition) === "object") {
	                    // if dependency is a schema, validate against this schema
	                    exports.validate.call(this, report, dependencyDefinition, json);
	                } else { // Array
	                    // if dependency is an array, object needs to have all properties in this array
	                    var idx2 = dependencyDefinition.length;
	                    while (idx2--) {
	                        var requiredPropertyName = dependencyDefinition[idx2];
	                        if (json[requiredPropertyName] === undefined) {
	                            report.addError("OBJECT_DEPENDENCY_KEY", [requiredPropertyName, dependencyName], null, schema.description);
	                        }
	                    }
	                }
	            }
	        }
	    },
	    enum: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.1.2
	        var match = false,
	            idx = schema.enum.length;
	        while (idx--) {
	            if (Utils.areEqual(json, schema.enum[idx])) {
	                match = true;
	                break;
	            }
	        }
	        if (match === false) {
	            report.addError("ENUM_MISMATCH", [json], null, schema.description);
	        }
	    },
	    /*
	    type: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.2.2
	        // type is handled before this is called so ignore
	    },
	    */
	    allOf: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.3.2
	        var idx = schema.allOf.length;
	        while (idx--) {
	            var validateResult = exports.validate.call(this, report, schema.allOf[idx], json);
	            if (this.options.breakOnFirstError && validateResult === false) {
	                break;
	            }
	        }
	    },
	    anyOf: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.4.2
	        var subReports = [],
	            passed = false,
	            idx = schema.anyOf.length;

	        while (idx-- && passed === false) {
	            var subReport = new Report(report);
	            subReports.push(subReport);
	            passed = exports.validate.call(this, subReport, schema.anyOf[idx], json);
	        }

	        if (passed === false) {
	            report.addError("ANY_OF_MISSING", undefined, subReports, schema.description);
	        }
	    },
	    oneOf: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.5.2
	        var passes = 0,
	            subReports = [],
	            idx = schema.oneOf.length;

	        while (idx--) {
	            var subReport = new Report(report, { maxErrors: 1 });
	            subReports.push(subReport);
	            if (exports.validate.call(this, subReport, schema.oneOf[idx], json) === true) {
	                passes++;
	            }
	        }

	        if (passes === 0) {
	            report.addError("ONE_OF_MISSING", undefined, subReports, schema.description);
	        } else if (passes > 1) {
	            report.addError("ONE_OF_MULTIPLE", null, null, schema.description);
	        }
	    },
	    not: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.6.2
	        var subReport = new Report(report);
	        if (exports.validate.call(this, subReport, schema.not, json) === true) {
	            report.addError("NOT_PASSED", null, null, schema.description);
	        }
	    },
	    definitions: function () { /*report, schema, json*/
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.7.2
	        // nothing to do here
	    },
	    format: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.7.2
	        var formatValidatorFn = FormatValidators[schema.format];
	        if (typeof formatValidatorFn === "function") {
	            if (formatValidatorFn.length === 2) {
	                // async
	                report.addAsyncTask(formatValidatorFn, [json], function (result) {
	                    if (result !== true) {
	                        report.addError("INVALID_FORMAT", [schema.format, json], null, schema.description);
	                    }
	                });
	            } else {
	                // sync
	                if (formatValidatorFn.call(this, json) !== true) {
	                    report.addError("INVALID_FORMAT", [schema.format, json], null, schema.description);
	                }
	            }
	        } else if (this.options.ignoreUnknownFormats !== true) {
	            report.addError("UNKNOWN_FORMAT", [schema.format], null, schema.description);
	        }
	    }
	};

	var recurseArray = function (report, schema, json) {
	    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.8.2

	    var idx = json.length;

	    // If "items" is an array, this situation, the schema depends on the index:
	    // if the index is less than, or equal to, the size of "items",
	    // the child instance must be valid against the corresponding schema in the "items" array;
	    // otherwise, it must be valid against the schema defined by "additionalItems".
	    if (Array.isArray(schema.items)) {

	        while (idx--) {
	            // equal to doesnt make sense here
	            if (idx < schema.items.length) {
	                report.path.push(idx.toString());
	                exports.validate.call(this, report, schema.items[idx], json[idx]);
	                report.path.pop();
	            } else {
	                // might be boolean, so check that it's an object
	                if (typeof schema.additionalItems === "object") {
	                    report.path.push(idx.toString());
	                    exports.validate.call(this, report, schema.additionalItems, json[idx]);
	                    report.path.pop();
	                }
	            }
	        }

	    } else if (typeof schema.items === "object") {

	        // If items is a schema, then the child instance must be valid against this schema,
	        // regardless of its index, and regardless of the value of "additionalItems".
	        while (idx--) {
	            report.path.push(idx.toString());
	            exports.validate.call(this, report, schema.items, json[idx]);
	            report.path.pop();
	        }

	    }
	};

	var recurseObject = function (report, schema, json) {
	    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.8.3

	    // If "additionalProperties" is absent, it is considered present with an empty schema as a value.
	    // In addition, boolean value true is considered equivalent to an empty schema.
	    var additionalProperties = schema.additionalProperties;
	    if (additionalProperties === true || additionalProperties === undefined) {
	        additionalProperties = {};
	    }

	    // p - The property set from "properties".
	    var p = schema.properties ? Object.keys(schema.properties) : [];

	    // pp - The property set from "patternProperties". Elements of this set will be called regexes for convenience.
	    var pp = schema.patternProperties ? Object.keys(schema.patternProperties) : [];

	    // m - The property name of the child.
	    var keys = Object.keys(json),
	        idx = keys.length;

	    while (idx--) {
	        var m = keys[idx],
	            propertyValue = json[m];

	        // s - The set of schemas for the child instance.
	        var s = [];

	        // 1. If set "p" contains value "m", then the corresponding schema in "properties" is added to "s".
	        if (p.indexOf(m) !== -1) {
	            s.push(schema.properties[m]);
	        }

	        // 2. For each regex in "pp", if it matches "m" successfully, the corresponding schema in "patternProperties" is added to "s".
	        var idx2 = pp.length;
	        while (idx2--) {
	            var regexString = pp[idx2];
	            if (RegExp(regexString).test(m) === true) {
	                s.push(schema.patternProperties[regexString]);
	            }
	        }

	        // 3. The schema defined by "additionalProperties" is added to "s" if and only if, at this stage, "s" is empty.
	        if (s.length === 0 && additionalProperties !== false) {
	            s.push(additionalProperties);
	        }

	        // we are passing tests even without this assert because this is covered by properties check
	        // if s is empty in this stage, no additionalProperties are allowed
	        // report.expect(s.length !== 0, 'E001', m);

	        // Instance property value must pass all schemas from s
	        idx2 = s.length;
	        while (idx2--) {
	            report.path.push(m);
	            exports.validate.call(this, report, s[idx2], propertyValue);
	            report.path.pop();
	        }
	    }
	};

	exports.validate = function (report, schema, json) {

	    report.commonErrorMessage = "JSON_OBJECT_VALIDATION_FAILED";

	    // check if schema is an object
	    var to = Utils.whatIs(schema);
	    if (to !== "object") {
	        report.addError("SCHEMA_NOT_AN_OBJECT", [to], null, schema.description);
	        return false;
	    }

	    // check if schema is empty, everything is valid against empty schema
	    var keys = Object.keys(schema);
	    if (keys.length === 0) {
	        return true;
	    }

	    // this method can be called recursively, so we need to remember our root
	    var isRoot = false;
	    if (!report.rootSchema) {
	        report.rootSchema = schema;
	        isRoot = true;
	    }

	    // follow schema.$ref keys
	    if (schema.$ref !== undefined) {
	        // avoid infinite loop with maxRefs
	        var maxRefs = 99;
	        while (schema.$ref && maxRefs > 0) {
	            if (!schema.__$refResolved) {
	                report.addError("REF_UNRESOLVED", [schema.$ref], null, schema.description);
	                break;
	            } else if (schema.__$refResolved === schema) {
	                break;
	            } else {
	                schema = schema.__$refResolved;
	                keys = Object.keys(schema);
	            }
	            maxRefs--;
	        }
	        if (maxRefs === 0) {
	            throw new Error("Circular dependency by $ref references!");
	        }
	    }

	    // type checking first
	    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.2.2
	    var jsonType = Utils.whatIs(json);
	    if (schema.type) {
	        if (typeof schema.type === "string") {
	            if (jsonType !== schema.type && (jsonType !== "integer" || schema.type !== "number")) {
	                report.addError("INVALID_TYPE", [schema.type, jsonType], null, schema.description);
	                if (this.options.breakOnFirstError) {
	                    return false;
	                }
	            }
	        } else {
	            if (schema.type.indexOf(jsonType) === -1 && (jsonType !== "integer" || schema.type.indexOf("number") === -1)) {
	                report.addError("INVALID_TYPE", [schema.type, jsonType], null, schema.description);
	                if (this.options.breakOnFirstError) {
	                    return false;
	                }
	            }
	        }
	    }

	    // now iterate all the keys in schema and execute validation methods
	    var idx = keys.length;
	    while (idx--) {
	        if (JsonValidators[keys[idx]]) {
	            JsonValidators[keys[idx]].call(this, report, schema, json);
	            if (report.errors.length && this.options.breakOnFirstError) { break; }
	        }
	    }

	    if (report.errors.length === 0 || this.options.breakOnFirstError === false) {
	        if (jsonType === "array") {
	            recurseArray.call(this, report, schema, json);
	        } else if (jsonType === "object") {
	            recurseObject.call(this, report, schema, json);
	        }
	    }

	    if (typeof this.options.customValidator === "function") {
	        this.options.customValidator(report, schema, json);
	    }

	    // we don't need the root pointer anymore
	    if (isRoot) {
	        report.rootSchema = undefined;
	    }

	    // return valid just to be able to break at some code points
	    return report.errors.length === 0;

	};


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Report              = __webpack_require__(205);
	var SchemaCompilation   = __webpack_require__(209);
	var SchemaValidation    = __webpack_require__(210);
	var Utils               = __webpack_require__(211);

	function decodeJSONPointer(str) {
	    // http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-07#section-3
	    return decodeURIComponent(str).replace(/~[0-1]/g, function (x) {
	        return x === "~1" ? "/" : "~";
	    });
	}

	function getRemotePath(uri) {
	    var io = uri.indexOf("#");
	    return io === -1 ? uri : uri.slice(0, io);
	}

	function getQueryPath(uri) {
	    var io = uri.indexOf("#");
	    var res = io === -1 ? undefined : uri.slice(io + 1);
	    // WARN: do not slice slash, #/ means take root and go down from it
	    // if (res && res[0] === "/") { res = res.slice(1); }
	    return res;
	}

	function findId(schema, id) {
	    // process only arrays and objects
	    if (typeof schema !== "object" || schema === null) {
	        return;
	    }

	    // no id means root so return itself
	    if (!id) {
	        return schema;
	    }

	    if (schema.id) {
	        if (schema.id === id || schema.id[0] === "#" && schema.id.substring(1) === id) {
	            return schema;
	        }
	    }

	    var idx, result;
	    if (Array.isArray(schema)) {
	        idx = schema.length;
	        while (idx--) {
	            result = findId(schema[idx], id);
	            if (result) { return result; }
	        }
	    } else {
	        var keys = Object.keys(schema);
	        idx = keys.length;
	        while (idx--) {
	            var k = keys[idx];
	            if (k.indexOf("__$") === 0) {
	                continue;
	            }
	            result = findId(schema[k], id);
	            if (result) { return result; }
	        }
	    }
	}

	exports.cacheSchemaByUri = function (uri, schema) {
	    var remotePath = getRemotePath(uri);
	    if (remotePath) {
	        this.cache[remotePath] = schema;
	    }
	};

	exports.removeFromCacheByUri = function (uri) {
	    var remotePath = getRemotePath(uri);
	    if (remotePath) {
	        delete this.cache[remotePath];
	    }
	};

	exports.checkCacheForUri = function (uri) {
	    var remotePath = getRemotePath(uri);
	    return remotePath ? this.cache[remotePath] != null : false;
	};

	exports.getSchema = function (report, schema) {
	    if (typeof schema === "object") {
	        schema = exports.getSchemaByReference.call(this, report, schema);
	    }
	    if (typeof schema === "string") {
	        schema = exports.getSchemaByUri.call(this, report, schema);
	    }
	    return schema;
	};

	exports.getSchemaByReference = function (report, key) {
	    var i = this.referenceCache.length;
	    while (i--) {
	        if (this.referenceCache[i][0] === key) {
	            return this.referenceCache[i][1];
	        }
	    }
	    // not found
	    var schema = Utils.cloneDeep(key);
	    this.referenceCache.push([key, schema]);
	    return schema;
	};

	exports.getSchemaByUri = function (report, uri, root) {
	    var remotePath = getRemotePath(uri),
	        queryPath = getQueryPath(uri),
	        result = remotePath ? this.cache[remotePath] : root;

	    if (result && remotePath) {
	        // we need to avoid compiling schemas in a recursive loop
	        var compileRemote = result !== root;
	        // now we need to compile and validate resolved schema (in case it's not already)
	        if (compileRemote) {

	            report.path.push(remotePath);

	            var remoteReport = new Report(report);
	            if (SchemaCompilation.compileSchema.call(this, remoteReport, result)) {
	                SchemaValidation.validateSchema.call(this, remoteReport, result);
	            }
	            var remoteReportIsValid = remoteReport.isValid();
	            if (!remoteReportIsValid) {
	                report.addError("REMOTE_NOT_VALID", [uri], remoteReport);
	            }

	            report.path.pop();

	            if (!remoteReportIsValid) {
	                return undefined;
	            }
	        }
	    }

	    if (result && queryPath) {
	        var parts = queryPath.split("/");
	        for (var idx = 0, lim = parts.length; result && idx < lim; idx++) {
	            var key = decodeJSONPointer(parts[idx]);
	            if (idx === 0) { // it's an id
	                result = findId(result, key);
	            } else { // it's a path behind id
	                result = result[key];
	            }
	        }
	    }

	    return result;
	};

	exports.getRemotePath = getRemotePath;


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Report      = __webpack_require__(205);
	var SchemaCache = __webpack_require__(208);
	var Utils       = __webpack_require__(211);

	function mergeReference(scope, ref) {
	    if (Utils.isAbsoluteUri(ref)) {
	        return ref;
	    }

	    var joinedScope = scope.join(""),
	        isScopeAbsolute = Utils.isAbsoluteUri(joinedScope),
	        isScopeRelative = Utils.isRelativeUri(joinedScope),
	        isRefRelative = Utils.isRelativeUri(ref),
	        toRemove;

	    if (isScopeAbsolute && isRefRelative) {
	        toRemove = joinedScope.match(/\/[^\/]*$/);
	        if (toRemove) {
	            joinedScope = joinedScope.slice(0, toRemove.index + 1);
	        }
	    } else if (isScopeRelative && isRefRelative) {
	        joinedScope = "";
	    } else {
	        toRemove = joinedScope.match(/[^#/]+$/);
	        if (toRemove) {
	            joinedScope = joinedScope.slice(0, toRemove.index);
	        }
	    }

	    var res = joinedScope + ref;
	    res = res.replace(/##/, "#");
	    return res;
	}

	function collectReferences(obj, results, scope, path) {
	    results = results || [];
	    scope = scope || [];
	    path = path || [];

	    if (typeof obj !== "object" || obj === null) {
	        return results;
	    }

	    if (typeof obj.id === "string") {
	        scope.push(obj.id);
	    }

	    if (typeof obj.$ref === "string" && typeof obj.__$refResolved === "undefined") {
	        results.push({
	            ref: mergeReference(scope, obj.$ref),
	            key: "$ref",
	            obj: obj,
	            path: path.slice(0)
	        });
	    }
	    if (typeof obj.$schema === "string" && typeof obj.__$schemaResolved === "undefined") {
	        results.push({
	            ref: mergeReference(scope, obj.$schema),
	            key: "$schema",
	            obj: obj,
	            path: path.slice(0)
	        });
	    }

	    var idx;
	    if (Array.isArray(obj)) {
	        idx = obj.length;
	        while (idx--) {
	            path.push(idx.toString());
	            collectReferences(obj[idx], results, scope, path);
	            path.pop();
	        }
	    } else {
	        var keys = Object.keys(obj);
	        idx = keys.length;
	        while (idx--) {
	            // do not recurse through resolved references and other z-schema props
	            if (keys[idx].indexOf("__$") === 0) { continue; }
	            path.push(keys[idx]);
	            collectReferences(obj[keys[idx]], results, scope, path);
	            path.pop();
	        }
	    }

	    if (typeof obj.id === "string") {
	        scope.pop();
	    }

	    return results;
	}

	var compileArrayOfSchemasLoop = function (mainReport, arr) {
	    var idx = arr.length,
	        compiledCount = 0;

	    while (idx--) {

	        // try to compile each schema separately
	        var report = new Report(mainReport);
	        var isValid = exports.compileSchema.call(this, report, arr[idx]);
	        if (isValid) { compiledCount++; }

	        // copy errors to report
	        mainReport.errors = mainReport.errors.concat(report.errors);

	    }

	    return compiledCount;
	};

	function findId(arr, id) {
	    var idx = arr.length;
	    while (idx--) {
	        if (arr[idx].id === id) {
	            return arr[idx];
	        }
	    }
	    return null;
	}

	var compileArrayOfSchemas = function (report, arr) {

	    var compiled = 0,
	        lastLoopCompiled;

	    do {

	        // remove all UNRESOLVABLE_REFERENCE errors before compiling array again
	        var idx = report.errors.length;
	        while (idx--) {
	            if (report.errors[idx].code === "UNRESOLVABLE_REFERENCE") {
	                report.errors.splice(idx, 1);
	            }
	        }

	        // remember how many were compiled in the last loop
	        lastLoopCompiled = compiled;

	        // count how many are compiled now
	        compiled = compileArrayOfSchemasLoop.call(this, report, arr);

	        // fix __$missingReferences if possible
	        idx = arr.length;
	        while (idx--) {
	            var sch = arr[idx];
	            if (sch.__$missingReferences) {
	                var idx2 = sch.__$missingReferences.length;
	                while (idx2--) {
	                    var refObj = sch.__$missingReferences[idx2];
	                    var response = findId(arr, refObj.ref);
	                    if (response) {
	                        // this might create circular references
	                        refObj.obj["__" + refObj.key + "Resolved"] = response;
	                        // it's resolved now so delete it
	                        sch.__$missingReferences.splice(idx2, 1);
	                    }
	                }
	                if (sch.__$missingReferences.length === 0) {
	                    delete sch.__$missingReferences;
	                }
	            }
	        }

	        // keep repeating if not all compiled and at least one more was compiled in the last loop
	    } while (compiled !== arr.length && compiled !== lastLoopCompiled);

	    return report.isValid();

	};

	exports.compileSchema = function (report, schema) {

	    report.commonErrorMessage = "SCHEMA_COMPILATION_FAILED";

	    // if schema is a string, assume it's a uri
	    if (typeof schema === "string") {
	        var loadedSchema = SchemaCache.getSchemaByUri.call(this, report, schema);
	        if (!loadedSchema) {
	            report.addError("SCHEMA_NOT_REACHABLE", [schema]);
	            return false;
	        }
	        schema = loadedSchema;
	    }

	    // if schema is an array, assume it's an array of schemas
	    if (Array.isArray(schema)) {
	        return compileArrayOfSchemas.call(this, report, schema);
	    }

	    // if we have an id than it should be cached already (if this instance has compiled it)
	    if (schema.__$compiled && schema.id && SchemaCache.checkCacheForUri.call(this, schema.id) === false) {
	        schema.__$compiled = undefined;
	    }

	    // do not re-compile schemas
	    if (schema.__$compiled) {
	        return true;
	    }

	    if (schema.id && typeof schema.id === "string") {
	        // add this to our schemaCache (before compilation in case we have references including id)
	        SchemaCache.cacheSchemaByUri.call(this, schema.id, schema);
	    }

	    // this method can be called recursively, so we need to remember our root
	    var isRoot = false;
	    if (!report.rootSchema) {
	        report.rootSchema = schema;
	        isRoot = true;
	    }

	    // delete all __$missingReferences from previous compilation attempts
	    var isValidExceptReferences = report.isValid();
	    delete schema.__$missingReferences;

	    // collect all references that need to be resolved - $ref and $schema
	    var refs = collectReferences.call(this, schema),
	        idx = refs.length;
	    while (idx--) {
	        // resolve all the collected references into __xxxResolved pointer
	        var refObj = refs[idx];
	        var response = SchemaCache.getSchemaByUri.call(this, report, refObj.ref, schema);

	        // we can try to use custom schemaReader if available
	        if (!response) {
	            var schemaReader = this.getSchemaReader();
	            if (schemaReader) {
	                // it's supposed to return a valid schema
	                var s = schemaReader(refObj.ref);
	                if (s) {
	                    // it needs to have the id
	                    s.id = refObj.ref;
	                    // try to compile the schema
	                    var subreport = new Report(report);
	                    if (!exports.compileSchema.call(this, subreport, s)) {
	                        // copy errors to report
	                        report.errors = report.errors.concat(subreport.errors);
	                    } else {
	                        response = SchemaCache.getSchemaByUri.call(this, report, refObj.ref, schema);
	                    }
	                }
	            }
	        }

	        if (!response) {

	            var hasNotValid = report.hasError("REMOTE_NOT_VALID", [refObj.ref]);
	            var isAbsolute = Utils.isAbsoluteUri(refObj.ref);
	            var isDownloaded = false;
	            var ignoreUnresolvableRemotes = this.options.ignoreUnresolvableReferences === true;

	            if (isAbsolute) {
	                // we shouldn't add UNRESOLVABLE_REFERENCE for schemas we already have downloaded
	                // and set through setRemoteReference method
	                isDownloaded = SchemaCache.checkCacheForUri.call(this, refObj.ref);
	            }

	            if (hasNotValid) {
	                // already has REMOTE_NOT_VALID error for this one
	            } else if (ignoreUnresolvableRemotes && isAbsolute) {
	                // ignoreUnresolvableRemotes is on and remote isAbsolute
	            } else if (isDownloaded) {
	                // remote is downloaded, so no UNRESOLVABLE_REFERENCE
	            } else {
	                Array.prototype.push.apply(report.path, refObj.path);
	                report.addError("UNRESOLVABLE_REFERENCE", [refObj.ref]);
	                report.path = report.path.slice(0, -refObj.path.length);

	                // pusblish unresolved references out
	                if (isValidExceptReferences) {
	                    schema.__$missingReferences = schema.__$missingReferences || [];
	                    schema.__$missingReferences.push(refObj);
	                }
	            }
	        }
	        // this might create circular references
	        refObj.obj["__" + refObj.key + "Resolved"] = response;
	    }

	    var isValid = report.isValid();
	    if (isValid) {
	        schema.__$compiled = true;
	    } else {
	        if (schema.id && typeof schema.id === "string") {
	            // remove this schema from schemaCache because it failed to compile
	            SchemaCache.removeFromCacheByUri.call(this, schema.id);
	        }
	    }

	    // we don't need the root pointer anymore
	    if (isRoot) {
	        report.rootSchema = undefined;
	    }

	    return isValid;

	};


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var FormatValidators = __webpack_require__(206),
	    JsonValidation   = __webpack_require__(207),
	    Report           = __webpack_require__(205),
	    Utils            = __webpack_require__(211);

	var SchemaValidators = {
	    $ref: function (report, schema) {
	        // http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-07
	        // http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03
	        if (typeof schema.$ref !== "string") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["$ref", "string"]);
	        }
	    },
	    $schema: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-core.html#rfc.section.6
	        if (typeof schema.$schema !== "string") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["$schema", "string"]);
	        }
	    },
	    multipleOf: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.1.1
	        if (typeof schema.multipleOf !== "number") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["multipleOf", "number"]);
	        } else if (schema.multipleOf <= 0) {
	            report.addError("KEYWORD_MUST_BE", ["multipleOf", "strictly greater than 0"]);
	        }
	    },
	    maximum: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.2.1
	        if (typeof schema.maximum !== "number") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["maximum", "number"]);
	        }
	    },
	    exclusiveMaximum: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.2.1
	        if (typeof schema.exclusiveMaximum !== "boolean") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["exclusiveMaximum", "boolean"]);
	        } else if (schema.maximum === undefined) {
	            report.addError("KEYWORD_DEPENDENCY", ["exclusiveMaximum", "maximum"]);
	        }
	    },
	    minimum: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.3.1
	        if (typeof schema.minimum !== "number") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["minimum", "number"]);
	        }
	    },
	    exclusiveMinimum: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.3.1
	        if (typeof schema.exclusiveMinimum !== "boolean") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["exclusiveMinimum", "boolean"]);
	        } else if (schema.minimum === undefined) {
	            report.addError("KEYWORD_DEPENDENCY", ["exclusiveMinimum", "minimum"]);
	        }
	    },
	    maxLength: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.1.1
	        if (Utils.whatIs(schema.maxLength) !== "integer") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["maxLength", "integer"]);
	        } else if (schema.maxLength < 0) {
	            report.addError("KEYWORD_MUST_BE", ["maxLength", "greater than, or equal to 0"]);
	        }
	    },
	    minLength: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.2.1
	        if (Utils.whatIs(schema.minLength) !== "integer") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["minLength", "integer"]);
	        } else if (schema.minLength < 0) {
	            report.addError("KEYWORD_MUST_BE", ["minLength", "greater than, or equal to 0"]);
	        }
	    },
	    pattern: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.3.1
	        if (typeof schema.pattern !== "string") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["pattern", "string"]);
	        } else {
	            try {
	                RegExp(schema.pattern);
	            } catch (e) {
	                report.addError("KEYWORD_PATTERN", ["pattern", schema.pattern]);
	            }
	        }
	    },
	    additionalItems: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.1.1
	        var type = Utils.whatIs(schema.additionalItems);
	        if (type !== "boolean" && type !== "object") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["additionalItems", ["boolean", "object"]]);
	        } else if (type === "object") {
	            report.path.push("additionalItems");
	            exports.validateSchema.call(this, report, schema.additionalItems);
	            report.path.pop();
	        }
	    },
	    items: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.1.1
	        var type = Utils.whatIs(schema.items);

	        if (type === "object") {
	            report.path.push("items");
	            exports.validateSchema.call(this, report, schema.items);
	            report.path.pop();
	        } else if (type === "array") {
	            var idx = schema.items.length;
	            while (idx--) {
	                report.path.push("items");
	                report.path.push(idx.toString());
	                exports.validateSchema.call(this, report, schema.items[idx]);
	                report.path.pop();
	                report.path.pop();
	            }
	        } else {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["items", ["array", "object"]]);
	        }

	        // custom - strict mode
	        if (this.options.forceAdditional === true && schema.additionalItems === undefined && Array.isArray(schema.items)) {
	            report.addError("KEYWORD_UNDEFINED_STRICT", ["additionalItems"]);
	        }
	        // custome - assume defined false mode
	        if (this.options.assumeAdditional && schema.additionalItems === undefined && Array.isArray(schema.items)) {
	            schema.additionalItems = false;
	        }
	    },
	    maxItems: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.2.1
	        if (typeof schema.maxItems !== "number") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["maxItems", "integer"]);
	        } else if (schema.maxItems < 0) {
	            report.addError("KEYWORD_MUST_BE", ["maxItems", "greater than, or equal to 0"]);
	        }
	    },
	    minItems: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.3.1
	        if (Utils.whatIs(schema.minItems) !== "integer") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["minItems", "integer"]);
	        } else if (schema.minItems < 0) {
	            report.addError("KEYWORD_MUST_BE", ["minItems", "greater than, or equal to 0"]);
	        }
	    },
	    uniqueItems: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.4.1
	        if (typeof schema.uniqueItems !== "boolean") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["uniqueItems", "boolean"]);
	        }
	    },
	    maxProperties: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.1.1
	        if (Utils.whatIs(schema.maxProperties) !== "integer") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["maxProperties", "integer"]);
	        } else if (schema.maxProperties < 0) {
	            report.addError("KEYWORD_MUST_BE", ["maxProperties", "greater than, or equal to 0"]);
	        }
	    },
	    minProperties: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.2.1
	        if (Utils.whatIs(schema.minProperties) !== "integer") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["minProperties", "integer"]);
	        } else if (schema.minProperties < 0) {
	            report.addError("KEYWORD_MUST_BE", ["minProperties", "greater than, or equal to 0"]);
	        }
	    },
	    required: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.3.1
	        if (Utils.whatIs(schema.required) !== "array") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["required", "array"]);
	        } else if (schema.required.length === 0) {
	            report.addError("KEYWORD_MUST_BE", ["required", "an array with at least one element"]);
	        } else {
	            var idx = schema.required.length;
	            while (idx--) {
	                if (typeof schema.required[idx] !== "string") {
	                    report.addError("KEYWORD_VALUE_TYPE", ["required", "string"]);
	                }
	            }
	            if (Utils.isUniqueArray(schema.required) === false) {
	                report.addError("KEYWORD_MUST_BE", ["required", "an array with unique items"]);
	            }
	        }
	    },
	    additionalProperties: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.1
	        var type = Utils.whatIs(schema.additionalProperties);
	        if (type !== "boolean" && type !== "object") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["additionalProperties", ["boolean", "object"]]);
	        } else if (type === "object") {
	            report.path.push("additionalProperties");
	            exports.validateSchema.call(this, report, schema.additionalProperties);
	            report.path.pop();
	        }
	    },
	    properties: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.1
	        if (Utils.whatIs(schema.properties) !== "object") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["properties", "object"]);
	            return;
	        }

	        var keys = Object.keys(schema.properties),
	            idx = keys.length;
	        while (idx--) {
	            var key = keys[idx],
	                val = schema.properties[key];
	            report.path.push("properties");
	            report.path.push(key);
	            exports.validateSchema.call(this, report, val);
	            report.path.pop();
	            report.path.pop();
	        }

	        // custom - strict mode
	        if (this.options.forceAdditional === true && schema.additionalProperties === undefined) {
	            report.addError("KEYWORD_UNDEFINED_STRICT", ["additionalProperties"]);
	        }
	        // custome - assume defined false mode
	        if (this.options.assumeAdditional && schema.additionalProperties === undefined) {
	            schema.additionalProperties = false;
	        }
	        // custom - forceProperties
	        if (this.options.forceProperties === true && keys.length === 0) {
	            report.addError("CUSTOM_MODE_FORCE_PROPERTIES", ["properties"]);
	        }
	    },
	    patternProperties: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.1
	        if (Utils.whatIs(schema.patternProperties) !== "object") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["patternProperties", "object"]);
	            return;
	        }

	        var keys = Object.keys(schema.patternProperties),
	            idx = keys.length;
	        while (idx--) {
	            var key = keys[idx],
	                val = schema.patternProperties[key];
	            try {
	                RegExp(key);
	            } catch (e) {
	                report.addError("KEYWORD_PATTERN", ["patternProperties", key]);
	            }
	            report.path.push("patternProperties");
	            report.path.push(key.toString());
	            exports.validateSchema.call(this, report, val);
	            report.path.pop();
	            report.path.pop();
	        }

	        // custom - forceProperties
	        if (this.options.forceProperties === true && keys.length === 0) {
	            report.addError("CUSTOM_MODE_FORCE_PROPERTIES", ["patternProperties"]);
	        }
	    },
	    dependencies: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.5.1
	        if (Utils.whatIs(schema.dependencies) !== "object") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["dependencies", "object"]);
	        } else {
	            var keys = Object.keys(schema.dependencies),
	                idx = keys.length;
	            while (idx--) {
	                var schemaKey = keys[idx],
	                    schemaDependency = schema.dependencies[schemaKey],
	                    type = Utils.whatIs(schemaDependency);

	                if (type === "object") {
	                    report.path.push("dependencies");
	                    report.path.push(schemaKey);
	                    exports.validateSchema.call(this, report, schemaDependency);
	                    report.path.pop();
	                    report.path.pop();
	                } else if (type === "array") {
	                    var idx2 = schemaDependency.length;
	                    if (idx2 === 0) {
	                        report.addError("KEYWORD_MUST_BE", ["dependencies", "not empty array"]);
	                    }
	                    while (idx2--) {
	                        if (typeof schemaDependency[idx2] !== "string") {
	                            report.addError("KEYWORD_VALUE_TYPE", ["dependensices", "string"]);
	                        }
	                    }
	                    if (Utils.isUniqueArray(schemaDependency) === false) {
	                        report.addError("KEYWORD_MUST_BE", ["dependencies", "an array with unique items"]);
	                    }
	                } else {
	                    report.addError("KEYWORD_VALUE_TYPE", ["dependencies", "object or array"]);
	                }
	            }
	        }
	    },
	    enum: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.1.1
	        if (Array.isArray(schema.enum) === false) {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["enum", "array"]);
	        } else if (schema.enum.length === 0) {
	            report.addError("KEYWORD_MUST_BE", ["enum", "an array with at least one element"]);
	        } else if (Utils.isUniqueArray(schema.enum) === false) {
	            report.addError("KEYWORD_MUST_BE", ["enum", "an array with unique elements"]);
	        }
	    },
	    type: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.2.1
	        var primitiveTypes = ["array", "boolean", "integer", "number", "null", "object", "string"],
	            primitiveTypeStr = primitiveTypes.join(","),
	            isArray = Array.isArray(schema.type);

	        if (isArray) {
	            var idx = schema.type.length;
	            while (idx--) {
	                if (primitiveTypes.indexOf(schema.type[idx]) === -1) {
	                    report.addError("KEYWORD_TYPE_EXPECTED", ["type", primitiveTypeStr]);
	                }
	            }
	            if (Utils.isUniqueArray(schema.type) === false) {
	                report.addError("KEYWORD_MUST_BE", ["type", "an object with unique properties"]);
	            }
	        } else if (typeof schema.type === "string") {
	            if (primitiveTypes.indexOf(schema.type) === -1) {
	                report.addError("KEYWORD_TYPE_EXPECTED", ["type", primitiveTypeStr]);
	            }
	        } else {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["type", ["string", "array"]]);
	        }

	        if (this.options.noEmptyStrings === true) {
	            if (schema.type === "string" || isArray && schema.type.indexOf("string") !== -1) {
	                if (schema.minLength === undefined &&
	                    schema.enum === undefined &&
	                    schema.format === undefined) {

	                    schema.minLength = 1;
	                }
	            }
	        }
	        if (this.options.noEmptyArrays === true) {
	            if (schema.type === "array" || isArray && schema.type.indexOf("array") !== -1) {
	                if (schema.minItems === undefined) {
	                    schema.minItems = 1;
	                }
	            }
	        }
	        if (this.options.forceProperties === true) {
	            if (schema.type === "object" || isArray && schema.type.indexOf("object") !== -1) {
	                if (schema.properties === undefined && schema.patternProperties === undefined) {
	                    report.addError("KEYWORD_UNDEFINED_STRICT", ["properties"]);
	                }
	            }
	        }
	        if (this.options.forceItems === true) {
	            if (schema.type === "array" || isArray && schema.type.indexOf("array") !== -1) {
	                if (schema.items === undefined) {
	                    report.addError("KEYWORD_UNDEFINED_STRICT", ["items"]);
	                }
	            }
	        }
	        if (this.options.forceMinItems === true) {
	            if (schema.type === "array" || isArray && schema.type.indexOf("array") !== -1) {
	                if (schema.minItems === undefined) {
	                    report.addError("KEYWORD_UNDEFINED_STRICT", ["minItems"]);
	                }
	            }
	        }
	        if (this.options.forceMaxItems === true) {
	            if (schema.type === "array" || isArray && schema.type.indexOf("array") !== -1) {
	                if (schema.maxItems === undefined) {
	                    report.addError("KEYWORD_UNDEFINED_STRICT", ["maxItems"]);
	                }
	            }
	        }
	        if (this.options.forceMinLength === true) {
	            if (schema.type === "string" || isArray && schema.type.indexOf("string") !== -1) {
	                if (schema.minLength === undefined &&
	                    schema.format === undefined &&
	                    schema.enum === undefined &&
	                    schema.pattern === undefined) {
	                    report.addError("KEYWORD_UNDEFINED_STRICT", ["minLength"]);
	                }
	            }
	        }
	        if (this.options.forceMaxLength === true) {
	            if (schema.type === "string" || isArray && schema.type.indexOf("string") !== -1) {
	                if (schema.maxLength === undefined &&
	                    schema.format === undefined &&
	                    schema.enum === undefined &&
	                    schema.pattern === undefined) {
	                    report.addError("KEYWORD_UNDEFINED_STRICT", ["maxLength"]);
	                }
	            }
	        }
	    },
	    allOf: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.3.1
	        if (Array.isArray(schema.allOf) === false) {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["allOf", "array"]);
	        } else if (schema.allOf.length === 0) {
	            report.addError("KEYWORD_MUST_BE", ["allOf", "an array with at least one element"]);
	        } else {
	            var idx = schema.allOf.length;
	            while (idx--) {
	                report.path.push("allOf");
	                report.path.push(idx.toString());
	                exports.validateSchema.call(this, report, schema.allOf[idx]);
	                report.path.pop();
	                report.path.pop();
	            }
	        }
	    },
	    anyOf: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.4.1
	        if (Array.isArray(schema.anyOf) === false) {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["anyOf", "array"]);
	        } else if (schema.anyOf.length === 0) {
	            report.addError("KEYWORD_MUST_BE", ["anyOf", "an array with at least one element"]);
	        } else {
	            var idx = schema.anyOf.length;
	            while (idx--) {
	                report.path.push("anyOf");
	                report.path.push(idx.toString());
	                exports.validateSchema.call(this, report, schema.anyOf[idx]);
	                report.path.pop();
	                report.path.pop();
	            }
	        }
	    },
	    oneOf: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.5.1
	        if (Array.isArray(schema.oneOf) === false) {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["oneOf", "array"]);
	        } else if (schema.oneOf.length === 0) {
	            report.addError("KEYWORD_MUST_BE", ["oneOf", "an array with at least one element"]);
	        } else {
	            var idx = schema.oneOf.length;
	            while (idx--) {
	                report.path.push("oneOf");
	                report.path.push(idx.toString());
	                exports.validateSchema.call(this, report, schema.oneOf[idx]);
	                report.path.pop();
	                report.path.pop();
	            }
	        }
	    },
	    not: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.6.1
	        if (Utils.whatIs(schema.not) !== "object") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["not", "object"]);
	        } else {
	            report.path.push("not");
	            exports.validateSchema.call(this, report, schema.not);
	            report.path.pop();
	        }
	    },
	    definitions: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.7.1
	        if (Utils.whatIs(schema.definitions) !== "object") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["definitions", "object"]);
	        } else {
	            var keys = Object.keys(schema.definitions),
	                idx = keys.length;
	            while (idx--) {
	                var key = keys[idx],
	                    val = schema.definitions[key];
	                report.path.push("definitions");
	                report.path.push(key);
	                exports.validateSchema.call(this, report, val);
	                report.path.pop();
	                report.path.pop();
	            }
	        }
	    },
	    format: function (report, schema) {
	        if (typeof schema.format !== "string") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["format", "string"]);
	        } else {
	            if (FormatValidators[schema.format] === undefined && this.options.ignoreUnknownFormats !== true) {
	                report.addError("UNKNOWN_FORMAT", [schema.format]);
	            }
	        }
	    },
	    id: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-core.html#rfc.section.7.2
	        if (typeof schema.id !== "string") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["id", "string"]);
	        }
	    },
	    title: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1
	        if (typeof schema.title !== "string") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["title", "string"]);
	        }
	    },
	    description: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1
	        if (typeof schema.description !== "string") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["description", "string"]);
	        }
	    },
	    "default": function (/* report, schema */) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.2
	        // There are no restrictions placed on the value of this keyword.
	    }
	};

	var validateArrayOfSchemas = function (report, arr) {
	    var idx = arr.length;
	    while (idx--) {
	        exports.validateSchema.call(this, report, arr[idx]);
	    }
	    return report.isValid();
	};

	exports.validateSchema = function (report, schema) {

	    report.commonErrorMessage = "SCHEMA_VALIDATION_FAILED";

	    // if schema is an array, assume it's an array of schemas
	    if (Array.isArray(schema)) {
	        return validateArrayOfSchemas.call(this, report, schema);
	    }

	    // do not revalidate schema that has already been validated once
	    if (schema.__$validated) {
	        return true;
	    }

	    // if $schema is present, this schema should validate against that $schema
	    var hasParentSchema = schema.$schema && schema.id !== schema.$schema;
	    if (hasParentSchema) {
	        if (schema.__$schemaResolved && schema.__$schemaResolved !== schema) {
	            var subReport = new Report(report);
	            var valid = JsonValidation.validate.call(this, subReport, schema.__$schemaResolved, schema);
	            if (valid === false) {
	                report.addError("PARENT_SCHEMA_VALIDATION_FAILED", null, subReport);
	            }
	        } else {
	            if (this.options.ignoreUnresolvableReferences !== true) {
	                report.addError("REF_UNRESOLVED", [schema.$schema]);
	            }
	        }
	    }

	    if (this.options.noTypeless === true) {
	        // issue #36 - inherit type to anyOf, oneOf, allOf if noTypeless is defined
	        if (schema.type !== undefined) {
	            var schemas = [];
	            if (Array.isArray(schema.anyOf)) { schemas = schemas.concat(schema.anyOf); }
	            if (Array.isArray(schema.oneOf)) { schemas = schemas.concat(schema.oneOf); }
	            if (Array.isArray(schema.allOf)) { schemas = schemas.concat(schema.allOf); }
	            schemas.forEach(function (sch) {
	                if (!sch.type) { sch.type = schema.type; }
	            });
	        }
	        // end issue #36
	        if (schema.enum === undefined &&
	            schema.type === undefined &&
	            schema.anyOf === undefined &&
	            schema.oneOf === undefined &&
	            schema.not === undefined &&
	            schema.$ref === undefined) {
	            report.addError("KEYWORD_UNDEFINED_STRICT", ["type"]);
	        }
	    }

	    var keys = Object.keys(schema),
	        idx = keys.length;
	    while (idx--) {
	        var key = keys[idx];
	        if (key.indexOf("__") === 0) { continue; }
	        if (SchemaValidators[key] !== undefined) {
	            SchemaValidators[key].call(this, report, schema);
	        } else if (!hasParentSchema) {
	            if (this.options.noExtraKeywords === true) {
	                report.addError("KEYWORD_UNEXPECTED", [key]);
	            }
	        }
	    }

	    if (this.options.pedanticCheck === true) {
	        if (schema.enum) {
	            // break recursion
	            var tmpSchema = Utils.clone(schema);
	            delete tmpSchema.enum;
	            delete tmpSchema.default;

	            report.path.push("enum");
	            idx = schema.enum.length;
	            while (idx--) {
	                report.path.push(idx.toString());
	                JsonValidation.validate.call(this, report, tmpSchema, schema.enum[idx]);
	                report.path.pop();
	            }
	            report.path.pop();
	        }

	        if (schema.default) {
	            report.path.push("default");
	            JsonValidation.validate.call(this, report, schema, schema.default);
	            report.path.pop();
	        }
	    }

	    var isValid = report.isValid();
	    if (isValid) {
	        schema.__$validated = true;
	    }
	    return isValid;
	};


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.isAbsoluteUri = function (uri) {
	    return /^https?:\/\//.test(uri);
	};

	exports.isRelativeUri = function (uri) {
	    // relative URIs that end with a hash sign, issue #56
	    return /.+#/.test(uri);
	};

	exports.whatIs = function (what) {

	    var to = typeof what;

	    if (to === "object") {
	        if (what === null) {
	            return "null";
	        }
	        if (Array.isArray(what)) {
	            return "array";
	        }
	        return "object"; // typeof what === 'object' && what === Object(what) && !Array.isArray(what);
	    }

	    if (to === "number") {
	        if (Number.isFinite(what)) {
	            if (what % 1 === 0) {
	                return "integer";
	            } else {
	                return "number";
	            }
	        }
	        if (Number.isNaN(what)) {
	            return "not-a-number";
	        }
	        return "unknown-number";
	    }

	    return to; // undefined, boolean, string, function

	};

	exports.areEqual = function areEqual(json1, json2) {
	    // http://json-schema.org/latest/json-schema-core.html#rfc.section.3.6

	    // Two JSON values are said to be equal if and only if:
	    // both are nulls; or
	    // both are booleans, and have the same value; or
	    // both are strings, and have the same value; or
	    // both are numbers, and have the same mathematical value; or
	    if (json1 === json2) {
	        return true;
	    }

	    var i, len;

	    // both are arrays, and:
	    if (Array.isArray(json1) && Array.isArray(json2)) {
	        // have the same number of items; and
	        if (json1.length !== json2.length) {
	            return false;
	        }
	        // items at the same index are equal according to this definition; or
	        len = json1.length;
	        for (i = 0; i < len; i++) {
	            if (!areEqual(json1[i], json2[i])) {
	                return false;
	            }
	        }
	        return true;
	    }

	    // both are objects, and:
	    if (exports.whatIs(json1) === "object" && exports.whatIs(json2) === "object") {
	        // have the same set of property names; and
	        var keys1 = Object.keys(json1);
	        var keys2 = Object.keys(json2);
	        if (!areEqual(keys1, keys2)) {
	            return false;
	        }
	        // values for a same property name are equal according to this definition.
	        len = keys1.length;
	        for (i = 0; i < len; i++) {
	            if (!areEqual(json1[keys1[i]], json2[keys1[i]])) {
	                return false;
	            }
	        }
	        return true;
	    }

	    return false;
	};

	exports.isUniqueArray = function (arr, indexes) {
	    var i, j, l = arr.length;
	    for (i = 0; i < l; i++) {
	        for (j = i + 1; j < l; j++) {
	            if (exports.areEqual(arr[i], arr[j])) {
	                if (indexes) { indexes.push(i, j); }
	                return false;
	            }
	        }
	    }
	    return true;
	};

	exports.difference = function (bigSet, subSet) {
	    var arr = [],
	        idx = bigSet.length;
	    while (idx--) {
	        if (subSet.indexOf(bigSet[idx]) === -1) {
	            arr.push(bigSet[idx]);
	        }
	    }
	    return arr;
	};

	// NOT a deep version of clone
	exports.clone = function (src) {
	    if (typeof src === "undefined") { return void 0; }
	    if (typeof src !== "object" || src === null) { return src; }
	    var res, idx;
	    if (Array.isArray(src)) {
	        res = [];
	        idx = src.length;
	        while (idx--) {
	            res[idx] = src[idx];
	        }
	    } else {
	        res = {};
	        var keys = Object.keys(src);
	        idx = keys.length;
	        while (idx--) {
	            var key = keys[idx];
	            res[key] = src[key];
	        }
	    }
	    return res;
	};

	exports.cloneDeep = function (src) {
	    var visited = [], cloned = [];
	    function cloneDeep(src) {
	        if (typeof src !== "object" || src === null) { return src; }
	        var res, idx, cidx;

	        cidx = visited.indexOf(src);
	        if (cidx !== -1) { return cloned[cidx]; }

	        visited.push(src);
	        if (Array.isArray(src)) {
	            res = [];
	            cloned.push(res);
	            idx = src.length;
	            while (idx--) {
	                res[idx] = cloneDeep(src[idx]);
	            }
	        } else {
	            res = {};
	            cloned.push(res);
	            var keys = Object.keys(src);
	            idx = keys.length;
	            while (idx--) {
	                var key = keys[idx];
	                res[key] = cloneDeep(src[key]);
	            }
	        }
	        return res;
	    }
	    return cloneDeep(src);
	};

	/*
	  following function comes from punycode.js library
	  see: https://github.com/bestiejs/punycode.js
	*/
	/*jshint -W016*/
	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	exports.ucs2decode = function (string) {
	    var output = [],
	        counter = 0,
	        length = string.length,
	        value,
	        extra;
	    while (counter < length) {
	        value = string.charCodeAt(counter++);
	        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
	            // high surrogate, and there is a next character
	            extra = string.charCodeAt(counter++);
	            if ((extra & 0xFC00) == 0xDC00) { // low surrogate
	                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
	            } else {
	                // unmatched surrogate; only append this code unit, in case the next
	                // code unit is the high surrogate of a surrogate pair
	                output.push(value);
	                counter--;
	            }
	        } else {
	            output.push(value);
	        }
	    }
	    return output;
	};
	/*jshint +W016*/


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module exports.
	 */

	module.exports = deprecate;

	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */

	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	}

	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */

	function config (name) {
	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
	  try {
	    if (!global.localStorage) return false;
	  } catch (_) {
	    return false;
	  }
	  var val = global.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var Schema = __webpack_require__(152);
	module.exports = new Schema({
	    explicit: [
	        __webpack_require__(231),
	        __webpack_require__(232),
	        __webpack_require__(233)
	    ]
	});
	//# sourceMappingURL=failsafe.js.map

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var Type = __webpack_require__(193);
	function resolveYamlNull(data) {
	    if (null === data) {
	        return true;
	    }
	    var max = data.length;
	    return (max === 1 && data === '~') ||
	        (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
	}
	function constructYamlNull() {
	    return null;
	}
	function isNull(object) {
	    return null === object;
	}
	module.exports = new Type('tag:yaml.org,2002:null', {
	    kind: 'scalar',
	    resolve: resolveYamlNull,
	    construct: constructYamlNull,
	    predicate: isNull,
	    represent: {
	        canonical: function () { return '~'; },
	        lowercase: function () { return 'null'; },
	        uppercase: function () { return 'NULL'; },
	        camelcase: function () { return 'Null'; }
	    },
	    defaultStyle: 'lowercase'
	});
	//# sourceMappingURL=null.js.map

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';
	var Type = __webpack_require__(193);
	function resolveYamlBoolean(data) {
	    if (null === data) {
	        return false;
	    }
	    var max = data.length;
	    return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
	        (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
	}
	function constructYamlBoolean(data) {
	    return data === 'true' ||
	        data === 'True' ||
	        data === 'TRUE';
	}
	function isBoolean(object) {
	    return '[object Boolean]' === Object.prototype.toString.call(object);
	}
	module.exports = new Type('tag:yaml.org,2002:bool', {
	    kind: 'scalar',
	    resolve: resolveYamlBoolean,
	    construct: constructYamlBoolean,
	    predicate: isBoolean,
	    represent: {
	        lowercase: function (object) { return object ? 'true' : 'false'; },
	        uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
	        camelcase: function (object) { return object ? 'True' : 'False'; }
	    },
	    defaultStyle: 'lowercase'
	});
	//# sourceMappingURL=bool.js.map

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var common = __webpack_require__(110);
	var Type = __webpack_require__(193);
	function isHexCode(c) {
	    return ((0x30 <= c) && (c <= 0x39)) ||
	        ((0x41 <= c) && (c <= 0x46)) ||
	        ((0x61 <= c) && (c <= 0x66));
	}
	function isOctCode(c) {
	    return ((0x30 <= c) && (c <= 0x37));
	}
	function isDecCode(c) {
	    return ((0x30 <= c) && (c <= 0x39));
	}
	function resolveYamlInteger(data) {
	    if (null === data) {
	        return false;
	    }
	    var max = data.length, index = 0, hasDigits = false, ch;
	    if (!max) {
	        return false;
	    }
	    ch = data[index];
	    if (ch === '-' || ch === '+') {
	        ch = data[++index];
	    }
	    if (ch === '0') {
	        if (index + 1 === max) {
	            return true;
	        }
	        ch = data[++index];
	        if (ch === 'b') {
	            index++;
	            for (; index < max; index++) {
	                ch = data[index];
	                if (ch === '_') {
	                    continue;
	                }
	                if (ch !== '0' && ch !== '1') {
	                    return false;
	                }
	                hasDigits = true;
	            }
	            return hasDigits;
	        }
	        if (ch === 'x') {
	            index++;
	            for (; index < max; index++) {
	                ch = data[index];
	                if (ch === '_') {
	                    continue;
	                }
	                if (!isHexCode(data.charCodeAt(index))) {
	                    return false;
	                }
	                hasDigits = true;
	            }
	            return hasDigits;
	        }
	        for (; index < max; index++) {
	            ch = data[index];
	            if (ch === '_') {
	                continue;
	            }
	            if (!isOctCode(data.charCodeAt(index))) {
	                return false;
	            }
	            hasDigits = true;
	        }
	        return hasDigits;
	    }
	    for (; index < max; index++) {
	        ch = data[index];
	        if (ch === '_') {
	            continue;
	        }
	        if (ch === ':') {
	            break;
	        }
	        if (!isDecCode(data.charCodeAt(index))) {
	            return false;
	        }
	        hasDigits = true;
	    }
	    if (!hasDigits) {
	        return false;
	    }
	    if (ch !== ':') {
	        return true;
	    }
	    return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
	}
	function constructYamlInteger(data) {
	    var value = data, sign = 1, ch, base, digits = [];
	    if (value.indexOf('_') !== -1) {
	        value = value.replace(/_/g, '');
	    }
	    ch = value[0];
	    if (ch === '-' || ch === '+') {
	        if (ch === '-') {
	            sign = -1;
	        }
	        value = value.slice(1);
	        ch = value[0];
	    }
	    if ('0' === value) {
	        return 0;
	    }
	    if (ch === '0') {
	        if (value[1] === 'b') {
	            return sign * parseInt(value.slice(2), 2);
	        }
	        if (value[1] === 'x') {
	            return sign * parseInt(value, 16);
	        }
	        return sign * parseInt(value, 8);
	    }
	    if (value.indexOf(':') !== -1) {
	        value.split(':').forEach(function (v) {
	            digits.unshift(parseInt(v, 10));
	        });
	        value = 0;
	        base = 1;
	        digits.forEach(function (d) {
	            value += (d * base);
	            base *= 60;
	        });
	        return sign * value;
	    }
	    return sign * parseInt(value, 10);
	}
	function isInteger(object) {
	    return ('[object Number]' === Object.prototype.toString.call(object)) &&
	        (0 === object % 1 && !common.isNegativeZero(object));
	}
	module.exports = new Type('tag:yaml.org,2002:int', {
	    kind: 'scalar',
	    resolve: resolveYamlInteger,
	    construct: constructYamlInteger,
	    predicate: isInteger,
	    represent: {
	        binary: function (object) { return '0b' + object.toString(2); },
	        octal: function (object) { return '0' + object.toString(8); },
	        decimal: function (object) { return object.toString(10); },
	        hexadecimal: function (object) { return '0x' + object.toString(16).toUpperCase(); }
	    },
	    defaultStyle: 'decimal',
	    styleAliases: {
	        binary: [2, 'bin'],
	        octal: [8, 'oct'],
	        decimal: [10, 'dec'],
	        hexadecimal: [16, 'hex']
	    }
	});
	//# sourceMappingURL=int.js.map

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var common = __webpack_require__(110);
	var Type = __webpack_require__(193);
	var YAML_FLOAT_PATTERN = new RegExp('^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' +
	    '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' +
	    '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
	    '|[-+]?\\.(?:inf|Inf|INF)' +
	    '|\\.(?:nan|NaN|NAN))$');
	function resolveYamlFloat(data) {
	    if (null === data) {
	        return false;
	    }
	    var value, sign, base, digits;
	    if (!YAML_FLOAT_PATTERN.test(data)) {
	        return false;
	    }
	    return true;
	}
	function constructYamlFloat(data) {
	    var value, sign, base, digits;
	    value = data.replace(/_/g, '').toLowerCase();
	    sign = '-' === value[0] ? -1 : 1;
	    digits = [];
	    if (0 <= '+-'.indexOf(value[0])) {
	        value = value.slice(1);
	    }
	    if ('.inf' === value) {
	        return (1 === sign) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
	    }
	    else if ('.nan' === value) {
	        return NaN;
	    }
	    else if (0 <= value.indexOf(':')) {
	        value.split(':').forEach(function (v) {
	            digits.unshift(parseFloat(v, 10));
	        });
	        value = 0.0;
	        base = 1;
	        digits.forEach(function (d) {
	            value += d * base;
	            base *= 60;
	        });
	        return sign * value;
	    }
	    return sign * parseFloat(value, 10);
	}
	function representYamlFloat(object, style) {
	    if (isNaN(object)) {
	        switch (style) {
	            case 'lowercase':
	                return '.nan';
	            case 'uppercase':
	                return '.NAN';
	            case 'camelcase':
	                return '.NaN';
	        }
	    }
	    else if (Number.POSITIVE_INFINITY === object) {
	        switch (style) {
	            case 'lowercase':
	                return '.inf';
	            case 'uppercase':
	                return '.INF';
	            case 'camelcase':
	                return '.Inf';
	        }
	    }
	    else if (Number.NEGATIVE_INFINITY === object) {
	        switch (style) {
	            case 'lowercase':
	                return '-.inf';
	            case 'uppercase':
	                return '-.INF';
	            case 'camelcase':
	                return '-.Inf';
	        }
	    }
	    else if (common.isNegativeZero(object)) {
	        return '-0.0';
	    }
	    return object.toString(10);
	}
	function isFloat(object) {
	    return ('[object Number]' === Object.prototype.toString.call(object)) &&
	        (0 !== object % 1 || common.isNegativeZero(object));
	}
	module.exports = new Type('tag:yaml.org,2002:float', {
	    kind: 'scalar',
	    resolve: resolveYamlFloat,
	    construct: constructYamlFloat,
	    predicate: isFloat,
	    represent: representYamlFloat,
	    defaultStyle: 'lowercase'
	});
	//# sourceMappingURL=float.js.map

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.

	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = Buffer.isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(92).Buffer))

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var hexTable = (function () {
	    var array = new Array(256);
	    for (var i = 0; i < 256; ++i) {
	        array[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();
	    }

	    return array;
	}());

	exports.arrayToObject = function (source, options) {
	    var obj = options.plainObjects ? Object.create(null) : {};
	    for (var i = 0; i < source.length; ++i) {
	        if (typeof source[i] !== 'undefined') {
	            obj[i] = source[i];
	        }
	    }

	    return obj;
	};

	exports.merge = function (target, source, options) {
	    if (!source) {
	        return target;
	    }

	    if (typeof source !== 'object') {
	        if (Array.isArray(target)) {
	            target.push(source);
	        } else if (typeof target === 'object') {
	            target[source] = true;
	        } else {
	            return [target, source];
	        }

	        return target;
	    }

	    if (typeof target !== 'object') {
	        return [target].concat(source);
	    }

	    var mergeTarget = target;
	    if (Array.isArray(target) && !Array.isArray(source)) {
	        mergeTarget = exports.arrayToObject(target, options);
	    }

		return Object.keys(source).reduce(function (acc, key) {
	        var value = source[key];

	        if (Object.prototype.hasOwnProperty.call(acc, key)) {
	            acc[key] = exports.merge(acc[key], value, options);
	        } else {
	            acc[key] = value;
	        }
			return acc;
	    }, mergeTarget);
	};

	exports.decode = function (str) {
	    try {
	        return decodeURIComponent(str.replace(/\+/g, ' '));
	    } catch (e) {
	        return str;
	    }
	};

	exports.encode = function (str) {
	    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
	    // It has been adapted here for stricter adherence to RFC 3986
	    if (str.length === 0) {
	        return str;
	    }

	    var string = typeof str === 'string' ? str : String(str);

	    var out = '';
	    for (var i = 0; i < string.length; ++i) {
	        var c = string.charCodeAt(i);

	        if (
	            c === 0x2D || // -
	            c === 0x2E || // .
	            c === 0x5F || // _
	            c === 0x7E || // ~
	            (c >= 0x30 && c <= 0x39) || // 0-9
	            (c >= 0x41 && c <= 0x5A) || // a-z
	            (c >= 0x61 && c <= 0x7A) // A-Z
	        ) {
	            out += string.charAt(i);
	            continue;
	        }

	        if (c < 0x80) {
	            out = out + hexTable[c];
	            continue;
	        }

	        if (c < 0x800) {
	            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }

	        if (c < 0xD800 || c >= 0xE000) {
	            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }

	        i += 1;
	        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
	        out += (hexTable[0xF0 | (c >> 18)] + hexTable[0x80 | ((c >> 12) & 0x3F)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
	    }

	    return out;
	};

	exports.compact = function (obj, references) {
	    if (typeof obj !== 'object' || obj === null) {
	        return obj;
	    }

	    var refs = references || [];
	    var lookup = refs.indexOf(obj);
	    if (lookup !== -1) {
	        return refs[lookup];
	    }

	    refs.push(obj);

	    if (Array.isArray(obj)) {
	        var compacted = [];

	        for (var i = 0; i < obj.length; ++i) {
	            if (typeof obj[i] !== 'undefined') {
	                compacted.push(obj[i]);
	            }
	        }

	        return compacted;
	    }

	    var keys = Object.keys(obj);
	    for (var j = 0; j < keys.length; ++j) {
	        var key = keys[j];
	        obj[key] = exports.compact(obj[key], refs);
	    }

	    return obj;
	};

	exports.isRegExp = function (obj) {
	    return Object.prototype.toString.call(obj) === '[object RegExp]';
	};

	exports.isBuffer = function (obj) {
	    if (obj === null || typeof obj === 'undefined') {
	        return false;
	    }

	    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
	};


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./ar": 234,
		"./ar.js": 234,
		"./bn": 235,
		"./bn.js": 235,
		"./de": 236,
		"./de.js": 236,
		"./es": 237,
		"./es.js": 237,
		"./fr": 238,
		"./fr.js": 238,
		"./hi": 239,
		"./hi.js": 239,
		"./it": 240,
		"./it.js": 240,
		"./ja": 241,
		"./ja.js": 241,
		"./ko": 242,
		"./ko.js": 242,
		"./pt": 243,
		"./pt.js": 243,
		"./ru": 244,
		"./ru.js": 244,
		"./zh-cn": 245,
		"./zh-cn.js": 245,
		"./zh-tw": 246,
		"./zh-tw.js": 246
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.id = 220;
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = __webpack_require__(254);
	exports.Stream = __webpack_require__(174);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(253);
	exports.Duplex = __webpack_require__(255);
	exports.Transform = __webpack_require__(256);
	exports.PassThrough = __webpack_require__(257);
	if (!process.browser && process.env.READABLE_STREAM === 'disable') {
	  module.exports = __webpack_require__(174);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59)))

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(253)


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(255)


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(256)


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(257)


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  "use strict";
	  var xml2js;

	  xml2js = __webpack_require__(197);

	  exports.stripBOM = function(str) {
	    if (str[0] === '\uFEFF') {
	      return str.substring(1);
	    } else {
	      return str;
	    }
	  };

	}).call(this);


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  "use strict";
	  var prefixMatch;

	  prefixMatch = new RegExp(/(?!xmlns)^.*:/);

	  exports.normalize = function(str) {
	    return str.toLowerCase();
	  };

	  exports.firstCharLowerCase = function(str) {
	    return str.charAt(0).toLowerCase() + str.slice(1);
	  };

	  exports.stripPrefix = function(str) {
	    return str.replace(prefixMatch, '');
	  };

	  exports.parseNumbers = function(str) {
	    if (!isNaN(str)) {
	      str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
	    }
	    return str;
	  };

	  exports.parseBooleans = function(str) {
	    if (/^(?:true|false)$/i.test(str)) {
	      str = str.toLowerCase() === 'true';
	    }
	    return str;
	  };

	}).call(this);


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 4.2.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	var stringToPath = __webpack_require__(262);

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = isKey(path, object) ? [path] : castPath(path);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[path[index++]];
	  }
	  return (index && index == length) ? object : undefined;
	}

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value) {
	  return isArray(value) ? value : stringToPath(value);
	}

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol') {
	    return true;
	  }
	  return !isArray(value) &&
	    (isSymbol(value) || reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	      (object != null && value in Object(object)));
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @type {Function}
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified,
	 *  else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified,
	 *  else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is used in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	module.exports = get;


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {

	    INVALID_TYPE:                           "Expected type {0} but found type {1}",
	    INVALID_FORMAT:                         "Object didn't pass validation for format {0}: {1}",
	    ENUM_MISMATCH:                          "No enum match for: {0}",
	    ANY_OF_MISSING:                         "Data does not match any schemas from 'anyOf'",
	    ONE_OF_MISSING:                         "Data does not match any schemas from 'oneOf'",
	    ONE_OF_MULTIPLE:                        "Data is valid against more than one schema from 'oneOf'",
	    NOT_PASSED:                             "Data matches schema from 'not'",

	    // Array errors
	    ARRAY_LENGTH_SHORT:                     "Array is too short ({0}), minimum {1}",
	    ARRAY_LENGTH_LONG:                      "Array is too long ({0}), maximum {1}",
	    ARRAY_UNIQUE:                           "Array items are not unique (indexes {0} and {1})",
	    ARRAY_ADDITIONAL_ITEMS:                 "Additional items not allowed",

	    // Numeric errors
	    MULTIPLE_OF:                            "Value {0} is not a multiple of {1}",
	    MINIMUM:                                "Value {0} is less than minimum {1}",
	    MINIMUM_EXCLUSIVE:                      "Value {0} is equal or less than exclusive minimum {1}",
	    MAXIMUM:                                "Value {0} is greater than maximum {1}",
	    MAXIMUM_EXCLUSIVE:                      "Value {0} is equal or greater than exclusive maximum {1}",

	    // Object errors
	    OBJECT_PROPERTIES_MINIMUM:              "Too few properties defined ({0}), minimum {1}",
	    OBJECT_PROPERTIES_MAXIMUM:              "Too many properties defined ({0}), maximum {1}",
	    OBJECT_MISSING_REQUIRED_PROPERTY:       "Missing required property: {0}",
	    OBJECT_ADDITIONAL_PROPERTIES:           "Additional properties not allowed: {0}",
	    OBJECT_DEPENDENCY_KEY:                  "Dependency failed - key must exist: {0} (due to key: {1})",

	    // String errors
	    MIN_LENGTH:                             "String is too short ({0} chars), minimum {1}",
	    MAX_LENGTH:                             "String is too long ({0} chars), maximum {1}",
	    PATTERN:                                "String does not match pattern {0}: {1}",

	    // Schema validation errors
	    KEYWORD_TYPE_EXPECTED:                  "Keyword '{0}' is expected to be of type '{1}'",
	    KEYWORD_UNDEFINED_STRICT:               "Keyword '{0}' must be defined in strict mode",
	    KEYWORD_UNEXPECTED:                     "Keyword '{0}' is not expected to appear in the schema",
	    KEYWORD_MUST_BE:                        "Keyword '{0}' must be {1}",
	    KEYWORD_DEPENDENCY:                     "Keyword '{0}' requires keyword '{1}'",
	    KEYWORD_PATTERN:                        "Keyword '{0}' is not a valid RegExp pattern: {1}",
	    KEYWORD_VALUE_TYPE:                     "Each element of keyword '{0}' array must be a '{1}'",
	    UNKNOWN_FORMAT:                         "There is no validation function for format '{0}'",
	    CUSTOM_MODE_FORCE_PROPERTIES:           "{0} must define at least one property if present",

	    // Remote errors
	    REF_UNRESOLVED:                         "Reference has not been resolved during compilation: {0}",
	    UNRESOLVABLE_REFERENCE:                 "Reference could not be resolved: {0}",
	    SCHEMA_NOT_REACHABLE:                   "Validator was not able to read schema with uri: {0}",
	    SCHEMA_TYPE_EXPECTED:                   "Schema is expected to be of type 'object'",
	    SCHEMA_NOT_AN_OBJECT:                   "Schema is not an object: {0}",
	    ASYNC_TIMEOUT:                          "{0} asynchronous task(s) have timed out after {1} ms",
	    PARENT_SCHEMA_VALIDATION_FAILED:        "Schema failed to validate against its parent schema, see inner errors for details.",
	    REMOTE_NOT_VALID:                       "Remote reference didn't compile successfully: {0}"

	};


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var Type = __webpack_require__(193);
	module.exports = new Type('tag:yaml.org,2002:str', {
	    kind: 'scalar',
	    construct: function (data) { return null !== data ? data : ''; }
	});
	//# sourceMappingURL=str.js.map

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var Type = __webpack_require__(193);
	module.exports = new Type('tag:yaml.org,2002:seq', {
	    kind: 'sequence',
	    construct: function (data) { return null !== data ? data : []; }
	});
	//# sourceMappingURL=seq.js.map

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var Type = __webpack_require__(193);
	module.exports = new Type('tag:yaml.org,2002:map', {
	    kind: 'mapping',
	    construct: function (data) { return null !== data ? data : {}; }
	});
	//# sourceMappingURL=map.js.map

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @preserve date-and-time.js locale configuration
	 * @preserve Arabic (ar)
	 * @preserve It is using moment.js locale configuration as a reference.
	 */
	(function (global) {
	    'use strict';

	    var locale = function (date) {
	        var num = ['', '', '', '', '', '', '', '', '', ''],
	            map = { '': 0, '': 1, '': 2, '': 3, '': 4, '': 5, '': 6, '': 7, '': 8, '': 9 };

	        date.setLocales('ar', {
	            MMMM: ['  ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '  ', '  ', '  '],
	            MMM: ['  ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '  ', '  ', '  '],
	            dddd: ['', '', '', '', '', '', ''],
	            ddd: ['', '', '', '', '', '', ''],
	            dd: ['', '', '', '', '', '', ''],
	            A: ['', ''],
	            formats: {
	                post: function (str) {
	                    return str.replace(/\d/g, function (i) {
	                        return num[i | 0];
	                    });
	                }
	            },
	            parsers: {
	                pre: function (str) {
	                    return str.replace(/[]/g, function (i) {
	                        return '' + map[i];
	                    });
	                }
	            }
	        });
	    };

	    if (typeof module === 'object' && typeof module.exports === 'object') {
	        locale(__webpack_require__(196));
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(196)], __WEBPACK_AMD_DEFINE_FACTORY__ = (locale), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        locale(global.date);
	    }

	}(this));



/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @preserve date-and-time.js locale configuration
	 * @preserve Bengali (bn)
	 * @preserve It is using moment.js locale configuration as a reference.
	 */
	(function (global) {
	    'use strict';

	    var locale = function (date) {
	        date.setLocales('bn', {
	            MMMM: ['', '', '', '', '', '', '', '', '', '', '', ''],
	            MMM: ['', '', '', '', '', '', '', '', '', '', '', ''],
	            dddd: ['', '', '', '', '', '', ''],
	            ddd: ['', '', '', '', '', '', ''],
	            dd: ['', '', '', '', '', '', ''],
	            A: ['', '', '', ''],
	            formats: {
	                A: function (d) {
	                    var h = d.getHours();
	                    if (h < 4) {
	                        return this.A[0];   // 
	                    } else if (h < 10) {
	                        return this.A[1];   // 
	                    } else if (h < 17) {
	                        return this.A[2];   // 
	                    } else if (h < 20) {
	                        return this.A[3];   // 
	                    }
	                    return this.A[0];       // 
	                }
	            },
	            parsers: {
	                h: function (h, a) {
	                    if (a < 1) {
	                        return h < 4 || h > 11 ? h : h + 12;    // 
	                    } else if (a < 2) {
	                        return h;                               // 
	                    } else if (a < 3) {
	                        return h > 9 ? h : h + 12;              // 
	                    }
	                    return h + 12;                              // 
	                }
	            }
	        });
	    };

	    if (typeof module === 'object' && typeof module.exports === 'object') {
	        locale(__webpack_require__(196));
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(196)], __WEBPACK_AMD_DEFINE_FACTORY__ = (locale), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        locale(global.date);
	    }

	}(this));



/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @preserve date-and-time.js locale configuration
	 * @preserve German (de)
	 * @preserve It is using moment.js locale configuration as a reference.
	 */
	(function (global) {
	    'use strict';

	    var locale = function (date) {
	        date.setLocales('de', {
	            MMMM: ['Januar', 'Februar', 'Mrz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
	            MMM: ['Jan.', 'Febr.', 'Mrz.', 'Apr.', 'Mai', 'Jun.', 'Jul.', 'Aug.', 'Sept.', 'Okt.', 'Nov.', 'Dez.'],
	            dddd: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
	            ddd: ['So.', 'Mo.', 'Di.', 'Mi.', 'Do.', 'Fr.', 'Sa.'],
	            dd: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
	            A: ['Uhr nachmittags', 'Uhr morgens']
	        });
	    };

	    if (typeof module === 'object' && typeof module.exports === 'object') {
	        locale(__webpack_require__(196));
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(196)], __WEBPACK_AMD_DEFINE_FACTORY__ = (locale), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        locale(global.date);
	    }

	}(this));



/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @preserve date-and-time.js locale configuration
	 * @preserve Spanish (es)
	 * @preserve It is using moment.js locale configuration as a reference.
	 */
	(function (global) {
	    'use strict';

	    var locale = function (date) {
	        date.setLocales('es', {
	            MMMM: ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre'],
	            MMM: ['ene.', 'feb.', 'mar.', 'abr.', 'may.', 'jun.', 'jul.', 'ago.', 'sep.', 'oct.', 'nov.', 'dic.'],
	            dddd: ['domingo', 'lunes', 'martes', 'mircoles', 'jueves', 'viernes', 'sbado'],
	            ddd: ['dom.', 'lun.', 'mar.', 'mi.', 'jue.', 'vie.', 'sb.'],
	            dd: ['do', 'lu', 'ma', 'mi', 'ju', 'vi', 's'],
	            A: ['de la maana', 'de la tarde', 'de la noche'],
	            formats: {
	                A: function (d) {
	                    var h = d.getHours();
	                    if (h < 12) {
	                        return this.A[0];   // de la maana
	                    } else if (h < 19) {
	                        return this.A[1];   // de la tarde
	                    }
	                    return this.A[2];       // de la noche
	                }
	            },
	            parsers: {
	                h: function (h, a) {
	                    if (a < 1) {    // de la maana
	                        return h;
	                    }
	                    return h > 11 ? h : h + 12; // de la tarde, de la noche
	                }
	            }
	        });
	    };

	    if (typeof module === 'object' && typeof module.exports === 'object') {
	        locale(__webpack_require__(196));
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(196)], __WEBPACK_AMD_DEFINE_FACTORY__ = (locale), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        locale(global.date);
	    }

	}(this));



/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @preserve date-and-time.js locale configuration
	 * @preserve French (fr)
	 * @preserve It is using moment.js locale configuration as a reference.
	 */
	(function (global) {
	    'use strict';

	    var locale = function (date) {
	        date.setLocales('fr', {
	            MMMM: ['janvier', 'fvrier', 'mars', 'avril', 'mai', 'juin', 'juillet', 'aot', 'septembre', 'octobre', 'novembre', 'dcembre'],
	            MMM: ['janv.', 'fvr.', 'mars', 'avr.', 'mai', 'juin', 'juil.', 'aot', 'sept.', 'oct.', 'nov.', 'dc.'],
	            dddd: ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi'],
	            ddd: ['dim.', 'lun.', 'mar.', 'mer.', 'jeu.', 'ven.', 'sam.'],
	            dd: ['Di', 'Lu', 'Ma', 'Me', 'Je', 'Ve', 'Sa'],
	            A: ['matin', 'l\'aprs-midi']
	        });
	    };

	    if (typeof module === 'object' && typeof module.exports === 'object') {
	        locale(__webpack_require__(196));
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(196)], __WEBPACK_AMD_DEFINE_FACTORY__ = (locale), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        locale(global.date);
	    }

	}(this));



/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @preserve date-and-time.js locale configuration
	 * @preserve Hindi (hi)
	 * @preserve It is using moment.js locale configuration as a reference.
	 */
	(function (global) {
	    'use strict';

	    var locale = function (date) {
	        date.setLocales('hi', {
	            MMMM: ['', '', '', '', '', '', '', '', '', '', '', ''],
	            MMM: ['.', '.', '', '.', '', '', '.', '.', '.', '.', '.', '.'],
	            dddd: ['', '', '', '', '', '', ''],
	            ddd: ['', '', '', '', '', '', ''],
	            dd: ['', '', '', '', '', '', ''],
	            A: ['', '', '', ''],
	            formats: {
	                A: function (d) {
	                    var h = d.getHours();
	                    if (h < 4) {
	                        return this.A[0];   // 
	                    } else if (h < 10) {
	                        return this.A[1];   // 
	                    } else if (h < 17) {
	                        return this.A[2];   // 
	                    } else if (h < 20) {
	                        return this.A[3];   // 
	                    }
	                    return this.A[0];       // 
	                }
	            },
	            parsers: {
	                h: function (h, a) {
	                    if (a < 1) {
	                        return h < 4 || h > 11 ? h : h + 12;    // 
	                    } else if (a < 2) {
	                        return h;                               // 
	                    } else if (a < 3) {
	                        return h > 9 ? h : h + 12;              // 
	                    }
	                    return h + 12;                              // 
	                }
	            }
	        });
	    };

	    if (typeof module === 'object' && typeof module.exports === 'object') {
	        locale(__webpack_require__(196));
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(196)], __WEBPACK_AMD_DEFINE_FACTORY__ = (locale), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        locale(global.date);
	    }

	}(this));



/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @preserve date-and-time.js locale configuration
	 * @preserve Italian (it)
	 * @preserve It is using moment.js locale configuration as a reference.
	 */
	(function (global) {
	    'use strict';

	    var locale = function (date) {
	        date.setLocales('it', {
	            MMMM: ['gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno', 'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre'],
	            MMM: ['gen', 'feb', 'mar', 'apr', 'mag', 'giu', 'lug', 'ago', 'set', 'ott', 'nov', 'dic'],
	            dddd: ['Domenica', 'Luned', 'Marted', 'Mercoled', 'Gioved', 'Venerd', 'Sabato'],
	            ddd: ['Dom', 'Lun', 'Mar', 'Mer', 'Gio', 'Ven', 'Sab'],
	            dd: ['Do', 'Lu', 'Ma', 'Me', 'Gi', 'Ve', 'Sa'],
	            A: ['di mattina', 'di pomerrigio']
	        });
	    };

	    if (typeof module === 'object' && typeof module.exports === 'object') {
	        locale(__webpack_require__(196));
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(196)], __WEBPACK_AMD_DEFINE_FACTORY__ = (locale), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        locale(global.date);
	    }

	}(this));



/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @preserve date-and-time.js locale configuration
	 * @preserve Japanese (ja)
	 * @preserve It is using moment.js locale configuration as a reference.
	 */
	(function (global) {
	    'use strict';

	    var locale = function (date) {
	        date.setLocales('ja', {
	            MMMM: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
	            MMM: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
	            dddd: ['', '', '', '', '', '', ''],
	            ddd: ['', '', '', '', '', '', ''],
	            dd: ['', '', '', '', '', '', ''],
	            A: ['', ''],
	            formats: {
	                hh: function (d) {
	                    return ('0' + d.getHours() % 12).slice(-2);
	                },
	                h: function (d) {
	                    return d.getHours() % 12;
	                }
	            }
	        });
	    };

	    if (typeof module === 'object' && typeof module.exports === 'object') {
	        locale(__webpack_require__(196));
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(196)], __WEBPACK_AMD_DEFINE_FACTORY__ = (locale), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        locale(global.date);
	    }

	}(this));



/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @preserve date-and-time.js locale configuration
	 * @preserve Korean (ko)
	 * @preserve It is using moment.js locale configuration as a reference.
	 */
	(function (global) {
	    'use strict';

	    var locale = function (date) {
	        date.setLocales('ko', {
	            MMMM: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
	            MMM: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
	            dddd: ['', '', '', '', '', '', ''],
	            ddd: ['', '', '', '', '', '', ''],
	            dd: ['', '', '', '', '', '', ''],
	            A: ['', '']
	        });
	    };

	    if (typeof module === 'object' && typeof module.exports === 'object') {
	        locale(__webpack_require__(196));
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(196)], __WEBPACK_AMD_DEFINE_FACTORY__ = (locale), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        locale(global.date);
	    }

	}(this));



/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @preserve date-and-time.js locale configuration
	 * @preserve Portuguese (pt)
	 * @preserve It is using moment.js locale configuration as a reference.
	 */
	(function (global) {
	    'use strict';

	    var locale = function (date) {
	        date.setLocales('pt', {
	            MMMM: ['Janeiro', 'Fevereiro', 'Maro', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
	            MMM: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
	            dddd: ['Domingo', 'Segunda-Feira', 'Tera-Feira', 'Quarta-Feira', 'Quinta-Feira', 'Sexta-Feira', 'Sbado'],
	            ddd: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sb'],
	            dd: ['Dom', '2', '3', '4', '5', '6', 'Sb'],
	            A: ['da madrugada', 'da manh', 'da tarde', 'da noite'],
	            formats: {
	                A: function (d) {
	                    var h = d.getHours();
	                    if (h < 5) {
	                        return this.A[0];   // da madrugada
	                    } else if (h < 12) {
	                        return this.A[1];   // da manh
	                    } else if (h < 19) {
	                        return this.A[2];   // da tarde
	                    }
	                    return this.A[3];       // da noite
	                }
	            },
	            parsers: {
	                h: function (h, a) {
	                    if (a < 2) {    // da madrugada, da manh
	                        return h;
	                    }
	                    return h > 11 ? h : h + 12; // da tarde, da noite
	                }
	            }
	        });
	    };

	    if (typeof module === 'object' && typeof module.exports === 'object') {
	        locale(__webpack_require__(196));
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(196)], __WEBPACK_AMD_DEFINE_FACTORY__ = (locale), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        locale(global.date);
	    }

	}(this));



/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @preserve date-and-time.js locale configuration
	 * @preserve Russian (ru)
	 * @preserve It is using moment.js locale configuration as a reference.
	 */
	(function (global) {
	    'use strict';

	    var locale = function (date) {
	        date.setLocales('ru', {
	            MMMM: ['', '', '', '', '', '', '', '', '', '', '', ''],
	            MMM: ['', '', '', '', '', '', '', '', '', '', '', ''],
	            dddd: ['', '', '', '', '', '', ''],
	            ddd: ['', '', '', '', '', '', ''],
	            dd: ['', '', '', '', '', '', ''],
	            A: ['', '', '', ''],
	            formats: {
	                A: function (d) {
	                    var h = d.getHours();
	                    if (h < 4) {
	                        return this.A[0];   // 
	                    } else if (h < 12) {
	                        return this.A[1];   // 
	                    } else if (h < 17) {
	                        return this.A[2];   // 
	                    }
	                    return this.A[3];       // 
	                }
	            },
	            parsers: {
	                h: function (h, a) {
	                    if (a < 2) {    // , 
	                        return h;
	                    }
	                    return h > 11 ? h : h + 12; // , 
	                }
	            }
	        });
	    };

	    if (typeof module === 'object' && typeof module.exports === 'object') {
	        locale(__webpack_require__(196));
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(196)], __WEBPACK_AMD_DEFINE_FACTORY__ = (locale), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        locale(global.date);
	    }

	}(this));



/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @preserve date-and-time.js locale configuration
	 * @preserve Chinese (zh-cn)
	 * @preserve It is using moment.js locale configuration as a reference.
	 */
	(function (global) {
	    'use strict';

	    var locale = function (date) {
	        date.setLocales('zh-cn', {
	            MMMM: ['', '', '', '', '', '', '', '', '', '', '', ''],
	            MMM: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
	            dddd: ['', '', '', '', '', '', ''],
	            ddd: ['', '', '', '', '', '', ''],
	            dd: ['', '', '', '', '', '', ''],
	            A: ['', '', '', '', '', ''],
	            formats: {
	                A: function (d) {
	                    var hm = d.getHours() * 100 + d.getMinutes();
	                    if (hm < 600) {
	                        return this.A[0];   // 
	                    } else if (hm < 900) {
	                        return this.A[1];   // 
	                    } else if (hm < 1130) {
	                        return this.A[2];   // 
	                    } else if (hm < 1230) {
	                        return this.A[3];   // 
	                    } else if (hm < 1800) {
	                        return this.A[4];   // 
	                    }
	                    return this.A[5];       // 
	                }
	            },
	            parsers: {
	                h: function (h, a) {
	                    if (a < 4) {    // , , , 
	                        return h;
	                    }
	                    return h > 11 ? h : h + 12; // , 
	                }
	            }
	        });
	    };

	    if (typeof module === 'object' && typeof module.exports === 'object') {
	        locale(__webpack_require__(196));
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(196)], __WEBPACK_AMD_DEFINE_FACTORY__ = (locale), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        locale(global.date);
	    }

	}(this));



/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @preserve date-and-time.js locale configuration
	 * @preserve Chinese (zh-tw)
	 * @preserve It is using moment.js locale configuration as a reference.
	 */
	(function (global) {
	    'use strict';

	    var locale = function (date) {
	        date.setLocales('zh-tw', {
	            MMMM: ['', '', '', '', '', '', '', '', '', '', '', ''],
	            MMM: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
	            dddd: ['', '', '', '', '', '', ''],
	            ddd: ['', '', '', '', '', '', ''],
	            dd: ['', '', '', '', '', '', ''],
	            A: ['', '', '', '', ''],
	            formats: {
	                A: function (d) {
	                    var hm = d.getHours() * 100 + d.getMinutes();
	                    if (hm < 900) {
	                        return this.A[0];   // 
	                    } else if (hm < 1130) {
	                        return this.A[1];   // 
	                    } else if (hm < 1230) {
	                        return this.A[2];   // 
	                    } else if (hm < 1800) {
	                        return this.A[3];   // 
	                    }
	                    return this.A[4];       // 
	                }
	            },
	            parsers: {
	                h: function (h, a) {
	                    if (a < 3) {    // , , 
	                        return h;
	                    }
	                    return h > 11 ? h : h + 12; // , 
	                }
	            }
	        });
	    };

	    if (typeof module === 'object' && typeof module.exports === 'object') {
	        locale(__webpack_require__(196));
	    } else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(196)], __WEBPACK_AMD_DEFINE_FACTORY__ = (locale), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        locale(global.date);
	    }

	}(this));



/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
		"id": "http://json-schema.org/draft-04/schema#",
		"$schema": "http://json-schema.org/draft-04/schema#",
		"description": "Core schema meta-schema",
		"definitions": {
			"schemaArray": {
				"type": "array",
				"minItems": 1,
				"items": {
					"$ref": "#"
				}
			},
			"positiveInteger": {
				"type": "integer",
				"minimum": 0
			},
			"positiveIntegerDefault0": {
				"allOf": [
					{
						"$ref": "#/definitions/positiveInteger"
					},
					{
						"default": 0
					}
				]
			},
			"simpleTypes": {
				"enum": [
					"array",
					"boolean",
					"integer",
					"null",
					"number",
					"object",
					"string"
				]
			},
			"stringArray": {
				"type": "array",
				"items": {
					"type": "string"
				},
				"minItems": 1,
				"uniqueItems": true
			}
		},
		"type": "object",
		"properties": {
			"id": {
				"type": "string",
				"format": "uri"
			},
			"$schema": {
				"type": "string",
				"format": "uri"
			},
			"title": {
				"type": "string"
			},
			"description": {
				"type": "string"
			},
			"default": {},
			"multipleOf": {
				"type": "number",
				"minimum": 0,
				"exclusiveMinimum": true
			},
			"maximum": {
				"type": "number"
			},
			"exclusiveMaximum": {
				"type": "boolean",
				"default": false
			},
			"minimum": {
				"type": "number"
			},
			"exclusiveMinimum": {
				"type": "boolean",
				"default": false
			},
			"maxLength": {
				"$ref": "#/definitions/positiveInteger"
			},
			"minLength": {
				"$ref": "#/definitions/positiveIntegerDefault0"
			},
			"pattern": {
				"type": "string",
				"format": "regex"
			},
			"additionalItems": {
				"anyOf": [
					{
						"type": "boolean"
					},
					{
						"$ref": "#"
					}
				],
				"default": {}
			},
			"items": {
				"anyOf": [
					{
						"$ref": "#"
					},
					{
						"$ref": "#/definitions/schemaArray"
					}
				],
				"default": {}
			},
			"maxItems": {
				"$ref": "#/definitions/positiveInteger"
			},
			"minItems": {
				"$ref": "#/definitions/positiveIntegerDefault0"
			},
			"uniqueItems": {
				"type": "boolean",
				"default": false
			},
			"maxProperties": {
				"$ref": "#/definitions/positiveInteger"
			},
			"minProperties": {
				"$ref": "#/definitions/positiveIntegerDefault0"
			},
			"required": {
				"$ref": "#/definitions/stringArray"
			},
			"additionalProperties": {
				"anyOf": [
					{
						"type": "boolean"
					},
					{
						"$ref": "#"
					}
				],
				"default": {}
			},
			"definitions": {
				"type": "object",
				"additionalProperties": {
					"$ref": "#"
				},
				"default": {}
			},
			"properties": {
				"type": "object",
				"additionalProperties": {
					"$ref": "#"
				},
				"default": {}
			},
			"patternProperties": {
				"type": "object",
				"additionalProperties": {
					"$ref": "#"
				},
				"default": {}
			},
			"dependencies": {
				"type": "object",
				"additionalProperties": {
					"anyOf": [
						{
							"$ref": "#"
						},
						{
							"$ref": "#/definitions/stringArray"
						}
					]
				}
			},
			"enum": {
				"type": "array",
				"minItems": 1,
				"uniqueItems": true
			},
			"type": {
				"anyOf": [
					{
						"$ref": "#/definitions/simpleTypes"
					},
					{
						"type": "array",
						"items": {
							"$ref": "#/definitions/simpleTypes"
						},
						"minItems": 1,
						"uniqueItems": true
					}
				]
			},
			"format": {
				"type": "string"
			},
			"allOf": {
				"$ref": "#/definitions/schemaArray"
			},
			"anyOf": {
				"$ref": "#/definitions/schemaArray"
			},
			"oneOf": {
				"$ref": "#/definitions/schemaArray"
			},
			"not": {
				"$ref": "#"
			}
		},
		"dependencies": {
			"exclusiveMaximum": [
				"maximum"
			],
			"exclusiveMinimum": [
				"minimum"
			]
		},
		"default": {}
	};

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
		"$schema": "http://json-schema.org/draft-04/hyper-schema#",
		"id": "http://json-schema.org/draft-04/hyper-schema#",
		"title": "JSON Hyper-Schema",
		"allOf": [
			{
				"$ref": "http://json-schema.org/draft-04/schema#"
			}
		],
		"properties": {
			"additionalItems": {
				"anyOf": [
					{
						"type": "boolean"
					},
					{
						"$ref": "#"
					}
				]
			},
			"additionalProperties": {
				"anyOf": [
					{
						"type": "boolean"
					},
					{
						"$ref": "#"
					}
				]
			},
			"dependencies": {
				"additionalProperties": {
					"anyOf": [
						{
							"$ref": "#"
						},
						{
							"type": "array"
						}
					]
				}
			},
			"items": {
				"anyOf": [
					{
						"$ref": "#"
					},
					{
						"$ref": "#/definitions/schemaArray"
					}
				]
			},
			"definitions": {
				"additionalProperties": {
					"$ref": "#"
				}
			},
			"patternProperties": {
				"additionalProperties": {
					"$ref": "#"
				}
			},
			"properties": {
				"additionalProperties": {
					"$ref": "#"
				}
			},
			"allOf": {
				"$ref": "#/definitions/schemaArray"
			},
			"anyOf": {
				"$ref": "#/definitions/schemaArray"
			},
			"oneOf": {
				"$ref": "#/definitions/schemaArray"
			},
			"not": {
				"$ref": "#"
			},
			"links": {
				"type": "array",
				"items": {
					"$ref": "#/definitions/linkDescription"
				}
			},
			"fragmentResolution": {
				"type": "string"
			},
			"media": {
				"type": "object",
				"properties": {
					"type": {
						"description": "A media type, as described in RFC 2046",
						"type": "string"
					},
					"binaryEncoding": {
						"description": "A content encoding scheme, as described in RFC 2045",
						"type": "string"
					}
				}
			},
			"pathStart": {
				"description": "Instances' URIs must start with this value for this schema to apply to them",
				"type": "string",
				"format": "uri"
			}
		},
		"definitions": {
			"schemaArray": {
				"type": "array",
				"items": {
					"$ref": "#"
				}
			},
			"linkDescription": {
				"title": "Link Description Object",
				"type": "object",
				"required": [
					"href",
					"rel"
				],
				"properties": {
					"href": {
						"description": "a URI template, as defined by RFC 6570, with the addition of the $, ( and ) characters for pre-processing",
						"type": "string"
					},
					"rel": {
						"description": "relation to the target resource of the link",
						"type": "string"
					},
					"title": {
						"description": "a title for the link",
						"type": "string"
					},
					"targetSchema": {
						"description": "JSON Schema describing the link target",
						"$ref": "#"
					},
					"mediaType": {
						"description": "media type (as defined by RFC 2046) describing the link target",
						"type": "string"
					},
					"method": {
						"description": "method for requesting the target of the link (e.g. for HTTP this might be \"GET\" or \"DELETE\")",
						"type": "string"
					},
					"encType": {
						"description": "The media type in which to submit data along with the request",
						"type": "string",
						"default": "application/json"
					},
					"schema": {
						"description": "Schema describing the data to submit along with the request",
						"$ref": "#"
					}
				}
			}
		}
	};

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";

	// Use the fastest means possible to execute a task in its own turn, with
	// priority over other events including IO, animation, reflow, and redraw
	// events in browsers.
	//
	// An exception thrown by a task will permanently interrupt the processing of
	// subsequent tasks. The higher level `asap` function ensures that if an
	// exception is thrown by a task, that the task queue will continue flushing as
	// soon as possible, but if you use `rawAsap` directly, you are responsible to
	// either ensure that no exceptions are thrown from your task, or to manually
	// call `rawAsap.requestFlush` if an exception is thrown.
	module.exports = rawAsap;
	function rawAsap(task) {
	    if (!queue.length) {
	        requestFlush();
	        flushing = true;
	    }
	    // Equivalent to push, but avoids a function call.
	    queue[queue.length] = task;
	}

	var queue = [];
	// Once a flush has been requested, no further calls to `requestFlush` are
	// necessary until the next `flush` completes.
	var flushing = false;
	// `requestFlush` is an implementation-specific method that attempts to kick
	// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
	// the event queue before yielding to the browser's own event loop.
	var requestFlush;
	// The position of the next task to execute in the task queue. This is
	// preserved between calls to `flush` so that it can be resumed if
	// a task throws an exception.
	var index = 0;
	// If a task schedules additional tasks recursively, the task queue can grow
	// unbounded. To prevent memory exhaustion, the task queue will periodically
	// truncate already-completed tasks.
	var capacity = 1024;

	// The flush function processes all tasks that have been scheduled with
	// `rawAsap` unless and until one of those tasks throws an exception.
	// If a task throws an exception, `flush` ensures that its state will remain
	// consistent and will resume where it left off when called again.
	// However, `flush` does not make any arrangements to be called again if an
	// exception is thrown.
	function flush() {
	    while (index < queue.length) {
	        var currentIndex = index;
	        // Advance the index before calling the task. This ensures that we will
	        // begin flushing on the next task the task throws an error.
	        index = index + 1;
	        queue[currentIndex].call();
	        // Prevent leaking memory for long chains of recursive calls to `asap`.
	        // If we call `asap` within tasks scheduled by `asap`, the queue will
	        // grow, but to avoid an O(n) walk for every task we execute, we don't
	        // shift tasks off the queue after they have been executed.
	        // Instead, we periodically shift 1024 tasks off the queue.
	        if (index > capacity) {
	            // Manually shift all values starting at the index back to the
	            // beginning of the queue.
	            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
	                queue[scan] = queue[scan + index];
	            }
	            queue.length -= index;
	            index = 0;
	        }
	    }
	    queue.length = 0;
	    index = 0;
	    flushing = false;
	}

	// `requestFlush` is implemented using a strategy based on data collected from
	// every available SauceLabs Selenium web driver worker at time of writing.
	// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

	// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
	// have WebKitMutationObserver but not un-prefixed MutationObserver.
	// Must use `global` instead of `window` to work in both frames and web
	// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
	var BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;

	// MutationObservers are desirable because they have high priority and work
	// reliably everywhere they are implemented.
	// They are implemented in all modern browsers.
	//
	// - Android 4-4.3
	// - Chrome 26-34
	// - Firefox 14-29
	// - Internet Explorer 11
	// - iPad Safari 6-7.1
	// - iPhone Safari 7-7.1
	// - Safari 6-7
	if (typeof BrowserMutationObserver === "function") {
	    requestFlush = makeRequestCallFromMutationObserver(flush);

	// MessageChannels are desirable because they give direct access to the HTML
	// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
	// 11-12, and in web workers in many engines.
	// Although message channels yield to any queued rendering and IO tasks, they
	// would be better than imposing the 4ms delay of timers.
	// However, they do not work reliably in Internet Explorer or Safari.

	// Internet Explorer 10 is the only browser that has setImmediate but does
	// not have MutationObservers.
	// Although setImmediate yields to the browser's renderer, it would be
	// preferrable to falling back to setTimeout since it does not have
	// the minimum 4ms penalty.
	// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
	// Desktop to a lesser extent) that renders both setImmediate and
	// MessageChannel useless for the purposes of ASAP.
	// https://github.com/kriskowal/q/issues/396

	// Timers are implemented universally.
	// We fall back to timers in workers in most engines, and in foreground
	// contexts in the following browsers.
	// However, note that even this simple case requires nuances to operate in a
	// broad spectrum of browsers.
	//
	// - Firefox 3-13
	// - Internet Explorer 6-9
	// - iPad Safari 4.3
	// - Lynx 2.8.7
	} else {
	    requestFlush = makeRequestCallFromTimer(flush);
	}

	// `requestFlush` requests that the high priority event queue be flushed as
	// soon as possible.
	// This is useful to prevent an error thrown in a task from stalling the event
	// queue if the exception handled by Node.jss
	// `process.on("uncaughtException")` or by a domain.
	rawAsap.requestFlush = requestFlush;

	// To request a high priority event, we induce a mutation observer by toggling
	// the text of a text node between "1" and "-1".
	function makeRequestCallFromMutationObserver(callback) {
	    var toggle = 1;
	    var observer = new BrowserMutationObserver(callback);
	    var node = document.createTextNode("");
	    observer.observe(node, {characterData: true});
	    return function requestCall() {
	        toggle = -toggle;
	        node.data = toggle;
	    };
	}

	// The message channel technique was discovered by Malte Ubl and was the
	// original foundation for this library.
	// http://www.nonblocking.io/2011/06/windownexttick.html

	// Safari 6.0.5 (at least) intermittently fails to create message ports on a
	// page's first load. Thankfully, this version of Safari supports
	// MutationObservers, so we don't need to fall back in that case.

	// function makeRequestCallFromMessageChannel(callback) {
	//     var channel = new MessageChannel();
	//     channel.port1.onmessage = callback;
	//     return function requestCall() {
	//         channel.port2.postMessage(0);
	//     };
	// }

	// For reasons explained above, we are also unable to use `setImmediate`
	// under any circumstances.
	// Even if we were, there is another bug in Internet Explorer 10.
	// It is not sufficient to assign `setImmediate` to `requestFlush` because
	// `setImmediate` must be called *by name* and therefore must be wrapped in a
	// closure.
	// Never forget.

	// function makeRequestCallFromSetImmediate(callback) {
	//     return function requestCall() {
	//         setImmediate(callback);
	//     };
	// }

	// Safari 6.0 has a problem where timers will get lost while the user is
	// scrolling. This problem does not impact ASAP because Safari 6.0 supports
	// mutation observers, so that implementation is used instead.
	// However, if we ever elect to use timers in Safari, the prevalent work-around
	// is to add a scroll event listener that calls for a flush.

	// `setTimeout` does not call the passed callback if the delay is less than
	// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
	// even then.

	function makeRequestCallFromTimer(callback) {
	    return function requestCall() {
	        // We dispatch a timeout with a specified delay of 0 for engines that
	        // can reliably accommodate that request. This will usually be snapped
	        // to a 4 milisecond delay, but once we're flushing, there's no delay
	        // between events.
	        var timeoutHandle = setTimeout(handleTimer, 0);
	        // However, since this timer gets frequently dropped in Firefox
	        // workers, we enlist an interval handle that will try to fire
	        // an event 20 times per second until it succeeds.
	        var intervalHandle = setInterval(handleTimer, 50);

	        function handleTimer() {
	            // Whichever timer succeeds will cancel both timers and
	            // execute the callback.
	            clearTimeout(timeoutHandle);
	            clearInterval(intervalHandle);
	            callback();
	        }
	    };
	}

	// This is for `asap.js` only.
	// Its name will be periodically randomized to break any code that depends on
	// its existence.
	rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

	// ASAP was originally a nextTick shim included in Q. This was factored out
	// into this ASAP package. It was later adapted to RSVP which made further
	// amendments. These decisions, particularly to marginalize MessageChannel and
	// to capture the MutationObserver implementation in a closure, were integrated
	// back into ASAP proper.
	// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// rawAsap provides everything we need except exception management.
	var rawAsap = __webpack_require__(249);
	// RawTasks are recycled to reduce GC churn.
	var freeTasks = [];
	// We queue errors to ensure they are thrown in right order (FIFO).
	// Array-as-queue is good enough here, since we are just dealing with exceptions.
	var pendingErrors = [];
	var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

	function throwFirstError() {
	    if (pendingErrors.length) {
	        throw pendingErrors.shift();
	    }
	}

	/**
	 * Calls a task as soon as possible after returning, in its own event, with priority
	 * over other events like animation, reflow, and repaint. An error thrown from an
	 * event will not interrupt, nor even substantially slow down the processing of
	 * other events, but will be rather postponed to a lower priority event.
	 * @param {{call}} task A callable object, typically a function that takes no
	 * arguments.
	 */
	module.exports = asap;
	function asap(task) {
	    var rawTask;
	    if (freeTasks.length) {
	        rawTask = freeTasks.pop();
	    } else {
	        rawTask = new RawTask();
	    }
	    rawTask.task = task;
	    rawAsap(rawTask);
	}

	// We wrap tasks with recyclable task objects.  A task object implements
	// `call`, just like a function.
	function RawTask() {
	    this.task = null;
	}

	// The sole purpose of wrapping the task is to catch the exception and recycle
	// the task object after its single use.
	RawTask.prototype.call = function () {
	    try {
	        this.task.call();
	    } catch (error) {
	        if (asap.onerror) {
	            // This hook exists purely for testing purposes.
	            // Its name will be periodically randomized to break any code that
	            // depends on its existence.
	            asap.onerror(error);
	        } else {
	            // In a web browser, exceptions are not fatal. However, to avoid
	            // slowing down the queue of pending tasks, we rethrow the error in a
	            // lower priority turn.
	            pendingErrors.push(error);
	            requestErrorThrow();
	        }
	    } finally {
	        this.task = null;
	        freeTasks[freeTasks.length] = this;
	    }
	};


/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	var nextTick = __webpack_require__(324).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _toDate = __webpack_require__(263);

	var _toDate2 = _interopRequireDefault(_toDate);

	var _toFloat = __webpack_require__(264);

	var _toFloat2 = _interopRequireDefault(_toFloat);

	var _toInt = __webpack_require__(265);

	var _toInt2 = _interopRequireDefault(_toInt);

	var _toBoolean = __webpack_require__(266);

	var _toBoolean2 = _interopRequireDefault(_toBoolean);

	var _equals = __webpack_require__(267);

	var _equals2 = _interopRequireDefault(_equals);

	var _contains = __webpack_require__(268);

	var _contains2 = _interopRequireDefault(_contains);

	var _matches = __webpack_require__(269);

	var _matches2 = _interopRequireDefault(_matches);

	var _isEmail = __webpack_require__(270);

	var _isEmail2 = _interopRequireDefault(_isEmail);

	var _isURL = __webpack_require__(271);

	var _isURL2 = _interopRequireDefault(_isURL);

	var _isMACAddress = __webpack_require__(272);

	var _isMACAddress2 = _interopRequireDefault(_isMACAddress);

	var _isIP = __webpack_require__(273);

	var _isIP2 = _interopRequireDefault(_isIP);

	var _isFQDN = __webpack_require__(274);

	var _isFQDN2 = _interopRequireDefault(_isFQDN);

	var _isBoolean = __webpack_require__(275);

	var _isBoolean2 = _interopRequireDefault(_isBoolean);

	var _isAlpha = __webpack_require__(276);

	var _isAlpha2 = _interopRequireDefault(_isAlpha);

	var _isAlphanumeric = __webpack_require__(277);

	var _isAlphanumeric2 = _interopRequireDefault(_isAlphanumeric);

	var _isNumeric = __webpack_require__(278);

	var _isNumeric2 = _interopRequireDefault(_isNumeric);

	var _isLowercase = __webpack_require__(279);

	var _isLowercase2 = _interopRequireDefault(_isLowercase);

	var _isUppercase = __webpack_require__(280);

	var _isUppercase2 = _interopRequireDefault(_isUppercase);

	var _isAscii = __webpack_require__(281);

	var _isAscii2 = _interopRequireDefault(_isAscii);

	var _isFullWidth = __webpack_require__(282);

	var _isFullWidth2 = _interopRequireDefault(_isFullWidth);

	var _isHalfWidth = __webpack_require__(283);

	var _isHalfWidth2 = _interopRequireDefault(_isHalfWidth);

	var _isVariableWidth = __webpack_require__(284);

	var _isVariableWidth2 = _interopRequireDefault(_isVariableWidth);

	var _isMultibyte = __webpack_require__(285);

	var _isMultibyte2 = _interopRequireDefault(_isMultibyte);

	var _isSurrogatePair = __webpack_require__(286);

	var _isSurrogatePair2 = _interopRequireDefault(_isSurrogatePair);

	var _isInt = __webpack_require__(287);

	var _isInt2 = _interopRequireDefault(_isInt);

	var _isFloat = __webpack_require__(288);

	var _isFloat2 = _interopRequireDefault(_isFloat);

	var _isDecimal = __webpack_require__(289);

	var _isDecimal2 = _interopRequireDefault(_isDecimal);

	var _isHexadecimal = __webpack_require__(290);

	var _isHexadecimal2 = _interopRequireDefault(_isHexadecimal);

	var _isDivisibleBy = __webpack_require__(291);

	var _isDivisibleBy2 = _interopRequireDefault(_isDivisibleBy);

	var _isHexColor = __webpack_require__(292);

	var _isHexColor2 = _interopRequireDefault(_isHexColor);

	var _isJSON = __webpack_require__(293);

	var _isJSON2 = _interopRequireDefault(_isJSON);

	var _isNull = __webpack_require__(294);

	var _isNull2 = _interopRequireDefault(_isNull);

	var _isLength = __webpack_require__(295);

	var _isLength2 = _interopRequireDefault(_isLength);

	var _isByteLength = __webpack_require__(296);

	var _isByteLength2 = _interopRequireDefault(_isByteLength);

	var _isUUID = __webpack_require__(297);

	var _isUUID2 = _interopRequireDefault(_isUUID);

	var _isMongoId = __webpack_require__(298);

	var _isMongoId2 = _interopRequireDefault(_isMongoId);

	var _isDate = __webpack_require__(299);

	var _isDate2 = _interopRequireDefault(_isDate);

	var _isAfter = __webpack_require__(300);

	var _isAfter2 = _interopRequireDefault(_isAfter);

	var _isBefore = __webpack_require__(301);

	var _isBefore2 = _interopRequireDefault(_isBefore);

	var _isIn = __webpack_require__(302);

	var _isIn2 = _interopRequireDefault(_isIn);

	var _isCreditCard = __webpack_require__(303);

	var _isCreditCard2 = _interopRequireDefault(_isCreditCard);

	var _isISIN = __webpack_require__(304);

	var _isISIN2 = _interopRequireDefault(_isISIN);

	var _isISBN = __webpack_require__(305);

	var _isISBN2 = _interopRequireDefault(_isISBN);

	var _isMobilePhone = __webpack_require__(306);

	var _isMobilePhone2 = _interopRequireDefault(_isMobilePhone);

	var _isCurrency = __webpack_require__(307);

	var _isCurrency2 = _interopRequireDefault(_isCurrency);

	var _isISO = __webpack_require__(308);

	var _isISO2 = _interopRequireDefault(_isISO);

	var _isBase = __webpack_require__(309);

	var _isBase2 = _interopRequireDefault(_isBase);

	var _isDataURI = __webpack_require__(310);

	var _isDataURI2 = _interopRequireDefault(_isDataURI);

	var _ltrim = __webpack_require__(311);

	var _ltrim2 = _interopRequireDefault(_ltrim);

	var _rtrim = __webpack_require__(312);

	var _rtrim2 = _interopRequireDefault(_rtrim);

	var _trim = __webpack_require__(313);

	var _trim2 = _interopRequireDefault(_trim);

	var _escape = __webpack_require__(314);

	var _escape2 = _interopRequireDefault(_escape);

	var _unescape = __webpack_require__(315);

	var _unescape2 = _interopRequireDefault(_unescape);

	var _stripLow = __webpack_require__(316);

	var _stripLow2 = _interopRequireDefault(_stripLow);

	var _whitelist = __webpack_require__(317);

	var _whitelist2 = _interopRequireDefault(_whitelist);

	var _blacklist = __webpack_require__(318);

	var _blacklist2 = _interopRequireDefault(_blacklist);

	var _isWhitelisted = __webpack_require__(319);

	var _isWhitelisted2 = _interopRequireDefault(_isWhitelisted);

	var _normalizeEmail = __webpack_require__(320);

	var _normalizeEmail2 = _interopRequireDefault(_normalizeEmail);

	var _toString = __webpack_require__(321);

	var _toString2 = _interopRequireDefault(_toString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var version = '5.2.0';

	var validator = {
	  version: version,
	  toDate: _toDate2.default,
	  toFloat: _toFloat2.default, toInt: _toInt2.default,
	  toBoolean: _toBoolean2.default,
	  equals: _equals2.default, contains: _contains2.default, matches: _matches2.default,
	  isEmail: _isEmail2.default, isURL: _isURL2.default, isMACAddress: _isMACAddress2.default, isIP: _isIP2.default, isFQDN: _isFQDN2.default,
	  isBoolean: _isBoolean2.default,
	  isAlpha: _isAlpha2.default, isAlphanumeric: _isAlphanumeric2.default, isNumeric: _isNumeric2.default, isLowercase: _isLowercase2.default, isUppercase: _isUppercase2.default,
	  isAscii: _isAscii2.default, isFullWidth: _isFullWidth2.default, isHalfWidth: _isHalfWidth2.default, isVariableWidth: _isVariableWidth2.default,
	  isMultibyte: _isMultibyte2.default, isSurrogatePair: _isSurrogatePair2.default,
	  isInt: _isInt2.default, isFloat: _isFloat2.default, isDecimal: _isDecimal2.default, isHexadecimal: _isHexadecimal2.default, isDivisibleBy: _isDivisibleBy2.default,
	  isHexColor: _isHexColor2.default,
	  isJSON: _isJSON2.default,
	  isNull: _isNull2.default,
	  isLength: _isLength2.default, isByteLength: _isByteLength2.default,
	  isUUID: _isUUID2.default, isMongoId: _isMongoId2.default,
	  isDate: _isDate2.default, isAfter: _isAfter2.default, isBefore: _isBefore2.default,
	  isIn: _isIn2.default,
	  isCreditCard: _isCreditCard2.default,
	  isISIN: _isISIN2.default, isISBN: _isISBN2.default,
	  isMobilePhone: _isMobilePhone2.default,
	  isCurrency: _isCurrency2.default,
	  isISO8601: _isISO2.default,
	  isBase64: _isBase2.default, isDataURI: _isDataURI2.default,
	  ltrim: _ltrim2.default, rtrim: _rtrim2.default, trim: _trim2.default,
	  escape: _escape2.default, unescape: _unescape2.default, stripLow: _stripLow2.default,
	  whitelist: _whitelist2.default, blacklist: _blacklist2.default,
	  isWhitelisted: _isWhitelisted2.default,
	  normalizeEmail: _normalizeEmail2.default,
	  toString: _toString2.default
	};

	exports.default = validator;
	module.exports = exports['default'];

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	module.exports = Writable;

	/*<replacement>*/
	var Buffer = __webpack_require__(92).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(329);
	util.inherits = __webpack_require__(325);
	/*</replacement>*/

	var Stream = __webpack_require__(174);

	util.inherits(Writable, Stream);

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}

	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(255);

	  options = options || {};

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.buffer = [];

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	function Writable(options) {
	  var Duplex = __webpack_require__(255);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (!util.isFunction(cb))
	    cb = function() {};

	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function() {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function() {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);

	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;

	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);

	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });

	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);

	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }

	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }

	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));

	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59)))

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Readable;

	/*<replacement>*/
	var isArray = __webpack_require__(323);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(92).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(201).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	var Stream = __webpack_require__(174);

	/*<replacement>*/
	var util = __webpack_require__(329);
	util.inherits = __webpack_require__(325);
	/*</replacement>*/

	var StringDecoder;


	/*<replacement>*/
	var debug = __webpack_require__(260);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/


	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(255);

	  options = options || {};

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;


	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(261).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  var Duplex = __webpack_require__(255);

	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      if (!addToFront)
	        state.reading = false;

	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);

	        if (state.needReadable)
	          emitReadable(stream);
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(261).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;

	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }

	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);

	  if (!util.isNull(ret))
	    this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }

	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}

	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}

	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59)))

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	module.exports = Duplex;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	/*<replacement>*/
	var util = __webpack_require__(329);
	util.inherits = __webpack_require__(325);
	/*</replacement>*/

	var Readable = __webpack_require__(254);
	var Writable = __webpack_require__(253);

	util.inherits(Duplex, Readable);

	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(59)))

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.


	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	module.exports = Transform;

	var Duplex = __webpack_require__(255);

	/*<replacement>*/
	var util = __webpack_require__(329);
	util.inherits = __webpack_require__(325);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (!util.isNullOrUndefined(data))
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(options, this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	module.exports = PassThrough;

	var Transform = __webpack_require__(256);

	/*<replacement>*/
	var util = __webpack_require__(329);
	util.inherits = __webpack_require__(325);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLBuilder, assign;

	  assign = __webpack_require__(334);

	  XMLBuilder = __webpack_require__(322);

	  module.exports.create = function(name, xmldec, doctype, options) {
	    options = assign({}, xmldec, doctype, options);
	    return new XMLBuilder(name, options).root();
	  };

	}).call(this);


/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {;(function (sax) { // wrapper for non-node envs
	  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
	  sax.SAXParser = SAXParser
	  sax.SAXStream = SAXStream
	  sax.createStream = createStream

	  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
	  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
	  // since that's the earliest that a buffer overrun could occur.  This way, checks are
	  // as rare as required, but as often as necessary to ensure never crossing this bound.
	  // Furthermore, buffers are only tested at most once per write(), so passing a very
	  // large string into write() might have undesirable effects, but this is manageable by
	  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
	  // edge case, result in creating at most one complete copy of the string passed in.
	  // Set to Infinity to have unlimited buffers.
	  sax.MAX_BUFFER_LENGTH = 64 * 1024

	  var buffers = [
	    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
	    'procInstName', 'procInstBody', 'entity', 'attribName',
	    'attribValue', 'cdata', 'script'
	  ]

	  sax.EVENTS = [
	    'text',
	    'processinginstruction',
	    'sgmldeclaration',
	    'doctype',
	    'comment',
	    'opentagstart',
	    'attribute',
	    'opentag',
	    'closetag',
	    'opencdata',
	    'cdata',
	    'closecdata',
	    'error',
	    'end',
	    'ready',
	    'script',
	    'opennamespace',
	    'closenamespace'
	  ]

	  function SAXParser (strict, opt) {
	    if (!(this instanceof SAXParser)) {
	      return new SAXParser(strict, opt)
	    }

	    var parser = this
	    clearBuffers(parser)
	    parser.q = parser.c = ''
	    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
	    parser.opt = opt || {}
	    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
	    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
	    parser.tags = []
	    parser.closed = parser.closedRoot = parser.sawRoot = false
	    parser.tag = parser.error = null
	    parser.strict = !!strict
	    parser.noscript = !!(strict || parser.opt.noscript)
	    parser.state = S.BEGIN
	    parser.strictEntities = parser.opt.strictEntities
	    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
	    parser.attribList = []

	    // namespaces form a prototype chain.
	    // it always points at the current tag,
	    // which protos to its parent tag.
	    if (parser.opt.xmlns) {
	      parser.ns = Object.create(rootNS)
	    }

	    // mostly just for error reporting
	    parser.trackPosition = parser.opt.position !== false
	    if (parser.trackPosition) {
	      parser.position = parser.line = parser.column = 0
	    }
	    emit(parser, 'onready')
	  }

	  if (!Object.create) {
	    Object.create = function (o) {
	      function F () {}
	      F.prototype = o
	      var newf = new F()
	      return newf
	    }
	  }

	  if (!Object.keys) {
	    Object.keys = function (o) {
	      var a = []
	      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
	      return a
	    }
	  }

	  function checkBufferLength (parser) {
	    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
	    var maxActual = 0
	    for (var i = 0, l = buffers.length; i < l; i++) {
	      var len = parser[buffers[i]].length
	      if (len > maxAllowed) {
	        // Text/cdata nodes can get big, and since they're buffered,
	        // we can get here under normal conditions.
	        // Avoid issues by emitting the text node now,
	        // so at least it won't get any bigger.
	        switch (buffers[i]) {
	          case 'textNode':
	            closeText(parser)
	            break

	          case 'cdata':
	            emitNode(parser, 'oncdata', parser.cdata)
	            parser.cdata = ''
	            break

	          case 'script':
	            emitNode(parser, 'onscript', parser.script)
	            parser.script = ''
	            break

	          default:
	            error(parser, 'Max buffer length exceeded: ' + buffers[i])
	        }
	      }
	      maxActual = Math.max(maxActual, len)
	    }
	    // schedule the next check for the earliest possible buffer overrun.
	    var m = sax.MAX_BUFFER_LENGTH - maxActual
	    parser.bufferCheckPosition = m + parser.position
	  }

	  function clearBuffers (parser) {
	    for (var i = 0, l = buffers.length; i < l; i++) {
	      parser[buffers[i]] = ''
	    }
	  }

	  function flushBuffers (parser) {
	    closeText(parser)
	    if (parser.cdata !== '') {
	      emitNode(parser, 'oncdata', parser.cdata)
	      parser.cdata = ''
	    }
	    if (parser.script !== '') {
	      emitNode(parser, 'onscript', parser.script)
	      parser.script = ''
	    }
	  }

	  SAXParser.prototype = {
	    end: function () { end(this) },
	    write: write,
	    resume: function () { this.error = null; return this },
	    close: function () { return this.write(null) },
	    flush: function () { flushBuffers(this) }
	  }

	  var Stream
	  try {
	    Stream = __webpack_require__(174).Stream
	  } catch (ex) {
	    Stream = function () {}
	  }

	  var streamWraps = sax.EVENTS.filter(function (ev) {
	    return ev !== 'error' && ev !== 'end'
	  })

	  function createStream (strict, opt) {
	    return new SAXStream(strict, opt)
	  }

	  function SAXStream (strict, opt) {
	    if (!(this instanceof SAXStream)) {
	      return new SAXStream(strict, opt)
	    }

	    Stream.apply(this)

	    this._parser = new SAXParser(strict, opt)
	    this.writable = true
	    this.readable = true

	    var me = this

	    this._parser.onend = function () {
	      me.emit('end')
	    }

	    this._parser.onerror = function (er) {
	      me.emit('error', er)

	      // if didn't throw, then means error was handled.
	      // go ahead and clear error, so we can write again.
	      me._parser.error = null
	    }

	    this._decoder = null

	    streamWraps.forEach(function (ev) {
	      Object.defineProperty(me, 'on' + ev, {
	        get: function () {
	          return me._parser['on' + ev]
	        },
	        set: function (h) {
	          if (!h) {
	            me.removeAllListeners(ev)
	            me._parser['on' + ev] = h
	            return h
	          }
	          me.on(ev, h)
	        },
	        enumerable: true,
	        configurable: false
	      })
	    })
	  }

	  SAXStream.prototype = Object.create(Stream.prototype, {
	    constructor: {
	      value: SAXStream
	    }
	  })

	  SAXStream.prototype.write = function (data) {
	    if (typeof Buffer === 'function' &&
	      typeof Buffer.isBuffer === 'function' &&
	      Buffer.isBuffer(data)) {
	      if (!this._decoder) {
	        var SD = __webpack_require__(261).StringDecoder
	        this._decoder = new SD('utf8')
	      }
	      data = this._decoder.write(data)
	    }

	    this._parser.write(data.toString())
	    this.emit('data', data)
	    return true
	  }

	  SAXStream.prototype.end = function (chunk) {
	    if (chunk && chunk.length) {
	      this.write(chunk)
	    }
	    this._parser.end()
	    return true
	  }

	  SAXStream.prototype.on = function (ev, handler) {
	    var me = this
	    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
	      me._parser['on' + ev] = function () {
	        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
	        args.splice(0, 0, ev)
	        me.emit.apply(me, args)
	      }
	    }

	    return Stream.prototype.on.call(me, ev, handler)
	  }

	  // character classes and tokens
	  var whitespace = '\r\n\t '

	  // this really needs to be replaced with character classes.
	  // XML allows all manner of ridiculous numbers and digits.
	  var number = '0124356789'
	  var letter = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

	  // (Letter | "_" | ":")
	  var quote = '\'"'
	  var attribEnd = whitespace + '>'
	  var CDATA = '[CDATA['
	  var DOCTYPE = 'DOCTYPE'
	  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
	  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
	  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

	  // turn all the string character sets into character class objects.
	  whitespace = charClass(whitespace)
	  number = charClass(number)
	  letter = charClass(letter)

	  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
	  // This implementation works on strings, a single character at a time
	  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
	  // without a significant breaking change to either this  parser, or the
	  // JavaScript language.  Implementation of an emoji-capable xml parser
	  // is left as an exercise for the reader.
	  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

	  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

	  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
	  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

	  quote = charClass(quote)
	  attribEnd = charClass(attribEnd)

	  function charClass (str) {
	    return str.split('').reduce(function (s, c) {
	      s[c] = true
	      return s
	    }, {})
	  }

	  function isRegExp (c) {
	    return Object.prototype.toString.call(c) === '[object RegExp]'
	  }

	  function is (charclass, c) {
	    return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]
	  }

	  function not (charclass, c) {
	    return !is(charclass, c)
	  }

	  var S = 0
	  sax.STATE = {
	    BEGIN: S++, // leading byte order mark or whitespace
	    BEGIN_WHITESPACE: S++, // leading whitespace
	    TEXT: S++, // general stuff
	    TEXT_ENTITY: S++, // &amp and such.
	    OPEN_WAKA: S++, // <
	    SGML_DECL: S++, // <!BLARG
	    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
	    DOCTYPE: S++, // <!DOCTYPE
	    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
	    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
	    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
	    COMMENT_STARTING: S++, // <!-
	    COMMENT: S++, // <!--
	    COMMENT_ENDING: S++, // <!-- blah -
	    COMMENT_ENDED: S++, // <!-- blah --
	    CDATA: S++, // <![CDATA[ something
	    CDATA_ENDING: S++, // ]
	    CDATA_ENDING_2: S++, // ]]
	    PROC_INST: S++, // <?hi
	    PROC_INST_BODY: S++, // <?hi there
	    PROC_INST_ENDING: S++, // <?hi "there" ?
	    OPEN_TAG: S++, // <strong
	    OPEN_TAG_SLASH: S++, // <strong /
	    ATTRIB: S++, // <a
	    ATTRIB_NAME: S++, // <a foo
	    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
	    ATTRIB_VALUE: S++, // <a foo=
	    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
	    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
	    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
	    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
	    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
	    CLOSE_TAG: S++, // </a
	    CLOSE_TAG_SAW_WHITE: S++, // </a   >
	    SCRIPT: S++, // <script> ...
	    SCRIPT_ENDING: S++ // <script> ... <
	  }

	  sax.XML_ENTITIES = {
	    'amp': '&',
	    'gt': '>',
	    'lt': '<',
	    'quot': '"',
	    'apos': "'"
	  }

	  sax.ENTITIES = {
	    'amp': '&',
	    'gt': '>',
	    'lt': '<',
	    'quot': '"',
	    'apos': "'",
	    'AElig': 198,
	    'Aacute': 193,
	    'Acirc': 194,
	    'Agrave': 192,
	    'Aring': 197,
	    'Atilde': 195,
	    'Auml': 196,
	    'Ccedil': 199,
	    'ETH': 208,
	    'Eacute': 201,
	    'Ecirc': 202,
	    'Egrave': 200,
	    'Euml': 203,
	    'Iacute': 205,
	    'Icirc': 206,
	    'Igrave': 204,
	    'Iuml': 207,
	    'Ntilde': 209,
	    'Oacute': 211,
	    'Ocirc': 212,
	    'Ograve': 210,
	    'Oslash': 216,
	    'Otilde': 213,
	    'Ouml': 214,
	    'THORN': 222,
	    'Uacute': 218,
	    'Ucirc': 219,
	    'Ugrave': 217,
	    'Uuml': 220,
	    'Yacute': 221,
	    'aacute': 225,
	    'acirc': 226,
	    'aelig': 230,
	    'agrave': 224,
	    'aring': 229,
	    'atilde': 227,
	    'auml': 228,
	    'ccedil': 231,
	    'eacute': 233,
	    'ecirc': 234,
	    'egrave': 232,
	    'eth': 240,
	    'euml': 235,
	    'iacute': 237,
	    'icirc': 238,
	    'igrave': 236,
	    'iuml': 239,
	    'ntilde': 241,
	    'oacute': 243,
	    'ocirc': 244,
	    'ograve': 242,
	    'oslash': 248,
	    'otilde': 245,
	    'ouml': 246,
	    'szlig': 223,
	    'thorn': 254,
	    'uacute': 250,
	    'ucirc': 251,
	    'ugrave': 249,
	    'uuml': 252,
	    'yacute': 253,
	    'yuml': 255,
	    'copy': 169,
	    'reg': 174,
	    'nbsp': 160,
	    'iexcl': 161,
	    'cent': 162,
	    'pound': 163,
	    'curren': 164,
	    'yen': 165,
	    'brvbar': 166,
	    'sect': 167,
	    'uml': 168,
	    'ordf': 170,
	    'laquo': 171,
	    'not': 172,
	    'shy': 173,
	    'macr': 175,
	    'deg': 176,
	    'plusmn': 177,
	    'sup1': 185,
	    'sup2': 178,
	    'sup3': 179,
	    'acute': 180,
	    'micro': 181,
	    'para': 182,
	    'middot': 183,
	    'cedil': 184,
	    'ordm': 186,
	    'raquo': 187,
	    'frac14': 188,
	    'frac12': 189,
	    'frac34': 190,
	    'iquest': 191,
	    'times': 215,
	    'divide': 247,
	    'OElig': 338,
	    'oelig': 339,
	    'Scaron': 352,
	    'scaron': 353,
	    'Yuml': 376,
	    'fnof': 402,
	    'circ': 710,
	    'tilde': 732,
	    'Alpha': 913,
	    'Beta': 914,
	    'Gamma': 915,
	    'Delta': 916,
	    'Epsilon': 917,
	    'Zeta': 918,
	    'Eta': 919,
	    'Theta': 920,
	    'Iota': 921,
	    'Kappa': 922,
	    'Lambda': 923,
	    'Mu': 924,
	    'Nu': 925,
	    'Xi': 926,
	    'Omicron': 927,
	    'Pi': 928,
	    'Rho': 929,
	    'Sigma': 931,
	    'Tau': 932,
	    'Upsilon': 933,
	    'Phi': 934,
	    'Chi': 935,
	    'Psi': 936,
	    'Omega': 937,
	    'alpha': 945,
	    'beta': 946,
	    'gamma': 947,
	    'delta': 948,
	    'epsilon': 949,
	    'zeta': 950,
	    'eta': 951,
	    'theta': 952,
	    'iota': 953,
	    'kappa': 954,
	    'lambda': 955,
	    'mu': 956,
	    'nu': 957,
	    'xi': 958,
	    'omicron': 959,
	    'pi': 960,
	    'rho': 961,
	    'sigmaf': 962,
	    'sigma': 963,
	    'tau': 964,
	    'upsilon': 965,
	    'phi': 966,
	    'chi': 967,
	    'psi': 968,
	    'omega': 969,
	    'thetasym': 977,
	    'upsih': 978,
	    'piv': 982,
	    'ensp': 8194,
	    'emsp': 8195,
	    'thinsp': 8201,
	    'zwnj': 8204,
	    'zwj': 8205,
	    'lrm': 8206,
	    'rlm': 8207,
	    'ndash': 8211,
	    'mdash': 8212,
	    'lsquo': 8216,
	    'rsquo': 8217,
	    'sbquo': 8218,
	    'ldquo': 8220,
	    'rdquo': 8221,
	    'bdquo': 8222,
	    'dagger': 8224,
	    'Dagger': 8225,
	    'bull': 8226,
	    'hellip': 8230,
	    'permil': 8240,
	    'prime': 8242,
	    'Prime': 8243,
	    'lsaquo': 8249,
	    'rsaquo': 8250,
	    'oline': 8254,
	    'frasl': 8260,
	    'euro': 8364,
	    'image': 8465,
	    'weierp': 8472,
	    'real': 8476,
	    'trade': 8482,
	    'alefsym': 8501,
	    'larr': 8592,
	    'uarr': 8593,
	    'rarr': 8594,
	    'darr': 8595,
	    'harr': 8596,
	    'crarr': 8629,
	    'lArr': 8656,
	    'uArr': 8657,
	    'rArr': 8658,
	    'dArr': 8659,
	    'hArr': 8660,
	    'forall': 8704,
	    'part': 8706,
	    'exist': 8707,
	    'empty': 8709,
	    'nabla': 8711,
	    'isin': 8712,
	    'notin': 8713,
	    'ni': 8715,
	    'prod': 8719,
	    'sum': 8721,
	    'minus': 8722,
	    'lowast': 8727,
	    'radic': 8730,
	    'prop': 8733,
	    'infin': 8734,
	    'ang': 8736,
	    'and': 8743,
	    'or': 8744,
	    'cap': 8745,
	    'cup': 8746,
	    'int': 8747,
	    'there4': 8756,
	    'sim': 8764,
	    'cong': 8773,
	    'asymp': 8776,
	    'ne': 8800,
	    'equiv': 8801,
	    'le': 8804,
	    'ge': 8805,
	    'sub': 8834,
	    'sup': 8835,
	    'nsub': 8836,
	    'sube': 8838,
	    'supe': 8839,
	    'oplus': 8853,
	    'otimes': 8855,
	    'perp': 8869,
	    'sdot': 8901,
	    'lceil': 8968,
	    'rceil': 8969,
	    'lfloor': 8970,
	    'rfloor': 8971,
	    'lang': 9001,
	    'rang': 9002,
	    'loz': 9674,
	    'spades': 9824,
	    'clubs': 9827,
	    'hearts': 9829,
	    'diams': 9830
	  }

	  Object.keys(sax.ENTITIES).forEach(function (key) {
	    var e = sax.ENTITIES[key]
	    var s = typeof e === 'number' ? String.fromCharCode(e) : e
	    sax.ENTITIES[key] = s
	  })

	  for (var s in sax.STATE) {
	    sax.STATE[sax.STATE[s]] = s
	  }

	  // shorthand
	  S = sax.STATE

	  function emit (parser, event, data) {
	    parser[event] && parser[event](data)
	  }

	  function emitNode (parser, nodeType, data) {
	    if (parser.textNode) closeText(parser)
	    emit(parser, nodeType, data)
	  }

	  function closeText (parser) {
	    parser.textNode = textopts(parser.opt, parser.textNode)
	    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
	    parser.textNode = ''
	  }

	  function textopts (opt, text) {
	    if (opt.trim) text = text.trim()
	    if (opt.normalize) text = text.replace(/\s+/g, ' ')
	    return text
	  }

	  function error (parser, er) {
	    closeText(parser)
	    if (parser.trackPosition) {
	      er += '\nLine: ' + parser.line +
	        '\nColumn: ' + parser.column +
	        '\nChar: ' + parser.c
	    }
	    er = new Error(er)
	    parser.error = er
	    emit(parser, 'onerror', er)
	    return parser
	  }

	  function end (parser) {
	    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
	    if ((parser.state !== S.BEGIN) &&
	      (parser.state !== S.BEGIN_WHITESPACE) &&
	      (parser.state !== S.TEXT)) {
	      error(parser, 'Unexpected end')
	    }
	    closeText(parser)
	    parser.c = ''
	    parser.closed = true
	    emit(parser, 'onend')
	    SAXParser.call(parser, parser.strict, parser.opt)
	    return parser
	  }

	  function strictFail (parser, message) {
	    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
	      throw new Error('bad call to strictFail')
	    }
	    if (parser.strict) {
	      error(parser, message)
	    }
	  }

	  function newTag (parser) {
	    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
	    var parent = parser.tags[parser.tags.length - 1] || parser
	    var tag = parser.tag = { name: parser.tagName, attributes: {} }

	    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
	    if (parser.opt.xmlns) {
	      tag.ns = parent.ns
	    }
	    parser.attribList.length = 0
	    emitNode(parser, 'onopentagstart', tag)
	  }

	  function qname (name, attribute) {
	    var i = name.indexOf(':')
	    var qualName = i < 0 ? [ '', name ] : name.split(':')
	    var prefix = qualName[0]
	    var local = qualName[1]

	    // <x "xmlns"="http://foo">
	    if (attribute && name === 'xmlns') {
	      prefix = 'xmlns'
	      local = ''
	    }

	    return { prefix: prefix, local: local }
	  }

	  function attrib (parser) {
	    if (!parser.strict) {
	      parser.attribName = parser.attribName[parser.looseCase]()
	    }

	    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
	      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
	      parser.attribName = parser.attribValue = ''
	      return
	    }

	    if (parser.opt.xmlns) {
	      var qn = qname(parser.attribName, true)
	      var prefix = qn.prefix
	      var local = qn.local

	      if (prefix === 'xmlns') {
	        // namespace binding attribute. push the binding into scope
	        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
	          strictFail(parser,
	            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
	            'Actual: ' + parser.attribValue)
	        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
	          strictFail(parser,
	            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
	            'Actual: ' + parser.attribValue)
	        } else {
	          var tag = parser.tag
	          var parent = parser.tags[parser.tags.length - 1] || parser
	          if (tag.ns === parent.ns) {
	            tag.ns = Object.create(parent.ns)
	          }
	          tag.ns[local] = parser.attribValue
	        }
	      }

	      // defer onattribute events until all attributes have been seen
	      // so any new bindings can take effect. preserve attribute order
	      // so deferred events can be emitted in document order
	      parser.attribList.push([parser.attribName, parser.attribValue])
	    } else {
	      // in non-xmlns mode, we can emit the event right away
	      parser.tag.attributes[parser.attribName] = parser.attribValue
	      emitNode(parser, 'onattribute', {
	        name: parser.attribName,
	        value: parser.attribValue
	      })
	    }

	    parser.attribName = parser.attribValue = ''
	  }

	  function openTag (parser, selfClosing) {
	    if (parser.opt.xmlns) {
	      // emit namespace binding events
	      var tag = parser.tag

	      // add namespace info to tag
	      var qn = qname(parser.tagName)
	      tag.prefix = qn.prefix
	      tag.local = qn.local
	      tag.uri = tag.ns[qn.prefix] || ''

	      if (tag.prefix && !tag.uri) {
	        strictFail(parser, 'Unbound namespace prefix: ' +
	          JSON.stringify(parser.tagName))
	        tag.uri = qn.prefix
	      }

	      var parent = parser.tags[parser.tags.length - 1] || parser
	      if (tag.ns && parent.ns !== tag.ns) {
	        Object.keys(tag.ns).forEach(function (p) {
	          emitNode(parser, 'onopennamespace', {
	            prefix: p,
	            uri: tag.ns[p]
	          })
	        })
	      }

	      // handle deferred onattribute events
	      // Note: do not apply default ns to attributes:
	      //   http://www.w3.org/TR/REC-xml-names/#defaulting
	      for (var i = 0, l = parser.attribList.length; i < l; i++) {
	        var nv = parser.attribList[i]
	        var name = nv[0]
	        var value = nv[1]
	        var qualName = qname(name, true)
	        var prefix = qualName.prefix
	        var local = qualName.local
	        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
	        var a = {
	          name: name,
	          value: value,
	          prefix: prefix,
	          local: local,
	          uri: uri
	        }

	        // if there's any attributes with an undefined namespace,
	        // then fail on them now.
	        if (prefix && prefix !== 'xmlns' && !uri) {
	          strictFail(parser, 'Unbound namespace prefix: ' +
	            JSON.stringify(prefix))
	          a.uri = prefix
	        }
	        parser.tag.attributes[name] = a
	        emitNode(parser, 'onattribute', a)
	      }
	      parser.attribList.length = 0
	    }

	    parser.tag.isSelfClosing = !!selfClosing

	    // process the tag
	    parser.sawRoot = true
	    parser.tags.push(parser.tag)
	    emitNode(parser, 'onopentag', parser.tag)
	    if (!selfClosing) {
	      // special case for <script> in non-strict mode.
	      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
	        parser.state = S.SCRIPT
	      } else {
	        parser.state = S.TEXT
	      }
	      parser.tag = null
	      parser.tagName = ''
	    }
	    parser.attribName = parser.attribValue = ''
	    parser.attribList.length = 0
	  }

	  function closeTag (parser) {
	    if (!parser.tagName) {
	      strictFail(parser, 'Weird empty close tag.')
	      parser.textNode += '</>'
	      parser.state = S.TEXT
	      return
	    }

	    if (parser.script) {
	      if (parser.tagName !== 'script') {
	        parser.script += '</' + parser.tagName + '>'
	        parser.tagName = ''
	        parser.state = S.SCRIPT
	        return
	      }
	      emitNode(parser, 'onscript', parser.script)
	      parser.script = ''
	    }

	    // first make sure that the closing tag actually exists.
	    // <a><b></c></b></a> will close everything, otherwise.
	    var t = parser.tags.length
	    var tagName = parser.tagName
	    if (!parser.strict) {
	      tagName = tagName[parser.looseCase]()
	    }
	    var closeTo = tagName
	    while (t--) {
	      var close = parser.tags[t]
	      if (close.name !== closeTo) {
	        // fail the first time in strict mode
	        strictFail(parser, 'Unexpected close tag')
	      } else {
	        break
	      }
	    }

	    // didn't find it.  we already failed for strict, so just abort.
	    if (t < 0) {
	      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
	      parser.textNode += '</' + parser.tagName + '>'
	      parser.state = S.TEXT
	      return
	    }
	    parser.tagName = tagName
	    var s = parser.tags.length
	    while (s-- > t) {
	      var tag = parser.tag = parser.tags.pop()
	      parser.tagName = parser.tag.name
	      emitNode(parser, 'onclosetag', parser.tagName)

	      var x = {}
	      for (var i in tag.ns) {
	        x[i] = tag.ns[i]
	      }

	      var parent = parser.tags[parser.tags.length - 1] || parser
	      if (parser.opt.xmlns && tag.ns !== parent.ns) {
	        // remove namespace bindings introduced by tag
	        Object.keys(tag.ns).forEach(function (p) {
	          var n = tag.ns[p]
	          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
	        })
	      }
	    }
	    if (t === 0) parser.closedRoot = true
	    parser.tagName = parser.attribValue = parser.attribName = ''
	    parser.attribList.length = 0
	    parser.state = S.TEXT
	  }

	  function parseEntity (parser) {
	    var entity = parser.entity
	    var entityLC = entity.toLowerCase()
	    var num
	    var numStr = ''

	    if (parser.ENTITIES[entity]) {
	      return parser.ENTITIES[entity]
	    }
	    if (parser.ENTITIES[entityLC]) {
	      return parser.ENTITIES[entityLC]
	    }
	    entity = entityLC
	    if (entity.charAt(0) === '#') {
	      if (entity.charAt(1) === 'x') {
	        entity = entity.slice(2)
	        num = parseInt(entity, 16)
	        numStr = num.toString(16)
	      } else {
	        entity = entity.slice(1)
	        num = parseInt(entity, 10)
	        numStr = num.toString(10)
	      }
	    }
	    entity = entity.replace(/^0+/, '')
	    if (numStr.toLowerCase() !== entity) {
	      strictFail(parser, 'Invalid character entity')
	      return '&' + parser.entity + ';'
	    }

	    return String.fromCodePoint(num)
	  }

	  function beginWhiteSpace (parser, c) {
	    if (c === '<') {
	      parser.state = S.OPEN_WAKA
	      parser.startTagPosition = parser.position
	    } else if (not(whitespace, c)) {
	      // have to process this as a text node.
	      // weird, but happens.
	      strictFail(parser, 'Non-whitespace before first tag.')
	      parser.textNode = c
	      parser.state = S.TEXT
	    }
	  }

	  function charAt (chunk, i) {
	    var result = ''
	    if (i < chunk.length) {
	      result = chunk.charAt(i)
	    }
	    return result
	  }

	  function write (chunk) {
	    var parser = this
	    if (this.error) {
	      throw this.error
	    }
	    if (parser.closed) {
	      return error(parser,
	        'Cannot write after close. Assign an onready handler.')
	    }
	    if (chunk === null) {
	      return end(parser)
	    }
	    if (typeof chunk === 'object') {
	      chunk = chunk.toString()
	    }
	    var i = 0
	    var c = ''
	    while (true) {
	      c = charAt(chunk, i++)
	      parser.c = c
	      if (!c) {
	        break
	      }
	      if (parser.trackPosition) {
	        parser.position++
	        if (c === '\n') {
	          parser.line++
	          parser.column = 0
	        } else {
	          parser.column++
	        }
	      }
	      switch (parser.state) {
	        case S.BEGIN:
	          parser.state = S.BEGIN_WHITESPACE
	          if (c === '\uFEFF') {
	            continue
	          }
	          beginWhiteSpace(parser, c)
	          continue

	        case S.BEGIN_WHITESPACE:
	          beginWhiteSpace(parser, c)
	          continue

	        case S.TEXT:
	          if (parser.sawRoot && !parser.closedRoot) {
	            var starti = i - 1
	            while (c && c !== '<' && c !== '&') {
	              c = charAt(chunk, i++)
	              if (c && parser.trackPosition) {
	                parser.position++
	                if (c === '\n') {
	                  parser.line++
	                  parser.column = 0
	                } else {
	                  parser.column++
	                }
	              }
	            }
	            parser.textNode += chunk.substring(starti, i - 1)
	          }
	          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
	            parser.state = S.OPEN_WAKA
	            parser.startTagPosition = parser.position
	          } else {
	            if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {
	              strictFail(parser, 'Text data outside of root node.')
	            }
	            if (c === '&') {
	              parser.state = S.TEXT_ENTITY
	            } else {
	              parser.textNode += c
	            }
	          }
	          continue

	        case S.SCRIPT:
	          // only non-strict
	          if (c === '<') {
	            parser.state = S.SCRIPT_ENDING
	          } else {
	            parser.script += c
	          }
	          continue

	        case S.SCRIPT_ENDING:
	          if (c === '/') {
	            parser.state = S.CLOSE_TAG
	          } else {
	            parser.script += '<' + c
	            parser.state = S.SCRIPT
	          }
	          continue

	        case S.OPEN_WAKA:
	          // either a /, ?, !, or text is coming next.
	          if (c === '!') {
	            parser.state = S.SGML_DECL
	            parser.sgmlDecl = ''
	          } else if (is(whitespace, c)) {
	            // wait for it...
	          } else if (is(nameStart, c)) {
	            parser.state = S.OPEN_TAG
	            parser.tagName = c
	          } else if (c === '/') {
	            parser.state = S.CLOSE_TAG
	            parser.tagName = ''
	          } else if (c === '?') {
	            parser.state = S.PROC_INST
	            parser.procInstName = parser.procInstBody = ''
	          } else {
	            strictFail(parser, 'Unencoded <')
	            // if there was some whitespace, then add that in.
	            if (parser.startTagPosition + 1 < parser.position) {
	              var pad = parser.position - parser.startTagPosition
	              c = new Array(pad).join(' ') + c
	            }
	            parser.textNode += '<' + c
	            parser.state = S.TEXT
	          }
	          continue

	        case S.SGML_DECL:
	          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
	            emitNode(parser, 'onopencdata')
	            parser.state = S.CDATA
	            parser.sgmlDecl = ''
	            parser.cdata = ''
	          } else if (parser.sgmlDecl + c === '--') {
	            parser.state = S.COMMENT
	            parser.comment = ''
	            parser.sgmlDecl = ''
	          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
	            parser.state = S.DOCTYPE
	            if (parser.doctype || parser.sawRoot) {
	              strictFail(parser,
	                'Inappropriately located doctype declaration')
	            }
	            parser.doctype = ''
	            parser.sgmlDecl = ''
	          } else if (c === '>') {
	            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
	            parser.sgmlDecl = ''
	            parser.state = S.TEXT
	          } else if (is(quote, c)) {
	            parser.state = S.SGML_DECL_QUOTED
	            parser.sgmlDecl += c
	          } else {
	            parser.sgmlDecl += c
	          }
	          continue

	        case S.SGML_DECL_QUOTED:
	          if (c === parser.q) {
	            parser.state = S.SGML_DECL
	            parser.q = ''
	          }
	          parser.sgmlDecl += c
	          continue

	        case S.DOCTYPE:
	          if (c === '>') {
	            parser.state = S.TEXT
	            emitNode(parser, 'ondoctype', parser.doctype)
	            parser.doctype = true // just remember that we saw it.
	          } else {
	            parser.doctype += c
	            if (c === '[') {
	              parser.state = S.DOCTYPE_DTD
	            } else if (is(quote, c)) {
	              parser.state = S.DOCTYPE_QUOTED
	              parser.q = c
	            }
	          }
	          continue

	        case S.DOCTYPE_QUOTED:
	          parser.doctype += c
	          if (c === parser.q) {
	            parser.q = ''
	            parser.state = S.DOCTYPE
	          }
	          continue

	        case S.DOCTYPE_DTD:
	          parser.doctype += c
	          if (c === ']') {
	            parser.state = S.DOCTYPE
	          } else if (is(quote, c)) {
	            parser.state = S.DOCTYPE_DTD_QUOTED
	            parser.q = c
	          }
	          continue

	        case S.DOCTYPE_DTD_QUOTED:
	          parser.doctype += c
	          if (c === parser.q) {
	            parser.state = S.DOCTYPE_DTD
	            parser.q = ''
	          }
	          continue

	        case S.COMMENT:
	          if (c === '-') {
	            parser.state = S.COMMENT_ENDING
	          } else {
	            parser.comment += c
	          }
	          continue

	        case S.COMMENT_ENDING:
	          if (c === '-') {
	            parser.state = S.COMMENT_ENDED
	            parser.comment = textopts(parser.opt, parser.comment)
	            if (parser.comment) {
	              emitNode(parser, 'oncomment', parser.comment)
	            }
	            parser.comment = ''
	          } else {
	            parser.comment += '-' + c
	            parser.state = S.COMMENT
	          }
	          continue

	        case S.COMMENT_ENDED:
	          if (c !== '>') {
	            strictFail(parser, 'Malformed comment')
	            // allow <!-- blah -- bloo --> in non-strict mode,
	            // which is a comment of " blah -- bloo "
	            parser.comment += '--' + c
	            parser.state = S.COMMENT
	          } else {
	            parser.state = S.TEXT
	          }
	          continue

	        case S.CDATA:
	          if (c === ']') {
	            parser.state = S.CDATA_ENDING
	          } else {
	            parser.cdata += c
	          }
	          continue

	        case S.CDATA_ENDING:
	          if (c === ']') {
	            parser.state = S.CDATA_ENDING_2
	          } else {
	            parser.cdata += ']' + c
	            parser.state = S.CDATA
	          }
	          continue

	        case S.CDATA_ENDING_2:
	          if (c === '>') {
	            if (parser.cdata) {
	              emitNode(parser, 'oncdata', parser.cdata)
	            }
	            emitNode(parser, 'onclosecdata')
	            parser.cdata = ''
	            parser.state = S.TEXT
	          } else if (c === ']') {
	            parser.cdata += ']'
	          } else {
	            parser.cdata += ']]' + c
	            parser.state = S.CDATA
	          }
	          continue

	        case S.PROC_INST:
	          if (c === '?') {
	            parser.state = S.PROC_INST_ENDING
	          } else if (is(whitespace, c)) {
	            parser.state = S.PROC_INST_BODY
	          } else {
	            parser.procInstName += c
	          }
	          continue

	        case S.PROC_INST_BODY:
	          if (!parser.procInstBody && is(whitespace, c)) {
	            continue
	          } else if (c === '?') {
	            parser.state = S.PROC_INST_ENDING
	          } else {
	            parser.procInstBody += c
	          }
	          continue

	        case S.PROC_INST_ENDING:
	          if (c === '>') {
	            emitNode(parser, 'onprocessinginstruction', {
	              name: parser.procInstName,
	              body: parser.procInstBody
	            })
	            parser.procInstName = parser.procInstBody = ''
	            parser.state = S.TEXT
	          } else {
	            parser.procInstBody += '?' + c
	            parser.state = S.PROC_INST_BODY
	          }
	          continue

	        case S.OPEN_TAG:
	          if (is(nameBody, c)) {
	            parser.tagName += c
	          } else {
	            newTag(parser)
	            if (c === '>') {
	              openTag(parser)
	            } else if (c === '/') {
	              parser.state = S.OPEN_TAG_SLASH
	            } else {
	              if (not(whitespace, c)) {
	                strictFail(parser, 'Invalid character in tag name')
	              }
	              parser.state = S.ATTRIB
	            }
	          }
	          continue

	        case S.OPEN_TAG_SLASH:
	          if (c === '>') {
	            openTag(parser, true)
	            closeTag(parser)
	          } else {
	            strictFail(parser, 'Forward-slash in opening tag not followed by >')
	            parser.state = S.ATTRIB
	          }
	          continue

	        case S.ATTRIB:
	          // haven't read the attribute name yet.
	          if (is(whitespace, c)) {
	            continue
	          } else if (c === '>') {
	            openTag(parser)
	          } else if (c === '/') {
	            parser.state = S.OPEN_TAG_SLASH
	          } else if (is(nameStart, c)) {
	            parser.attribName = c
	            parser.attribValue = ''
	            parser.state = S.ATTRIB_NAME
	          } else {
	            strictFail(parser, 'Invalid attribute name')
	          }
	          continue

	        case S.ATTRIB_NAME:
	          if (c === '=') {
	            parser.state = S.ATTRIB_VALUE
	          } else if (c === '>') {
	            strictFail(parser, 'Attribute without value')
	            parser.attribValue = parser.attribName
	            attrib(parser)
	            openTag(parser)
	          } else if (is(whitespace, c)) {
	            parser.state = S.ATTRIB_NAME_SAW_WHITE
	          } else if (is(nameBody, c)) {
	            parser.attribName += c
	          } else {
	            strictFail(parser, 'Invalid attribute name')
	          }
	          continue

	        case S.ATTRIB_NAME_SAW_WHITE:
	          if (c === '=') {
	            parser.state = S.ATTRIB_VALUE
	          } else if (is(whitespace, c)) {
	            continue
	          } else {
	            strictFail(parser, 'Attribute without value')
	            parser.tag.attributes[parser.attribName] = ''
	            parser.attribValue = ''
	            emitNode(parser, 'onattribute', {
	              name: parser.attribName,
	              value: ''
	            })
	            parser.attribName = ''
	            if (c === '>') {
	              openTag(parser)
	            } else if (is(nameStart, c)) {
	              parser.attribName = c
	              parser.state = S.ATTRIB_NAME
	            } else {
	              strictFail(parser, 'Invalid attribute name')
	              parser.state = S.ATTRIB
	            }
	          }
	          continue

	        case S.ATTRIB_VALUE:
	          if (is(whitespace, c)) {
	            continue
	          } else if (is(quote, c)) {
	            parser.q = c
	            parser.state = S.ATTRIB_VALUE_QUOTED
	          } else {
	            strictFail(parser, 'Unquoted attribute value')
	            parser.state = S.ATTRIB_VALUE_UNQUOTED
	            parser.attribValue = c
	          }
	          continue

	        case S.ATTRIB_VALUE_QUOTED:
	          if (c !== parser.q) {
	            if (c === '&') {
	              parser.state = S.ATTRIB_VALUE_ENTITY_Q
	            } else {
	              parser.attribValue += c
	            }
	            continue
	          }
	          attrib(parser)
	          parser.q = ''
	          parser.state = S.ATTRIB_VALUE_CLOSED
	          continue

	        case S.ATTRIB_VALUE_CLOSED:
	          if (is(whitespace, c)) {
	            parser.state = S.ATTRIB
	          } else if (c === '>') {
	            openTag(parser)
	          } else if (c === '/') {
	            parser.state = S.OPEN_TAG_SLASH
	          } else if (is(nameStart, c)) {
	            strictFail(parser, 'No whitespace between attributes')
	            parser.attribName = c
	            parser.attribValue = ''
	            parser.state = S.ATTRIB_NAME
	          } else {
	            strictFail(parser, 'Invalid attribute name')
	          }
	          continue

	        case S.ATTRIB_VALUE_UNQUOTED:
	          if (not(attribEnd, c)) {
	            if (c === '&') {
	              parser.state = S.ATTRIB_VALUE_ENTITY_U
	            } else {
	              parser.attribValue += c
	            }
	            continue
	          }
	          attrib(parser)
	          if (c === '>') {
	            openTag(parser)
	          } else {
	            parser.state = S.ATTRIB
	          }
	          continue

	        case S.CLOSE_TAG:
	          if (!parser.tagName) {
	            if (is(whitespace, c)) {
	              continue
	            } else if (not(nameStart, c)) {
	              if (parser.script) {
	                parser.script += '</' + c
	                parser.state = S.SCRIPT
	              } else {
	                strictFail(parser, 'Invalid tagname in closing tag.')
	              }
	            } else {
	              parser.tagName = c
	            }
	          } else if (c === '>') {
	            closeTag(parser)
	          } else if (is(nameBody, c)) {
	            parser.tagName += c
	          } else if (parser.script) {
	            parser.script += '</' + parser.tagName
	            parser.tagName = ''
	            parser.state = S.SCRIPT
	          } else {
	            if (not(whitespace, c)) {
	              strictFail(parser, 'Invalid tagname in closing tag')
	            }
	            parser.state = S.CLOSE_TAG_SAW_WHITE
	          }
	          continue

	        case S.CLOSE_TAG_SAW_WHITE:
	          if (is(whitespace, c)) {
	            continue
	          }
	          if (c === '>') {
	            closeTag(parser)
	          } else {
	            strictFail(parser, 'Invalid characters in closing tag')
	          }
	          continue

	        case S.TEXT_ENTITY:
	        case S.ATTRIB_VALUE_ENTITY_Q:
	        case S.ATTRIB_VALUE_ENTITY_U:
	          var returnState
	          var buffer
	          switch (parser.state) {
	            case S.TEXT_ENTITY:
	              returnState = S.TEXT
	              buffer = 'textNode'
	              break

	            case S.ATTRIB_VALUE_ENTITY_Q:
	              returnState = S.ATTRIB_VALUE_QUOTED
	              buffer = 'attribValue'
	              break

	            case S.ATTRIB_VALUE_ENTITY_U:
	              returnState = S.ATTRIB_VALUE_UNQUOTED
	              buffer = 'attribValue'
	              break
	          }

	          if (c === ';') {
	            parser[buffer] += parseEntity(parser)
	            parser.entity = ''
	            parser.state = returnState
	          } else if (is(parser.entity.length ? entityBody : entityStart, c)) {
	            parser.entity += c
	          } else {
	            strictFail(parser, 'Invalid character in entity name')
	            parser[buffer] += '&' + parser.entity + c
	            parser.entity = ''
	            parser.state = returnState
	          }

	          continue

	        default:
	          throw new Error(parser, 'Unknown state: ' + parser.state)
	      }
	    } // while

	    if (parser.position >= parser.bufferCheckPosition) {
	      checkBufferLength(parser)
	    }
	    return parser
	  }

	  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
	  if (!String.fromCodePoint) {
	    (function () {
	      var stringFromCharCode = String.fromCharCode
	      var floor = Math.floor
	      var fromCodePoint = function () {
	        var MAX_SIZE = 0x4000
	        var codeUnits = []
	        var highSurrogate
	        var lowSurrogate
	        var index = -1
	        var length = arguments.length
	        if (!length) {
	          return ''
	        }
	        var result = ''
	        while (++index < length) {
	          var codePoint = Number(arguments[index])
	          if (
	            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
	            codePoint < 0 || // not a valid Unicode code point
	            codePoint > 0x10FFFF || // not a valid Unicode code point
	            floor(codePoint) !== codePoint // not an integer
	          ) {
	            throw RangeError('Invalid code point: ' + codePoint)
	          }
	          if (codePoint <= 0xFFFF) { // BMP code point
	            codeUnits.push(codePoint)
	          } else { // Astral code point; split in surrogate halves
	            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	            codePoint -= 0x10000
	            highSurrogate = (codePoint >> 10) + 0xD800
	            lowSurrogate = (codePoint % 0x400) + 0xDC00
	            codeUnits.push(highSurrogate, lowSurrogate)
	          }
	          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
	            result += stringFromCharCode.apply(null, codeUnits)
	            codeUnits.length = 0
	          }
	        }
	        return result
	      }
	      if (Object.defineProperty) {
	        Object.defineProperty(String, 'fromCodePoint', {
	          value: fromCodePoint,
	          configurable: true,
	          writable: true
	        })
	      } else {
	        String.fromCodePoint = fromCodePoint
	      }
	    }())
	  }
	})(typeof exports === 'undefined' ? this.sax = {} : exports)
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(92).Buffer))

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	/* (ignored) */

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(92).Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, global) {/**
	 * lodash 4.7.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** `Object#toString` result references. */
	var funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    symbolTag = '[object Symbol]';

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used to determine if values are of the language type `Object`. */
	var objectTypes = {
	  'function': true,
	  'object': true
	};

	/** Detect free variable `exports`. */
	var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
	  ? exports
	  : undefined;

	/** Detect free variable `module`. */
	var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
	  ? module
	  : undefined;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);

	/** Detect free variable `self`. */
	var freeSelf = checkGlobal(objectTypes[typeof self] && self);

	/** Detect free variable `window`. */
	var freeWindow = checkGlobal(objectTypes[typeof window] && window);

	/** Detect `this` as the global object. */
	var thisGlobal = checkGlobal(objectTypes[typeof this] && this);

	/**
	 * Used as a reference to the global object.
	 *
	 * The `this` value is used if it's the global object to avoid Greasemonkey's
	 * restricted `window` object, otherwise the `window` object is used.
	 */
	var root = freeGlobal ||
	  ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
	    freeSelf || thisGlobal || Function('return this')();

	/**
	 * Checks if `value` is a global object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {null|Object} Returns `value` if it's a global object, else `null`.
	 */
	function checkGlobal(value) {
	  return (value && value.Object === Object) ? value : null;
	}

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = Function.prototype.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var Symbol = root.Symbol,
	    splice = arrayProto.splice;

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map'),
	    nativeCreate = getNative(Object, 'create');

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @returns {Object} Returns the new hash object.
	 */
	function Hash() {}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(hash, key) {
	  return hashHas(hash, key) && delete hash[key];
	}

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @param {Object} hash The hash to query.
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(hash, key) {
	  if (nativeCreate) {
	    var result = hash[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(hash, key) ? hash[key] : undefined;
	}

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @param {Object} hash The hash to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(hash, key) {
	  return nativeCreate ? hash[key] !== undefined : hasOwnProperty.call(hash, key);
	}

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 */
	function hashSet(hash, key, value) {
	  hash[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	}

	// Avoid inheriting from `Object.prototype` when possible.
	Hash.prototype = nativeCreate ? nativeCreate(null) : objectProto;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function MapCache(values) {
	  var index = -1,
	      length = values ? values.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = values[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapClear() {
	  this.__data__ = {
	    'hash': new Hash,
	    'map': Map ? new Map : [],
	    'string': new Hash
	  };
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapDelete(key) {
	  var data = this.__data__;
	  if (isKeyable(key)) {
	    return hashDelete(typeof key == 'string' ? data.string : data.hash, key);
	  }
	  return Map ? data.map['delete'](key) : assocDelete(data.map, key);
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapGet(key) {
	  var data = this.__data__;
	  if (isKeyable(key)) {
	    return hashGet(typeof key == 'string' ? data.string : data.hash, key);
	  }
	  return Map ? data.map.get(key) : assocGet(data.map, key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapHas(key) {
	  var data = this.__data__;
	  if (isKeyable(key)) {
	    return hashHas(typeof key == 'string' ? data.string : data.hash, key);
	  }
	  return Map ? data.map.has(key) : assocHas(data.map, key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapSet(key, value) {
	  var data = this.__data__;
	  if (isKeyable(key)) {
	    hashSet(typeof key == 'string' ? data.string : data.hash, key, value);
	  } else if (Map) {
	    data.map.set(key, value);
	  } else {
	    assocSet(data.map, key, value);
	  }
	  return this;
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapClear;
	MapCache.prototype['delete'] = mapDelete;
	MapCache.prototype.get = mapGet;
	MapCache.prototype.has = mapHas;
	MapCache.prototype.set = mapSet;

	/**
	 * Removes `key` and its value from the associative array.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function assocDelete(array, key) {
	  var index = assocIndexOf(array, key);
	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = array.length - 1;
	  if (index == lastIndex) {
	    array.pop();
	  } else {
	    splice.call(array, index, 1);
	  }
	  return true;
	}

	/**
	 * Gets the associative array value for `key`.
	 *
	 * @private
	 * @param {Array} array The array to query.
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function assocGet(array, key) {
	  var index = assocIndexOf(array, key);
	  return index < 0 ? undefined : array[index][1];
	}

	/**
	 * Checks if an associative array value for `key` exists.
	 *
	 * @private
	 * @param {Array} array The array to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function assocHas(array, key) {
	  return assocIndexOf(array, key) > -1;
	}

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to search.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/**
	 * Sets the associative array `key` to `value`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 */
	function assocSet(array, key, value) {
	  var index = assocIndexOf(array, key);
	  if (index < 0) {
	    array.push([key, value]);
	  } else {
	    array[index][1] = value;
	  }
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object[key];
	  return isNative(value) ? value : undefined;
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return type == 'number' || type == 'boolean' ||
	    (type == 'string' && value != '__proto__') || value == null;
	}

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoize(function(string) {
	  var result = [];
	  toString(string).replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoizing function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result);
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Assign cache to `_.memoize`.
	memoize.Cache = MapCache;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'user': 'fred' };
	 * var other = { 'user': 'fred' };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified,
	 *  else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8 which returns 'object' for typed array and weak map constructors,
	  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified,
	 *  else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}

	/**
	 * Converts `value` to a string if it's not one. An empty string is returned
	 * for `null` and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (value == null) {
	    return '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	module.exports = stringToPath;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(145)(module), (function() { return this; }())))

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = toDate;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function toDate(date) {
	  (0, _assertString2.default)(date);
	  date = Date.parse(date);
	  return !isNaN(date) ? new Date(date) : null;
	}
	module.exports = exports['default'];

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = toFloat;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function toFloat(str) {
	  (0, _assertString2.default)(str);
	  return parseFloat(str);
	}
	module.exports = exports['default'];

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = toInt;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function toInt(str, radix) {
	  (0, _assertString2.default)(str);
	  return parseInt(str, radix || 10);
	}
	module.exports = exports['default'];

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = toBoolean;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function toBoolean(str, strict) {
	  (0, _assertString2.default)(str);
	  if (strict) {
	    return str === '1' || str === 'true';
	  }
	  return str !== '0' && str !== 'false' && str !== '';
	}
	module.exports = exports['default'];

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = equals;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function equals(str, comparison) {
	  (0, _assertString2.default)(str);
	  return str === comparison;
	}
	module.exports = exports['default'];

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = contains;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	var _toString = __webpack_require__(321);

	var _toString2 = _interopRequireDefault(_toString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function contains(str, elem) {
	  (0, _assertString2.default)(str);
	  return str.indexOf((0, _toString2.default)(elem)) >= 0;
	}
	module.exports = exports['default'];

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = matches;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function matches(str, pattern, modifiers) {
	  (0, _assertString2.default)(str);
	  if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {
	    pattern = new RegExp(pattern, modifiers);
	  }
	  return pattern.test(str);
	}
	module.exports = exports['default'];

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isEmail;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	var _merge = __webpack_require__(327);

	var _merge2 = _interopRequireDefault(_merge);

	var _isByteLength = __webpack_require__(296);

	var _isByteLength2 = _interopRequireDefault(_isByteLength);

	var _isFQDN = __webpack_require__(274);

	var _isFQDN2 = _interopRequireDefault(_isFQDN);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var default_email_options = {
	  allow_display_name: false,
	  allow_utf8_local_part: true,
	  require_tld: true
	};

	/* eslint-disable max-len */
	var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
	var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
	var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
	var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
	var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
	/* eslint-enable max-len */

	function isEmail(str, options) {
	  (0, _assertString2.default)(str);
	  options = (0, _merge2.default)(options, default_email_options);

	  if (options.allow_display_name) {
	    var display_email = str.match(displayName);
	    if (display_email) {
	      str = display_email[1];
	    }
	  }

	  var parts = str.split('@');
	  var domain = parts.pop();
	  var user = parts.join('@');

	  var lower_domain = domain.toLowerCase();
	  if (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com') {
	    user = user.replace(/\./g, '').toLowerCase();
	  }

	  if (!(0, _isByteLength2.default)(user, { max: 64 }) || !(0, _isByteLength2.default)(domain, { max: 256 })) {
	    return false;
	  }

	  if (!(0, _isFQDN2.default)(domain, { require_tld: options.require_tld })) {
	    return false;
	  }

	  if (user[0] === '"') {
	    user = user.slice(1, user.length - 1);
	    return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
	  }

	  var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;

	  var user_parts = user.split('.');
	  for (var i = 0; i < user_parts.length; i++) {
	    if (!pattern.test(user_parts[i])) {
	      return false;
	    }
	  }

	  return true;
	}
	module.exports = exports['default'];

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isURL;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	var _isFQDN = __webpack_require__(274);

	var _isFQDN2 = _interopRequireDefault(_isFQDN);

	var _isIP = __webpack_require__(273);

	var _isIP2 = _interopRequireDefault(_isIP);

	var _merge = __webpack_require__(327);

	var _merge2 = _interopRequireDefault(_merge);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var default_url_options = {
	  protocols: ['http', 'https', 'ftp'],
	  require_tld: true,
	  require_protocol: false,
	  require_valid_protocol: true,
	  allow_underscores: false,
	  allow_trailing_dot: false,
	  allow_protocol_relative_urls: false
	};

	function isURL(url, options) {
	  (0, _assertString2.default)(url);
	  if (!url || url.length >= 2083 || /\s/.test(url)) {
	    return false;
	  }
	  if (url.indexOf('mailto:') === 0) {
	    return false;
	  }
	  options = (0, _merge2.default)(options, default_url_options);
	  var protocol = void 0,
	      auth = void 0,
	      host = void 0,
	      hostname = void 0,
	      port = void 0,
	      port_str = void 0,
	      split = void 0;

	  split = url.split('#');
	  url = split.shift();

	  split = url.split('?');
	  url = split.shift();

	  split = url.split('://');
	  if (split.length > 1) {
	    protocol = split.shift();
	    if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
	      return false;
	    }
	  } else if (options.require_protocol) {
	    return false;
	  } else if (options.allow_protocol_relative_urls && url.substr(0, 2) === '//') {
	    split[0] = url.substr(2);
	  }
	  url = split.join('://');

	  split = url.split('/');
	  url = split.shift();
	  split = url.split('@');
	  if (split.length > 1) {
	    auth = split.shift();
	    if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
	      return false;
	    }
	  }
	  hostname = split.join('@');
	  split = hostname.split(':');
	  host = split.shift();
	  if (split.length) {
	    port_str = split.join(':');
	    port = parseInt(port_str, 10);
	    if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
	      return false;
	    }
	  }
	  if (!(0, _isIP2.default)(host) && !(0, _isFQDN2.default)(host, options) && host !== 'localhost') {
	    return false;
	  }
	  if (options.host_whitelist && options.host_whitelist.indexOf(host) === -1) {
	    return false;
	  }
	  if (options.host_blacklist && options.host_blacklist.indexOf(host) !== -1) {
	    return false;
	  }
	  return true;
	}
	module.exports = exports['default'];

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isMACAddress;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var macAddress = /^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$/;

	function isMACAddress(str) {
	  (0, _assertString2.default)(str);
	  return macAddress.test(str);
	}
	module.exports = exports['default'];

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isIP;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ipv4Maybe = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
	var ipv6Block = /^[0-9A-F]{1,4}$/i;

	function isIP(str) {
	  var version = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

	  (0, _assertString2.default)(str);
	  version = String(version);
	  if (!version) {
	    return isIP(str, 4) || isIP(str, 6);
	  } else if (version === '4') {
	    if (!ipv4Maybe.test(str)) {
	      return false;
	    }
	    var parts = str.split('.').sort(function (a, b) {
	      return a - b;
	    });
	    return parts[3] <= 255;
	  } else if (version === '6') {
	    var blocks = str.split(':');
	    var foundOmissionBlock = false; // marker to indicate ::

	    // At least some OS accept the last 32 bits of an IPv6 address
	    // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
	    // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
	    // and '::a.b.c.d' is deprecated, but also valid.
	    var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);
	    var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;

	    if (blocks.length > expectedNumberOfBlocks) {
	      return false;
	    }
	    // initial or final ::
	    if (str === '::') {
	      return true;
	    } else if (str.substr(0, 2) === '::') {
	      blocks.shift();
	      blocks.shift();
	      foundOmissionBlock = true;
	    } else if (str.substr(str.length - 2) === '::') {
	      blocks.pop();
	      blocks.pop();
	      foundOmissionBlock = true;
	    }

	    for (var i = 0; i < blocks.length; ++i) {
	      // test for a :: which can not be at the string start/end
	      // since those cases have been handled above
	      if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
	        if (foundOmissionBlock) {
	          return false; // multiple :: in address
	        }
	        foundOmissionBlock = true;
	      } else if (foundIPv4TransitionBlock && i === blocks.length - 1) {
	        // it has been checked before that the last
	        // block is a valid IPv4 address
	      } else if (!ipv6Block.test(blocks[i])) {
	          return false;
	        }
	    }
	    if (foundOmissionBlock) {
	      return blocks.length >= 1;
	    }
	    return blocks.length === expectedNumberOfBlocks;
	  }
	  return false;
	}
	module.exports = exports['default'];

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isFDQN;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	var _merge = __webpack_require__(327);

	var _merge2 = _interopRequireDefault(_merge);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var default_fqdn_options = {
	  require_tld: true,
	  allow_underscores: false,
	  allow_trailing_dot: false
	};

	function isFDQN(str, options) {
	  (0, _assertString2.default)(str);
	  options = (0, _merge2.default)(options, default_fqdn_options);

	  /* Remove the optional trailing dot before checking validity */
	  if (options.allow_trailing_dot && str[str.length - 1] === '.') {
	    str = str.substring(0, str.length - 1);
	  }
	  var parts = str.split('.');
	  if (options.require_tld) {
	    var tld = parts.pop();
	    if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
	      return false;
	    }
	  }
	  for (var part, i = 0; i < parts.length; i++) {
	    part = parts[i];
	    if (options.allow_underscores) {
	      part = part.replace(/_/g, '');
	    }
	    if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
	      return false;
	    }
	    if (/[\uff01-\uff5e]/.test(part)) {
	      // disallow full-width chars
	      return false;
	    }
	    if (part[0] === '-' || part[part.length - 1] === '-') {
	      return false;
	    }
	  }
	  return true;
	}
	module.exports = exports['default'];

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isBoolean;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isBoolean(str) {
	  (0, _assertString2.default)(str);
	  return ['true', 'false', '1', '0'].indexOf(str) >= 0;
	}
	module.exports = exports['default'];

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isAlpha;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	var _alpha = __webpack_require__(328);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isAlpha(str) {
	  var locale = arguments.length <= 1 || arguments[1] === undefined ? 'en-US' : arguments[1];

	  (0, _assertString2.default)(str);
	  if (locale in _alpha.alpha) {
	    return _alpha.alpha[locale].test(str);
	  }
	  throw new Error('Invalid locale \'' + locale + '\'');
	}
	module.exports = exports['default'];

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isAlphanumeric;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	var _alpha = __webpack_require__(328);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isAlphanumeric(str) {
	  var locale = arguments.length <= 1 || arguments[1] === undefined ? 'en-US' : arguments[1];

	  (0, _assertString2.default)(str);
	  if (locale in _alpha.alphanumeric) {
	    return _alpha.alphanumeric[locale].test(str);
	  }
	  throw new Error('Invalid locale \'' + locale + '\'');
	}
	module.exports = exports['default'];

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isNumeric;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var numeric = /^[-+]?[0-9]+$/;

	function isNumeric(str) {
	  (0, _assertString2.default)(str);
	  return numeric.test(str);
	}
	module.exports = exports['default'];

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isLowercase;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isLowercase(str) {
	  (0, _assertString2.default)(str);
	  return str === str.toLowerCase();
	}
	module.exports = exports['default'];

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isUppercase;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isUppercase(str) {
	  (0, _assertString2.default)(str);
	  return str === str.toUpperCase();
	}
	module.exports = exports['default'];

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isAscii;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ascii = /^[\x00-\x7F]+$/;

	function isAscii(str) {
	  (0, _assertString2.default)(str);
	  return ascii.test(str);
	}
	module.exports = exports['default'];

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.fullWidth = undefined;
	exports.default = isFullWidth;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var fullWidth = exports.fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;

	function isFullWidth(str) {
	  (0, _assertString2.default)(str);
	  return fullWidth.test(str);
	}

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.halfWidth = undefined;
	exports.default = isHalfWidth;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var halfWidth = exports.halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;

	function isHalfWidth(str) {
	  (0, _assertString2.default)(str);
	  return halfWidth.test(str);
	}

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isVariableWidth;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	var _isFullWidth = __webpack_require__(282);

	var _isHalfWidth = __webpack_require__(283);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isVariableWidth(str) {
	  (0, _assertString2.default)(str);
	  return _isFullWidth.fullWidth.test(str) && _isHalfWidth.halfWidth.test(str);
	}
	module.exports = exports['default'];

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isMultibyte;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var multibyte = /[^\x00-\x7F]/;

	function isMultibyte(str) {
	  (0, _assertString2.default)(str);
	  return multibyte.test(str);
	}
	module.exports = exports['default'];

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isSurrogatePair;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;

	function isSurrogatePair(str) {
	  (0, _assertString2.default)(str);
	  return surrogatePair.test(str);
	}
	module.exports = exports['default'];

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isInt;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;

	function isInt(str, options) {
	  (0, _assertString2.default)(str);
	  options = options || {};
	  return int.test(str) && (!options.hasOwnProperty('min') || str >= options.min) && (!options.hasOwnProperty('max') || str <= options.max);
	}
	module.exports = exports['default'];

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isFloat;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var float = /^(?:[-+]?(?:[0-9]+))?(?:\.[0-9]*)?(?:[eE][\+\-]?(?:[0-9]+))?$/;

	function isFloat(str, options) {
	  (0, _assertString2.default)(str);
	  options = options || {};
	  if (str === '' || str === '.') {
	    return false;
	  }
	  return float.test(str) && (!options.hasOwnProperty('min') || str >= options.min) && (!options.hasOwnProperty('max') || str <= options.max);
	}
	module.exports = exports['default'];

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isDecimal;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var decimal = /^[-+]?([0-9]+|\.[0-9]+|[0-9]+\.[0-9]+)$/;

	function isDecimal(str) {
	  (0, _assertString2.default)(str);
	  return str !== '' && decimal.test(str);
	}
	module.exports = exports['default'];

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isHexadecimal;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var hexadecimal = /^[0-9A-F]+$/i;

	function isHexadecimal(str) {
	  (0, _assertString2.default)(str);
	  return hexadecimal.test(str);
	}
	module.exports = exports['default'];

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isDivisibleBy;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	var _toFloat = __webpack_require__(264);

	var _toFloat2 = _interopRequireDefault(_toFloat);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isDivisibleBy(str, num) {
	  (0, _assertString2.default)(str);
	  return (0, _toFloat2.default)(str) % parseInt(num, 10) === 0;
	}
	module.exports = exports['default'];

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isHexColor;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{6})$/i;

	function isHexColor(str) {
	  (0, _assertString2.default)(str);
	  return hexcolor.test(str);
	}
	module.exports = exports['default'];

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.default = isJSON;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isJSON(str) {
	  (0, _assertString2.default)(str);
	  try {
	    var obj = JSON.parse(str);
	    return !!obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
	  } catch (e) {/* ignore */}
	  return false;
	}
	module.exports = exports['default'];

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isNull;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isNull(str) {
	  (0, _assertString2.default)(str);
	  return str.length === 0;
	}
	module.exports = exports['default'];

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.default = isLength;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* eslint-disable prefer-rest-params */
	function isLength(str, options) {
	  (0, _assertString2.default)(str);
	  var min = void 0;
	  var max = void 0;
	  if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
	    min = options.min || 0;
	    max = options.max;
	  } else {
	    // backwards compatibility: isLength(str, min [, max])
	    min = arguments[1];
	    max = arguments[2];
	  }
	  var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
	  var len = str.length - surrogatePairs.length;
	  return len >= min && (typeof max === 'undefined' || len <= max);
	}
	module.exports = exports['default'];

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.default = isByteLength;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* eslint-disable prefer-rest-params */
	function isByteLength(str, options) {
	  (0, _assertString2.default)(str);
	  var min = void 0;
	  var max = void 0;
	  if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
	    min = options.min || 0;
	    max = options.max;
	  } else {
	    // backwards compatibility: isByteLength(str, min [, max])
	    min = arguments[1];
	    max = arguments[2];
	  }
	  var len = encodeURI(str).split(/%..|./).length - 1;
	  return len >= min && (typeof max === 'undefined' || len <= max);
	}
	module.exports = exports['default'];

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isUUID;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var uuid = {
	  3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
	  4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
	  5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
	  all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
	};

	function isUUID(str) {
	  var version = arguments.length <= 1 || arguments[1] === undefined ? 'all' : arguments[1];

	  (0, _assertString2.default)(str);
	  var pattern = uuid[version];
	  return pattern && pattern.test(str);
	}
	module.exports = exports['default'];

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isMongoId;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	var _isHexadecimal = __webpack_require__(290);

	var _isHexadecimal2 = _interopRequireDefault(_isHexadecimal);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isMongoId(str) {
	  (0, _assertString2.default)(str);
	  return (0, _isHexadecimal2.default)(str) && str.length === 24;
	}
	module.exports = exports['default'];

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isDate;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	var _isISO = __webpack_require__(308);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function getTimezoneOffset(str) {
	  var iso8601Parts = str.match(_isISO.iso8601);
	  var timezone = void 0,
	      sign = void 0,
	      hours = void 0,
	      minutes = void 0;
	  if (!iso8601Parts) {
	    str = str.toLowerCase();
	    timezone = str.match(/(?:\s|gmt\s*)(-|\+)(\d{1,4})(\s|$)/);
	    if (!timezone) {
	      return str.indexOf('gmt') !== -1 ? 0 : null;
	    }
	    sign = timezone[1];
	    var offset = timezone[2];
	    if (offset.length === 3) {
	      offset = '0' + offset;
	    }
	    if (offset.length <= 2) {
	      hours = 0;
	      minutes = parseInt(offset, 10);
	    } else {
	      hours = parseInt(offset.slice(0, 2), 10);
	      minutes = parseInt(offset.slice(2, 4), 10);
	    }
	  } else {
	    timezone = iso8601Parts[21];
	    if (!timezone) {
	      // if no hour/minute was provided, the date is GMT
	      return !iso8601Parts[12] ? 0 : null;
	    }
	    if (timezone === 'z' || timezone === 'Z') {
	      return 0;
	    }
	    sign = iso8601Parts[22];
	    if (timezone.indexOf(':') !== -1) {
	      hours = parseInt(iso8601Parts[23], 10);
	      minutes = parseInt(iso8601Parts[24], 10);
	    } else {
	      hours = 0;
	      minutes = parseInt(iso8601Parts[23], 10);
	    }
	  }
	  return (hours * 60 + minutes) * (sign === '-' ? 1 : -1);
	}

	function isDate(str) {
	  (0, _assertString2.default)(str);
	  var normalizedDate = new Date(Date.parse(str));
	  if (isNaN(normalizedDate)) {
	    return false;
	  }

	  // normalizedDate is in the user's timezone. Apply the input
	  // timezone offset to the date so that the year and day match
	  // the input
	  var timezoneOffset = getTimezoneOffset(str);
	  if (timezoneOffset !== null) {
	    var timezoneDifference = normalizedDate.getTimezoneOffset() - timezoneOffset;
	    normalizedDate = new Date(normalizedDate.getTime() + 60000 * timezoneDifference);
	  }

	  var day = String(normalizedDate.getDate());
	  var dayOrYear = void 0,
	      dayOrYearMatches = void 0,
	      year = void 0;
	  // check for valid double digits that could be late days
	  // check for all matches since a string like '12/23' is a valid date
	  // ignore everything with nearby colons
	  dayOrYearMatches = str.match(/(^|[^:\d])[23]\d([^:\d]|$)/g);
	  if (!dayOrYearMatches) {
	    return true;
	  }
	  dayOrYear = dayOrYearMatches.map(function (digitString) {
	    return digitString.match(/\d+/g)[0];
	  }).join('/');

	  year = String(normalizedDate.getFullYear()).slice(-2);
	  if (dayOrYear === day || dayOrYear === year) {
	    return true;
	  } else if (dayOrYear === '' + day / year || dayOrYear === '' + year / day) {
	    return true;
	  }
	  return false;
	}
	module.exports = exports['default'];

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isAfter;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	var _toDate = __webpack_require__(263);

	var _toDate2 = _interopRequireDefault(_toDate);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isAfter(str) {
	  var date = arguments.length <= 1 || arguments[1] === undefined ? String(new Date()) : arguments[1];

	  (0, _assertString2.default)(str);
	  var comparison = (0, _toDate2.default)(date);
	  var original = (0, _toDate2.default)(str);
	  return !!(original && comparison && original > comparison);
	}
	module.exports = exports['default'];

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isBefore;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	var _toDate = __webpack_require__(263);

	var _toDate2 = _interopRequireDefault(_toDate);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isBefore(str) {
	  var date = arguments.length <= 1 || arguments[1] === undefined ? String(new Date()) : arguments[1];

	  (0, _assertString2.default)(str);
	  var comparison = (0, _toDate2.default)(date);
	  var original = (0, _toDate2.default)(str);
	  return !!(original && comparison && original < comparison);
	}
	module.exports = exports['default'];

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.default = isIn;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	var _toString = __webpack_require__(321);

	var _toString2 = _interopRequireDefault(_toString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isIn(str, options) {
	  (0, _assertString2.default)(str);
	  var i = void 0;
	  if (Object.prototype.toString.call(options) === '[object Array]') {
	    var array = [];
	    for (i in options) {
	      if ({}.hasOwnProperty.call(options, i)) {
	        array[i] = (0, _toString2.default)(options[i]);
	      }
	    }
	    return array.indexOf(str) >= 0;
	  } else if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
	    return options.hasOwnProperty(str);
	  } else if (options && typeof options.indexOf === 'function') {
	    return options.indexOf(str) >= 0;
	  }
	  return false;
	}
	module.exports = exports['default'];

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isCreditCard;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* eslint-disable max-len */
	var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/;
	/* eslint-enable max-len */

	function isCreditCard(str) {
	  (0, _assertString2.default)(str);
	  var sanitized = str.replace(/[^0-9]+/g, '');
	  if (!creditCard.test(sanitized)) {
	    return false;
	  }
	  var sum = 0;
	  var digit = void 0;
	  var tmpNum = void 0;
	  var shouldDouble = void 0;
	  for (var i = sanitized.length - 1; i >= 0; i--) {
	    digit = sanitized.substring(i, i + 1);
	    tmpNum = parseInt(digit, 10);
	    if (shouldDouble) {
	      tmpNum *= 2;
	      if (tmpNum >= 10) {
	        sum += tmpNum % 10 + 1;
	      } else {
	        sum += tmpNum;
	      }
	    } else {
	      sum += tmpNum;
	    }
	    shouldDouble = !shouldDouble;
	  }
	  return !!(sum % 10 === 0 ? sanitized : false);
	}
	module.exports = exports['default'];

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isISIN;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;

	function isISIN(str) {
	  (0, _assertString2.default)(str);
	  if (!isin.test(str)) {
	    return false;
	  }

	  var checksumStr = str.replace(/[A-Z]/g, function (character) {
	    return parseInt(character, 36);
	  });

	  var sum = 0;
	  var digit = void 0;
	  var tmpNum = void 0;
	  var shouldDouble = true;
	  for (var i = checksumStr.length - 2; i >= 0; i--) {
	    digit = checksumStr.substring(i, i + 1);
	    tmpNum = parseInt(digit, 10);
	    if (shouldDouble) {
	      tmpNum *= 2;
	      if (tmpNum >= 10) {
	        sum += tmpNum + 1;
	      } else {
	        sum += tmpNum;
	      }
	    } else {
	      sum += tmpNum;
	    }
	    shouldDouble = !shouldDouble;
	  }

	  return parseInt(str.substr(str.length - 1), 10) === (10000 - sum) % 10;
	}
	module.exports = exports['default'];

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isISBN;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var isbn10Maybe = /^(?:[0-9]{9}X|[0-9]{10})$/;
	var isbn13Maybe = /^(?:[0-9]{13})$/;
	var factor = [1, 3];

	function isISBN(str) {
	  var version = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

	  (0, _assertString2.default)(str);
	  version = String(version);
	  if (!version) {
	    return isISBN(str, 10) || isISBN(str, 13);
	  }
	  var sanitized = str.replace(/[\s-]+/g, '');
	  var checksum = 0;
	  var i = void 0;
	  if (version === '10') {
	    if (!isbn10Maybe.test(sanitized)) {
	      return false;
	    }
	    for (i = 0; i < 9; i++) {
	      checksum += (i + 1) * sanitized.charAt(i);
	    }
	    if (sanitized.charAt(9) === 'X') {
	      checksum += 10 * 10;
	    } else {
	      checksum += 10 * sanitized.charAt(9);
	    }
	    if (checksum % 11 === 0) {
	      return !!sanitized;
	    }
	  } else if (version === '13') {
	    if (!isbn13Maybe.test(sanitized)) {
	      return false;
	    }
	    for (i = 0; i < 12; i++) {
	      checksum += factor[i % 2] * sanitized.charAt(i);
	    }
	    if (sanitized.charAt(12) - (10 - checksum % 10) % 10 === 0) {
	      return !!sanitized;
	    }
	  }
	  return false;
	}
	module.exports = exports['default'];

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isMobilePhone;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* eslint-disable max-len */
	var phones = {
	  'ar-SY': /^(!?(\+?963)|0)?9\d{8}$/,
	  'en-US': /^(\+?1)?[2-9]\d{2}[2-9](?!11)\d{6}$/,
	  'cs-CZ': /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
	  'de-DE': /^(\+?49[ \.\-])?([\(]{1}[0-9]{1,6}[\)])?([0-9 \.\-\/]{3,20})((x|ext|extension)[ ]?[0-9]{1,4})?$/,
	  'el-GR': /^(\+?30)?(69\d{8})$/,
	  'en-AU': /^(\+?61|0)4\d{8}$/,
	  'en-GB': /^(\+?44|0)7\d{9}$/,
	  'en-HK': /^(\+?852\-?)?[569]\d{3}\-?\d{4}$/,
	  'en-IN': /^(\+?91|0)?[789]\d{9}$/,
	  'en-NZ': /^(\+?64|0)2\d{7,9}$/,
	  'en-ZA': /^(\+?27|0)\d{9}$/,
	  'en-ZM': /^(\+?26)?09[567]\d{7}$/,
	  'es-ES': /^(\+?34)?(6\d{1}|7[1234])\d{7}$/,
	  'fi-FI': /^(\+?358|0)\s?(4(0|1|2|4|5)?|50)\s?(\d\s?){4,8}\d$/,
	  'fr-FR': /^(\+?33|0)[67]\d{8}$/,
	  'ms-MY': /^(\+?6?01){1}(([145]{1}(\-|\s)?\d{7,8})|([236789]{1}(\s|\-)?\d{7}))$/,
	  'nb-NO': /^(\+?47)?[49]\d{7}$/,
	  'nn-NO': /^(\+?47)?[49]\d{7}$/,
	  'pt-BR': /^(\+?55|0)\-?[1-9]{2}\-?[2-9]{1}\d{3,4}\-?\d{4}$/,
	  'pt-PT': /^(\+?351)?9[1236]\d{7}$/,
	  'ru-RU': /^(\+?7|8)?9\d{9}$/,
	  'tr-TR': /^(\+?90|0)?5\d{9}$/,
	  'vi-VN': /^(\+?84|0)?((1(2([0-9])|6([2-9])|88|99))|(9((?!5)[0-9])))([0-9]{7})$/,
	  'zh-CN': /^(\+?0?86\-?)?((13\d|14[57]|15[^4,\D]|17[678]|18\d)\d{8}|170[059]\d{7})$/,
	  'zh-TW': /^(\+?886\-?|0)?9\d{8}$/
	};
	/* eslint-enable max-len */

	function isMobilePhone(str, locale) {
	  (0, _assertString2.default)(str);
	  if (locale in phones) {
	    return phones[locale].test(str);
	  }
	  return false;
	}
	module.exports = exports['default'];

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isCurrency;

	var _merge = __webpack_require__(327);

	var _merge2 = _interopRequireDefault(_merge);

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function currencyRegex(options) {
	  var symbol = '(\\' + options.symbol.replace(/\./g, '\\.') + ')' + (options.require_symbol ? '' : '?'),
	      negative = '-?',
	      whole_dollar_amount_without_sep = '[1-9]\\d*',
	      whole_dollar_amount_with_sep = '[1-9]\\d{0,2}(\\' + options.thousands_separator + '\\d{3})*',
	      valid_whole_dollar_amounts = ['0', whole_dollar_amount_without_sep, whole_dollar_amount_with_sep],
	      whole_dollar_amount = '(' + valid_whole_dollar_amounts.join('|') + ')?',
	      decimal_amount = '(\\' + options.decimal_separator + '\\d{2})?';
	  var pattern = whole_dollar_amount + decimal_amount;

	  // default is negative sign before symbol, but there are two other options (besides parens)
	  if (options.allow_negatives && !options.parens_for_negatives) {
	    if (options.negative_sign_after_digits) {
	      pattern += negative;
	    } else if (options.negative_sign_before_digits) {
	      pattern = negative + pattern;
	    }
	  }

	  // South African Rand, for example, uses R 123 (space) and R-123 (no space)
	  if (options.allow_negative_sign_placeholder) {
	    pattern = '( (?!\\-))?' + pattern;
	  } else if (options.allow_space_after_symbol) {
	    pattern = ' ?' + pattern;
	  } else if (options.allow_space_after_digits) {
	    pattern += '( (?!$))?';
	  }

	  if (options.symbol_after_digits) {
	    pattern += symbol;
	  } else {
	    pattern = symbol + pattern;
	  }

	  if (options.allow_negatives) {
	    if (options.parens_for_negatives) {
	      pattern = '(\\(' + pattern + '\\)|' + pattern + ')';
	    } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
	      pattern = negative + pattern;
	    }
	  }

	  /* eslint-disable prefer-template */
	  return new RegExp('^' +
	  // ensure there's a dollar and/or decimal amount, and that
	  // it doesn't start with a space or a negative sign followed by a space
	  '(?!-? )(?=.*\\d)' + pattern + '$');
	  /* eslint-enable prefer-template */
	}

	var default_currency_options = {
	  symbol: '$',
	  require_symbol: false,
	  allow_space_after_symbol: false,
	  symbol_after_digits: false,
	  allow_negatives: true,
	  parens_for_negatives: false,
	  negative_sign_before_digits: false,
	  negative_sign_after_digits: false,
	  allow_negative_sign_placeholder: false,
	  thousands_separator: ',',
	  decimal_separator: '.',
	  allow_space_after_digits: false
	};

	function isCurrency(str, options) {
	  (0, _assertString2.default)(str);
	  options = (0, _merge2.default)(options, default_currency_options);
	  return currencyRegex(options).test(str);
	}
	module.exports = exports['default'];

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.iso8601 = undefined;

	exports.default = function (str) {
	  (0, _assertString2.default)(str);
	  return iso8601.test(str);
	};

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* eslint-disable max-len */
	// from http://goo.gl/0ejHHW
	var iso8601 = exports.iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24\:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
	/* eslint-enable max-len */

/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isBase64;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var notBase64 = /[^A-Z0-9+\/=]/i;

	function isBase64(str) {
	  (0, _assertString2.default)(str);
	  var len = str.length;
	  if (!len || len % 4 !== 0 || notBase64.test(str)) {
	    return false;
	  }
	  var firstPaddingChar = str.indexOf('=');
	  return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === '=';
	}
	module.exports = exports['default'];

/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isDataURI;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var dataURI = /^\s*data:([a-z]+\/[a-z0-9\-\+]+(;[a-z\-]+\=[a-z0-9\-]+)?)?(;base64)?,[a-z0-9\!\$\&\'\,\(\)\*\+\,\;\=\-\.\_\~\:\@\/\?\%\s]*\s*$/i; // eslint-disable-line max-len

	function isDataURI(str) {
	  (0, _assertString2.default)(str);
	  return dataURI.test(str);
	}
	module.exports = exports['default'];

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ltrim;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function ltrim(str, chars) {
	  (0, _assertString2.default)(str);
	  var pattern = chars ? new RegExp('^[' + chars + ']+', 'g') : /^\s+/g;
	  return str.replace(pattern, '');
	}
	module.exports = exports['default'];

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = rtrim;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function rtrim(str, chars) {
	  (0, _assertString2.default)(str);
	  var pattern = chars ? new RegExp('[' + chars + ']+$', 'g') : /\s+$/g;
	  return str.replace(pattern, '');
	}
	module.exports = exports['default'];

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = trim;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function trim(str, chars) {
	  (0, _assertString2.default)(str);
	  var pattern = chars ? new RegExp('^[' + chars + ']+|[' + chars + ']+$', 'g') : /^\s+|\s+$/g;
	  return str.replace(pattern, '');
	}
	module.exports = exports['default'];

/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	      value: true
	});
	exports.default = escape;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function escape(str) {
	      (0, _assertString2.default)(str);
	      return str.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\//g, '&#x2F;').replace(/\`/g, '&#96;');
	}
	module.exports = exports['default'];

/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	      value: true
	});
	exports.default = unescape;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function unescape(str) {
	      (0, _assertString2.default)(str);
	      return str.replace(/&amp;/g, '&').replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&#x2F;/g, '\/').replace(/&#96;/g, '\`');
	}
	module.exports = exports['default'];

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = stripLow;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	var _blacklist = __webpack_require__(318);

	var _blacklist2 = _interopRequireDefault(_blacklist);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function stripLow(str, keep_new_lines) {
	  (0, _assertString2.default)(str);
	  var chars = keep_new_lines ? '\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F' : '\\x00-\\x1F\\x7F';
	  return (0, _blacklist2.default)(str, chars);
	}
	module.exports = exports['default'];

/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = whitelist;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function whitelist(str, chars) {
	  (0, _assertString2.default)(str);
	  return str.replace(new RegExp('[^' + chars + ']+', 'g'), '');
	}
	module.exports = exports['default'];

/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = blacklist;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function blacklist(str, chars) {
	  (0, _assertString2.default)(str);
	  return str.replace(new RegExp('[' + chars + ']+', 'g'), '');
	}
	module.exports = exports['default'];

/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isWhitelisted;

	var _assertString = __webpack_require__(326);

	var _assertString2 = _interopRequireDefault(_assertString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isWhitelisted(str, chars) {
	  (0, _assertString2.default)(str);
	  for (var i = str.length - 1; i >= 0; i--) {
	    if (chars.indexOf(str[i]) === -1) {
	      return false;
	    }
	  }
	  return true;
	}
	module.exports = exports['default'];

/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = normalizeEmail;

	var _isEmail = __webpack_require__(270);

	var _isEmail2 = _interopRequireDefault(_isEmail);

	var _merge = __webpack_require__(327);

	var _merge2 = _interopRequireDefault(_merge);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var default_normalize_email_options = {
	  lowercase: true,
	  remove_dots: true,
	  remove_extension: true
	};

	function normalizeEmail(email, options) {
	  options = (0, _merge2.default)(options, default_normalize_email_options);
	  if (!(0, _isEmail2.default)(email)) {
	    return false;
	  }
	  var parts = email.split('@', 2);
	  parts[1] = parts[1].toLowerCase();
	  if (parts[1] === 'gmail.com' || parts[1] === 'googlemail.com') {
	    if (options.remove_extension) {
	      parts[0] = parts[0].split('+')[0];
	    }
	    if (options.remove_dots) {
	      parts[0] = parts[0].replace(/\./g, '');
	    }
	    if (!parts[0].length) {
	      return false;
	    }
	    parts[0] = parts[0].toLowerCase();
	    parts[1] = 'gmail.com';
	  } else if (options.lowercase) {
	    parts[0] = parts[0].toLowerCase();
	  }
	  return parts.join('@');
	}
	module.exports = exports['default'];

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	exports.default = toString;
	function toString(input) {
	  if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' && input !== null) {
	    if (typeof input.toString === 'function') {
	      input = input.toString();
	    } else {
	      input = '[object Object]';
	    }
	  } else if (input === null || typeof input === 'undefined' || isNaN(input) && !input.length) {
	    input = '';
	  }
	  return String(input);
	}
	module.exports = exports['default'];

/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLBuilder, XMLDeclaration, XMLDocType, XMLElement, XMLStringifier;

	  XMLStringifier = __webpack_require__(330);

	  XMLDeclaration = __webpack_require__(331);

	  XMLDocType = __webpack_require__(332);

	  XMLElement = __webpack_require__(333);

	  module.exports = XMLBuilder = (function() {
	    function XMLBuilder(name, options) {
	      var root, temp;
	      if (name == null) {
	        throw new Error("Root element needs a name");
	      }
	      if (options == null) {
	        options = {};
	      }
	      this.options = options;
	      this.stringify = new XMLStringifier(options);
	      temp = new XMLElement(this, 'doc');
	      root = temp.element(name);
	      root.isRoot = true;
	      root.documentObject = this;
	      this.rootObject = root;
	      if (!options.headless) {
	        root.declaration(options);
	        if ((options.pubID != null) || (options.sysID != null)) {
	          root.doctype(options);
	        }
	      }
	    }

	    XMLBuilder.prototype.root = function() {
	      return this.rootObject;
	    };

	    XMLBuilder.prototype.end = function(options) {
	      return this.toString(options);
	    };

	    XMLBuilder.prototype.toString = function(options) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      r = '';
	      if (this.xmldec != null) {
	        r += this.xmldec.toString(options);
	      }
	      if (this.doctype != null) {
	        r += this.doctype.toString(options);
	      }
	      r += this.rootObject.toString(options);
	      if (pretty && r.slice(-newline.length) === newline) {
	        r = r.slice(0, -newline.length);
	      }
	      return r;
	    };

	    return XMLBuilder;

	  })();

	}).call(this);


/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = assertString;
	function assertString(input) {
	  if (typeof input !== 'string') {
	    throw new TypeError('This library (validator.js) validates strings only');
	  }
	}
	module.exports = exports['default'];

/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = merge;
	function merge() {
	  var obj = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var defaults = arguments[1];

	  for (var key in defaults) {
	    if (typeof obj[key] === 'undefined') {
	      obj[key] = defaults[key];
	    }
	  }
	  return obj;
	}
	module.exports = exports['default'];

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var alpha = exports.alpha = {
	  'en-US': /^[A-Z]+$/i,
	  'cs-CZ': /^[A-Z]+$/i,
	  'de-DE': /^[A-Z]+$/i,
	  'es-ES': /^[A-Z]+$/i,
	  'fr-FR': /^[A-Z]+$/i,
	  'nl-NL': /^[A-Z]+$/i,
	  'pl-PL': /^[A-Z]+$/i,
	  'pt-PT': /^[A-Z]+$/i,
	  'ru-RU': /^[--]+$/i,
	  'tr-TR': /^[A-Z]+$/i,
	  ar: /^[]+$/
	};

	var alphanumeric = exports.alphanumeric = {
	  'en-US': /^[0-9A-Z]+$/i,
	  'cs-CZ': /^[0-9A-Z]+$/i,
	  'de-DE': /^[0-9A-Z]+$/i,
	  'es-ES': /^[0-9A-Z]+$/i,
	  'fr-FR': /^[0-9A-Z]+$/i,
	  'nl-NL': /^[0-9A-Z]+$/i,
	  'pl-PL': /^[0-9A-Z]+$/i,
	  'pt-PT': /^[0-9A-Z]+$/i,
	  'ru-RU': /^[0-9--]+$/i,
	  'tr-TR': /^[0-9A-Z]+$/i,
	  ar: /^[0-9]+$/
	};

	var englishLocales = exports.englishLocales = ['AU', 'GB', 'HK', 'IN', 'NZ', 'ZA', 'ZM'];

	for (var locale, i = 0; i < englishLocales.length; i++) {
	  locale = 'en-' + englishLocales[i];
	  alpha[locale] = alpha['en-US'];
	  alphanumeric[locale] = alphanumeric['en-US'];
	}

	// Source: http://www.localeplanet.com/java/
	var arabicLocales = exports.arabicLocales = ['AE', 'BH', 'DZ', 'EG', 'IQ', 'JO', 'KW', 'LB', 'LY', 'MA', 'QM', 'QA', 'SA', 'SD', 'SY', 'TN', 'YE'];

	for (var _locale, _i = 0; _i < arabicLocales.length; _i++) {
	  _locale = 'ar-' + arabicLocales[_i];
	  alpha[_locale] = alpha.ar;
	  alphanumeric[_locale] = alphanumeric.ar;
	}

/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.

	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = Buffer.isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(92).Buffer))

/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLStringifier,
	    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    hasProp = {}.hasOwnProperty;

	  module.exports = XMLStringifier = (function() {
	    function XMLStringifier(options) {
	      this.assertLegalChar = bind(this.assertLegalChar, this);
	      var key, ref, value;
	      this.allowSurrogateChars = options != null ? options.allowSurrogateChars : void 0;
	      this.noDoubleEncoding = options != null ? options.noDoubleEncoding : void 0;
	      ref = (options != null ? options.stringify : void 0) || {};
	      for (key in ref) {
	        if (!hasProp.call(ref, key)) continue;
	        value = ref[key];
	        this[key] = value;
	      }
	    }

	    XMLStringifier.prototype.eleName = function(val) {
	      val = '' + val || '';
	      return this.assertLegalChar(val);
	    };

	    XMLStringifier.prototype.eleText = function(val) {
	      val = '' + val || '';
	      return this.assertLegalChar(this.elEscape(val));
	    };

	    XMLStringifier.prototype.cdata = function(val) {
	      val = '' + val || '';
	      if (val.match(/]]>/)) {
	        throw new Error("Invalid CDATA text: " + val);
	      }
	      return this.assertLegalChar(val);
	    };

	    XMLStringifier.prototype.comment = function(val) {
	      val = '' + val || '';
	      if (val.match(/--/)) {
	        throw new Error("Comment text cannot contain double-hypen: " + val);
	      }
	      return this.assertLegalChar(val);
	    };

	    XMLStringifier.prototype.raw = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.attName = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.attValue = function(val) {
	      val = '' + val || '';
	      return this.attEscape(val);
	    };

	    XMLStringifier.prototype.insTarget = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.insValue = function(val) {
	      val = '' + val || '';
	      if (val.match(/\?>/)) {
	        throw new Error("Invalid processing instruction value: " + val);
	      }
	      return val;
	    };

	    XMLStringifier.prototype.xmlVersion = function(val) {
	      val = '' + val || '';
	      if (!val.match(/1\.[0-9]+/)) {
	        throw new Error("Invalid version number: " + val);
	      }
	      return val;
	    };

	    XMLStringifier.prototype.xmlEncoding = function(val) {
	      val = '' + val || '';
	      if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-]|-)*$/)) {
	        throw new Error("Invalid encoding: " + val);
	      }
	      return val;
	    };

	    XMLStringifier.prototype.xmlStandalone = function(val) {
	      if (val) {
	        return "yes";
	      } else {
	        return "no";
	      }
	    };

	    XMLStringifier.prototype.dtdPubID = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.dtdSysID = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.dtdElementValue = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.dtdAttType = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.dtdAttDefault = function(val) {
	      if (val != null) {
	        return '' + val || '';
	      } else {
	        return val;
	      }
	    };

	    XMLStringifier.prototype.dtdEntityValue = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.dtdNData = function(val) {
	      return '' + val || '';
	    };

	    XMLStringifier.prototype.convertAttKey = '@';

	    XMLStringifier.prototype.convertPIKey = '?';

	    XMLStringifier.prototype.convertTextKey = '#text';

	    XMLStringifier.prototype.convertCDataKey = '#cdata';

	    XMLStringifier.prototype.convertCommentKey = '#comment';

	    XMLStringifier.prototype.convertRawKey = '#raw';

	    XMLStringifier.prototype.assertLegalChar = function(str) {
	      var chars, chr;
	      if (this.allowSurrogateChars) {
	        chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uFFFE-\uFFFF]/;
	      } else {
	        chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uD800-\uDFFF\uFFFE-\uFFFF]/;
	      }
	      chr = str.match(chars);
	      if (chr) {
	        throw new Error("Invalid character (" + chr + ") in string: " + str + " at index " + chr.index);
	      }
	      return str;
	    };

	    XMLStringifier.prototype.elEscape = function(str) {
	      var ampregex;
	      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
	      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
	    };

	    XMLStringifier.prototype.attEscape = function(str) {
	      var ampregex;
	      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
	      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;');
	    };

	    return XMLStringifier;

	  })();

	}).call(this);


/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLDeclaration, XMLNode, create, isObject,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  create = __webpack_require__(335);

	  isObject = __webpack_require__(336);

	  XMLNode = __webpack_require__(337);

	  module.exports = XMLDeclaration = (function(superClass) {
	    extend(XMLDeclaration, superClass);

	    function XMLDeclaration(parent, version, encoding, standalone) {
	      var ref;
	      XMLDeclaration.__super__.constructor.call(this, parent);
	      if (isObject(version)) {
	        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
	      }
	      if (!version) {
	        version = '1.0';
	      }
	      this.version = this.stringify.xmlVersion(version);
	      if (encoding != null) {
	        this.encoding = this.stringify.xmlEncoding(encoding);
	      }
	      if (standalone != null) {
	        this.standalone = this.stringify.xmlStandalone(standalone);
	      }
	    }

	    XMLDeclaration.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += '<?xml';
	      r += ' version="' + this.version + '"';
	      if (this.encoding != null) {
	        r += ' encoding="' + this.encoding + '"';
	      }
	      if (this.standalone != null) {
	        r += ' standalone="' + this.standalone + '"';
	      }
	      r += '?>';
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLDeclaration;

	  })(XMLNode);

	}).call(this);


/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLProcessingInstruction, create, isObject;

	  create = __webpack_require__(335);

	  isObject = __webpack_require__(336);

	  XMLCData = __webpack_require__(342);

	  XMLComment = __webpack_require__(343);

	  XMLDTDAttList = __webpack_require__(344);

	  XMLDTDEntity = __webpack_require__(345);

	  XMLDTDElement = __webpack_require__(346);

	  XMLDTDNotation = __webpack_require__(347);

	  XMLProcessingInstruction = __webpack_require__(341);

	  module.exports = XMLDocType = (function() {
	    function XMLDocType(parent, pubID, sysID) {
	      var ref, ref1;
	      this.documentObject = parent;
	      this.stringify = this.documentObject.stringify;
	      this.children = [];
	      if (isObject(pubID)) {
	        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
	      }
	      if (sysID == null) {
	        ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
	      }
	      if (pubID != null) {
	        this.pubID = this.stringify.dtdPubID(pubID);
	      }
	      if (sysID != null) {
	        this.sysID = this.stringify.dtdSysID(sysID);
	      }
	    }

	    XMLDocType.prototype.element = function(name, value) {
	      var child;
	      child = new XMLDTDElement(this, name, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
	      var child;
	      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.entity = function(name, value) {
	      var child;
	      child = new XMLDTDEntity(this, false, name, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.pEntity = function(name, value) {
	      var child;
	      child = new XMLDTDEntity(this, true, name, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.notation = function(name, value) {
	      var child;
	      child = new XMLDTDNotation(this, name, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.cdata = function(value) {
	      var child;
	      child = new XMLCData(this, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.comment = function(value) {
	      var child;
	      child = new XMLComment(this, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.instruction = function(target, value) {
	      var child;
	      child = new XMLProcessingInstruction(this, target, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLDocType.prototype.root = function() {
	      return this.documentObject.root();
	    };

	    XMLDocType.prototype.document = function() {
	      return this.documentObject;
	    };

	    XMLDocType.prototype.toString = function(options, level) {
	      var child, i, indent, len, newline, offset, pretty, r, ref, ref1, ref2, ref3, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += '<!DOCTYPE ' + this.root().name;
	      if (this.pubID && this.sysID) {
	        r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
	      } else if (this.sysID) {
	        r += ' SYSTEM "' + this.sysID + '"';
	      }
	      if (this.children.length > 0) {
	        r += ' [';
	        if (pretty) {
	          r += newline;
	        }
	        ref3 = this.children;
	        for (i = 0, len = ref3.length; i < len; i++) {
	          child = ref3[i];
	          r += child.toString(options, level + 1);
	        }
	        r += ']';
	      }
	      r += '>';
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    XMLDocType.prototype.ele = function(name, value) {
	      return this.element(name, value);
	    };

	    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
	      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
	    };

	    XMLDocType.prototype.ent = function(name, value) {
	      return this.entity(name, value);
	    };

	    XMLDocType.prototype.pent = function(name, value) {
	      return this.pEntity(name, value);
	    };

	    XMLDocType.prototype.not = function(name, value) {
	      return this.notation(name, value);
	    };

	    XMLDocType.prototype.dat = function(value) {
	      return this.cdata(value);
	    };

	    XMLDocType.prototype.com = function(value) {
	      return this.comment(value);
	    };

	    XMLDocType.prototype.ins = function(target, value) {
	      return this.instruction(target, value);
	    };

	    XMLDocType.prototype.up = function() {
	      return this.root();
	    };

	    XMLDocType.prototype.doc = function() {
	      return this.document();
	    };

	    return XMLDocType;

	  })();

	}).call(this);


/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLAttribute, XMLElement, XMLNode, XMLProcessingInstruction, create, every, isFunction, isObject,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  create = __webpack_require__(335);

	  isObject = __webpack_require__(336);

	  isFunction = __webpack_require__(338);

	  every = __webpack_require__(339);

	  XMLNode = __webpack_require__(337);

	  XMLAttribute = __webpack_require__(340);

	  XMLProcessingInstruction = __webpack_require__(341);

	  module.exports = XMLElement = (function(superClass) {
	    extend(XMLElement, superClass);

	    function XMLElement(parent, name, attributes) {
	      XMLElement.__super__.constructor.call(this, parent);
	      if (name == null) {
	        throw new Error("Missing element name");
	      }
	      this.name = this.stringify.eleName(name);
	      this.children = [];
	      this.instructions = [];
	      this.attributes = {};
	      if (attributes != null) {
	        this.attribute(attributes);
	      }
	    }

	    XMLElement.prototype.clone = function() {
	      var att, attName, clonedSelf, i, len, pi, ref, ref1;
	      clonedSelf = create(XMLElement.prototype, this);
	      if (clonedSelf.isRoot) {
	        clonedSelf.documentObject = null;
	      }
	      clonedSelf.attributes = {};
	      ref = this.attributes;
	      for (attName in ref) {
	        if (!hasProp.call(ref, attName)) continue;
	        att = ref[attName];
	        clonedSelf.attributes[attName] = att.clone();
	      }
	      clonedSelf.instructions = [];
	      ref1 = this.instructions;
	      for (i = 0, len = ref1.length; i < len; i++) {
	        pi = ref1[i];
	        clonedSelf.instructions.push(pi.clone());
	      }
	      clonedSelf.children = [];
	      this.children.forEach(function(child) {
	        var clonedChild;
	        clonedChild = child.clone();
	        clonedChild.parent = clonedSelf;
	        return clonedSelf.children.push(clonedChild);
	      });
	      return clonedSelf;
	    };

	    XMLElement.prototype.attribute = function(name, value) {
	      var attName, attValue;
	      if (name != null) {
	        name = name.valueOf();
	      }
	      if (isObject(name)) {
	        for (attName in name) {
	          if (!hasProp.call(name, attName)) continue;
	          attValue = name[attName];
	          this.attribute(attName, attValue);
	        }
	      } else {
	        if (isFunction(value)) {
	          value = value.apply();
	        }
	        if (!this.options.skipNullAttributes || (value != null)) {
	          this.attributes[name] = new XMLAttribute(this, name, value);
	        }
	      }
	      return this;
	    };

	    XMLElement.prototype.removeAttribute = function(name) {
	      var attName, i, len;
	      if (name == null) {
	        throw new Error("Missing attribute name");
	      }
	      name = name.valueOf();
	      if (Array.isArray(name)) {
	        for (i = 0, len = name.length; i < len; i++) {
	          attName = name[i];
	          delete this.attributes[attName];
	        }
	      } else {
	        delete this.attributes[name];
	      }
	      return this;
	    };

	    XMLElement.prototype.instruction = function(target, value) {
	      var i, insTarget, insValue, instruction, len;
	      if (target != null) {
	        target = target.valueOf();
	      }
	      if (value != null) {
	        value = value.valueOf();
	      }
	      if (Array.isArray(target)) {
	        for (i = 0, len = target.length; i < len; i++) {
	          insTarget = target[i];
	          this.instruction(insTarget);
	        }
	      } else if (isObject(target)) {
	        for (insTarget in target) {
	          if (!hasProp.call(target, insTarget)) continue;
	          insValue = target[insTarget];
	          this.instruction(insTarget, insValue);
	        }
	      } else {
	        if (isFunction(value)) {
	          value = value.apply();
	        }
	        instruction = new XMLProcessingInstruction(this, target, value);
	        this.instructions.push(instruction);
	      }
	      return this;
	    };

	    XMLElement.prototype.toString = function(options, level) {
	      var att, child, i, indent, instruction, j, len, len1, name, newline, offset, pretty, r, ref, ref1, ref2, ref3, ref4, ref5, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      ref3 = this.instructions;
	      for (i = 0, len = ref3.length; i < len; i++) {
	        instruction = ref3[i];
	        r += instruction.toString(options, level);
	      }
	      if (pretty) {
	        r += space;
	      }
	      r += '<' + this.name;
	      ref4 = this.attributes;
	      for (name in ref4) {
	        if (!hasProp.call(ref4, name)) continue;
	        att = ref4[name];
	        r += att.toString(options);
	      }
	      if (this.children.length === 0 || every(this.children, function(e) {
	        return e.value === '';
	      })) {
	        r += '/>';
	        if (pretty) {
	          r += newline;
	        }
	      } else if (pretty && this.children.length === 1 && (this.children[0].value != null)) {
	        r += '>';
	        r += this.children[0].value;
	        r += '</' + this.name + '>';
	        r += newline;
	      } else {
	        r += '>';
	        if (pretty) {
	          r += newline;
	        }
	        ref5 = this.children;
	        for (j = 0, len1 = ref5.length; j < len1; j++) {
	          child = ref5[j];
	          r += child.toString(options, level + 1);
	        }
	        if (pretty) {
	          r += space;
	        }
	        r += '</' + this.name + '>';
	        if (pretty) {
	          r += newline;
	        }
	      }
	      return r;
	    };

	    XMLElement.prototype.att = function(name, value) {
	      return this.attribute(name, value);
	    };

	    XMLElement.prototype.ins = function(target, value) {
	      return this.instruction(target, value);
	    };

	    XMLElement.prototype.a = function(name, value) {
	      return this.attribute(name, value);
	    };

	    XMLElement.prototype.i = function(target, value) {
	      return this.instruction(target, value);
	    };

	    return XMLElement;

	  })(XMLNode);

	}).call(this);


/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(348),
	    copyObject = __webpack_require__(349),
	    createAssigner = __webpack_require__(350),
	    isArrayLike = __webpack_require__(351),
	    isPrototype = __webpack_require__(352),
	    keys = __webpack_require__(353);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
	var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');

	/**
	 * Assigns own enumerable string keyed properties of source objects to the
	 * destination object. Source objects are applied from left to right.
	 * Subsequent sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object` and is loosely based on
	 * [`Object.assign`](https://mdn.io/Object/assign).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.10.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * function Foo() {
	 *   this.c = 3;
	 * }
	 *
	 * function Bar() {
	 *   this.e = 5;
	 * }
	 *
	 * Foo.prototype.d = 4;
	 * Bar.prototype.f = 6;
	 *
	 * _.assign({ 'a': 1 }, new Foo, new Bar);
	 * // => { 'a': 1, 'c': 3, 'e': 5 }
	 */
	var assign = createAssigner(function(object, source) {
	  if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
	    copyObject(source, keys(source), object);
	    return;
	  }
	  for (var key in source) {
	    if (hasOwnProperty.call(source, key)) {
	      assignValue(object, key, source[key]);
	    }
	  }
	});

	module.exports = assign;


/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	var baseAssign = __webpack_require__(354),
	    baseCreate = __webpack_require__(355);

	/**
	 * Creates an object that inherits from the `prototype` object. If a
	 * `properties` object is given, its own enumerable string keyed properties
	 * are assigned to the created object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Object
	 * @param {Object} prototype The object to inherit from.
	 * @param {Object} [properties] The properties to assign to the object.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * function Shape() {
	 *   this.x = 0;
	 *   this.y = 0;
	 * }
	 *
	 * function Circle() {
	 *   Shape.call(this);
	 * }
	 *
	 * Circle.prototype = _.create(Shape.prototype, {
	 *   'constructor': Circle
	 * });
	 *
	 * var circle = new Circle;
	 * circle instanceof Circle;
	 * // => true
	 *
	 * circle instanceof Shape;
	 * // => true
	 */
	function create(prototype, properties) {
	  var result = baseCreate(prototype);
	  return properties ? baseAssign(result, properties) : result;
	}

	module.exports = create;


/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	module.exports = isObject;


/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLRaw, XMLText, isEmpty, isFunction, isObject,
	    hasProp = {}.hasOwnProperty;

	  isObject = __webpack_require__(336);

	  isFunction = __webpack_require__(338);

	  isEmpty = __webpack_require__(356);

	  XMLElement = null;

	  XMLCData = null;

	  XMLComment = null;

	  XMLDeclaration = null;

	  XMLDocType = null;

	  XMLRaw = null;

	  XMLText = null;

	  module.exports = XMLNode = (function() {
	    function XMLNode(parent) {
	      this.parent = parent;
	      this.options = this.parent.options;
	      this.stringify = this.parent.stringify;
	      if (XMLElement === null) {
	        XMLElement = __webpack_require__(333);
	        XMLCData = __webpack_require__(342);
	        XMLComment = __webpack_require__(343);
	        XMLDeclaration = __webpack_require__(331);
	        XMLDocType = __webpack_require__(332);
	        XMLRaw = __webpack_require__(357);
	        XMLText = __webpack_require__(358);
	      }
	    }

	    XMLNode.prototype.element = function(name, attributes, text) {
	      var childNode, item, j, k, key, lastChild, len, len1, ref, val;
	      lastChild = null;
	      if (attributes == null) {
	        attributes = {};
	      }
	      attributes = attributes.valueOf();
	      if (!isObject(attributes)) {
	        ref = [attributes, text], text = ref[0], attributes = ref[1];
	      }
	      if (name != null) {
	        name = name.valueOf();
	      }
	      if (Array.isArray(name)) {
	        for (j = 0, len = name.length; j < len; j++) {
	          item = name[j];
	          lastChild = this.element(item);
	        }
	      } else if (isFunction(name)) {
	        lastChild = this.element(name.apply());
	      } else if (isObject(name)) {
	        for (key in name) {
	          if (!hasProp.call(name, key)) continue;
	          val = name[key];
	          if (isFunction(val)) {
	            val = val.apply();
	          }
	          if ((isObject(val)) && (isEmpty(val))) {
	            val = null;
	          }
	          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
	            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
	          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && key.indexOf(this.stringify.convertPIKey) === 0) {
	            lastChild = this.instruction(key.substr(this.stringify.convertPIKey.length), val);
	          } else if (!this.options.separateArrayItems && Array.isArray(val)) {
	            for (k = 0, len1 = val.length; k < len1; k++) {
	              item = val[k];
	              childNode = {};
	              childNode[key] = item;
	              lastChild = this.element(childNode);
	            }
	          } else if (isObject(val)) {
	            lastChild = this.element(key);
	            lastChild.element(val);
	          } else {
	            lastChild = this.element(key, val);
	          }
	        }
	      } else {
	        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
	          lastChild = this.text(text);
	        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
	          lastChild = this.cdata(text);
	        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
	          lastChild = this.comment(text);
	        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
	          lastChild = this.raw(text);
	        } else {
	          lastChild = this.node(name, attributes, text);
	        }
	      }
	      if (lastChild == null) {
	        throw new Error("Could not create any elements with: " + name);
	      }
	      return lastChild;
	    };

	    XMLNode.prototype.insertBefore = function(name, attributes, text) {
	      var child, i, removed;
	      if (this.isRoot) {
	        throw new Error("Cannot insert elements at root level");
	      }
	      i = this.parent.children.indexOf(this);
	      removed = this.parent.children.splice(i);
	      child = this.parent.element(name, attributes, text);
	      Array.prototype.push.apply(this.parent.children, removed);
	      return child;
	    };

	    XMLNode.prototype.insertAfter = function(name, attributes, text) {
	      var child, i, removed;
	      if (this.isRoot) {
	        throw new Error("Cannot insert elements at root level");
	      }
	      i = this.parent.children.indexOf(this);
	      removed = this.parent.children.splice(i + 1);
	      child = this.parent.element(name, attributes, text);
	      Array.prototype.push.apply(this.parent.children, removed);
	      return child;
	    };

	    XMLNode.prototype.remove = function() {
	      var i, ref;
	      if (this.isRoot) {
	        throw new Error("Cannot remove the root element");
	      }
	      i = this.parent.children.indexOf(this);
	      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref = [])), ref;
	      return this.parent;
	    };

	    XMLNode.prototype.node = function(name, attributes, text) {
	      var child, ref;
	      if (name != null) {
	        name = name.valueOf();
	      }
	      if (attributes == null) {
	        attributes = {};
	      }
	      attributes = attributes.valueOf();
	      if (!isObject(attributes)) {
	        ref = [attributes, text], text = ref[0], attributes = ref[1];
	      }
	      child = new XMLElement(this, name, attributes);
	      if (text != null) {
	        child.text(text);
	      }
	      this.children.push(child);
	      return child;
	    };

	    XMLNode.prototype.text = function(value) {
	      var child;
	      child = new XMLText(this, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLNode.prototype.cdata = function(value) {
	      var child;
	      child = new XMLCData(this, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLNode.prototype.comment = function(value) {
	      var child;
	      child = new XMLComment(this, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLNode.prototype.raw = function(value) {
	      var child;
	      child = new XMLRaw(this, value);
	      this.children.push(child);
	      return this;
	    };

	    XMLNode.prototype.declaration = function(version, encoding, standalone) {
	      var doc, xmldec;
	      doc = this.document();
	      xmldec = new XMLDeclaration(doc, version, encoding, standalone);
	      doc.xmldec = xmldec;
	      return doc.root();
	    };

	    XMLNode.prototype.doctype = function(pubID, sysID) {
	      var doc, doctype;
	      doc = this.document();
	      doctype = new XMLDocType(doc, pubID, sysID);
	      doc.doctype = doctype;
	      return doctype;
	    };

	    XMLNode.prototype.up = function() {
	      if (this.isRoot) {
	        throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
	      }
	      return this.parent;
	    };

	    XMLNode.prototype.root = function() {
	      var child;
	      if (this.isRoot) {
	        return this;
	      }
	      child = this.parent;
	      while (!child.isRoot) {
	        child = child.parent;
	      }
	      return child;
	    };

	    XMLNode.prototype.document = function() {
	      return this.root().documentObject;
	    };

	    XMLNode.prototype.end = function(options) {
	      return this.document().toString(options);
	    };

	    XMLNode.prototype.prev = function() {
	      var i;
	      if (this.isRoot) {
	        throw new Error("Root node has no siblings");
	      }
	      i = this.parent.children.indexOf(this);
	      if (i < 1) {
	        throw new Error("Already at the first node");
	      }
	      return this.parent.children[i - 1];
	    };

	    XMLNode.prototype.next = function() {
	      var i;
	      if (this.isRoot) {
	        throw new Error("Root node has no siblings");
	      }
	      i = this.parent.children.indexOf(this);
	      if (i === -1 || i === this.parent.children.length - 1) {
	        throw new Error("Already at the last node");
	      }
	      return this.parent.children[i + 1];
	    };

	    XMLNode.prototype.importXMLBuilder = function(xmlbuilder) {
	      var clonedRoot;
	      clonedRoot = xmlbuilder.root().clone();
	      clonedRoot.parent = this;
	      clonedRoot.isRoot = false;
	      this.children.push(clonedRoot);
	      return this;
	    };

	    XMLNode.prototype.ele = function(name, attributes, text) {
	      return this.element(name, attributes, text);
	    };

	    XMLNode.prototype.nod = function(name, attributes, text) {
	      return this.node(name, attributes, text);
	    };

	    XMLNode.prototype.txt = function(value) {
	      return this.text(value);
	    };

	    XMLNode.prototype.dat = function(value) {
	      return this.cdata(value);
	    };

	    XMLNode.prototype.com = function(value) {
	      return this.comment(value);
	    };

	    XMLNode.prototype.doc = function() {
	      return this.document();
	    };

	    XMLNode.prototype.dec = function(version, encoding, standalone) {
	      return this.declaration(version, encoding, standalone);
	    };

	    XMLNode.prototype.dtd = function(pubID, sysID) {
	      return this.doctype(pubID, sysID);
	    };

	    XMLNode.prototype.e = function(name, attributes, text) {
	      return this.element(name, attributes, text);
	    };

	    XMLNode.prototype.n = function(name, attributes, text) {
	      return this.node(name, attributes, text);
	    };

	    XMLNode.prototype.t = function(value) {
	      return this.text(value);
	    };

	    XMLNode.prototype.d = function(value) {
	      return this.cdata(value);
	    };

	    XMLNode.prototype.c = function(value) {
	      return this.comment(value);
	    };

	    XMLNode.prototype.r = function(value) {
	      return this.raw(value);
	    };

	    XMLNode.prototype.u = function() {
	      return this.up();
	    };

	    return XMLNode;

	  })();

	}).call(this);


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(336);

	/** `Object#toString` result references. */
	var funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified,
	 *  else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8 which returns 'object' for typed array and weak map constructors,
	  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	module.exports = isFunction;


/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	var arrayEvery = __webpack_require__(359),
	    baseEvery = __webpack_require__(360),
	    baseIteratee = __webpack_require__(361),
	    isArray = __webpack_require__(362),
	    isIterateeCall = __webpack_require__(363);

	/**
	 * Checks if `predicate` returns truthy for **all** elements of `collection`.
	 * Iteration is stopped once `predicate` returns falsey. The predicate is
	 * invoked with three arguments: (value, index|key, collection).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Array|Function|Object|string} [predicate=_.identity]
	 *  The function invoked per iteration.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {boolean} Returns `true` if all elements pass the predicate check,
	 *  else `false`.
	 * @example
	 *
	 * _.every([true, 1, null, 'yes'], Boolean);
	 * // => false
	 *
	 * var users = [
	 *   { 'user': 'barney', 'age': 36, 'active': false },
	 *   { 'user': 'fred',   'age': 40, 'active': false }
	 * ];
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.every(users, { 'user': 'barney', 'active': false });
	 * // => false
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.every(users, ['active', false]);
	 * // => true
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.every(users, 'active');
	 * // => false
	 */
	function every(collection, predicate, guard) {
	  var func = isArray(collection) ? arrayEvery : baseEvery;
	  if (guard && isIterateeCall(collection, predicate, guard)) {
	    predicate = undefined;
	  }
	  return func(collection, baseIteratee(predicate, 3));
	}

	module.exports = every;


/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLAttribute, create;

	  create = __webpack_require__(335);

	  module.exports = XMLAttribute = (function() {
	    function XMLAttribute(parent, name, value) {
	      this.stringify = parent.stringify;
	      if (name == null) {
	        throw new Error("Missing attribute name of element " + parent.name);
	      }
	      if (value == null) {
	        throw new Error("Missing attribute value for attribute " + name + " of element " + parent.name);
	      }
	      this.name = this.stringify.attName(name);
	      this.value = this.stringify.attValue(value);
	    }

	    XMLAttribute.prototype.clone = function() {
	      return create(XMLAttribute.prototype, this);
	    };

	    XMLAttribute.prototype.toString = function(options, level) {
	      return ' ' + this.name + '="' + this.value + '"';
	    };

	    return XMLAttribute;

	  })();

	}).call(this);


/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLProcessingInstruction, create;

	  create = __webpack_require__(335);

	  module.exports = XMLProcessingInstruction = (function() {
	    function XMLProcessingInstruction(parent, target, value) {
	      this.stringify = parent.stringify;
	      if (target == null) {
	        throw new Error("Missing instruction target");
	      }
	      this.target = this.stringify.insTarget(target);
	      if (value) {
	        this.value = this.stringify.insValue(value);
	      }
	    }

	    XMLProcessingInstruction.prototype.clone = function() {
	      return create(XMLProcessingInstruction.prototype, this);
	    };

	    XMLProcessingInstruction.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += '<?';
	      r += this.target;
	      if (this.value) {
	        r += ' ' + this.value;
	      }
	      r += '?>';
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLProcessingInstruction;

	  })();

	}).call(this);


/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLCData, XMLNode, create,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  create = __webpack_require__(335);

	  XMLNode = __webpack_require__(337);

	  module.exports = XMLCData = (function(superClass) {
	    extend(XMLCData, superClass);

	    function XMLCData(parent, text) {
	      XMLCData.__super__.constructor.call(this, parent);
	      if (text == null) {
	        throw new Error("Missing CDATA text");
	      }
	      this.text = this.stringify.cdata(text);
	    }

	    XMLCData.prototype.clone = function() {
	      return create(XMLCData.prototype, this);
	    };

	    XMLCData.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += '<![CDATA[' + this.text + ']]>';
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLCData;

	  })(XMLNode);

	}).call(this);


/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLComment, XMLNode, create,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  create = __webpack_require__(335);

	  XMLNode = __webpack_require__(337);

	  module.exports = XMLComment = (function(superClass) {
	    extend(XMLComment, superClass);

	    function XMLComment(parent, text) {
	      XMLComment.__super__.constructor.call(this, parent);
	      if (text == null) {
	        throw new Error("Missing comment text");
	      }
	      this.text = this.stringify.comment(text);
	    }

	    XMLComment.prototype.clone = function() {
	      return create(XMLComment.prototype, this);
	    };

	    XMLComment.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += '<!-- ' + this.text + ' -->';
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLComment;

	  })(XMLNode);

	}).call(this);


/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLDTDAttList, create;

	  create = __webpack_require__(335);

	  module.exports = XMLDTDAttList = (function() {
	    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
	      this.stringify = parent.stringify;
	      if (elementName == null) {
	        throw new Error("Missing DTD element name");
	      }
	      if (attributeName == null) {
	        throw new Error("Missing DTD attribute name");
	      }
	      if (!attributeType) {
	        throw new Error("Missing DTD attribute type");
	      }
	      if (!defaultValueType) {
	        throw new Error("Missing DTD attribute default");
	      }
	      if (defaultValueType.indexOf('#') !== 0) {
	        defaultValueType = '#' + defaultValueType;
	      }
	      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
	        throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");
	      }
	      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
	        throw new Error("Default value only applies to #FIXED or #DEFAULT");
	      }
	      this.elementName = this.stringify.eleName(elementName);
	      this.attributeName = this.stringify.attName(attributeName);
	      this.attributeType = this.stringify.dtdAttType(attributeType);
	      this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
	      this.defaultValueType = defaultValueType;
	    }

	    XMLDTDAttList.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += '<!ATTLIST ' + this.elementName + ' ' + this.attributeName + ' ' + this.attributeType;
	      if (this.defaultValueType !== '#DEFAULT') {
	        r += ' ' + this.defaultValueType;
	      }
	      if (this.defaultValue) {
	        r += ' "' + this.defaultValue + '"';
	      }
	      r += '>';
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLDTDAttList;

	  })();

	}).call(this);


/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLDTDEntity, create, isObject;

	  create = __webpack_require__(335);

	  isObject = __webpack_require__(336);

	  module.exports = XMLDTDEntity = (function() {
	    function XMLDTDEntity(parent, pe, name, value) {
	      this.stringify = parent.stringify;
	      if (name == null) {
	        throw new Error("Missing entity name");
	      }
	      if (value == null) {
	        throw new Error("Missing entity value");
	      }
	      this.pe = !!pe;
	      this.name = this.stringify.eleName(name);
	      if (!isObject(value)) {
	        this.value = this.stringify.dtdEntityValue(value);
	      } else {
	        if (!value.pubID && !value.sysID) {
	          throw new Error("Public and/or system identifiers are required for an external entity");
	        }
	        if (value.pubID && !value.sysID) {
	          throw new Error("System identifier is required for a public external entity");
	        }
	        if (value.pubID != null) {
	          this.pubID = this.stringify.dtdPubID(value.pubID);
	        }
	        if (value.sysID != null) {
	          this.sysID = this.stringify.dtdSysID(value.sysID);
	        }
	        if (value.nData != null) {
	          this.nData = this.stringify.dtdNData(value.nData);
	        }
	        if (this.pe && this.nData) {
	          throw new Error("Notation declaration is not allowed in a parameter entity");
	        }
	      }
	    }

	    XMLDTDEntity.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += '<!ENTITY';
	      if (this.pe) {
	        r += ' %';
	      }
	      r += ' ' + this.name;
	      if (this.value) {
	        r += ' "' + this.value + '"';
	      } else {
	        if (this.pubID && this.sysID) {
	          r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
	        } else if (this.sysID) {
	          r += ' SYSTEM "' + this.sysID + '"';
	        }
	        if (this.nData) {
	          r += ' NDATA ' + this.nData;
	        }
	      }
	      r += '>';
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLDTDEntity;

	  })();

	}).call(this);


/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLDTDElement, create;

	  create = __webpack_require__(335);

	  module.exports = XMLDTDElement = (function() {
	    function XMLDTDElement(parent, name, value) {
	      this.stringify = parent.stringify;
	      if (name == null) {
	        throw new Error("Missing DTD element name");
	      }
	      if (!value) {
	        value = '(#PCDATA)';
	      }
	      if (Array.isArray(value)) {
	        value = '(' + value.join(',') + ')';
	      }
	      this.name = this.stringify.eleName(name);
	      this.value = this.stringify.dtdElementValue(value);
	    }

	    XMLDTDElement.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += '<!ELEMENT ' + this.name + ' ' + this.value + '>';
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLDTDElement;

	  })();

	}).call(this);


/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLDTDNotation, create;

	  create = __webpack_require__(335);

	  module.exports = XMLDTDNotation = (function() {
	    function XMLDTDNotation(parent, name, value) {
	      this.stringify = parent.stringify;
	      if (name == null) {
	        throw new Error("Missing notation name");
	      }
	      if (!value.pubID && !value.sysID) {
	        throw new Error("Public or system identifiers are required for an external entity");
	      }
	      this.name = this.stringify.eleName(name);
	      if (value.pubID != null) {
	        this.pubID = this.stringify.dtdPubID(value.pubID);
	      }
	      if (value.sysID != null) {
	        this.sysID = this.stringify.dtdSysID(value.sysID);
	      }
	    }

	    XMLDTDNotation.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += '<!NOTATION ' + this.name;
	      if (this.pubID && this.sysID) {
	        r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
	      } else if (this.pubID) {
	        r += ' PUBLIC "' + this.pubID + '"';
	      } else if (this.sysID) {
	        r += ' SYSTEM "' + this.sysID + '"';
	      }
	      r += '>';
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLDTDNotation;

	  })();

	}).call(this);


/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(364);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    object[key] = value;
	  }
	}

	module.exports = assignValue;


/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(348);

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : source[key];

	    assignValue(object, key, newValue);
	  }
	  return object;
	}

	module.exports = copyObject;


/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	var isIterateeCall = __webpack_require__(363),
	    rest = __webpack_require__(365);

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return rest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = typeof customizer == 'function'
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	module.exports = createAssigner;


/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	var getLength = __webpack_require__(366),
	    isFunction = __webpack_require__(338),
	    isLength = __webpack_require__(367);

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value)) && !isFunction(value);
	}

	module.exports = isArrayLike;


/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	module.exports = isPrototype;


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	var baseHas = __webpack_require__(368),
	    baseKeys = __webpack_require__(369),
	    indexKeys = __webpack_require__(370),
	    isArrayLike = __webpack_require__(351),
	    isIndex = __webpack_require__(371),
	    isPrototype = __webpack_require__(352);

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  var isProto = isPrototype(object);
	  if (!(isProto || isArrayLike(object))) {
	    return baseKeys(object);
	  }
	  var indexes = indexKeys(object),
	      skipIndexes = !!indexes,
	      result = indexes || [],
	      length = result.length;

	  for (var key in object) {
	    if (baseHas(object, key) &&
	        !(skipIndexes && (key == 'length' || isIndex(key, length))) &&
	        !(isProto && key == 'constructor')) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = keys;


/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	var copyObject = __webpack_require__(349),
	    keys = __webpack_require__(353);

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return object && copyObject(source, keys(source), object);
	}

	module.exports = baseAssign;


/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(336);

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} prototype The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	function baseCreate(proto) {
	  return isObject(proto) ? objectCreate(proto) : {};
	}

	module.exports = baseCreate;


/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	var getTag = __webpack_require__(372),
	    isArguments = __webpack_require__(373),
	    isArray = __webpack_require__(362),
	    isArrayLike = __webpack_require__(351),
	    isBuffer = __webpack_require__(374),
	    isFunction = __webpack_require__(338),
	    isObjectLike = __webpack_require__(375),
	    isString = __webpack_require__(376),
	    keys = __webpack_require__(353);

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    setTag = '[object Set]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
	var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');

	/**
	 * Checks if `value` is an empty object, collection, map, or set.
	 *
	 * Objects are considered empty if they have no own enumerable string keyed
	 * properties.
	 *
	 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	 * jQuery-like collections are considered empty if they have a `length` of `0`.
	 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	 * @example
	 *
	 * _.isEmpty(null);
	 * // => true
	 *
	 * _.isEmpty(true);
	 * // => true
	 *
	 * _.isEmpty(1);
	 * // => true
	 *
	 * _.isEmpty([1, 2, 3]);
	 * // => false
	 *
	 * _.isEmpty({ 'a': 1 });
	 * // => false
	 */
	function isEmpty(value) {
	  if (isArrayLike(value) &&
	      (isArray(value) || isString(value) || isFunction(value.splice) ||
	        isArguments(value) || isBuffer(value))) {
	    return !value.length;
	  }
	  if (isObjectLike(value)) {
	    var tag = getTag(value);
	    if (tag == mapTag || tag == setTag) {
	      return !value.size;
	    }
	  }
	  for (var key in value) {
	    if (hasOwnProperty.call(value, key)) {
	      return false;
	    }
	  }
	  return !(nonEnumShadows && keys(value).length);
	}

	module.exports = isEmpty;


/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLNode, XMLRaw, create,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  create = __webpack_require__(335);

	  XMLNode = __webpack_require__(337);

	  module.exports = XMLRaw = (function(superClass) {
	    extend(XMLRaw, superClass);

	    function XMLRaw(parent, text) {
	      XMLRaw.__super__.constructor.call(this, parent);
	      if (text == null) {
	        throw new Error("Missing raw text");
	      }
	      this.value = this.stringify.raw(text);
	    }

	    XMLRaw.prototype.clone = function() {
	      return create(XMLRaw.prototype, this);
	    };

	    XMLRaw.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += this.value;
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLRaw;

	  })(XMLNode);

	}).call(this);


/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.9.1
	(function() {
	  var XMLNode, XMLText, create,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;

	  create = __webpack_require__(335);

	  XMLNode = __webpack_require__(337);

	  module.exports = XMLText = (function(superClass) {
	    extend(XMLText, superClass);

	    function XMLText(parent, text) {
	      XMLText.__super__.constructor.call(this, parent);
	      if (text == null) {
	        throw new Error("Missing element text");
	      }
	      this.value = this.stringify.eleText(text);
	    }

	    XMLText.prototype.clone = function() {
	      return create(XMLText.prototype, this);
	    };

	    XMLText.prototype.toString = function(options, level) {
	      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
	      pretty = (options != null ? options.pretty : void 0) || false;
	      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
	      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
	      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
	      level || (level = 0);
	      space = new Array(level + offset + 1).join(indent);
	      r = '';
	      if (pretty) {
	        r += space;
	      }
	      r += this.value;
	      if (pretty) {
	        r += newline;
	      }
	      return r;
	    };

	    return XMLText;

	  })(XMLNode);

	}).call(this);


/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * A specialized version of `_.every` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if all elements pass the predicate check,
	 *  else `false`.
	 */
	function arrayEvery(array, predicate) {
	  var index = -1,
	      length = array.length;

	  while (++index < length) {
	    if (!predicate(array[index], index, array)) {
	      return false;
	    }
	  }
	  return true;
	}

	module.exports = arrayEvery;


/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	var baseEach = __webpack_require__(381);

	/**
	 * The base implementation of `_.every` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if all elements pass the predicate check,
	 *  else `false`
	 */
	function baseEvery(collection, predicate) {
	  var result = true;
	  baseEach(collection, function(value, index, collection) {
	    result = !!predicate(value, index, collection);
	    return result;
	  });
	  return result;
	}

	module.exports = baseEvery;


/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	var baseMatches = __webpack_require__(377),
	    baseMatchesProperty = __webpack_require__(378),
	    identity = __webpack_require__(379),
	    isArray = __webpack_require__(362),
	    property = __webpack_require__(380);

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	module.exports = baseIteratee;


/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @type {Function}
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified,
	 *  else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	module.exports = isArray;


/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(364),
	    isArrayLike = __webpack_require__(351),
	    isIndex = __webpack_require__(371),
	    isObject = __webpack_require__(336);

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	module.exports = isIterateeCall;


/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'user': 'fred' };
	 * var other = { 'user': 'fred' };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	module.exports = eq;


/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(382),
	    toInteger = __webpack_require__(383);

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * Creates a function that invokes `func` with the `this` binding of the
	 * created function and arguments from `start` and beyond provided as
	 * an array.
	 *
	 * **Note:** This method is based on the
	 * [rest parameter](https://mdn.io/rest_parameters).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Function
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var say = _.rest(function(what, names) {
	 *   return what + ' ' + _.initial(names).join(', ') +
	 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	 * });
	 *
	 * say('hello', 'fred', 'barney', 'pebbles');
	 * // => 'hello fred, barney, & pebbles'
	 */
	function rest(func, start) {
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  start = nativeMax(start === undefined ? (func.length - 1) : toInteger(start), 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    switch (start) {
	      case 0: return func.call(this, array);
	      case 1: return func.call(this, args[0], array);
	      case 2: return func.call(this, args[0], args[1], array);
	    }
	    var otherArgs = Array(start + 1);
	    index = -1;
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = array;
	    return apply(func, this, otherArgs);
	  };
	}

	module.exports = rest;


/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	var baseProperty = __webpack_require__(384);

	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a
	 * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects
	 * Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');

	module.exports = getLength;


/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length,
	 *  else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	module.exports = isLength;


/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	var getPrototype = __webpack_require__(386);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.has` without support for deep paths.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHas(object, key) {
	  // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
	  // that are composed entirely of index properties, return `false` for
	  // `hasOwnProperty` checks of them.
	  return hasOwnProperty.call(object, key) ||
	    (typeof object == 'object' && key in object && getPrototype(object) === null);
	}

	module.exports = baseHas;


/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = Object.keys;

	/**
	 * The base implementation of `_.keys` which doesn't skip the constructor
	 * property of prototypes or treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  return nativeKeys(Object(object));
	}

	module.exports = baseKeys;


/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	var baseTimes = __webpack_require__(385),
	    isArguments = __webpack_require__(373),
	    isArray = __webpack_require__(362),
	    isLength = __webpack_require__(367),
	    isString = __webpack_require__(376);

	/**
	 * Creates an array of index keys for `object` values of arrays,
	 * `arguments` objects, and strings, otherwise `null` is returned.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array|null} Returns index keys, else `null`.
	 */
	function indexKeys(object) {
	  var length = object ? object.length : undefined;
	  if (isLength(length) &&
	      (isArray(object) || isString(object) || isArguments(object))) {
	    return baseTimes(length, String);
	  }
	  return null;
	}

	module.exports = indexKeys;


/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return value > -1 && value % 1 == 0 && value < length;
	}

	module.exports = isIndex;


/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

	var DataView = __webpack_require__(387),
	    Map = __webpack_require__(388),
	    Promise = __webpack_require__(389),
	    Set = __webpack_require__(390),
	    WeakMap = __webpack_require__(391),
	    toSource = __webpack_require__(392);

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag = '[object Set]',
	    weakMapTag = '[object WeakMap]';

	var dataViewTag = '[object DataView]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function getTag(value) {
	  return objectToString.call(value);
	}

	// Fallback for data views, maps, sets, and weak maps in IE 11,
	// for data views in Edge, and promises in Node.js.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = objectToString.call(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : undefined;

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	module.exports = getTag;


/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLikeObject = __webpack_require__(393);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	module.exports = isArguments;


/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var constant = __webpack_require__(394),
	    root = __webpack_require__(395);

	/** Used to determine if values are of the language type `Object`. */
	var objectTypes = {
	  'function': true,
	  'object': true
	};

	/** Detect free variable `exports`. */
	var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
	  ? exports
	  : undefined;

	/** Detect free variable `module`. */
	var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
	  ? module
	  : undefined;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = (freeModule && freeModule.exports === freeExports)
	  ? freeExports
	  : undefined;

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = !Buffer ? constant(false) : function(value) {
	  return value instanceof Buffer;
	};

	module.exports = isBuffer;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(145)(module)))

/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	module.exports = isObjectLike;


/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(362),
	    isObjectLike = __webpack_require__(375);

	/** `Object#toString` result references. */
	var stringTag = '[object String]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * Checks if `value` is classified as a `String` primitive or object.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified,
	 *  else `false`.
	 * @example
	 *
	 * _.isString('abc');
	 * // => true
	 *
	 * _.isString(1);
	 * // => false
	 */
	function isString(value) {
	  return typeof value == 'string' ||
	    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
	}

	module.exports = isString;


/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsMatch = __webpack_require__(396),
	    getMatchData = __webpack_require__(397),
	    matchesStrictComparable = __webpack_require__(398);

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	module.exports = baseMatches;


/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqual = __webpack_require__(399),
	    get = __webpack_require__(400),
	    hasIn = __webpack_require__(401),
	    isKey = __webpack_require__(402),
	    isStrictComparable = __webpack_require__(403),
	    matchesStrictComparable = __webpack_require__(398);

	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(path, srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
	  };
	}

	module.exports = baseMatchesProperty;


/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * This method returns the first argument given to it.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'user': 'fred' };
	 *
	 * _.identity(object) === object;
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	var baseProperty = __webpack_require__(384),
	    basePropertyDeep = __webpack_require__(407),
	    isKey = __webpack_require__(402);

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
	}

	module.exports = property;


/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	var baseForOwn = __webpack_require__(405),
	    createBaseEach = __webpack_require__(406);

	/**
	 * The base implementation of `_.forEach` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */
	var baseEach = createBaseEach(baseForOwn);

	module.exports = baseEach;


/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  var length = args.length;
	  switch (length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	module.exports = apply;


/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	var toNumber = __webpack_require__(404);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_INTEGER = 1.7976931348623157e+308;

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This function is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3');
	 * // => 3
	 */
	function toInteger(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY || value === -INFINITY) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  var remainder = value % 1;
	  return value === value ? (remainder ? value - remainder : value) : 0;
	}

	module.exports = toInteger;


/***/ },
/* 384 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	module.exports = baseProperty;


/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	module.exports = baseTimes;


/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetPrototype = Object.getPrototypeOf;

	/**
	 * Gets the `[[Prototype]]` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {null|Object} Returns the `[[Prototype]]`.
	 */
	function getPrototype(value) {
	  return nativeGetPrototype(Object(value));
	}

	module.exports = getPrototype;


/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(408),
	    root = __webpack_require__(395);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView');

	module.exports = DataView;


/***/ },
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(408),
	    root = __webpack_require__(395);

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');

	module.exports = Map;


/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(408),
	    root = __webpack_require__(395);

	/* Built-in method references that are verified to be native. */
	var Promise = getNative(root, 'Promise');

	module.exports = Promise;


/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(408),
	    root = __webpack_require__(395);

	/* Built-in method references that are verified to be native. */
	var Set = getNative(root, 'Set');

	module.exports = Set;


/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(408),
	    root = __webpack_require__(395);

	/* Built-in method references that are verified to be native. */
	var WeakMap = getNative(root, 'WeakMap');

	module.exports = WeakMap;


/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	/** Used to resolve the decompiled source of functions. */
	var funcToString = Function.prototype.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	module.exports = toSource;


/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(351),
	    isObjectLike = __webpack_require__(375);

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	module.exports = isArrayLikeObject;


/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var object = { 'user': 'fred' };
	 * var getter = _.constant(object);
	 *
	 * getter() === object;
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	module.exports = constant;


/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, global) {var checkGlobal = __webpack_require__(409);

	/** Used to determine if values are of the language type `Object`. */
	var objectTypes = {
	  'function': true,
	  'object': true
	};

	/** Detect free variable `exports`. */
	var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
	  ? exports
	  : undefined;

	/** Detect free variable `module`. */
	var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
	  ? module
	  : undefined;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);

	/** Detect free variable `self`. */
	var freeSelf = checkGlobal(objectTypes[typeof self] && self);

	/** Detect free variable `window`. */
	var freeWindow = checkGlobal(objectTypes[typeof window] && window);

	/** Detect `this` as the global object. */
	var thisGlobal = checkGlobal(objectTypes[typeof this] && this);

	/**
	 * Used as a reference to the global object.
	 *
	 * The `this` value is used if it's the global object to avoid Greasemonkey's
	 * restricted `window` object, otherwise the `window` object is used.
	 */
	var root = freeGlobal ||
	  ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
	    freeSelf || thisGlobal || Function('return this')();

	module.exports = root;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(145)(module), (function() { return this; }())))

/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(410),
	    baseIsEqual = __webpack_require__(399);

	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	module.exports = baseIsMatch;


/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	var isStrictComparable = __webpack_require__(403),
	    toPairs = __webpack_require__(411);

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = toPairs(object),
	      length = result.length;

	  while (length--) {
	    result[length][2] = isStrictComparable(result[length][1]);
	  }
	  return result;
	}

	module.exports = getMatchData;


/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	module.exports = matchesStrictComparable;


/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqualDeep = __webpack_require__(412),
	    isObject = __webpack_require__(336),
	    isObjectLike = __webpack_require__(375);

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {boolean} [bitmask] The bitmask of comparison flags.
	 *  The bitmask may be composed of the following flags:
	 *     1 - Unordered comparison
	 *     2 - Partial comparison
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, customizer, bitmask, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
	}

	module.exports = baseIsEqual;


/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(413);

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is used in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	module.exports = get;


/***/ },
/* 401 */
/***/ function(module, exports, __webpack_require__) {

	var baseHasIn = __webpack_require__(414),
	    hasPath = __webpack_require__(415);

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	module.exports = hasIn;


/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(362),
	    isSymbol = __webpack_require__(416);

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol') {
	    return true;
	  }
	  return !isArray(value) &&
	    (isSymbol(value) || reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	      (object != null && value in Object(object)));
	}

	module.exports = isKey;


/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(336);

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}

	module.exports = isStrictComparable;


/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(338),
	    isObject = __webpack_require__(336),
	    isSymbol = __webpack_require__(416);

	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3);
	 * // => 3
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3');
	 * // => 3
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = isFunction(value.valueOf) ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	module.exports = toNumber;


/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	var baseFor = __webpack_require__(417),
	    keys = __webpack_require__(353);

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}

	module.exports = baseForOwn;


/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(351);

	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    if (collection == null) {
	      return collection;
	    }
	    if (!isArrayLike(collection)) {
	      return eachFunc(collection, iteratee);
	    }
	    var length = collection.length,
	        index = fromRight ? length : -1,
	        iterable = Object(collection);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}

	module.exports = createBaseEach;


/***/ },
/* 407 */
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(413);

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}

	module.exports = basePropertyDeep;


/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	var isNative = __webpack_require__(418);

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object[key];
	  return isNative(value) ? value : undefined;
	}

	module.exports = getNative;


/***/ },
/* 409 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Checks if `value` is a global object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {null|Object} Returns `value` if it's a global object, else `null`.
	 */
	function checkGlobal(value) {
	  return (value && value.Object === Object) ? value : null;
	}

	module.exports = checkGlobal;


/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	var stackClear = __webpack_require__(419),
	    stackDelete = __webpack_require__(420),
	    stackGet = __webpack_require__(421),
	    stackHas = __webpack_require__(422),
	    stackSet = __webpack_require__(423);

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function Stack(values) {
	  var index = -1,
	      length = values ? values.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = values[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	module.exports = Stack;


/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	var baseToPairs = __webpack_require__(424),
	    keys = __webpack_require__(353);

	/**
	 * Creates an array of own enumerable string keyed-value pairs for `object`
	 * which can be consumed by `_.fromPairs`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @alias entries
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the new array of key-value pairs.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.toPairs(new Foo);
	 * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
	 */
	function toPairs(object) {
	  return baseToPairs(object, keys(object));
	}

	module.exports = toPairs;


/***/ },
/* 412 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(410),
	    equalArrays = __webpack_require__(425),
	    equalByTag = __webpack_require__(426),
	    equalObjects = __webpack_require__(427),
	    getTag = __webpack_require__(372),
	    isArray = __webpack_require__(362),
	    isHostObject = __webpack_require__(428),
	    isTypedArray = __webpack_require__(429);

	/** Used to compose bitmasks for comparison styles. */
	var PARTIAL_COMPARE_FLAG = 2;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = arrayTag,
	      othTag = arrayTag;

	  if (!objIsArr) {
	    objTag = getTag(object);
	    objTag = objTag == argsTag ? objectTag : objTag;
	  }
	  if (!othIsArr) {
	    othTag = getTag(other);
	    othTag = othTag == argsTag ? objectTag : othTag;
	  }
	  var objIsObj = objTag == objectTag && !isHostObject(object),
	      othIsObj = othTag == objectTag && !isHostObject(other),
	      isSameTag = objTag == othTag;

	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
	      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
	  }
	  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
	}

	module.exports = baseIsEqualDeep;


/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(430),
	    isKey = __webpack_require__(402);

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = isKey(path, object) ? [path] : castPath(path);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[path[index++]];
	  }
	  return (index && index == length) ? object : undefined;
	}

	module.exports = baseGet;


/***/ },
/* 414 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return key in Object(object);
	}

	module.exports = baseHasIn;


/***/ },
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(430),
	    isArguments = __webpack_require__(373),
	    isArray = __webpack_require__(362),
	    isIndex = __webpack_require__(371),
	    isKey = __webpack_require__(402),
	    isLength = __webpack_require__(367),
	    isString = __webpack_require__(376);

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = isKey(path, object) ? [path] : castPath(path);

	  var result,
	      index = -1,
	      length = path.length;

	  while (++index < length) {
	    var key = path[index];
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result) {
	    return result;
	  }
	  var length = object ? object.length : 0;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isString(object) || isArguments(object));
	}

	module.exports = hasPath;


/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	var isObjectLike = __webpack_require__(375);

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified,
	 *  else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}

	module.exports = isSymbol;


/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	var createBaseFor = __webpack_require__(431);

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	module.exports = baseFor;


/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(338),
	    isHostObject = __webpack_require__(428),
	    isObject = __webpack_require__(336),
	    toSource = __webpack_require__(392);

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = Function.prototype.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	module.exports = isNative;


/***/ },
/* 419 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = { 'array': [], 'map': null };
	}

	module.exports = stackClear;


/***/ },
/* 420 */
/***/ function(module, exports, __webpack_require__) {

	var assocDelete = __webpack_require__(441);

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      array = data.array;

	  return array ? assocDelete(array, key) : data.map['delete'](key);
	}

	module.exports = stackDelete;


/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

	var assocGet = __webpack_require__(442);

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  var data = this.__data__,
	      array = data.array;

	  return array ? assocGet(array, key) : data.map.get(key);
	}

	module.exports = stackGet;


/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

	var assocHas = __webpack_require__(432);

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  var data = this.__data__,
	      array = data.array;

	  return array ? assocHas(array, key) : data.map.has(key);
	}

	module.exports = stackHas;


/***/ },
/* 423 */
/***/ function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(433),
	    assocSet = __webpack_require__(434);

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__,
	      array = data.array;

	  if (array) {
	    if (array.length < (LARGE_ARRAY_SIZE - 1)) {
	      assocSet(array, key, value);
	    } else {
	      data.array = null;
	      data.map = new MapCache(array);
	    }
	  }
	  var map = data.map;
	  if (map) {
	    map.set(key, value);
	  }
	  return this;
	}

	module.exports = stackSet;


/***/ },
/* 424 */
/***/ function(module, exports, __webpack_require__) {

	var arrayMap = __webpack_require__(435);

	/**
	 * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
	 * of key-value pairs for `object` corresponding to the property names of `props`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the new array of key-value pairs.
	 */
	function baseToPairs(object, props) {
	  return arrayMap(props, function(key) {
	    return [key, object[key]];
	  });
	}

	module.exports = baseToPairs;


/***/ },
/* 425 */
/***/ function(module, exports, __webpack_require__) {

	var arraySome = __webpack_require__(436);

	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
	  var index = -1,
	      isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      isUnordered = bitmask & UNORDERED_COMPARE_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(array, other);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (isUnordered) {
	      if (!arraySome(other, function(othValue) {
	            return arrValue === othValue ||
	              equalFunc(arrValue, othValue, customizer, bitmask, stack);
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, customizer, bitmask, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  return result;
	}

	module.exports = equalArrays;


/***/ },
/* 426 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(437),
	    Uint8Array = __webpack_require__(438),
	    equalArrays = __webpack_require__(425),
	    mapToArray = __webpack_require__(439),
	    setToArray = __webpack_require__(440);

	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	      // Coerce dates and booleans to numbers, dates to milliseconds and
	      // booleans to `1` or `0` treating invalid dates coerced to `NaN` as
	      // not equal.
	      return +object == +other;

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case numberTag:
	      // Treat `NaN` vs. `NaN` as equal.
	      return (object != +object) ? other != +other : object == +other;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/6.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= UNORDERED_COMPARE_FLAG;
	      stack.set(object, other);

	      // Recursively compare objects (susceptible to call stack limits).
	      return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	module.exports = equalByTag;


/***/ },
/* 427 */
/***/ function(module, exports, __webpack_require__) {

	var baseHas = __webpack_require__(368),
	    keys = __webpack_require__(353);

	/** Used to compose bitmasks for comparison styles. */
	var PARTIAL_COMPARE_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      objProps = keys(object),
	      objLength = objProps.length,
	      othProps = keys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : baseHas(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  return result;
	}

	module.exports = equalObjects;


/***/ },
/* 428 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}

	module.exports = isHostObject;


/***/ },
/* 429 */
/***/ function(module, exports, __webpack_require__) {

	var isLength = __webpack_require__(367),
	    isObjectLike = __webpack_require__(375);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified,
	 *  else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	function isTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
	}

	module.exports = isTypedArray;


/***/ },
/* 430 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(362),
	    stringToPath = __webpack_require__(443);

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value) {
	  return isArray(value) ? value : stringToPath(value);
	}

	module.exports = castPath;


/***/ },
/* 431 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	module.exports = createBaseFor;


/***/ },
/* 432 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(449);

	/**
	 * Checks if an associative array value for `key` exists.
	 *
	 * @private
	 * @param {Array} array The array to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function assocHas(array, key) {
	  return assocIndexOf(array, key) > -1;
	}

	module.exports = assocHas;


/***/ },
/* 433 */
/***/ function(module, exports, __webpack_require__) {

	var mapClear = __webpack_require__(444),
	    mapDelete = __webpack_require__(445),
	    mapGet = __webpack_require__(446),
	    mapHas = __webpack_require__(447),
	    mapSet = __webpack_require__(448);

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function MapCache(values) {
	  var index = -1,
	      length = values ? values.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = values[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapClear;
	MapCache.prototype['delete'] = mapDelete;
	MapCache.prototype.get = mapGet;
	MapCache.prototype.has = mapHas;
	MapCache.prototype.set = mapSet;

	module.exports = MapCache;


/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(449);

	/**
	 * Sets the associative array `key` to `value`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 */
	function assocSet(array, key, value) {
	  var index = assocIndexOf(array, key);
	  if (index < 0) {
	    array.push([key, value]);
	  } else {
	    array[index][1] = value;
	  }
	}

	module.exports = assocSet;


/***/ },
/* 435 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	module.exports = arrayMap;


/***/ },
/* 436 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	module.exports = arraySome;


/***/ },
/* 437 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(395);

	/** Built-in value references. */
	var Symbol = root.Symbol;

	module.exports = Symbol;


/***/ },
/* 438 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(395);

	/** Built-in value references. */
	var Uint8Array = root.Uint8Array;

	module.exports = Uint8Array;


/***/ },
/* 439 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Converts `map` to an array.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	module.exports = mapToArray;


/***/ },
/* 440 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Converts `set` to an array.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	module.exports = setToArray;


/***/ },
/* 441 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(449);

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the associative array.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function assocDelete(array, key) {
	  var index = assocIndexOf(array, key);
	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = array.length - 1;
	  if (index == lastIndex) {
	    array.pop();
	  } else {
	    splice.call(array, index, 1);
	  }
	  return true;
	}

	module.exports = assocDelete;


/***/ },
/* 442 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(449);

	/**
	 * Gets the associative array value for `key`.
	 *
	 * @private
	 * @param {Array} array The array to query.
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function assocGet(array, key) {
	  var index = assocIndexOf(array, key);
	  return index < 0 ? undefined : array[index][1];
	}

	module.exports = assocGet;


/***/ },
/* 443 */
/***/ function(module, exports, __webpack_require__) {

	var memoize = __webpack_require__(450),
	    toString = __webpack_require__(451);

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoize(function(string) {
	  var result = [];
	  toString(string).replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	module.exports = stringToPath;


/***/ },
/* 444 */
/***/ function(module, exports, __webpack_require__) {

	var Hash = __webpack_require__(452),
	    Map = __webpack_require__(388);

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapClear() {
	  this.__data__ = {
	    'hash': new Hash,
	    'map': Map ? new Map : [],
	    'string': new Hash
	  };
	}

	module.exports = mapClear;


/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

	var Map = __webpack_require__(388),
	    assocDelete = __webpack_require__(441),
	    hashDelete = __webpack_require__(453),
	    isKeyable = __webpack_require__(454);

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapDelete(key) {
	  var data = this.__data__;
	  if (isKeyable(key)) {
	    return hashDelete(typeof key == 'string' ? data.string : data.hash, key);
	  }
	  return Map ? data.map['delete'](key) : assocDelete(data.map, key);
	}

	module.exports = mapDelete;


/***/ },
/* 446 */
/***/ function(module, exports, __webpack_require__) {

	var Map = __webpack_require__(388),
	    assocGet = __webpack_require__(442),
	    hashGet = __webpack_require__(455),
	    isKeyable = __webpack_require__(454);

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapGet(key) {
	  var data = this.__data__;
	  if (isKeyable(key)) {
	    return hashGet(typeof key == 'string' ? data.string : data.hash, key);
	  }
	  return Map ? data.map.get(key) : assocGet(data.map, key);
	}

	module.exports = mapGet;


/***/ },
/* 447 */
/***/ function(module, exports, __webpack_require__) {

	var Map = __webpack_require__(388),
	    assocHas = __webpack_require__(432),
	    hashHas = __webpack_require__(456),
	    isKeyable = __webpack_require__(454);

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapHas(key) {
	  var data = this.__data__;
	  if (isKeyable(key)) {
	    return hashHas(typeof key == 'string' ? data.string : data.hash, key);
	  }
	  return Map ? data.map.has(key) : assocHas(data.map, key);
	}

	module.exports = mapHas;


/***/ },
/* 448 */
/***/ function(module, exports, __webpack_require__) {

	var Map = __webpack_require__(388),
	    assocSet = __webpack_require__(434),
	    hashSet = __webpack_require__(457),
	    isKeyable = __webpack_require__(454);

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapSet(key, value) {
	  var data = this.__data__;
	  if (isKeyable(key)) {
	    hashSet(typeof key == 'string' ? data.string : data.hash, key, value);
	  } else if (Map) {
	    data.map.set(key, value);
	  } else {
	    assocSet(data.map, key, value);
	  }
	  return this;
	}

	module.exports = mapSet;


/***/ },
/* 449 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(364);

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to search.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	module.exports = assocIndexOf;


/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(433);

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoizing function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result);
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Assign cache to `_.memoize`.
	memoize.Cache = MapCache;

	module.exports = memoize;


/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(437),
	    isSymbol = __webpack_require__(416);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (value == null) {
	    return '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	module.exports = toString;


/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(458);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @returns {Object} Returns the new hash object.
	 */
	function Hash() {}

	// Avoid inheriting from `Object.prototype` when possible.
	Hash.prototype = nativeCreate ? nativeCreate(null) : objectProto;

	module.exports = Hash;


/***/ },
/* 453 */
/***/ function(module, exports, __webpack_require__) {

	var hashHas = __webpack_require__(456);

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(hash, key) {
	  return hashHas(hash, key) && delete hash[key];
	}

	module.exports = hashDelete;


/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return type == 'number' || type == 'boolean' ||
	    (type == 'string' && value != '__proto__') || value == null;
	}

	module.exports = isKeyable;


/***/ },
/* 455 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(458);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @param {Object} hash The hash to query.
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(hash, key) {
	  if (nativeCreate) {
	    var result = hash[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(hash, key) ? hash[key] : undefined;
	}

	module.exports = hashGet;


/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(458);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @param {Object} hash The hash to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(hash, key) {
	  return nativeCreate ? hash[key] !== undefined : hasOwnProperty.call(hash, key);
	}

	module.exports = hashHas;


/***/ },
/* 457 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(458);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 */
	function hashSet(hash, key, value) {
	  hash[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	}

	module.exports = hashSet;


/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(408);

	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');

	module.exports = nativeCreate;


/***/ }
/******/ ])
});
